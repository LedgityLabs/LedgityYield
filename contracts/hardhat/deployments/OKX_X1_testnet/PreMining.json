{
  "address": "0x2Bb79F621518BbA45dA5Ec57BC885C4686A60De9",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "lTokenAddress_",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "maxDistributedLDY_",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "lockedHardCap_",
          "type": "uint256"
        },
        {
          "internalType": "uint8",
          "name": "minLockDuration_",
          "type": "uint8"
        },
        {
          "internalType": "uint8",
          "name": "maxLockDuration_",
          "type": "uint8"
        },
        {
          "internalType": "uint8",
          "name": "vestingDuration_",
          "type": "uint8"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "account",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint8",
          "name": "duration",
          "type": "uint8"
        }
      ],
      "name": "Lock",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "previousOwner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "OwnershipTransferStarted",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "previousOwner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "OwnershipTransferred",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "Paused",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "Unpaused",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "acceptOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "accountsLocks",
      "outputs": [
        {
          "internalType": "uint240",
          "name": "amount",
          "type": "uint240"
        },
        {
          "internalType": "uint8",
          "name": "duration",
          "type": "uint8"
        },
        {
          "internalType": "bool",
          "name": "hasUnlocked",
          "type": "bool"
        },
        {
          "internalType": "uint216",
          "name": "claimedRewards",
          "type": "uint216"
        },
        {
          "internalType": "uint40",
          "name": "lockEndTimestamp",
          "type": "uint40"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "availableToClaim",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "claimPhaseStartTimestamp",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "claimRewards",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "eligibleRewardsOf",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "endDepositPhase",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "hasClaimPhaseStarted",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "hasDepositPhaseEnded",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "hasRecoveryPhaseStarted",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "instantUnlock",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "lToken",
      "outputs": [
        {
          "internalType": "contract LToken",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "ldyToken",
      "outputs": [
        {
          "internalType": "contract IERC20",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "internalType": "uint8",
          "name": "duration",
          "type": "uint8"
        }
      ],
      "name": "lock",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "lockedHardCap",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "maxDistributedLDY",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "maxLockDuration",
      "outputs": [
        {
          "internalType": "uint8",
          "name": "",
          "type": "uint8"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "maxWeight",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "minLockDuration",
      "outputs": [
        {
          "internalType": "uint8",
          "name": "",
          "type": "uint8"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "owner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "pause",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "paused",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "pendingOwner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "processUnlockRequests",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "tokenAddress",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "recoverERC20",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "renounceOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "requestUnlock",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "ldyTokenAddress",
          "type": "address"
        }
      ],
      "name": "setLDYToken",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "startClaimPhase",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "startRecoveryPhase",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "totalLocked",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "transferOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "underlyingToken",
      "outputs": [
        {
          "internalType": "contract IERC20",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "unlockRequests",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "unlockRequestsCursor",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "unpause",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "vestingDuration",
      "outputs": [
        {
          "internalType": "uint8",
          "name": "",
          "type": "uint8"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0xb5a81f8866729118794e06c9adc1d93ed55875686f69ea2aed7f7eabf809b9fd",
  "receipt": {
    "to": null,
    "from": "0xB8A2b9DA0b39b9D41907F2Db44cfD0d67d7237c4",
    "contractAddress": "0x2Bb79F621518BbA45dA5Ec57BC885C4686A60De9",
    "transactionIndex": 0,
    "gasUsed": "1907005",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000028000000000000000000800000200000000000000000000000000400000000000400000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000020000000000000000400000000000000000000000000000000000000000000000000",
    "blockHash": "0x0b4ab0cd9b1a51c71ccb09865f85db6b32d3c2509cd8a19737a8d444564dbc13",
    "transactionHash": "0xb5a81f8866729118794e06c9adc1d93ed55875686f69ea2aed7f7eabf809b9fd",
    "logs": [
      {
        "transactionIndex": 0,
        "blockNumber": 10172300,
        "transactionHash": "0xb5a81f8866729118794e06c9adc1d93ed55875686f69ea2aed7f7eabf809b9fd",
        "address": "0x2Bb79F621518BbA45dA5Ec57BC885C4686A60De9",
        "topics": [
          "0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x000000000000000000000000b8a2b9da0b39b9d41907f2db44cfd0d67d7237c4"
        ],
        "data": "0x",
        "logIndex": 0,
        "blockHash": "0x0b4ab0cd9b1a51c71ccb09865f85db6b32d3c2509cd8a19737a8d444564dbc13"
      }
    ],
    "blockNumber": 10172300,
    "cumulativeGasUsed": "1907005",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x1e1B0bB6C182eFD7d64cdAbbF3A3E315dE26E259",
    "1125000000000000000000000",
    "4000000000000",
    3,
    12,
    6
  ],
  "numDeployments": 1,
  "solcInputHash": "289d96c4eee8f123d72afd6fe6bc7791",
  "metadata": "{\"compiler\":{\"version\":\"0.8.18+commit.87f61d96\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lTokenAddress_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maxDistributedLDY_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockedHardCap_\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"minLockDuration_\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"maxLockDuration_\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"vestingDuration_\",\"type\":\"uint8\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"duration\",\"type\":\"uint8\"}],\"name\":\"Lock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"accountsLocks\",\"outputs\":[{\"internalType\":\"uint240\",\"name\":\"amount\",\"type\":\"uint240\"},{\"internalType\":\"uint8\",\"name\":\"duration\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"hasUnlocked\",\"type\":\"bool\"},{\"internalType\":\"uint216\",\"name\":\"claimedRewards\",\"type\":\"uint216\"},{\"internalType\":\"uint40\",\"name\":\"lockEndTimestamp\",\"type\":\"uint40\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"availableToClaim\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimPhaseStartTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"eligibleRewardsOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"endDepositPhase\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hasClaimPhaseStarted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hasDepositPhaseEnded\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hasRecoveryPhaseStarted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"instantUnlock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lToken\",\"outputs\":[{\"internalType\":\"contract LToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ldyToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"duration\",\"type\":\"uint8\"}],\"name\":\"lock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockedHardCap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxDistributedLDY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxLockDuration\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxWeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minLockDuration\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"processUnlockRequests\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"recoverERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"requestUnlock\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ldyTokenAddress\",\"type\":\"address\"}],\"name\":\"setLDYToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startClaimPhase\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startRecoveryPhase\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalLocked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"underlyingToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"unlockRequests\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unlockRequestsCursor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vestingDuration\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"author\":\"Lila Rest (https://lila.rest)\",\"custom:security-contact\":\"security@ledgity.comsecurity@ledgity.com\",\"details\":\"Intuition  Lifecycle of a lockdrop pool is composed by 3 main phases: 1) Deposit: During this phase, users can lock their underlying tokens. 2) Claim: During this phase, users can claim their LDY rewards. 3) Recovery: During this phase, owner can recover remaining ERC20 on the contract.  Transitioning between two phases is manually triggered by contract's owner. To ensure fair usage of this power and prevent potential misuse: - the Recovery phase cannot start before 3 months after the end of rewards vesting, - the Recovery phase cannot start before 3 months after the maximum lock end.  Finally, note that this contract proxies main L-Token contract's functions: - lock() --> deposit() - instantUnlock() --> instantWithdrawal() - requestUnlock() --> requestWithdrawal() This design enables users to interact with the PreMining contract in a similar fashion to the L-Token contract. Definitions: - Locker: An account that has locked underlying tokens in the pool. \",\"events\":{\"Paused(address)\":{\"details\":\"Emitted when the pause is triggered by `account`.\"},\"Unpaused(address)\":{\"details\":\"Emitted when the pause is lifted by `account`.\"}},\"kind\":\"dev\",\"methods\":{\"acceptOwnership()\":{\"details\":\"The new owner accepts the ownership transfer.\"},\"availableToClaim(address)\":{\"details\":\"This function considers vesting and already claimed rewards.\",\"params\":{\"account\":\"The account to compute the available rewards of.\"},\"returns\":{\"_0\":\"The amount of LDY rewards available to claim.\"}},\"constructor\":{\"params\":{\"lTokenAddress_\":\"Address of the L-Token contract to use.\",\"lockedHardCap_\":\"Maximum total amount of L-Tokens that can be locked.\",\"maxDistributedLDY_\":\"Amount of LDY to be distributed to lockers.\",\"maxLockDuration_\":\"Maximum possible lock duration (in months).\",\"minLockDuration_\":\"Minimum possible lock duration (in months).\",\"vestingDuration_\":\"Duration of LDY rewards vesting (in months).\"}},\"eligibleRewardsOf(address)\":{\"details\":\"Note: This function neither considers vesting nor already claimed rewards.\",\"params\":{\"account\":\"The account to compute the eligible rewards of.\"},\"returns\":{\"_0\":\"The total amount of LDY rewards that the account is eligible to.\"}},\"instantUnlock()\":{\"details\":\"In order to save some gas and time to users, frontends should propose this function to users only when it has been verified that it will not revert. They should propose the requestUnlock() function otherwise.\"},\"lock(uint256,uint8)\":{\"details\":\"This function proxies LToken.deposit()Lockers can extend their lock duration by calling this function again with a greater duration and 0 as amount.\",\"params\":{\"amount\":\"Amount of underlying tokens to lock.\",\"duration\":\"Duration of the lock (in months).\"}},\"owner()\":{\"details\":\"Returns the address of the current owner.\"},\"paused()\":{\"details\":\"Returns true if the contract is paused, and false otherwise.\"},\"pendingOwner()\":{\"details\":\"Returns the address of the pending owner.\"},\"recoverERC20(address,uint256)\":{\"params\":{\"amount\":\"The amount of token to recover.\",\"tokenAddress\":\"The address of the token to recover.\"}},\"renounceOwnership()\":{\"details\":\"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner.\"},\"requestUnlock()\":{\"details\":\"The sender must attach 0.003 ETH to pre-pay the future processing gas fees paid by the withdrawer wallet.\"},\"setLDYToken(address)\":{\"details\":\"As the first Ledgity Yield lockdrop campaigns will start before the LDY TGE, this function allows the contract's owner to set the LDY token address once it becomes available.\",\"params\":{\"ldyTokenAddress\":\"Address of the LDY token contract.\"}},\"transferOwnership(address)\":{\"details\":\"Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one. Can only be called by the current owner.\"}},\"title\":\"PreMining\",\"version\":1},\"userdoc\":{\"events\":{\"Lock(address,uint256,uint8)\":{\"notice\":\"Emitted to inform about a new lock/deposit.\"}},\"kind\":\"user\",\"methods\":{\"accountsLocks(address)\":{\"notice\":\"Holds lockers' participations informations.\"},\"availableToClaim(address)\":{\"notice\":\"Computes the amount of LDY rewards available to claim for a given account.\"},\"claimPhaseStartTimestamp()\":{\"notice\":\"Holds the timestamp at which the Claim phase started.\"},\"claimRewards()\":{\"notice\":\"Allows the caller to claim its available LDY rewards.\"},\"constructor\":{\"notice\":\"This constructor function etches the lockdrop terms in immutable states. Ensuring that those terms cannot be modified after deployment.\"},\"eligibleRewardsOf(address)\":{\"notice\":\"Compute the total amount of LDY rewards that a given account is eligible to.\"},\"endDepositPhase()\":{\"notice\":\"Closes the Deposit phase. After calling this function, account won't be able to lock additional underlying tokens anymore.\"},\"hasClaimPhaseStarted()\":{\"notice\":\"Holds whether the Claim phase has started.\"},\"hasDepositPhaseEnded()\":{\"notice\":\"Holds whether the Deposit phase has ended.\"},\"hasRecoveryPhaseStarted()\":{\"notice\":\"Holds whether the Recovery phase has started.\"},\"instantUnlock()\":{\"notice\":\"Allows the caller to instaneously unlock its locked amount of underlying tokens.\"},\"lToken()\":{\"notice\":\"Holds a reference to the locked L-Token contract.\"},\"ldyToken()\":{\"notice\":\"Holds a reference to the LDY token contract.\"},\"lock(uint256,uint8)\":{\"notice\":\"Allows locking a specified amount of underlying tokens for a given duration. By locking, an account became eligible to a portion of the distributed LDY rewards.\"},\"lockedHardCap()\":{\"notice\":\"Holds the maximum total amount of L-Tokens that can be locked.\"},\"maxDistributedLDY()\":{\"notice\":\"Holds the amount of LDY to be distributed to lockers.\"},\"maxLockDuration()\":{\"notice\":\"Holds the maximum possible lock duration (in months).\"},\"maxWeight()\":{\"notice\":\"Holds the max pool weight.\"},\"minLockDuration()\":{\"notice\":\"Holds the minimum possible lock duration (in months).\"},\"pause()\":{\"notice\":\"Public implementation of Pausable's pausing and unpausing functions, but restricted to contract's owner.\"},\"processUnlockRequests()\":{\"notice\":\"Processes queued unlock requests until there is else no more requests, else not enough underlying tokens to continue.\"},\"recoverERC20(address,uint256)\":{\"notice\":\"Recovers a specified amount of a given token address. Will revert if recovery phase has not started yet or if the contract doesn't hold enough tokens.\"},\"requestUnlock()\":{\"notice\":\"Allows the call to request for the unlocking of its locked amount of underlying tokens. The request will be automatically processed later.\"},\"setLDYToken(address)\":{\"notice\":\"Updates the LDY token contract address.\"},\"startClaimPhase()\":{\"notice\":\"Opens the Claim phase. After calling this function, lockers will be able to start claiming their LDY rewards.\"},\"startRecoveryPhase()\":{\"notice\":\"Opens the Recovery phase. After calling this function, the contract owner will be able to recover remaining ERC20 tokens on the contract. Note that this won't close the Claim phase and lockers will still be able to claim their LDY rewards.\"},\"totalLocked()\":{\"notice\":\"Holds the total amount of locked underlying tokens.\"},\"underlyingToken()\":{\"notice\":\"Holds a reference to the L-Token underlying stablecoin.\"},\"unlockRequests(uint256)\":{\"notice\":\"Holds an ordered queue of accounts that requested to unlock their tokens.\"},\"unlockRequestsCursor()\":{\"notice\":\"Holds the index of the first request in the queue (a.k.a, next one to be processed).\"},\"vestingDuration()\":{\"notice\":\"Holds the duration of LDY rewards vesting (in months).\"}},\"notice\":\"PreMining pool contract, allowing accounts to lock underlying tokens in a  pre-defined L-Token contract, over a given duration (in months), in exchange of  vested LDY rewards. \",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/src/PreMining.sol\":\"PreMining\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable2Step.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./OwnableUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership} and {acceptOwnership}.\\n *\\n * This module is used through inheritance. It will make available all functions\\n * from parent (Ownable).\\n */\\nabstract contract Ownable2StepUpgradeable is Initializable, OwnableUpgradeable {\\n    function __Ownable2Step_init() internal onlyInitializing {\\n        __Ownable_init_unchained();\\n    }\\n\\n    function __Ownable2Step_init_unchained() internal onlyInitializing {\\n    }\\n    address private _pendingOwner;\\n\\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Returns the address of the pending owner.\\n     */\\n    function pendingOwner() public view virtual returns (address) {\\n        return _pendingOwner;\\n    }\\n\\n    /**\\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\\n        _pendingOwner = newOwner;\\n        emit OwnershipTransferStarted(owner(), newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual override {\\n        delete _pendingOwner;\\n        super._transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev The new owner accepts the ownership transfer.\\n     */\\n    function acceptOwnership() public virtual {\\n        address sender = _msgSender();\\n        require(pendingOwner() == sender, \\\"Ownable2Step: caller is not the new owner\\\");\\n        _transferOwnership(sender);\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\",\"keccak256\":\"0x84efb8889801b0ac817324aff6acc691d07bbee816b671817132911d287a8c63\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    function __Ownable_init() internal onlyInitializing {\\n        __Ownable_init_unchained();\\n    }\\n\\n    function __Ownable_init_unchained() internal onlyInitializing {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\",\"keccak256\":\"0x4075622496acc77fd6d4de4cc30a8577a744d5c75afad33fdeacf1704d6eda98\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/interfaces/IERC1967Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC1967.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev ERC-1967: Proxy Storage Slots. This interface contains the events defined in the ERC.\\n *\\n * _Available since v4.8.3._\\n */\\ninterface IERC1967Upgradeable {\\n    /**\\n     * @dev Emitted when the implementation is upgraded.\\n     */\\n    event Upgraded(address indexed implementation);\\n\\n    /**\\n     * @dev Emitted when the admin account has changed.\\n     */\\n    event AdminChanged(address previousAdmin, address newAdmin);\\n\\n    /**\\n     * @dev Emitted when the beacon is changed.\\n     */\\n    event BeaconUpgraded(address indexed beacon);\\n}\\n\",\"keccak256\":\"0x47d6e06872b12e72c79d1b5eb55842f860b5fb1207b2317c2358d2766b950a7b\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/interfaces/draft-IERC1822Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\\n * proxy whose upgrades are fully controlled by the current implementation.\\n */\\ninterface IERC1822ProxiableUpgradeable {\\n    /**\\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\\n     * address.\\n     *\\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\\n     * function revert if invoked through a proxy.\\n     */\\n    function proxiableUUID() external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0x77c89f893e403efc6929ba842b7ccf6534d4ffe03afe31670b4a528c0ad78c0f\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/proxy/ERC1967/ERC1967UpgradeUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/ERC1967/ERC1967Upgrade.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../beacon/IBeaconUpgradeable.sol\\\";\\nimport \\\"../../interfaces/IERC1967Upgradeable.sol\\\";\\nimport \\\"../../interfaces/draft-IERC1822Upgradeable.sol\\\";\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\nimport \\\"../../utils/StorageSlotUpgradeable.sol\\\";\\nimport \\\"../utils/Initializable.sol\\\";\\n\\n/**\\n * @dev This abstract contract provides getters and event emitting update functions for\\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\\n *\\n * _Available since v4.1._\\n */\\nabstract contract ERC1967UpgradeUpgradeable is Initializable, IERC1967Upgradeable {\\n    function __ERC1967Upgrade_init() internal onlyInitializing {\\n    }\\n\\n    function __ERC1967Upgrade_init_unchained() internal onlyInitializing {\\n    }\\n    // This is the keccak-256 hash of \\\"eip1967.proxy.rollback\\\" subtracted by 1\\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\\n\\n    /**\\n     * @dev Storage slot with the address of the current implementation.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     */\\n    function _getImplementation() internal view returns (address) {\\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 implementation slot.\\n     */\\n    function _setImplementation(address newImplementation) private {\\n        require(AddressUpgradeable.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeTo(address newImplementation) internal {\\n        _setImplementation(newImplementation);\\n        emit Upgraded(newImplementation);\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade with additional setup call.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\\n        _upgradeTo(newImplementation);\\n        if (data.length > 0 || forceCall) {\\n            AddressUpgradeable.functionDelegateCall(newImplementation, data);\\n        }\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\\n        if (StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT).value) {\\n            _setImplementation(newImplementation);\\n        } else {\\n            try IERC1822ProxiableUpgradeable(newImplementation).proxiableUUID() returns (bytes32 slot) {\\n                require(slot == _IMPLEMENTATION_SLOT, \\\"ERC1967Upgrade: unsupported proxiableUUID\\\");\\n            } catch {\\n                revert(\\\"ERC1967Upgrade: new implementation is not UUPS\\\");\\n            }\\n            _upgradeToAndCall(newImplementation, data, forceCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Storage slot with the admin of the contract.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.admin\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /**\\n     * @dev Returns the current admin.\\n     */\\n    function _getAdmin() internal view returns (address) {\\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 admin slot.\\n     */\\n    function _setAdmin(address newAdmin) private {\\n        require(newAdmin != address(0), \\\"ERC1967: new admin is the zero address\\\");\\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\\n    }\\n\\n    /**\\n     * @dev Changes the admin of the proxy.\\n     *\\n     * Emits an {AdminChanged} event.\\n     */\\n    function _changeAdmin(address newAdmin) internal {\\n        emit AdminChanged(_getAdmin(), newAdmin);\\n        _setAdmin(newAdmin);\\n    }\\n\\n    /**\\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\\n     */\\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\\n\\n    /**\\n     * @dev Returns the current beacon.\\n     */\\n    function _getBeacon() internal view returns (address) {\\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\\n     */\\n    function _setBeacon(address newBeacon) private {\\n        require(AddressUpgradeable.isContract(newBeacon), \\\"ERC1967: new beacon is not a contract\\\");\\n        require(\\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\\n            \\\"ERC1967: beacon implementation is not a contract\\\"\\n        );\\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\\n    }\\n\\n    /**\\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\\n     *\\n     * Emits a {BeaconUpgraded} event.\\n     */\\n    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\\n        _setBeacon(newBeacon);\\n        emit BeaconUpgraded(newBeacon);\\n        if (data.length > 0 || forceCall) {\\n            AddressUpgradeable.functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\\n        }\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0x584ebdf9c1118a7c773f98788e3f3ede01982bdf8932aa06f5acc7d54876e161\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/proxy/beacon/IBeaconUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\\n */\\ninterface IBeaconUpgradeable {\\n    /**\\n     * @dev Must return an address that can be used as a delegate call target.\\n     *\\n     * {BeaconProxy} will check that this address is a contract.\\n     */\\n    function implementation() external view returns (address);\\n}\\n\",\"keccak256\":\"0x24b86ac8c005b8c654fbf6ac34a5a4f61580d7273541e83e013e89d66fbf0908\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```solidity\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n *\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\n     *\\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\\n     * constructor.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = !_initializing;\\n        require(\\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\\n            \\\"Initializable: contract is already initialized\\\"\\n        );\\n        _initialized = 1;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\n     * are added through upgrades and that require initialization.\\n     *\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     *\\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        require(!_initializing && _initialized < version, \\\"Initializable: contract is already initialized\\\");\\n        _initialized = version;\\n        _initializing = true;\\n        _;\\n        _initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     *\\n     * Emits an {Initialized} event the first time it is successfully executed.\\n     */\\n    function _disableInitializers() internal virtual {\\n        require(!_initializing, \\\"Initializable: contract is initializing\\\");\\n        if (_initialized != type(uint8).max) {\\n            _initialized = type(uint8).max;\\n            emit Initialized(type(uint8).max);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\\n     */\\n    function _getInitializedVersion() internal view returns (uint8) {\\n        return _initialized;\\n    }\\n\\n    /**\\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\\n     */\\n    function _isInitializing() internal view returns (bool) {\\n        return _initializing;\\n    }\\n}\\n\",\"keccak256\":\"0x89be10e757d242e9b18d5a32c9fbe2019f6d63052bbe46397a430a1d60d7f794\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/UUPSUpgradeable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../interfaces/draft-IERC1822Upgradeable.sol\\\";\\nimport \\\"../ERC1967/ERC1967UpgradeUpgradeable.sol\\\";\\nimport \\\"./Initializable.sol\\\";\\n\\n/**\\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\\n *\\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\\n * `UUPSUpgradeable` with a custom implementation of upgrades.\\n *\\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\\n *\\n * _Available since v4.1._\\n */\\nabstract contract UUPSUpgradeable is Initializable, IERC1822ProxiableUpgradeable, ERC1967UpgradeUpgradeable {\\n    function __UUPSUpgradeable_init() internal onlyInitializing {\\n    }\\n\\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\\n    }\\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\\n    address private immutable __self = address(this);\\n\\n    /**\\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\\n     * fail.\\n     */\\n    modifier onlyProxy() {\\n        require(address(this) != __self, \\\"Function must be called through delegatecall\\\");\\n        require(_getImplementation() == __self, \\\"Function must be called through active proxy\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\\n     * callable on the implementing contract but not through proxies.\\n     */\\n    modifier notDelegated() {\\n        require(address(this) == __self, \\\"UUPSUpgradeable: must not be called through delegatecall\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\\n     * implementation. It is used to validate the implementation's compatibility when performing an upgrade.\\n     *\\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\\n     */\\n    function proxiableUUID() external view virtual override notDelegated returns (bytes32) {\\n        return _IMPLEMENTATION_SLOT;\\n    }\\n\\n    /**\\n     * @dev Upgrade the implementation of the proxy to `newImplementation`.\\n     *\\n     * Calls {_authorizeUpgrade}.\\n     *\\n     * Emits an {Upgraded} event.\\n     *\\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\\n     */\\n    function upgradeTo(address newImplementation) public virtual onlyProxy {\\n        _authorizeUpgrade(newImplementation);\\n        _upgradeToAndCallUUPS(newImplementation, new bytes(0), false);\\n    }\\n\\n    /**\\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\\n     * encoded in `data`.\\n     *\\n     * Calls {_authorizeUpgrade}.\\n     *\\n     * Emits an {Upgraded} event.\\n     *\\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\\n     */\\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\\n        _authorizeUpgrade(newImplementation);\\n        _upgradeToAndCallUUPS(newImplementation, data, true);\\n    }\\n\\n    /**\\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\\n     * {upgradeTo} and {upgradeToAndCall}.\\n     *\\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\\n     *\\n     * ```solidity\\n     * function _authorizeUpgrade(address) internal override onlyOwner {}\\n     * ```\\n     */\\n    function _authorizeUpgrade(address newImplementation) internal virtual;\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0xb607cb94c27e89750f5ae2ccebcb94e654e926f6125f4fd4c6262c89875118ad\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    function __Pausable_init() internal onlyInitializing {\\n        __Pausable_init_unchained();\\n    }\\n\\n    function __Pausable_init_unchained() internal onlyInitializing {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        _requireNotPaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        _requirePaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is paused.\\n     */\\n    function _requireNotPaused() internal view virtual {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is not paused.\\n     */\\n    function _requirePaused() internal view virtual {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\",\"keccak256\":\"0x40c636b4572ff5f1dc50cf22097e93c0723ee14eff87e99ac2b02636eeca1250\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20Upgradeable.sol\\\";\\nimport \\\"./extensions/IERC20MetadataUpgradeable.sol\\\";\\nimport \\\"../../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * The default value of {decimals} is 18. To change this, you should override\\n * this function so it returns a different value.\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\\n        __ERC20_init_unchained(name_, symbol_);\\n    }\\n\\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the default value returned by this function, unless\\n     * it's overridden.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, amount);\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        uint256 currentAllowance = allowance(owner, spender);\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `from` to `to`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address from, address to, uint256 amount) internal virtual {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, amount);\\n\\n        uint256 fromBalance = _balances[from];\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[from] = fromBalance - amount;\\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\\n            // decrementing then incrementing.\\n            _balances[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        unchecked {\\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\\n            _balances[account] += amount;\\n        }\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\\n            _totalSupply -= amount;\\n        }\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\\n     *\\n     * Does not update the allowance amount in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Might emit an {Approval} event.\\n     */\\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[45] private __gap;\\n}\\n\",\"keccak256\":\"0xd14a627157b9a411d2410713e5dd3a377e9064bd5c194a90748bbf27ea625784\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20Upgradeable {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\",\"keccak256\":\"0x0e1f0f5f62f67a881cd1a9597acbc0a5e4071f3c2c10449a183b922ae7272e3f\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20PausableUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/ERC20Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../ERC20Upgradeable.sol\\\";\\nimport \\\"../../../security/PausableUpgradeable.sol\\\";\\nimport \\\"../../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev ERC20 token with pausable token transfers, minting and burning.\\n *\\n * Useful for scenarios such as preventing trades until the end of an evaluation\\n * period, or having an emergency switch for freezing all token transfers in the\\n * event of a large bug.\\n *\\n * IMPORTANT: This contract does not include public pause and unpause functions. In\\n * addition to inheriting this contract, you must define both functions, invoking the\\n * {Pausable-_pause} and {Pausable-_unpause} internal functions, with appropriate\\n * access control, e.g. using {AccessControl} or {Ownable}. Not doing so will\\n * make the contract unpausable.\\n */\\nabstract contract ERC20PausableUpgradeable is Initializable, ERC20Upgradeable, PausableUpgradeable {\\n    function __ERC20Pausable_init() internal onlyInitializing {\\n        __Pausable_init_unchained();\\n    }\\n\\n    function __ERC20Pausable_init_unchained() internal onlyInitializing {\\n    }\\n    /**\\n     * @dev See {ERC20-_beforeTokenTransfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - the contract must not be paused.\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override {\\n        super._beforeTokenTransfer(from, to, amount);\\n\\n        require(!paused(), \\\"ERC20Pausable: token transfer while paused\\\");\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0xf0bd7f71ffae5f0addd375e8511fbf2ad8ca0c9b2606c32d92bdda7d76a7a81c\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20WrapperUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/ERC20Wrapper.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../ERC20Upgradeable.sol\\\";\\nimport \\\"../utils/SafeERC20Upgradeable.sol\\\";\\nimport \\\"../../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Extension of the ERC20 token contract to support token wrapping.\\n *\\n * Users can deposit and withdraw \\\"underlying tokens\\\" and receive a matching number of \\\"wrapped tokens\\\". This is useful\\n * in conjunction with other modules. For example, combining this wrapping mechanism with {ERC20Votes} will allow the\\n * wrapping of an existing \\\"basic\\\" ERC20 into a governance token.\\n *\\n * _Available since v4.2._\\n *\\n * @custom:storage-size 51\\n */\\nabstract contract ERC20WrapperUpgradeable is Initializable, ERC20Upgradeable {\\n    IERC20Upgradeable private _underlying;\\n\\n    function __ERC20Wrapper_init(IERC20Upgradeable underlyingToken) internal onlyInitializing {\\n        __ERC20Wrapper_init_unchained(underlyingToken);\\n    }\\n\\n    function __ERC20Wrapper_init_unchained(IERC20Upgradeable underlyingToken) internal onlyInitializing {\\n        require(underlyingToken != this, \\\"ERC20Wrapper: cannot self wrap\\\");\\n        _underlying = underlyingToken;\\n    }\\n\\n    /**\\n     * @dev See {ERC20-decimals}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        try IERC20MetadataUpgradeable(address(_underlying)).decimals() returns (uint8 value) {\\n            return value;\\n        } catch {\\n            return super.decimals();\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address of the underlying ERC-20 token that is being wrapped.\\n     */\\n    function underlying() public view returns (IERC20Upgradeable) {\\n        return _underlying;\\n    }\\n\\n    /**\\n     * @dev Allow a user to deposit underlying tokens and mint the corresponding number of wrapped tokens.\\n     */\\n    function depositFor(address account, uint256 amount) public virtual returns (bool) {\\n        address sender = _msgSender();\\n        require(sender != address(this), \\\"ERC20Wrapper: wrapper can't deposit\\\");\\n        SafeERC20Upgradeable.safeTransferFrom(_underlying, sender, address(this), amount);\\n        _mint(account, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Allow a user to burn a number of wrapped tokens and withdraw the corresponding number of underlying tokens.\\n     */\\n    function withdrawTo(address account, uint256 amount) public virtual returns (bool) {\\n        _burn(_msgSender(), amount);\\n        SafeERC20Upgradeable.safeTransfer(_underlying, account, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Mint wrapped token to cover any underlyingTokens that would have been transferred by mistake. Internal\\n     * function that can be exposed with access control if desired.\\n     */\\n    function _recover(address account) internal virtual returns (uint256) {\\n        uint256 value = _underlying.balanceOf(address(this)) - totalSupply();\\n        _mint(account, value);\\n        return value;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0x14bb62a60fcbc911c33ac0e5456bf31ed50b502c30be46ee15bd3b698e91bd81\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20Upgradeable.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0x605434219ebbe4653f703640f06969faa5a1d78f0bfef878e5ddbb1ca369ceeb\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20PermitUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20PermitUpgradeable {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0xd60f939a3ca0199014d079b4dd66aa757954334947d81eb5c1d35d7a83061ab3\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20Upgradeable.sol\\\";\\nimport \\\"../extensions/IERC20PermitUpgradeable.sol\\\";\\nimport \\\"../../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20Upgradeable {\\n    using AddressUpgradeable for address;\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransfer(IERC20Upgradeable token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransferFrom(IERC20Upgradeable token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    /**\\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeIncreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\\n        uint256 oldAllowance = token.allowance(address(this), spender);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\\n    }\\n\\n    /**\\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeDecreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\\n        }\\n    }\\n\\n    /**\\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful. Compatible with tokens that require the approval to be set to\\n     * 0 before setting it to a non-zero value.\\n     */\\n    function forceApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\\n\\n        if (!_callOptionalReturnBool(token, approvalCall)) {\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\\n            _callOptionalReturn(token, approvalCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\\n     * Revert on invalid signature.\\n     */\\n    function safePermit(\\n        IERC20PermitUpgradeable token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     *\\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\\n     */\\n    function _callOptionalReturnBool(IERC20Upgradeable token, bytes memory data) private returns (bool) {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\\n        // and not revert is the subcall reverts.\\n\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        return\\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && AddressUpgradeable.isContract(address(token));\\n    }\\n}\\n\",\"keccak256\":\"0x4dae161227d332808312ee2caf6384929321b83c16cc89b5642985fbec6b814c\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x9c80f545915582e63fe206c6ce27cbe85a86fc10b9cd2a0e8c9488fb7c2ee422\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal onlyInitializing {\\n    }\\n\\n    function __Context_init_unchained() internal onlyInitializing {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0x963ea7f0b48b032eef72fe3a7582edf78408d6f834115b9feadd673a4d5bd149\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/StorageSlotUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/StorageSlot.sol)\\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for reading and writing primitive types to specific storage slots.\\n *\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\n *\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\n *\\n * Example usage to set ERC1967 implementation slot:\\n * ```solidity\\n * contract ERC1967 {\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n *\\n *     function _getImplementation() internal view returns (address) {\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n *     }\\n *\\n *     function _setImplementation(address newImplementation) internal {\\n *         require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n *     }\\n * }\\n * ```\\n *\\n * _Available since v4.1 for `address`, `bool`, `bytes32`, `uint256`._\\n * _Available since v4.9 for `string`, `bytes`._\\n */\\nlibrary StorageSlotUpgradeable {\\n    struct AddressSlot {\\n        address value;\\n    }\\n\\n    struct BooleanSlot {\\n        bool value;\\n    }\\n\\n    struct Bytes32Slot {\\n        bytes32 value;\\n    }\\n\\n    struct Uint256Slot {\\n        uint256 value;\\n    }\\n\\n    struct StringSlot {\\n        string value;\\n    }\\n\\n    struct BytesSlot {\\n        bytes value;\\n    }\\n\\n    /**\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\n     */\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\\n     */\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\\n     */\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\\n     */\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\\n     */\\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\\n     */\\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := store.slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\\n     */\\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\\n     */\\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := store.slot\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x07ac95acad040f1fb1f6120dd0aa5f702db69446e95f82613721879d30de0908\",\"license\":\"MIT\"},\"@openzeppelin/contracts/access/Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\",\"keccak256\":\"0xba43b97fba0d32eb4254f6a5a297b39a19a247082a02d6e69349e071e2946218\",\"license\":\"MIT\"},\"@openzeppelin/contracts/access/Ownable2Step.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable2Step.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Ownable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership} and {acceptOwnership}.\\n *\\n * This module is used through inheritance. It will make available all functions\\n * from parent (Ownable).\\n */\\nabstract contract Ownable2Step is Ownable {\\n    address private _pendingOwner;\\n\\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Returns the address of the pending owner.\\n     */\\n    function pendingOwner() public view virtual returns (address) {\\n        return _pendingOwner;\\n    }\\n\\n    /**\\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\\n        _pendingOwner = newOwner;\\n        emit OwnershipTransferStarted(owner(), newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual override {\\n        delete _pendingOwner;\\n        super._transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev The new owner accepts the ownership transfer.\\n     */\\n    function acceptOwnership() public virtual {\\n        address sender = _msgSender();\\n        require(pendingOwner() == sender, \\\"Ownable2Step: caller is not the new owner\\\");\\n        _transferOwnership(sender);\\n    }\\n}\\n\",\"keccak256\":\"0xde231558366826d7cb61725af8147965a61c53b77a352cc8c9af38fc5a92ac3c\",\"license\":\"MIT\"},\"@openzeppelin/contracts/security/Pausable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor() {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        _requireNotPaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        _requirePaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is paused.\\n     */\\n    function _requireNotPaused() internal view virtual {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is not paused.\\n     */\\n    function _requirePaused() internal view virtual {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\",\"keccak256\":\"0x0849d93b16c9940beb286a7864ed02724b248b93e0d80ef6355af5ef15c64773\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\",\"keccak256\":\"0x287b55befed2961a7eabd7d7b1b2839cbca8a5b80ef8dcbb25ed3d4c2002c305\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0xec63854014a5b4f2b3290ab9103a21bdf902a508d0f41a8573fea49e98bf571a\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../extensions/IERC20Permit.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    /**\\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 oldAllowance = token.allowance(address(this), spender);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\\n    }\\n\\n    /**\\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\\n        }\\n    }\\n\\n    /**\\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful. Compatible with tokens that require the approval to be set to\\n     * 0 before setting it to a non-zero value.\\n     */\\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\\n\\n        if (!_callOptionalReturnBool(token, approvalCall)) {\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\\n            _callOptionalReturn(token, approvalCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\\n     * Revert on invalid signature.\\n     */\\n    function safePermit(\\n        IERC20Permit token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     *\\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\\n     */\\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\\n        // and not revert is the subcall reverts.\\n\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        return\\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\\n    }\\n}\\n\",\"keccak256\":\"0x909d608c2db6eb165ca178c81289a07ed2e118e444d0025b2a85c97d0b44a4fa\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x006dd67219697fe68d7fbfdea512e7c4cb64a43565ed86171d67e844982da6fa\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0xe2e337e6dde9ef6b680e07338c493ebea1b5fd09b43424112868e9cc1706bca7\",\"license\":\"MIT\"},\"contracts/src/DummyLDYStaking.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.18;\\r\\n\\r\\nimport {Ownable2Step} from \\\"@openzeppelin/contracts/access/Ownable2Step.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title LDYStaking\\r\\n * @author Lila Rest (https://lila.rest)\\r\\n * @custom:security-contact security@ledgity.com\\r\\n *\\r\\n * @notice Replacement to the LDYStaking contract until the $LDY token is available and\\r\\n * the real LDYStaking can be deployed.\\r\\n *\\r\\n * @dev This contract only implements tierOf() function from LDYStaking as it's the only\\r\\n * one the LToken contract relies on.\\r\\n *\\r\\n * @custom:security-contact security@ledgity.com\\r\\n */\\r\\ncontract LDYStaking is Ownable2Step {\\r\\n    /**\\r\\n     * @notice Holds a mapping of addresses that default to the highest staking tier.\\r\\n     * @dev This is notably used to allow PreMining contracts to benefit from 0%\\r\\n     * withdrawal fees in L-Tokens contracts, when accounts unlock their funds.\\r\\n     */\\r\\n    mapping(address => bool) public highTierAccounts;\\r\\n\\r\\n    /**\\r\\n     * @notice Update high tier status of a given account.\\r\\n     * @param account The account to update the high tier status of.\\r\\n     */\\r\\n    function setHighTierAccount(address account, bool status) public onlyOwner {\\r\\n        highTierAccounts[account] = status;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Dummy tierOf() function that always return that the given account is not\\r\\n     * ellgible to any LDY staking tier, except if the account is in the\\r\\n     * defaultToHighestTier mapping.\\r\\n     * @param account The account to check the tier of.\\r\\n     */\\r\\n    function tierOf(address account) public view returns (uint256 tier) {\\r\\n        if (highTierAccounts[account]) return 3;\\r\\n        return 0;\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0xf9f5650cf68997c860b0d69c8b9122b4c2df28faaef3eedca008c9daf4fe1b89\",\"license\":\"MIT\"},\"contracts/src/GlobalBlacklist.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.18;\\r\\n\\r\\nimport {Initializable} from \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\r\\nimport {UUPSUpgradeable} from \\\"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\\\";\\r\\nimport {GlobalOwnableUpgradeable} from \\\"./abstracts/GlobalOwnableUpgradeable.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title GlobalBlacklist\\r\\n * @author Lila Rest (https://lila.rest)\\r\\n * @custom:security-contact security@ledgity.com\\r\\n *\\r\\n * @notice Maintains a global mapping of blacklisted accounts on-chain. All contracts\\r\\n * within the Ledgity Yield codebase reference this mapping to prevent access by\\r\\n * blacklisted accounts.\\r\\n *\\r\\n * @dev Specifically, some contracts within the codebase inherit from the\\r\\n * GlobalRestrictableUpgradeable abstract contract. This provides them with modifiers\\r\\n * and getter functions to easily check against this global blacklist.\\r\\n *\\r\\n * @dev For further details, see \\\"GlobalBlacklist\\\" section of whitepaper.\\r\\n * @custom:security-contact security@ledgity.com\\r\\n */\\r\\ncontract GlobalBlacklist is Initializable, UUPSUpgradeable, GlobalOwnableUpgradeable {\\r\\n    /**\\r\\n     * @notice Mapping of accounts to their blacklist status.\\r\\n     * @dev This mapping is made private and isBlacklisted() should be used instead.This\\r\\n     * helps saving gas in some scenario. See isBlacklisted() documentation for more details.\\r\\n     */\\r\\n    mapping(address => bool) private _list;\\r\\n\\r\\n    /**\\r\\n     * @notice Prevents implementation contract from being initialized as recommended by\\r\\n     * OpenZeppelin.\\r\\n     * @dev See: https://docs.openzeppelin.com/contracts/4.x/api/proxy#Initializable-_disableInitializers--\\r\\n     * @custom:oz-upgrades-unsafe-allow constructor\\r\\n     */\\r\\n    constructor() {\\r\\n        _disableInitializers();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Initializer function of the contract. It replaces the constructor()\\r\\n     * function in the context of upgradeable contracts.\\r\\n     * @dev See: https://docs.openzeppelin.com/contracts/4.x/upgradeable\\r\\n     * @param globalOwner_ The address of the GlobalOwner contract.\\r\\n     */\\r\\n    function initialize(address globalOwner_) public initializer {\\r\\n        __GlobalOwnable_init(globalOwner_);\\r\\n        __UUPSUpgradeable_init();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Override of UUPSUpgradeable._authorizeUpgrade() function restricted to\\r\\n     * global owner. It is called by the proxy contract during an upgrade.\\r\\n     * @param newImplementation The address of the new implementation contract.\\r\\n     */\\r\\n    function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}\\r\\n\\r\\n    /**\\r\\n     * @notice Adds a given account to the blacklist.\\r\\n     * @param account The account's address to be blacklisted.\\r\\n     */\\r\\n    function blacklist(address account) external onlyOwner {\\r\\n        require(account != address(0), \\\"L20\\\");\\r\\n        _list[account] = true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Removes a given account from the blacklist.\\r\\n     * @param account The account's address to be un-blacklisted.\\r\\n     */\\r\\n    function unBlacklist(address account) external onlyOwner {\\r\\n        _list[account] = false;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Checks whether a given account is blacklisted.\\r\\n     * @param account Address of the account to check.\\r\\n     * @return 'true' if the account is blacklisted, 'false' otherwise\\r\\n     */\\r\\n    function isBlacklisted(address account) external view returns (bool) {\\r\\n        // Gas optimization: Avoid accessing storage if account is the zero address\\r\\n        // (e.g, during a mint or a burn of tokens)\\r\\n        if (account == address(0)) return false;\\r\\n\\r\\n        // Else, return current account's blacklist status\\r\\n        return _list[account];\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0xa5313bead8fee2d264f3c32bad2907b239ff7614b9c5983843d370cef5ddc721\",\"license\":\"MIT\"},\"contracts/src/GlobalOwner.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.18;\\r\\n\\r\\nimport {Initializable} from \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\r\\nimport {UUPSUpgradeable} from \\\"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\\\";\\r\\nimport {Ownable2StepUpgradeable} from \\\"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title GlobalOwner\\r\\n * @author Lila Rest (https://lila.rest)\\r\\n * @custom:security-contact security@ledgity.com\\r\\n *\\r\\n * @notice Maintains the address of a global owner account shared by all contracts of the\\r\\n * Ledgity Yield's codebase.\\r\\n *\\r\\n * @dev Specifically, some contracts within the codebase inherit from the\\r\\n * GlobalOwnableUpgradeable abstract contract. This provides them with an overriden\\r\\n * owner() function that retrieves the owner's address from this contract instead.\\r\\n *\\r\\n * @dev For further details, see \\\"GlobalOwner\\\" section of whitepaper.\\r\\n * @custom:security-contact security@ledgity.com\\r\\n */\\r\\ncontract GlobalOwner is Initializable, UUPSUpgradeable, Ownable2StepUpgradeable {\\r\\n    /**\\r\\n     * @notice Prevents implementation contract from being initialized as recommended by\\r\\n     * OpenZeppelin.\\r\\n     * @dev See: https://docs.openzeppelin.com/contracts/4.x/api/proxy#Initializable-_disableInitializers--\\r\\n     * @custom:oz-upgrades-unsafe-allow constructor\\r\\n     */\\r\\n    constructor() {\\r\\n        _disableInitializers();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Initializer function of the contract. It replaces the constructor()\\r\\n     * function in the context of upgradeable contracts.\\r\\n     * @dev See: https://docs.openzeppelin.com/contracts/4.x/upgradeable\\r\\n     */\\r\\n    function initialize() public initializer {\\r\\n        __Ownable2Step_init();\\r\\n        __UUPSUpgradeable_init();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Override of UUPSUpgradeable._authorizeUpgrade() function restricted to\\r\\n     * global owner. It is called by the proxy contract during an upgrade.\\r\\n     * @param newImplementation The address of the new implementation contract.\\r\\n     */\\r\\n    function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}\\r\\n}\\r\\n\",\"keccak256\":\"0x7eed673c8fd26a555f52c509b4b9f501a743df6e1dc78c4f4eca108fdaa27d9c\",\"license\":\"MIT\"},\"contracts/src/GlobalPause.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.18;\\r\\n\\r\\nimport {Initializable} from \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\r\\nimport {UUPSUpgradeable} from \\\"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\\\";\\r\\nimport {PausableUpgradeable} from \\\"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\\\";\\r\\nimport {GlobalOwnableUpgradeable} from \\\"./abstracts/GlobalOwnableUpgradeable.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title GlobalPause\\r\\n * @author Lila Rest (https://lila.rest)\\r\\n * @custom:security-contact security@ledgity.com\\r\\n *\\r\\n * @notice Maintains a global pause state shared by all contracts of the Ledgity Yield\\r\\n * codebase.\\r\\n *\\r\\n * @dev Specifically, some contracts within the codebase inherit from the\\r\\n * GlobalPausableUpgradeable abstract contract. This provides them with an overriden\\r\\n * paused() function that retrieves the pause state from this contract instead.\\r\\n *\\r\\n * @dev For further details, see \\\"GlobalPause\\\" section of whitepaper.\\r\\n * @custom:security-contact security@ledgity.com\\r\\n */\\r\\ncontract GlobalPause is\\r\\n    Initializable,\\r\\n    UUPSUpgradeable,\\r\\n    GlobalOwnableUpgradeable,\\r\\n    PausableUpgradeable\\r\\n{\\r\\n    /**\\r\\n     * @notice Prevents implementation contract from being initialized as recommended by\\r\\n     * OpenZeppelin.\\r\\n     * @dev See: https://docs.openzeppelin.com/contracts/4.x/api/proxy#Initializable-_disableInitializers--\\r\\n     * @custom:oz-upgrades-unsafe-allow constructor\\r\\n     */\\r\\n    constructor() {\\r\\n        _disableInitializers();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Initializer function of the contract. It replaces the constructor()\\r\\n     * function in the context of upgradeable contracts.\\r\\n     * @dev See: https://docs.openzeppelin.com/contracts/4.x/upgradeable\\r\\n     * @param globalOwner_ The address of the GlobalOwner contract.\\r\\n     */\\r\\n    function initialize(address globalOwner_) public initializer {\\r\\n        __GlobalOwnable_init(globalOwner_);\\r\\n        __Pausable_init();\\r\\n        __UUPSUpgradeable_init();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Override of UUPSUpgradeable._authorizeUpgrade() function restricted to\\r\\n     * global owner. It is called by the proxy contract during an upgrade.\\r\\n     * @param newImplementation The address of the new implementation contract.\\r\\n     */\\r\\n    function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}\\r\\n\\r\\n    /**\\r\\n     * @dev Public implementation of PausableUpgradeable's pausing and unpausing functions\\r\\n     * but restricted to contract's owner.\\r\\n     */\\r\\n    function pause() public onlyOwner {\\r\\n        _pause();\\r\\n    }\\r\\n\\r\\n    function unpause() public onlyOwner {\\r\\n        _unpause();\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x43dc86a468bfcc0620ec46251b22230c1029f2b62d72f5aa3fdb11ee0733467c\",\"license\":\"MIT\"},\"contracts/src/LToken.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.18;\\r\\n\\r\\n// Contracts\\r\\nimport {ERC20WrapperUpgradeable} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20WrapperUpgradeable.sol\\\";\\r\\nimport \\\"./abstracts/base/ERC20BaseUpgradeable.sol\\\";\\r\\nimport {InvestUpgradeable} from \\\"./abstracts/InvestUpgradeable.sol\\\";\\r\\nimport {LDYStaking} from \\\"./DummyLDYStaking.sol\\\";\\r\\n\\r\\n// Libraries\\r\\nimport {SafeERC20Upgradeable} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\\\";\\r\\nimport {SUD} from \\\"./libs/SUD.sol\\\";\\r\\n\\r\\n// Interfaces\\r\\nimport {IERC20Upgradeable} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\r\\nimport {IERC20MetadataUpgradeable} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\\\";\\r\\nimport {ITransfersListener} from \\\"./interfaces/ITransfersListener.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title LToken\\r\\n * @author Lila Rest (https://lila.rest)\\r\\n * @custom:security-contact security@ledgity.com\\r\\n *\\r\\n * @notice Main contract of the Ledgity Yield protocol. It powers every L-Token (i.e,\\r\\n * investment pools backed by RWA). An L-Token is an ERC20 wrapper around a stablecoin.\\r\\n * As soon as a wallet holds some L-Tokens, it starts receiving rewards in\\r\\n * the form of additional L-Tokens, which are auto-compounded over time.\\r\\n *\\r\\n * @dev Definitions:\\r\\n * - Deposit: Swap of underlying tokens for L-Tokens (1:1 ratio).\\r\\n * - Withdrawal: Swap of L-Tokens for underlying tokens (1:1 ratio, minus applicable fees).\\r\\n *   - Instant: Processed immediately.\\r\\n *   - Requested: Queued for later processing.\\r\\n *   - Big Requested: A requested withdrawal exceeding half of the retention rate.\\r\\n * - (Withdrawal) queue: An list of all requested withdrawals sorted by priority.\\r\\n * - Request ID: The index of a withdrawal request in the queue array.\\r\\n * - Retention rate: Maximum fraction of underlying tokens TVL that the contract can retain.\\r\\n * - Fees Rate: Percentage of fees applied to successful withdrawals.\\r\\n * - Usable underlyings: Amount of underlying tokens that have been deposited through\\r\\n *                       expected ways and are so considered as safe to use by the contract.\\r\\n * - Transfers listeners: External contracts listening on L-Tokens transfers.\\r\\n * - Fund wallet: Wallet managed by the Ledgity's financial team.\\r\\n * - Withdrawer wallet: Managed by an off-chain server to automate withdrawal request\\r\\n *                      processing.\\r\\n *\\r\\n * Note that words between parenthesis are sometimes omitted for brevity.\\r\\n *\\r\\n * @dev Security: This contract can safely receive funds immediately after initialization.\\r\\n * (i.e., there is no way for funds to be sent to non-owned addresses). It is however\\r\\n * recommended to replace ASAP owner and fund wallets by multi-sig wallets.\\r\\n *\\r\\n * @dev For further details, see \\\"LToken\\\" section of whitepaper.\\r\\n * @custom:oz-upgrades-unsafe-allow external-library-linking\\r\\n * @custom:security-contact security@ledgity.com\\r\\n */\\r\\ncontract LToken is ERC20BaseUpgradeable, InvestUpgradeable, ERC20WrapperUpgradeable {\\r\\n    using SafeERC20Upgradeable for IERC20Upgradeable;\\r\\n\\r\\n    /// @dev Represents type of actions triggering ActivityEvent events.\\r\\n    enum Action {\\r\\n        Deposit,\\r\\n        Withdraw\\r\\n    }\\r\\n\\r\\n    /// @dev Represents different status of actions triggering ActivityEvent events.\\r\\n    enum Status {\\r\\n        Queued,\\r\\n        Cancelled,\\r\\n        Success,\\r\\n        Moved\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Represents a withdrawal request in the queue.\\r\\n     * @dev A request fits in a single storage slot (32 bytes).\\r\\n     * @param account The account that initiated the request.\\r\\n     * @param amount The amount of underlying tokens requested.\\r\\n     */\\r\\n    struct WithdrawalRequest {\\r\\n        address account; // 20 bytes\\r\\n        uint96 amount; // 12 bytes\\r\\n    }\\r\\n\\r\\n    /// @notice Upper limit of retention rate.\\r\\n    uint32 private constant MAX_RETENTION_RATE_UD7x3 = 10 * 10 ** 3; // 10%\\r\\n\\r\\n    /// @notice Used in activity events to represent the absence of request ID.\\r\\n    int256 private constant NO_ID = -1;\\r\\n\\r\\n    /// @notice Holds a reference to the LDYStaking contract.\\r\\n    LDYStaking public ldyStaking;\\r\\n\\r\\n    /// @notice Holds address of withdrawer wallet (managed by withdrawal server).\\r\\n    address payable public withdrawer;\\r\\n\\r\\n    /// @notice Holds address of fund wallet (managed by Ledgity financial team).\\r\\n    address public fund;\\r\\n\\r\\n    /// @notice Holds the withdrawal fees rate in UD7x3 format (e.g., 350 = 0.350%).\\r\\n    uint32 public feesRateUD7x3;\\r\\n\\r\\n    /// @notice Holds the retention rate in UD7x3 format.\\r\\n    uint32 public retentionRateUD7x3;\\r\\n\\r\\n    /// @notice Holds the amount of withdrawal fees not yet claimed by contract's owner.\\r\\n    uint256 public unclaimedFees;\\r\\n\\r\\n    /// @notice Holds the amount of L-Tokens currently in the withdrawal queue.\\r\\n    uint256 public totalQueued;\\r\\n\\r\\n    /**\\r\\n     * @notice Holds the amount of underlying tokens considered as usable by the contract.\\r\\n     * @dev Are usable, only underlying tokens deposit through deposit() or fund() functions.\\r\\n     */\\r\\n    uint256 public usableUnderlyings;\\r\\n\\r\\n    /// @notice Holds an ordered list of active withdrawal requests.\\r\\n    WithdrawalRequest[] public withdrawalQueue;\\r\\n\\r\\n    /// @notice Holds the index of the next withdrawal request to process in the queue.\\r\\n    uint256 public withdrawalQueueCursor;\\r\\n\\r\\n    /**\\r\\n     * @notice Holds a list of all currently frozen withdrawal requests.\\r\\n     * @dev If a request emitter as been blacklisted, its request is moved here to prevent\\r\\n     * it from blocking the queue.\\r\\n     */\\r\\n    WithdrawalRequest[] public frozenRequests;\\r\\n\\r\\n    /**\\r\\n     * @notice Holds a list of contracts' references that are listening to L-Tokens transfers.\\r\\n     * @dev onLTokenTransfer() functions of those contracts will be called on each transfer.\\r\\n     */\\r\\n    ITransfersListener[] public transfersListeners;\\r\\n\\r\\n    /**\\r\\n     * @notice Emitted to inform listeners about a change in the contract's TVL.\\r\\n     * @dev TVL = realTotalSupply()\\r\\n     * @param newTVL The new TVL of the contract.\\r\\n     */\\r\\n    event TVLChangeEvent(uint256 newTVL);\\r\\n\\r\\n    /**\\r\\n     * @notice Emitted to inform listerners about an activity related to deposits and withdrawals.\\r\\n     * @param id ID of the involved withdrawal request or NO_ID (-1) if not applicable.\\r\\n     * @param account The account involved in the activity.\\r\\n     * @param action The type of activity.\\r\\n     * @param amount The amount of underlying tokens involved in the activity.\\r\\n     * @param newStatus The new status of the activity.\\r\\n     * @param newId The new ID of the request if it has been moved in the queue.\\r\\n     */\\r\\n    event ActivityEvent(\\r\\n        int256 indexed id,\\r\\n        address indexed account,\\r\\n        Action indexed action,\\r\\n        uint256 amount,\\r\\n        uint256 amountAfterFees,\\r\\n        Status newStatus,\\r\\n        int256 newId\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @notice Emitted to inform listeners that some rewards have been minted.\\r\\n     * @param account The account that received the rewards.\\r\\n     * @param balanceBefore The balance of the account before the minting.\\r\\n     * @param rewards The amount of minted rewards.\\r\\n     */\\r\\n    event MintedRewardsEvent(address indexed account, uint256 balanceBefore, uint256 rewards);\\r\\n\\r\\n    /// @notice Reverts if the function caller is not the withdrawer wallet.\\r\\n    modifier onlyWithdrawer() {\\r\\n        require(_msgSender() == withdrawer, \\\"L39\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /// @notice Reverts if the function caller is not the fund wallet.\\r\\n    modifier onlyFund() {\\r\\n        require(_msgSender() == fund, \\\"L40\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Initializer function of the contract. It replaces the constructor()\\r\\n     * function in the context of upgradeable contracts.\\r\\n     * @dev See: https://docs.openzeppelin.com/contracts/4.x/upgradeable\\r\\n     * @param globalOwner_ The address of the GlobalOwner contract.\\r\\n     * @param globalPause_ The address of the GlobalPause contract.\\r\\n     * @param globalBlacklist_ The address of the GlobalBlacklist contract.\\r\\n     * @param underlyingToken The address of the underlying stablecoin ERC20 token.\\r\\n     */\\r\\n    function initialize(\\r\\n        address globalOwner_,\\r\\n        address globalPause_,\\r\\n        address globalBlacklist_,\\r\\n        address ldyStaking_,\\r\\n        address underlyingToken\\r\\n    ) public initializer {\\r\\n        // Initialize ERC20 base.\\r\\n        string memory underlyingSymbol = IERC20MetadataUpgradeable(underlyingToken).symbol();\\r\\n        __ERC20Base_init(\\r\\n            globalOwner_,\\r\\n            globalPause_,\\r\\n            globalBlacklist_,\\r\\n            string(abi.encodePacked(\\\"Ledgity \\\", underlyingSymbol)),\\r\\n            string(abi.encodePacked(\\\"L\\\", underlyingSymbol))\\r\\n        );\\r\\n\\r\\n        // IMPORTANT: Below calls must not be restricted to owner at any point.\\r\\n        // This is because the GlobalOwner contract may not be a fresh one, and so\\r\\n        // the contract deployer may not be the owner anymore after ERC20Base init.\\r\\n\\r\\n        // Initialize other parents contracts.\\r\\n        __ERC20Wrapper_init(IERC20Upgradeable(underlyingToken));\\r\\n        __Invest_init_unchained(address(this));\\r\\n\\r\\n        // Set LDYStaking contract\\r\\n        ldyStaking = LDYStaking(ldyStaking_);\\r\\n\\r\\n        // Set initial withdrawal fees rate to 0.3%\\r\\n        feesRateUD7x3 = 300;\\r\\n\\r\\n        // Set initial retention rate to 10%\\r\\n        retentionRateUD7x3 = 10_000;\\r\\n\\r\\n        // Default withdrawer and fund wallet to contract owner address. This prevents\\r\\n        // any loss of funds if a deposit/withdrawal is made before those are manually set.\\r\\n        withdrawer = payable(owner());\\r\\n        fund = payable(owner());\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Required override of decimals() which is implemented by both\\r\\n     * ERC20Upgradeable and ERC20WrapperUpgradeable parent contracts.\\r\\n     * @dev The ERC20WrapperUpgradeable version is preferred because it mirrors the\\r\\n     * decimals amount of the underlying stablecoin token.\\r\\n     * @inheritdoc ERC20WrapperUpgradeable\\r\\n     */\\r\\n    function decimals()\\r\\n        public\\r\\n        view\\r\\n        override(ERC20Upgradeable, ERC20WrapperUpgradeable)\\r\\n        returns (uint8)\\r\\n    {\\r\\n        return ERC20WrapperUpgradeable.decimals();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Required override of paused() which is implemented by both\\r\\n     * GlobalPausableUpgradeable and ERC20BaseUpgradeable parent contracts.\\r\\n     * @dev Both version are the same as ERC20BaseUpgradeable.paused() mirrors\\r\\n     * GlobalPausableUpgradeable.paused(), so a random one is chosen.\\r\\n     * @inheritdoc GlobalPausableUpgradeable\\r\\n     */\\r\\n    function paused()\\r\\n        public\\r\\n        view\\r\\n        virtual\\r\\n        override(GlobalPausableUpgradeable, ERC20BaseUpgradeable)\\r\\n        returns (bool)\\r\\n    {\\r\\n        return GlobalPausableUpgradeable.paused();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Updates the current withdrawal fee rate.\\r\\n     * @param feesRateUD7x3_ The new withdrawal fee rate in UD7x3 format.\\r\\n     */\\r\\n    function setFeesRate(uint32 feesRateUD7x3_) public onlyOwner {\\r\\n        feesRateUD7x3 = feesRateUD7x3_;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Updates the current underlying token retention rate.\\r\\n     * @dev The retention rate is capped at 10%, which ensures that no more than 10% of\\r\\n     * deposited assets will ever be exposed in this contract (reduces attack surface).\\r\\n     * @param retentionRateUD7x3_ The new retention rate in UD7x3 format.\\r\\n     */\\r\\n    function setRetentionRate(uint32 retentionRateUD7x3_) public onlyOwner {\\r\\n        require(retentionRateUD7x3_ <= MAX_RETENTION_RATE_UD7x3, \\\"L41\\\");\\r\\n        retentionRateUD7x3 = retentionRateUD7x3_;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Updates the address of LDYStaking contract.\\r\\n     * @param ldyStakingAddress The address of the new LDYStaking contract.\\r\\n     */\\r\\n    function setLDYStaking(address ldyStakingAddress) public onlyOwner {\\r\\n        ldyStaking = LDYStaking(ldyStakingAddress);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Updates the address of the withdrawer wallet.\\r\\n     * @param withdrawer_ The address of the new withdrawer wallet.\\r\\n     */\\r\\n    function setWithdrawer(address payable withdrawer_) public onlyOwner {\\r\\n        // Ensure address is not the zero address (pre-processing fees would be lost else)\\r\\n        require(withdrawer_ != address(0), \\\"L63\\\");\\r\\n\\r\\n        // Set new withdrawer wallet's address\\r\\n        withdrawer = withdrawer_;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Updates the address of the fund wallet.\\r\\n     * @param fund_ The address of the new fund wallet.\\r\\n     */\\r\\n    function setFund(address payable fund_) public onlyOwner {\\r\\n        // Ensure address is not the zero address (deposited tokens would be lost else)\\r\\n        require(fund_ != address(0), \\\"L64\\\");\\r\\n\\r\\n        // Set new fund wallet's address\\r\\n        fund = fund_;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Adds a new contract to the L-Token transfers list.\\r\\n     * @dev Each time a transfer occurs, the onLTokenTransfer() function of the\\r\\n     * specified contract will be called.\\r\\n     * @dev IMPORTANT SECURITY NOTE: This method is not intended to be used with\\r\\n     * contracts that are not owned by the Ledgity team.\\r\\n     * @param listenerContract The address of the new transfers listener contract.\\r\\n     */\\r\\n    function listenToTransfers(address listenerContract) public onlyOwner {\\r\\n        transfersListeners.push(ITransfersListener(listenerContract));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Removes a contract from the L-Token transfers list.\\r\\n     * @dev The onLTokenTransfer() function of the specified contract will not be called\\r\\n     * anymore each time a L-Token transfer occurs.\\r\\n     * @param listenerContract The address of the listener contract.\\r\\n     */\\r\\n    function unlistenToTransfers(address listenerContract) public onlyOwner {\\r\\n        // Find index of listener contract in transferListeners array\\r\\n        int256 index = -1;\\r\\n        uint256 transfersListenersLength = transfersListeners.length;\\r\\n        for (uint256 i = 0; i < transfersListenersLength; i++) {\\r\\n            if (address(transfersListeners[i]) == listenerContract) {\\r\\n                index = int256(i);\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Revert if given contract wasn't listening to transfers\\r\\n        require(index > -1, \\\"L42\\\");\\r\\n\\r\\n        // Else, remove transfers listener contract from listeners array\\r\\n        transfersListeners[uint256(index)] = transfersListeners[transfersListenersLength - 1];\\r\\n        transfersListeners.pop();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Retrieves the amount of given account's not yet minted rewards.\\r\\n     * @dev This is a public implementation of InvestUpgradeable_rewardsOf(). In the\\r\\n     * context of LToken, this function returns the amount of rewards that have not been\\r\\n     * distributed/minted yet to the specified account.\\r\\n     * @dev This is particularly useful for off-chain services to display charts and\\r\\n     * statistics, as seen in the Ledgity Yield's frontend.\\r\\n     * @param account The account to check the unminted rewards of.\\r\\n     * @return The amount of account's unminted rewards.\\r\\n     */\\r\\n    function unmintedRewardsOf(address account) public view returns (uint256) {\\r\\n        return _rewardsOf(account, true);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Retrieves the \\\"real\\\" balance of an account, i.e., excluding its not yet\\r\\n     * minted/distributed rewards.\\r\\n     * @param account The account to check the real balance of.\\r\\n     * @return The real balance of the account.\\r\\n     */\\r\\n    function realBalanceOf(address account) public view returns (uint256) {\\r\\n        return super.balanceOf(account);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Retrieves the total balance of L-Tokens that belong to the account.\\r\\n     * @dev This is an oOverride of ERC20Upgradeable.balanceOf() that rewards that have\\r\\n     * not been yet minted to the specified account.\\r\\n     * @param account The account to check the total balance of.\\r\\n     * @return The total balance of the account.\\r\\n     */\\r\\n    function balanceOf(address account) public view override returns (uint256) {\\r\\n        return realBalanceOf(account) + unmintedRewardsOf(account);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Returns the \\\"real\\\" amount of existing L-Tokens, i.e., excluding not yet\\r\\n     * minted withdrawal fees and L-Tokens currently in the withdrawal queue.\\r\\n     * @return The real total supply of L-Tokens.\\r\\n     */\\r\\n    function realTotalSupply() public view returns (uint256) {\\r\\n        return super.totalSupply();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Retrives the total supply of L-Tokens, including not yet minted withdrawal\\r\\n     * fees and L-Tokens currently in the withdrawal queue.\\r\\n     * @return The total supply of L-Tokens.\\r\\n     */\\r\\n    function totalSupply() public view override returns (uint256) {\\r\\n        return realTotalSupply() + totalQueued + unclaimedFees;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Recovers a specified amount of a given token address.\\r\\n     * @dev This override of RecoverableUpgradeable.recoverERC20() prevents the recovered\\r\\n     * token from being the underlying token.\\r\\n     * @inheritdoc RecoverableUpgradeable\\r\\n     */\\r\\n    function recoverERC20(address tokenAddress, uint256 amount) public override onlyOwner {\\r\\n        // Ensure the token is not the underlying token\\r\\n        require(tokenAddress != address(underlying()), \\\"L43\\\");\\r\\n\\r\\n        // Proceed to recovery\\r\\n        super.recoverERC20(tokenAddress, amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Recovers underlying tokens accidentally sent to the contract.\\r\\n     * @dev To prevent owner from being able to drain the contract, this function only\\r\\n     * allows recovering \\\"unusable\\\" underlying tokens, i.e., tokens that have not been\\r\\n     * sent through fund() or deposit() functions.\\r\\n     */\\r\\n    function recoverUnderlying() external onlyOwner {\\r\\n        // Compute the recoverable amount by taking the difference between the contract's\\r\\n        // balance and the amount of usable underlying tokens\\r\\n        uint256 recoverableAmount = underlying().balanceOf(address(this)) - usableUnderlyings;\\r\\n\\r\\n        // Revert if there is nothing to recover\\r\\n        require(recoverableAmount > 0, \\\"L44\\\");\\r\\n\\r\\n        // Else, proceed to underlying tokens recovery\\r\\n        super.recoverERC20(address(underlying()), recoverableAmount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Retrieves the amount of underlying tokens invested by the given account.\\r\\n     * @dev Implementing this function is required by the InvestUpgradeable contract. In\\r\\n     * LToken contract, the investment of an account is equal to its real balance.\\r\\n     * @inheritdoc InvestUpgradeable\\r\\n     */\\r\\n    function _investmentOf(address account) internal view override returns (uint256) {\\r\\n        return realBalanceOf(account);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Distributes a specified amount of rewards (in L-Tokens) to a given account.\\r\\n     * @dev Implementing this function is required by the InvestUpgradeable contract so\\r\\n     * it can distribute rewards to accounts before each period reset.\\r\\n     * @dev InvestUpgradeable contract already ensure that amount > 0.\\r\\n     * @inheritdoc InvestUpgradeable\\r\\n     */\\r\\n    function _distributeRewards(address account, uint256 amount) internal override returns (bool) {\\r\\n        // Inform listeners of the rewards minting\\r\\n        emit MintedRewardsEvent(account, realBalanceOf(account), amount);\\r\\n\\r\\n        // Mint L-Tokens rewards to account\\r\\n        _mint(account, amount);\\r\\n\\r\\n        // Return true indicating to InvestUpgradeable that the rewards have been distributed\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Override of ERC20._beforeTokenTransfer() to integrate with InvestUpgradeable.\\r\\n     * @dev This overriden version ensure that _beforeInvestmentChange() hook is properly\\r\\n     * called each time an account's balance is going to change.\\r\\n     * @dev Note: whenNotPaused and notBlacklisted modifiers are not set as they are\\r\\n     * already included in ERC20BaseUpgradeable._beforeTokenTransfer().\\r\\n     * @inheritdoc ERC20BaseUpgradeable\\r\\n     */\\r\\n    function _beforeTokenTransfer(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) internal override(ERC20Upgradeable, ERC20BaseUpgradeable) {\\r\\n        ERC20BaseUpgradeable._beforeTokenTransfer(from, to, amount);\\r\\n\\r\\n        // Invoke _beforeInvestmentChange() hook for non-zero accounts\\r\\n        if (from != address(0)) _beforeInvestmentChange(from, true);\\r\\n        if (to != address(0)) _beforeInvestmentChange(to, true);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Override of ERC20._afterTokenTransfer() to notify all transfers listeners.\\r\\n     * @dev This overriden version will trigger onLTokenTransfer() functions of all\\r\\n     * transfers listeners.\\r\\n     * @dev Note: whenNotPaused and notBlacklisted modifiers are not set as they are\\r\\n     * already checked in _beforeTokenTransfer().\\r\\n     * @inheritdoc ERC20Upgradeable\\r\\n     */\\r\\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal override {\\r\\n        super._afterTokenTransfer(from, to, amount);\\r\\n\\r\\n        // If some L-Token have been burned/minted, inform listeners of a TVL change\\r\\n        if (from == address(0) || to == address(0)) emit TVLChangeEvent(totalSupply());\\r\\n\\r\\n        // Trigger onLTokenTransfer() functions of all the transfers listeners\\r\\n        for (uint256 i = 0; i < transfersListeners.length; i++) {\\r\\n            transfersListeners[i].onLTokenTransfer(from, to, amount);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Computes the maximum amount of underlying tokens that should be retained\\r\\n     * by the contract (based on retention rate).\\r\\n     * @return amount The expected amount of retained underlying tokens.\\r\\n     */\\r\\n    function getExpectedRetained() public view returns (uint256 amount) {\\r\\n        // Cache invested token's decimals number\\r\\n        uint256 d = SUD.decimalsOf(address(invested()));\\r\\n\\r\\n        // Convert totalSupply and retentionRate to SUD\\r\\n        uint256 totalSupplySUD = SUD.fromAmount(totalSupply(), d);\\r\\n        uint256 retentionRateSUD = SUD.fromRate(retentionRateUD7x3, d);\\r\\n\\r\\n        // Compute and return expected retained amount\\r\\n        uint256 expectedRetainedSUD = (totalSupplySUD * retentionRateSUD) / SUD.fromInt(100, d);\\r\\n        return SUD.toAmount(expectedRetainedSUD, d);\\r\\n    }\\r\\n\\r\\n    /// @notice Transfers underlying tokens exceeding the retention rate to the fund wallet.\\r\\n    function _transferExceedingToFund() internal {\\r\\n        // Retrieve the expected amount retained\\r\\n        uint256 expectedRetained = getExpectedRetained();\\r\\n\\r\\n        // If usable underlyings are less than or equal to expected retained, return\\r\\n        if (usableUnderlyings <= expectedRetained) return;\\r\\n\\r\\n        // Else, exceeding amount is equal to difference between those values\\r\\n        uint256 exceedingAmount = usableUnderlyings - expectedRetained;\\r\\n\\r\\n        // Decrease usable underlyings amount accordingly\\r\\n        usableUnderlyings -= exceedingAmount;\\r\\n\\r\\n        // Transfer the exceeding amount to the fund wallet\\r\\n        underlying().safeTransfer(fund, exceedingAmount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Override of ERC20WrapperUpgradeable.withdrawTo() that reverts.\\r\\n     * Use instantWithdrawal() or requestWithdrawal() functions instead.\\r\\n     * @inheritdoc ERC20WrapperUpgradeable\\r\\n     */\\r\\n    function withdrawTo(address account, uint256 amount) public pure override returns (bool) {\\r\\n        account; // Silence unused variable compiler warning\\r\\n        amount;\\r\\n        revert(\\\"L45\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Override of ERC20WrapperUpgradeable.depositFor() that reverts.\\r\\n     * Use deposit() function instead.\\r\\n     * @inheritdoc ERC20WrapperUpgradeable\\r\\n     */\\r\\n    function depositFor(address account, uint256 amount) public pure override returns (bool) {\\r\\n        account; // Silence unused variable compiler warning\\r\\n        amount;\\r\\n        revert(\\\"L46\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Allows exchanging some underlying tokens for the same amount of L-Tokens.\\r\\n     * @param amount The amount of underlying tokens to deposit.\\r\\n     */\\r\\n    function deposit(uint256 amount) public whenNotPaused notBlacklisted(_msgSender()) {\\r\\n        // Ensure the account has enough underlying tokens to deposit\\r\\n        require(underlying().balanceOf(_msgSender()) >= amount, \\\"L47\\\");\\r\\n\\r\\n        // Update usable underlyings balance accordingly\\r\\n        usableUnderlyings += amount;\\r\\n\\r\\n        // Inform listeners of the deposit activity event\\r\\n        emit ActivityEvent(\\r\\n            NO_ID,\\r\\n            _msgSender(),\\r\\n            Action.Deposit,\\r\\n            amount,\\r\\n            amount,\\r\\n            Status.Success,\\r\\n            NO_ID\\r\\n        );\\r\\n\\r\\n        // Receive underlying tokens and mint L-Tokens to the account in a 1:1 ratio\\r\\n        super.depositFor(_msgSender(), amount);\\r\\n\\r\\n        // Transfer exceeding underlying tokens to the fund wallet\\r\\n        _transferExceedingToFund();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Computes fees and net withdrawn amount for a given account withdrawing a\\r\\n     * given amount.\\r\\n     * @param account The account initiating the withdrawal.\\r\\n     * @param amount The amount of the withdrawal.\\r\\n     */\\r\\n    function getWithdrawnAmountAndFees(\\r\\n        address account,\\r\\n        uint256 amount\\r\\n    ) public view returns (uint256 withdrawnAmount, uint256 fees) {\\r\\n        // If the account is eligible to staking tier 2, no fees are applied\\r\\n        if (ldyStaking.tierOf(account) >= 2) return (amount, 0);\\r\\n\\r\\n        // Cache invested token's decimals number\\r\\n        uint256 d = SUD.decimalsOf(address(invested()));\\r\\n\\r\\n        // Convert amount and fees rate to SUD\\r\\n        uint256 amountSUD = SUD.fromAmount(amount, d);\\r\\n        uint256 feesRateSUD = SUD.fromRate(feesRateUD7x3, d);\\r\\n\\r\\n        // Compute fees and withdrawn amount (initial amount minus fees)\\r\\n        uint256 feesSUD = (amountSUD * feesRateSUD) / SUD.fromInt(100, d);\\r\\n        fees = SUD.toAmount(feesSUD, d);\\r\\n        withdrawnAmount = amount - fees;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Allows instaneously exchanging a given amount of L-Tokens for the same\\r\\n     * amount of underlying tokens. It will fail if the contract currently doesn't hold\\r\\n     * enough underlying tokens to cover the withdrawal.\\r\\n     * @dev In order to save some gas and time to users, frontends should propose this\\r\\n     * function to users only when it has been verified that it will not revert. They\\r\\n     * should propose the requestWithdrawal() function otherwise.\\r\\n     * @param amount The amount L-Tokens to withdraw.\\r\\n     */\\r\\n    function instantWithdrawal(uint256 amount) external whenNotPaused notBlacklisted(_msgSender()) {\\r\\n        // Ensure the account has enough L-Tokens to withdraw\\r\\n        require(amount <= balanceOf(_msgSender()), \\\"L48\\\");\\r\\n\\r\\n        // Can the contract cover this withdrawal plus all already queued requests?\\r\\n        bool cond1 = totalQueued + amount <= usableUnderlyings;\\r\\n\\r\\n        // Is caller eligible to staking tier 2 and the contract can cover this withdrawal?\\r\\n        bool cond2 = ldyStaking.tierOf(_msgSender()) >= 2 && amount <= usableUnderlyings;\\r\\n\\r\\n        // Revert if conditions are not met for the withdrawal to be processed instantaneously\\r\\n        if (!(cond1 || cond2)) revert(\\\"L49\\\");\\r\\n\\r\\n        // Else, retrieve withdrawal fees and net withdrawn amount\\r\\n        (uint256 withdrawnAmount, uint256 fees) = getWithdrawnAmountAndFees(_msgSender(), amount);\\r\\n\\r\\n        // Increase unclaimed fees amount accordingly\\r\\n        unclaimedFees += fees;\\r\\n\\r\\n        // Decrease usable underlyings balance accordingly\\r\\n        usableUnderlyings -= withdrawnAmount;\\r\\n\\r\\n        // Inform listeners of this instant withdrawal activity event\\r\\n        emit ActivityEvent(\\r\\n            NO_ID,\\r\\n            _msgSender(),\\r\\n            Action.Withdraw,\\r\\n            amount,\\r\\n            withdrawnAmount,\\r\\n            Status.Success,\\r\\n            NO_ID\\r\\n        );\\r\\n\\r\\n        // Burn withdrawal fees from the account\\r\\n        _burn(_msgSender(), fees);\\r\\n\\r\\n        // Burn account's withdrawn L-Tokens and transfer to it underlying tokens in a 1:1 ratio\\r\\n        super.withdrawTo(_msgSender(), withdrawnAmount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Allows requesting the exchange of a given amount of L-Tokens for the same\\r\\n     * amount of underlying tokens. The request will be automatically processed later.\\r\\n     * @dev The sender must attach 0.003 ETH to pre-pay the future processing gas fees\\r\\n     * paid by the withdrawer wallet.\\r\\n     * @param amount The amount L-Tokens to withdraw.\\r\\n     */\\r\\n    function requestWithdrawal(\\r\\n        uint256 amount\\r\\n    ) public payable whenNotPaused notBlacklisted(_msgSender()) {\\r\\n        // Ensure the account has enough L-Tokens to withdraw\\r\\n        require(amount <= balanceOf(_msgSender()), \\\"L53\\\");\\r\\n\\r\\n        // Ensure the requested amount doesn't overflow uint96\\r\\n        require(amount <= type(uint96).max, \\\"L54\\\");\\r\\n\\r\\n        // Ensure the sender attached the pre-paid processing gas fees\\r\\n        require(msg.value == 0.003 * 10 ** 18, \\\"L55\\\");\\r\\n\\r\\n        // Create withdrawal request data\\r\\n        WithdrawalRequest memory request = WithdrawalRequest({\\r\\n            account: _msgSender(),\\r\\n            amount: uint96(amount)\\r\\n        });\\r\\n\\r\\n        // Will hold the request ID\\r\\n        uint256 requestId;\\r\\n\\r\\n        // Append request to the withdrawal queue:\\r\\n        // - At the beginning, if account is eligible to staking tier 2 and cursor is not 0\\r\\n        if (ldyStaking.tierOf(_msgSender()) >= 2 && withdrawalQueueCursor > 0) {\\r\\n            withdrawalQueueCursor--;\\r\\n            requestId = withdrawalQueueCursor;\\r\\n            withdrawalQueue[requestId] = request;\\r\\n        }\\r\\n        // - At the end else\\r\\n        else {\\r\\n            withdrawalQueue.push(request);\\r\\n            requestId = withdrawalQueue.length - 1;\\r\\n        }\\r\\n\\r\\n        // Increase total amount queued accordingly\\r\\n        totalQueued += amount;\\r\\n\\r\\n        // Inform listeners of this new queued withdrawal activity event\\r\\n        emit ActivityEvent(\\r\\n            int256(requestId),\\r\\n            _msgSender(),\\r\\n            Action.Withdraw,\\r\\n            amount,\\r\\n            amount,\\r\\n            Status.Queued,\\r\\n            NO_ID\\r\\n        );\\r\\n\\r\\n        // Burn withdrawal L-Tokens amount from account's balance\\r\\n        _burn(_msgSender(), amount);\\r\\n\\r\\n        // Forward pre-paid processing gas fees to the withdrawer wallet\\r\\n        (bool sent, ) = withdrawer.call{value: msg.value}(\\\"\\\");\\r\\n        require(sent, \\\"L56\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Processes queued withdrawal requests until there is else no more requests,\\r\\n     * else not enough underlying tokens to continue.\\r\\n     * @dev For further details, see \\\"LToken  > Withdrawals\\\" section of whitepaper.\\r\\n     */\\r\\n    function processQueuedRequests() external onlyWithdrawer whenNotPaused {\\r\\n        // Accumulators variables, will be written on-chain after the loop\\r\\n        uint256 cumulatedFees = 0;\\r\\n        uint256 cumulatedWithdrawnAmount = 0;\\r\\n        uint256 nextRequestId = withdrawalQueueCursor;\\r\\n\\r\\n        // Cache queue length to avoid multiple SLOADs and avoid infinite loop as big\\r\\n        // requests are increasing the queue length when moved at the end of the queue.\\r\\n        uint256 queueLength = withdrawalQueue.length;\\r\\n\\r\\n        // Iterate over requests to be processed\\r\\n        while (nextRequestId < queueLength) {\\r\\n            // Stop processing requests if there is not enough gas left to continue the\\r\\n            // loop and properly end the function call. This prevents an attacker from\\r\\n            // blocking the withdrawal processing by creating a ton of tiny requests so\\r\\n            // this function call cannot fit anymore in block gas limit.\\r\\n            if (gasleft() < 45000) break;\\r\\n\\r\\n            // Retrieve request data\\r\\n            WithdrawalRequest memory request = withdrawalQueue[nextRequestId];\\r\\n\\r\\n            // Skip empty request (processed big requests or cancelled requests)\\r\\n            if (request.account == address(0)) {}\\r\\n            //\\r\\n            // If account has been blacklisted since request emission\\r\\n            else if (isBlacklisted(request.account)) {\\r\\n                // Remove request from queue\\r\\n                delete withdrawalQueue[nextRequestId];\\r\\n\\r\\n                // Append request in the frozen requests list\\r\\n                frozenRequests.push(request);\\r\\n            }\\r\\n            //\\r\\n            // Or if request is a big request, move it at the end of the queue for now.\\r\\n            // This request will be processed manually later using processBigQueuedRequest()\\r\\n            else if (request.amount > getExpectedRetained() / 2) {\\r\\n                // Inform listeners of this queued request being moved at the end of the queue\\r\\n                emit ActivityEvent(\\r\\n                    int256(nextRequestId),\\r\\n                    _msgSender(),\\r\\n                    Action.Withdraw,\\r\\n                    request.amount,\\r\\n                    request.amount,\\r\\n                    Status.Moved,\\r\\n                    int256(withdrawalQueue.length)\\r\\n                );\\r\\n\\r\\n                // Remove request from queue\\r\\n                delete withdrawalQueue[nextRequestId];\\r\\n\\r\\n                // Append request at the end of the queue\\r\\n                withdrawalQueue.push(request);\\r\\n            }\\r\\n            //\\r\\n            // Else, continue request processing\\r\\n            else {\\r\\n                // Retrieve withdrawal fees and net withdrawn amount\\r\\n                (uint256 withdrawnAmount, uint256 fees) = getWithdrawnAmountAndFees(\\r\\n                    request.account,\\r\\n                    request.amount\\r\\n                );\\r\\n\\r\\n                // Break if the contract doesn't hold enough funds to cover the request\\r\\n                if (withdrawnAmount > usableUnderlyings - cumulatedWithdrawnAmount) break;\\r\\n\\r\\n                // Accumulate fees and withdrawn amount\\r\\n                cumulatedFees += fees;\\r\\n                cumulatedWithdrawnAmount += withdrawnAmount;\\r\\n\\r\\n                // Inform listeners of this queued withdrawal processing activity event\\r\\n                emit ActivityEvent(\\r\\n                    int256(nextRequestId),\\r\\n                    request.account,\\r\\n                    Action.Withdraw,\\r\\n                    request.amount,\\r\\n                    withdrawnAmount,\\r\\n                    Status.Success,\\r\\n                    NO_ID\\r\\n                );\\r\\n\\r\\n                // Remove request from queue\\r\\n                delete withdrawalQueue[nextRequestId];\\r\\n\\r\\n                // Transfer underlying tokens to account. Burning L-Tokens is not required\\r\\n                // as equestWithdrawal() already did it.\\r\\n                // Security note: Re-entrancy warning are disabled as the request has\\r\\n                // just been deleted from the queue, it will so be skipped if trying to\\r\\n                // process it again.\\r\\n                // slither-disable-next-line reentrancy-no-eth\\r\\n                underlying().safeTransfer(request.account, withdrawnAmount);\\r\\n            }\\r\\n\\r\\n            // Increment next request ID\\r\\n            nextRequestId++;\\r\\n        }\\r\\n\\r\\n        // Increase unclaimed fees by the amount of cumulated fees\\r\\n        unclaimedFees += cumulatedFees;\\r\\n\\r\\n        // Decrease usable underlyings by the cumulated amount of withdrawn underlyings\\r\\n        usableUnderlyings -= cumulatedWithdrawnAmount;\\r\\n\\r\\n        // Decrease total amount queued by the cumulated amount requested\\r\\n        totalQueued -= cumulatedWithdrawnAmount + cumulatedFees;\\r\\n\\r\\n        // Update new queue cursor\\r\\n        withdrawalQueueCursor = nextRequestId;\\r\\n\\r\\n        // Retention rate cannot exceeds as the withdrawal decreases both usable\\r\\n        // underlyings and expected retained amounts by the same number and as the\\r\\n        // expected retained amount is a subset of usable underlyings amount.\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Processes a given queued big withdrawal request (one that exceeds half of\\r\\n     * the retention rate).\\r\\n     * @dev In contrast to non-big requests processing, this function will uses to fund\\r\\n     * wallet's balance to fill the request. This allows processing requests that are\\r\\n     * greater than retention rate without having to exceed this rate on the contract.\\r\\n     * @param requestId The ID of the big request to process.\\r\\n     */\\r\\n    function processBigQueuedRequest(uint256 requestId) external onlyFund whenNotPaused {\\r\\n        // Retrieve request data\\r\\n        WithdrawalRequest memory request = withdrawalQueue[requestId];\\r\\n\\r\\n        // Ensure the request is active\\r\\n        require(request.account != address(0), \\\"L66\\\");\\r\\n\\r\\n        // Ensure the request emitter has not been blacklisted since request emission\\r\\n        require(!isBlacklisted(request.account), \\\"L50\\\");\\r\\n\\r\\n        // Ensure this is indeed a big request\\r\\n        require(request.amount > getExpectedRetained() / 2, \\\"L51\\\");\\r\\n\\r\\n        // Retrieve withdrawal fees and net withdrawn amount\\r\\n        (uint256 withdrawnAmount, uint256 fees) = getWithdrawnAmountAndFees(\\r\\n            request.account,\\r\\n            request.amount\\r\\n        );\\r\\n\\r\\n        // Ensure withdrawn amount can be covered by contract + fund wallet balances\\r\\n        uint256 fundBalance = underlying().balanceOf(fund);\\r\\n        require(withdrawnAmount <= usableUnderlyings + fundBalance, \\\"L52\\\");\\r\\n\\r\\n        // Increase amount of unclaimed fees accordingly\\r\\n        unclaimedFees += fees;\\r\\n\\r\\n        // Decrease total queued amount by request amount\\r\\n        totalQueued -= request.amount;\\r\\n\\r\\n        // Increment queue cursor if request was the next request to be processed\\r\\n        if (requestId == withdrawalQueueCursor) withdrawalQueueCursor++;\\r\\n\\r\\n        // Inform listeners of this queued withdrawal processing activity event\\r\\n        emit ActivityEvent(\\r\\n            int256(requestId),\\r\\n            request.account,\\r\\n            Action.Withdraw,\\r\\n            request.amount,\\r\\n            withdrawnAmount,\\r\\n            Status.Success,\\r\\n            NO_ID\\r\\n        );\\r\\n\\r\\n        // Remove request from queue\\r\\n        delete withdrawalQueue[requestId];\\r\\n\\r\\n        // If fund wallet's balance can cover request, rely on it only\\r\\n        if (withdrawnAmount <= fundBalance) {\\r\\n            underlying().safeTransferFrom(_msgSender(), request.account, withdrawnAmount);\\r\\n        }\\r\\n        // Else, cover request from both fund wallet and contract balances\\r\\n        else {\\r\\n            // Compute amount missing from fund wallet to cover request\\r\\n            uint256 missingAmount = withdrawnAmount - fundBalance;\\r\\n\\r\\n            // Decrease usable amount of underlying tokens accordingly\\r\\n            usableUnderlyings -= missingAmount;\\r\\n\\r\\n            // Transfer entire fund balance to request's emitter\\r\\n            underlying().safeTransferFrom(_msgSender(), request.account, fundBalance);\\r\\n\\r\\n            // Transfer missing amount from contract balance to request emitter\\r\\n            underlying().safeTransfer(request.account, missingAmount);\\r\\n        }\\r\\n\\r\\n        // Transfer exceeding underlying tokens to the fund wallet\\r\\n        _transferExceedingToFund();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Cancels a given withdrawal request. The request emitter receive back its\\r\\n     * L-Tokens and no fees will be charged.\\r\\n     * @param requestId The ID of the withdrawal request to cancel.\\r\\n     */\\r\\n    function cancelWithdrawalRequest(\\r\\n        uint256 requestId\\r\\n    ) public whenNotPaused notBlacklisted(_msgSender()) {\\r\\n        // Retrieve request data\\r\\n        WithdrawalRequest memory request = withdrawalQueue[requestId];\\r\\n\\r\\n        // Ensure request belongs to caller\\r\\n        require(_msgSender() == request.account, \\\"L57\\\");\\r\\n\\r\\n        // Decrease total amount queued accordingly\\r\\n        totalQueued -= request.amount;\\r\\n\\r\\n        // Delete the withdrawal request from queue\\r\\n        delete withdrawalQueue[requestId];\\r\\n\\r\\n        // Inform listeners of this cancelled withdrawal request activity event\\r\\n        emit ActivityEvent(\\r\\n            int256(requestId),\\r\\n            request.account,\\r\\n            Action.Withdraw,\\r\\n            request.amount,\\r\\n            request.amount,\\r\\n            Status.Cancelled,\\r\\n            NO_ID\\r\\n        );\\r\\n\\r\\n        // Mint back L-Tokens to account\\r\\n        _mint(request.account, uint256(request.amount));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Used by the fund wallet to repatriate underlying tokens on the contract\\r\\n     * whenever those are required to fulfill some withdrawal requests.\\r\\n     * @dev The function will revert if repatriated amount makes the contract exceeding\\r\\n     * the retention rate.\\r\\n     * @param amount The amount of underlying tokens to repatriate.\\r\\n     */\\r\\n    function repatriate(uint256 amount) external onlyFund whenNotPaused {\\r\\n        // Ensure the fund wallet has enough funds to repatriate\\r\\n        require(amount <= underlying().balanceOf(fund), \\\"L58\\\");\\r\\n\\r\\n        // Calculate new contract usable balance\\r\\n        uint256 newBalance = usableUnderlyings + amount;\\r\\n\\r\\n        // Ensure the new balance doesn't exceed the retention rate\\r\\n        require(newBalance <= getExpectedRetained(), \\\"L59\\\");\\r\\n\\r\\n        // Increase usable underlyings amount by repatriated amount\\r\\n        usableUnderlyings += amount;\\r\\n\\r\\n        // Transfer amount from fund wallet to contract\\r\\n        underlying().safeTransferFrom(_msgSender(), address(this), amount);\\r\\n    }\\r\\n\\r\\n    /// @notice Used by owner to claim fees generated from successful withdrawals.\\r\\n    function claimFees() external onlyOwner {\\r\\n        // Ensure there are some fees to claim\\r\\n        require(unclaimedFees > 0, \\\"L60\\\");\\r\\n\\r\\n        // Ensure the contract holds enough underlying tokens to cover fees\\r\\n        require(usableUnderlyings >= unclaimedFees, \\\"L61\\\");\\r\\n\\r\\n        // Decrease usable underlyings amount accordingly\\r\\n        usableUnderlyings -= unclaimedFees;\\r\\n\\r\\n        // Store fees amount in memory and reset unclaimed fees amount\\r\\n        uint256 fees = unclaimedFees;\\r\\n        unclaimedFees = 0;\\r\\n\\r\\n        // Transfer unclaimed fees to owner\\r\\n        underlying().safeTransfer(owner(), fees);\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x13d036e334e664e5ee7d76c67d887fe7b7468fc23c323d527fbfca87ab436682\",\"license\":\"MIT\"},\"contracts/src/PreMining.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.18;\\r\\n\\r\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\nimport {LToken} from \\\"./LToken.sol\\\";\\r\\nimport {SafeERC20} from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\r\\nimport {Ownable2Step} from \\\"@openzeppelin/contracts/access/Ownable2Step.sol\\\";\\r\\nimport {Pausable} from \\\"@openzeppelin/contracts/security/Pausable.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title PreMining\\r\\n * @author Lila Rest (https://lila.rest)\\r\\n * @custom:security-contact security@ledgity.com\\r\\n\\r\\n * @notice PreMining pool contract, allowing accounts to lock underlying tokens in a \\r\\n * pre-defined L-Token contract, over a given duration (in months), in exchange of \\r\\n * vested LDY rewards.\\r\\n * \\r\\n * @dev Intuition\\r\\n * \\r\\n * Lifecycle of a lockdrop pool is composed by 3 main phases:\\r\\n * 1) Deposit: During this phase, users can lock their underlying tokens.\\r\\n * 2) Claim: During this phase, users can claim their LDY rewards.\\r\\n * 3) Recovery: During this phase, owner can recover remaining ERC20 on the contract.\\r\\n * \\r\\n * Transitioning between two phases is manually triggered by contract's owner.\\r\\n * To ensure fair usage of this power and prevent potential misuse:\\r\\n * - the Recovery phase cannot start before 3 months after the end of rewards vesting,\\r\\n * - the Recovery phase cannot start before 3 months after the maximum lock end.\\r\\n * \\r\\n * Finally, note that this contract proxies main L-Token contract's functions:\\r\\n * - lock() --> deposit()\\r\\n * - instantUnlock() --> instantWithdrawal()\\r\\n * - requestUnlock() --> requestWithdrawal()\\r\\n * This design enables users to interact with the PreMining contract in a similar fashion\\r\\n * to the L-Token contract.\\r\\n * \\r\\n * @dev Definitions:\\r\\n * - Locker: An account that has locked underlying tokens in the pool.\\r\\n * \\r\\n * @custom:security-contact security@ledgity.com\\r\\n */\\r\\ncontract PreMining is Ownable2Step, Pausable {\\r\\n    using SafeERC20 for IERC20;\\r\\n\\r\\n    /**\\r\\n     * @notice Represents the lock information of an account.\\r\\n     * @param amount Amount of underlying tokens locked.\\r\\n     * @param duration Duration of the lock (in months).\\r\\n     * @param hasUnlocked Whether the account has unlocked its locked tokens.\\r\\n     * @param claimedRewards Amount of LDY rewards already claimed.\\r\\n     * @param lockEndTimestamp Timestamp at which the account's lock ends.\\r\\n     */\\r\\n    struct AccountLock {\\r\\n        uint240 amount;\\r\\n        uint8 duration;\\r\\n        bool hasUnlocked;\\r\\n        uint216 claimedRewards;\\r\\n        uint40 lockEndTimestamp;\\r\\n    }\\r\\n\\r\\n    /// @notice Holds the amount of LDY to be distributed to lockers.\\r\\n    uint256 public immutable maxDistributedLDY;\\r\\n\\r\\n    /// @notice Holds the maximum total amount of L-Tokens that can be locked.\\r\\n    uint256 public immutable lockedHardCap;\\r\\n\\r\\n    /// @notice Holds the minimum possible lock duration (in months).\\r\\n    uint8 public immutable minLockDuration;\\r\\n\\r\\n    /// @notice Holds the maximum possible lock duration (in months).\\r\\n    uint8 public immutable maxLockDuration;\\r\\n\\r\\n    /// @notice Holds the duration of LDY rewards vesting (in months).\\r\\n    uint8 public immutable vestingDuration;\\r\\n\\r\\n    /// @notice Holds a reference to the locked L-Token contract.\\r\\n    LToken public immutable lToken;\\r\\n\\r\\n    /// @notice Holds a reference to the L-Token underlying stablecoin.\\r\\n    IERC20 public immutable underlyingToken;\\r\\n\\r\\n    /// @notice Holds the max pool weight.\\r\\n    uint256 public immutable maxWeight;\\r\\n\\r\\n    /// @notice Holds a reference to the LDY token contract.\\r\\n    IERC20 public ldyToken;\\r\\n\\r\\n    /// @notice Holds lockers' participations informations.\\r\\n    mapping(address => AccountLock) public accountsLocks;\\r\\n\\r\\n    /// @notice Holds the total amount of locked underlying tokens.\\r\\n    uint256 public totalLocked;\\r\\n\\r\\n    /// @notice Holds whether the Deposit phase has ended.\\r\\n    bool public hasDepositPhaseEnded;\\r\\n\\r\\n    /// @notice Holds whether the Claim phase has started.\\r\\n    bool public hasClaimPhaseStarted;\\r\\n\\r\\n    /// @notice Holds whether the Recovery phase has started.\\r\\n    bool public hasRecoveryPhaseStarted;\\r\\n\\r\\n    /// @notice Holds the timestamp at which the Claim phase started.\\r\\n    uint256 public claimPhaseStartTimestamp;\\r\\n\\r\\n    /// @notice Holds an ordered queue of accounts that requested to unlock their tokens.\\r\\n    address[] public unlockRequests;\\r\\n\\r\\n    /// @notice Holds the index of the first request in the queue (a.k.a, next one to be processed).\\r\\n    uint256 public unlockRequestsCursor;\\r\\n\\r\\n    /// @notice Emitted to inform about a new lock/deposit.\\r\\n    event Lock(address indexed account, uint256 amount, uint8 duration);\\r\\n\\r\\n    /// @notice Top-level checks and code shared by both unlock functions.\\r\\n    modifier safeUnlock() {\\r\\n        // Ensure that the account's lock has ended\\r\\n        require(accountsLocks[msg.sender].lockEndTimestamp <= block.timestamp, \\\"L68\\\");\\r\\n\\r\\n        // Ensure the account hasn't already unlocked its tokens\\r\\n        require(!accountsLocks[msg.sender].hasUnlocked, \\\"L69\\\");\\r\\n\\r\\n        // Ensure the account has something to unlock\\r\\n        require(accountsLocks[msg.sender].amount > 0, \\\"L70\\\");\\r\\n\\r\\n        // Indicate that account has unlocked its tokens\\r\\n        accountsLocks[msg.sender].hasUnlocked = true;\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice This constructor function etches the lockdrop terms in immutable states.\\r\\n     * Ensuring that those terms cannot be modified after deployment.\\r\\n     * @param lTokenAddress_ Address of the L-Token contract to use.\\r\\n     * @param maxDistributedLDY_ Amount of LDY to be distributed to lockers.\\r\\n     * @param lockedHardCap_ Maximum total amount of L-Tokens that can be locked.\\r\\n     * @param minLockDuration_ Minimum possible lock duration (in months).\\r\\n     * @param maxLockDuration_ Maximum possible lock duration (in months).\\r\\n     * @param vestingDuration_ Duration of LDY rewards vesting (in months).\\r\\n     */\\r\\n    constructor(\\r\\n        address lTokenAddress_,\\r\\n        uint256 maxDistributedLDY_,\\r\\n        uint256 lockedHardCap_,\\r\\n        uint8 minLockDuration_,\\r\\n        uint8 maxLockDuration_,\\r\\n        uint8 vestingDuration_\\r\\n    ) {\\r\\n        // Ensure minLockDuration is at least 1 month\\r\\n        require(minLockDuration_ >= 1, \\\"L72\\\");\\r\\n\\r\\n        // Ensure minLockDuration is not greater than maxLockDuration\\r\\n        require(minLockDuration_ <= maxLockDuration_, \\\"L73\\\");\\r\\n\\r\\n        // Set immutable states\\r\\n        lToken = LToken(lTokenAddress_);\\r\\n        underlyingToken = IERC20(address(lToken.underlying()));\\r\\n        lockedHardCap = lockedHardCap_;\\r\\n        maxDistributedLDY = maxDistributedLDY_;\\r\\n        minLockDuration = minLockDuration_;\\r\\n        maxLockDuration = maxLockDuration_;\\r\\n        vestingDuration = vestingDuration_;\\r\\n        maxWeight = lockedHardCap * uint256(maxLockDuration);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Public implementation of Pausable's pausing and unpausing functions, but\\r\\n     * restricted to contract's owner.\\r\\n     */\\r\\n    function pause() public onlyOwner {\\r\\n        _pause();\\r\\n    }\\r\\n\\r\\n    function unpause() public onlyOwner {\\r\\n        _unpause();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Updates the LDY token contract address.\\r\\n     * @dev As the first Ledgity Yield lockdrop campaigns will start before the LDY TGE,\\r\\n     * this function allows the contract's owner to set the LDY token address once it\\r\\n     * becomes available.\\r\\n     * @param ldyTokenAddress Address of the LDY token contract.\\r\\n     */\\r\\n    function setLDYToken(address ldyTokenAddress) external onlyOwner {\\r\\n        // Prevent owner from changing the LDY address after Claim phase has started\\r\\n        require(!hasClaimPhaseStarted, \\\"L74\\\");\\r\\n\\r\\n        // Set LDY token address\\r\\n        ldyToken = IERC20(ldyTokenAddress);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Closes the Deposit phase. After calling this function, account won't be\\r\\n     * able to lock additional underlying tokens anymore.\\r\\n     */\\r\\n    function endDepositPhase() external onlyOwner {\\r\\n        hasDepositPhaseEnded = true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Opens the Claim phase. After calling this function, lockers will be able\\r\\n     * to start claiming their LDY rewards.\\r\\n     */\\r\\n    function startClaimPhase() external onlyOwner {\\r\\n        // Ensure Claim phase has not already started\\r\\n        require(!hasClaimPhaseStarted, \\\"L76\\\");\\r\\n\\r\\n        // Ensure that LDY token address is available\\r\\n        require(address(ldyToken) != address(0), \\\"L77\\\");\\r\\n\\r\\n        // Set Claim phase as started and store the start timestamp\\r\\n        hasClaimPhaseStarted = true;\\r\\n        claimPhaseStartTimestamp = block.timestamp;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Opens the Recovery phase. After calling this function, the contract owner\\r\\n     * will be able to recover remaining ERC20 tokens on the contract.\\r\\n     * Note that this won't close the Claim phase and lockers will still be able to claim\\r\\n     * their LDY rewards.\\r\\n     */\\r\\n    function startRecoveryPhase() external onlyOwner {\\r\\n        // Ensure Claim phase has started\\r\\n        require(hasClaimPhaseStarted, \\\"L79\\\");\\r\\n\\r\\n        // Compute some durations in seconds\\r\\n        uint256 threeMonthsInSecond = 3 * 30 days;\\r\\n        uint256 vestingInSecond = uint256(vestingDuration) * 30 days;\\r\\n        uint256 maxLockInSecond = uint256(maxLockDuration) * 30 days;\\r\\n\\r\\n        // Compute timestamp of vesting end + 3 months\\r\\n        uint256 afterVestingTimestamp = claimPhaseStartTimestamp +\\r\\n            vestingInSecond +\\r\\n            threeMonthsInSecond;\\r\\n\\r\\n        // Ensure we are at least 3 months after the end of reward vesting\\r\\n        // This prevents owner from recovering LDY before lockers can claim their rewards\\r\\n        require(block.timestamp >= afterVestingTimestamp, \\\"L80\\\");\\r\\n\\r\\n        // Compute end of maximum lock + 3 months\\r\\n        // Note that claimPhaseStartTimestamp is used for simplicity even if it can exist a time\\r\\n        // span between Deposit and Claim phases.\\r\\n        uint256 afterMaxLockTimestamp = claimPhaseStartTimestamp +\\r\\n            maxLockInSecond +\\r\\n            threeMonthsInSecond;\\r\\n\\r\\n        // Ensure we are at least 3 months after the maximum lock end\\r\\n        // This prevents owner from recovering underlying tokens before lockers can unlock those\\r\\n        require(block.timestamp >= afterMaxLockTimestamp, \\\"L81\\\");\\r\\n\\r\\n        // Set recovery phase as started\\r\\n        hasRecoveryPhaseStarted = true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Recovers a specified amount of a given token address. Will revert if\\r\\n     * recovery phase has not started yet or if the contract doesn't hold enough tokens.\\r\\n     * @param tokenAddress The address of the token to recover.\\r\\n     * @param amount The amount of token to recover.\\r\\n     */\\r\\n    function recoverERC20(address tokenAddress, uint256 amount) external onlyOwner {\\r\\n        // Ensure recovery phase has started\\r\\n        require(hasRecoveryPhaseStarted, \\\"L82\\\");\\r\\n\\r\\n        // Create a reference to token's contract\\r\\n        IERC20 tokenContract = IERC20(tokenAddress);\\r\\n\\r\\n        // Ensure there is enough tokens to recover\\r\\n        require(tokenContract.balanceOf(address(this)) >= amount, \\\"L83\\\");\\r\\n\\r\\n        // Transfer the recovered token amount to the sender (owner)\\r\\n        tokenContract.safeTransfer(msg.sender, amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Compute the total amount of LDY rewards that a given account is eligible to.\\r\\n     * @dev Note: This function neither considers vesting nor already claimed rewards.\\r\\n     * @param account The account to compute the eligible rewards of.\\r\\n     * @return The total amount of LDY rewards that the account is eligible to.\\r\\n     */\\r\\n    function eligibleRewardsOf(address account) public view returns (uint256) {\\r\\n        // Compute account's lock weight\\r\\n        uint256 lockerWeight = accountsLocks[account].amount * accountsLocks[account].duration;\\r\\n\\r\\n        // Compute amount of LDY that this locker is eligible to\\r\\n        if (maxWeight == 0) return 0;\\r\\n        else return (maxDistributedLDY * lockerWeight) / maxWeight;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Allows locking a specified amount of underlying tokens for a given duration.\\r\\n     * By locking, an account became eligible to a portion of the distributed LDY rewards.\\r\\n     * @dev This function proxies LToken.deposit()\\r\\n     * @dev Lockers can extend their lock duration by calling this function again with a\\r\\n     * greater duration and 0 as amount.\\r\\n     * @param amount Amount of underlying tokens to lock.\\r\\n     * @param duration Duration of the lock (in months).\\r\\n     */\\r\\n    function lock(uint256 amount, uint8 duration) external whenNotPaused {\\r\\n        // Ensure Deposit phase has not ended yet\\r\\n        require(!hasDepositPhaseEnded, \\\"L84\\\");\\r\\n\\r\\n        // Ensure account hasn't already unlocked a past lock\\r\\n        require(!accountsLocks[msg.sender].hasUnlocked, \\\"L71\\\");\\r\\n\\r\\n        // Ensure lock duration is in valid range\\r\\n        require(duration >= minLockDuration && duration <= maxLockDuration, \\\"L85\\\");\\r\\n\\r\\n        // Ensure it won't exceed the hardcap\\r\\n        require(totalLocked + amount <= uint256(lockedHardCap), \\\"L86\\\");\\r\\n\\r\\n        // Increase account's locked amount\\r\\n        accountsLocks[msg.sender].amount += uint240(amount);\\r\\n\\r\\n        // Increase total locked amount accordingly\\r\\n        totalLocked += amount;\\r\\n\\r\\n        // Use existing lock duration if greater than the new one\\r\\n        uint8 existingDuration = accountsLocks[msg.sender].duration;\\r\\n        uint8 appliedDuration = existingDuration > duration ? existingDuration : duration;\\r\\n\\r\\n        // Update account's lock duration\\r\\n        accountsLocks[msg.sender].duration = appliedDuration;\\r\\n\\r\\n        // Update account's lock end timestamp\\r\\n        accountsLocks[msg.sender].lockEndTimestamp = uint40(\\r\\n            block.timestamp + uint40(appliedDuration) * 30 days\\r\\n        );\\r\\n\\r\\n        // Emit a Lock event\\r\\n        emit Lock(msg.sender, amount, appliedDuration);\\r\\n\\r\\n        // If amount is 0, skip deposit\\r\\n        if (amount == 0) return;\\r\\n\\r\\n        // Transfer underlyingToken from account to contract\\r\\n        underlyingToken.safeTransferFrom(msg.sender, address(this), amount);\\r\\n\\r\\n        // Deposit USDC in the L-Token contract\\r\\n        underlyingToken.safeApprove(address(lToken), amount);\\r\\n        lToken.deposit(amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Allows the caller to instaneously unlock its locked amount of underlying\\r\\n     * tokens.\\r\\n     * @dev In order to save some gas and time to users, frontends should propose this\\r\\n     * function to users only when it has been verified that it will not revert. They\\r\\n     * should propose the requestUnlock() function otherwise.\\r\\n     */\\r\\n    function instantUnlock() external whenNotPaused safeUnlock {\\r\\n        // Retrieve underlying tokens from the L-Token contract\\r\\n        uint256 unlockedAmount = accountsLocks[msg.sender].amount;\\r\\n        lToken.instantWithdrawal(unlockedAmount);\\r\\n\\r\\n        // Transfer underlying tokens back to caller\\r\\n        underlyingToken.safeTransfer(msg.sender, unlockedAmount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Allows the call to request for the unlocking of its locked amount of\\r\\n     * underlying tokens. The request will be automatically processed later.\\r\\n     * @dev The sender must attach 0.003 ETH to pre-pay the future processing gas fees\\r\\n     * paid by the withdrawer wallet.\\r\\n     */\\r\\n    function requestUnlock() external payable whenNotPaused safeUnlock {\\r\\n        // Put account in the unlock requests queue\\r\\n        unlockRequests.push(msg.sender);\\r\\n\\r\\n        // Request underlying tokens to the L-Token contract\\r\\n        uint256 unlockedAmount = accountsLocks[msg.sender].amount;\\r\\n        lToken.requestWithdrawal{value: msg.value}(unlockedAmount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Processes queued unlock requests until there is else no more requests,\\r\\n     * else not enough underlying tokens to continue.\\r\\n     */\\r\\n    function processUnlockRequests() external onlyOwner {\\r\\n        // Store the current request ID to process\\r\\n        uint256 processedId = unlockRequestsCursor;\\r\\n\\r\\n        // Loop over remaining requests\\r\\n        while (processedId < unlockRequests.length) {\\r\\n            // Prevent OOG by stopping request processing if there is not enough gas left\\r\\n            // to continue the loop and properly end the function call.\\r\\n            if (gasleft() < 45000) break;\\r\\n\\r\\n            // Retrieve the request account\\r\\n            address unlockAccount = unlockRequests[processedId];\\r\\n\\r\\n            // Retrieve the unlocked amount\\r\\n            uint256 unlockAmount = accountsLocks[unlockAccount].amount;\\r\\n\\r\\n            // If the request has already been processed, skip it\\r\\n            if (unlockAccount != address(0)) {\\r\\n                // If the contract doesn't hold enough underlying tokens to process the request, stop here\\r\\n                if (underlyingToken.balanceOf(address(this)) < unlockAmount) break;\\r\\n\\r\\n                // Delete the request\\r\\n                delete unlockRequests[processedId];\\r\\n\\r\\n                // Transfer underlying back to account\\r\\n                underlyingToken.safeTransfer(unlockAccount, unlockAmount);\\r\\n            }\\r\\n\\r\\n            // Increment processed request ID\\r\\n            processedId++;\\r\\n        }\\r\\n\\r\\n        // Write back the cursor in storage\\r\\n        unlockRequestsCursor = processedId;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Computes the amount of LDY rewards available to claim for a given account.\\r\\n     * @dev This function considers vesting and already claimed rewards.\\r\\n     * @param account The account to compute the available rewards of.\\r\\n     * @return The amount of LDY rewards available to claim.\\r\\n     */\\r\\n    function availableToClaim(address account) public view returns (uint256) {\\r\\n        // Compute total amount of rewards allocated to this locker\\r\\n        uint256 totalEligibleRewards = eligibleRewardsOf(account);\\r\\n\\r\\n        // Compute vesting duration in seconds\\r\\n        uint256 vestingInSeconds = uint256(vestingDuration) * 30 days;\\r\\n\\r\\n        // Compute elapsed months since claim phase started, and cap it to vesting duration\\r\\n        uint256 elapsedTime = block.timestamp - claimPhaseStartTimestamp;\\r\\n        if (elapsedTime > vestingInSeconds) elapsedTime = vestingInSeconds;\\r\\n\\r\\n        // Compute total available to claim (proportionally to elapsed time)\\r\\n        uint256 totalAvailableToClaim = (totalEligibleRewards * elapsedTime) / vestingInSeconds;\\r\\n\\r\\n        // Else return net claimable (available minus already claimed)\\r\\n        return totalAvailableToClaim - accountsLocks[account].claimedRewards;\\r\\n    }\\r\\n\\r\\n    /// @notice Allows the caller to claim its available LDY rewards.\\r\\n    function claimRewards() external whenNotPaused {\\r\\n        // Ensure Claim phase has started\\r\\n        require(hasClaimPhaseStarted, \\\"L87\\\");\\r\\n\\r\\n        // Compute claimable LDY rewards\\r\\n        uint256 claimableLDY = availableToClaim(msg.sender);\\r\\n\\r\\n        // Increase account claimed amount accordingly\\r\\n        accountsLocks[msg.sender].claimedRewards += uint216(claimableLDY);\\r\\n\\r\\n        // Transfer rewards to account\\r\\n        ldyToken.safeTransfer(msg.sender, claimableLDY);\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x479ae01550253a6a29228ce6b2246955e1623845ea44063e26a002265d2d7d2b\",\"license\":\"MIT\"},\"contracts/src/abstracts/GlobalOwnableUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.18;\\r\\n\\r\\nimport {Initializable} from \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\r\\nimport {OwnableUpgradeable} from \\\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\r\\nimport {GlobalOwner} from \\\"../GlobalOwner.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title GlobalOwnableUpgradeable\\r\\n * @author Lila Rest (https://lila.rest)\\r\\n * @custom:security-contact security@ledgity.com\\r\\n *\\r\\n * @notice Derived contracts will inherit ownership from the specified GlobalOwner\\r\\n * contract (see GlobalOwner.sol). This design facilitates centralized management\\r\\n * of ownership for all the Ledgity Yield contracts.\\r\\n *\\r\\n * @dev Note: The _globalOwner state must be set at initialization-time and for evident\\r\\n * security reasons cannot be changed afterwards.\\r\\n *\\r\\n * @dev For further details, see \\\"GlobalOwnableUpgradeable\\\" section of whitepaper.\\r\\n * @custom:security-contact security@ledgity.com\\r\\n */\\r\\nabstract contract GlobalOwnableUpgradeable is Initializable, OwnableUpgradeable {\\r\\n    /**\\r\\n     * @notice The GlobalOwner contract the ownership will be inherited from.\\r\\n     * @dev This state is private so derived contracts cannot change its value.\\r\\n     */\\r\\n    GlobalOwner private _globalOwner;\\r\\n\\r\\n    /**\\r\\n     * @notice Initializer functions of the contract. They replace the constructor()\\r\\n     * function in the context of upgradeable contracts.\\r\\n     * @dev See: https://docs.openzeppelin.com/contracts/4.x/upgradeable\\r\\n     * @param globalOwner_ The address of the GlobalOwner contract.\\r\\n     */\\r\\n    function __GlobalOwnable_init(address globalOwner_) internal onlyInitializing {\\r\\n        __GlobalOwnable_init_unchained(globalOwner_);\\r\\n        // Note: __Ownable_init() doesn't have to be called as the overriden owner()\\r\\n        // function no longer rely on the _owner state. Since __Ownable_init() only sets\\r\\n        // the initial _owner value, calling it would have no effect.\\r\\n    }\\r\\n\\r\\n    function __GlobalOwnable_init_unchained(address globalOwner_) internal onlyInitializing {\\r\\n        _globalOwner = GlobalOwner(globalOwner_);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Retrieves the address of GlobalOwner contract.\\r\\n     * @return The address of the GlobalOwner contract.\\r\\n     */\\r\\n    function globalOwner() public view returns (address) {\\r\\n        return address(_globalOwner);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Override of OwnableUpgradeable.owner() that retrieves the owner's address\\r\\n     * from the GlobalOwner contract instead.\\r\\n     * @return The address of the owner\\r\\n     */\\r\\n    function owner() public view override returns (address) {\\r\\n        return _globalOwner.owner();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Override of OwnableUpgradeable.transferOwnership() that always reverts.\\r\\n     * Ownership is managed by the GlobalOwner contract and must be modified there.\\r\\n     */\\r\\n    function transferOwnership(address newOwner) public view override onlyOwner {\\r\\n        newOwner; // Silence unused variable compiler warning\\r\\n        revert(\\\"L8\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Override of OwnableUpgradeable.renounceOwnership() that always reverts.\\r\\n     * Ownership is managed by the GlobalOwner contract and must be modified there.\\r\\n     */\\r\\n    function renounceOwnership() public view override onlyOwner {\\r\\n        revert(\\\"L65\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev This empty reserved space is put in place to allow future versions to add\\r\\n     * new variables without shifting down storage in the inheritance chain.\\r\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\r\\n     */\\r\\n    uint256[50] private __gap;\\r\\n}\\r\\n\",\"keccak256\":\"0x5b0b6d4f7a461d8b56e360cf829d73b7aa7d9641dcac664ec50f31470e008b1b\",\"license\":\"MIT\"},\"contracts/src/abstracts/GlobalPausableUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.18;\\r\\n\\r\\nimport {Initializable} from \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\r\\nimport {PausableUpgradeable} from \\\"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\\\";\\r\\nimport {GlobalPause} from \\\"../GlobalPause.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title GlobalPausableUpgradeable\\r\\n * @author Lila Rest (https://lila.rest)\\r\\n * @custom:security-contact security@ledgity.com\\r\\n *\\r\\n * @notice Derived contracts will inherit pause state from the specified GlobalPause\\r\\n * contract (see GlobalPause.sol). This design facilitates centralized management of\\r\\n * pause state for all the Ledgity Yield contracts.\\r\\n *\\r\\n * @dev Note: The _globalPause state must be set at initialization-time and for evident\\r\\n * security reasons cannot be changed afterwards.\\r\\n *\\r\\n * @dev For further details, see \\\"GlobalPausableUpgradeable\\\" section of whitepaper.\\r\\n * @custom:security-contact security@ledgity.com\\r\\n */\\r\\nabstract contract GlobalPausableUpgradeable is Initializable, PausableUpgradeable {\\r\\n    /**\\r\\n     * @notice The GlobalPause contract the pause state will be inherited from.\\r\\n     * @dev This state is private so derived contracts cannot change its value.\\r\\n     */\\r\\n    GlobalPause private _globalPause;\\r\\n\\r\\n    /**\\r\\n     * @notice Initializer functions of the contract. They replace the constructor()\\r\\n     * function in the context of upgradeable contracts.\\r\\n     * @dev See: https://docs.openzeppelin.com/contracts/4.x/upgradeable\\r\\n     * @param globalPause_ The address of the GlobalPause contract.\\r\\n     */\\r\\n    function __GlobalPausable_init(address globalPause_) internal onlyInitializing {\\r\\n        __Pausable_init();\\r\\n        __GlobalPausable_init_unchained(globalPause_);\\r\\n    }\\r\\n\\r\\n    function __GlobalPausable_init_unchained(address globalPause_) internal onlyInitializing {\\r\\n        _globalPause = GlobalPause(globalPause_);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Retrieves the address of GlobalPause contract.\\r\\n     * @return The address of the GlobalPause contract.\\r\\n     */\\r\\n    function globalPause() public view returns (address) {\\r\\n        return address(_globalPause);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Override of PausableUpgradeable.pause() that retrieves the pause state\\r\\n     * from the GlobalPause contract instead.\\r\\n     * @return Whether the contract is paused or not.\\r\\n     */\\r\\n    function paused() public view virtual override returns (bool) {\\r\\n        return _globalPause.paused();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev This empty reserved space is put in place to allow future versions to add\\r\\n     * new variables without shifting down storage in the inheritance chain.\\r\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\r\\n     */\\r\\n    uint256[50] private __gap;\\r\\n}\\r\\n\",\"keccak256\":\"0xdd07fb275079cdafec6fd9c5848fbe2caf52af114e574d2714160d7622c51ddc\",\"license\":\"MIT\"},\"contracts/src/abstracts/GlobalRestrictableUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.18;\\r\\n\\r\\nimport {Initializable} from \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\r\\nimport {GlobalBlacklist} from \\\"../GlobalBlacklist.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title GlobalRestrictableUpgradeable\\r\\n * @author Lila Rest (https://lila.rest)\\r\\n * @custom:security-contact security@ledgity.com\\r\\n *\\r\\n * @notice Derived contracts will inherit blacklist state from the specified\\r\\n * GlobalBlacklist contract (see GlobalBlacklist.sol). This design facilitates\\r\\n * centralized management of a blacklist for all the Ledgity Yield contracts.\\r\\n *\\r\\n * @dev Note: The _globalBlacklist state must be set at initialization-time and for\\r\\n * evident security reasons cannot be changed afterwards.\\r\\n *\\r\\n * @dev For further details, see \\\"GlobalRestrictableUpgradeable\\\" section of whitepaper.\\r\\n * @custom:security-contact security@ledgity.com\\r\\n */\\r\\nabstract contract GlobalRestrictableUpgradeable is Initializable {\\r\\n    /**\\r\\n     * @notice The GlobalBlacklist contract the blacklist state will be inherited from.\\r\\n     * @dev This state is private so derived contracts cannot change its value.\\r\\n     */\\r\\n    GlobalBlacklist private _globalBlacklist;\\r\\n\\r\\n    /**\\r\\n     * @notice Initializer functions of the contract. They replace the constructor()\\r\\n     * function in the context of upgradeable contracts.\\r\\n     * @dev See: https://docs.openzeppelin.com/contracts/4.x/upgradeable\\r\\n     * @param globalBlacklist_ The address of the GlobalBlacklist contract.\\r\\n     */\\r\\n    function __GlobalRestrictable_init(address globalBlacklist_) internal onlyInitializing {\\r\\n        __GlobalRestrictable_init_unchained(globalBlacklist_);\\r\\n    }\\r\\n\\r\\n    function __GlobalRestrictable_init_unchained(\\r\\n        address globalBlacklist_\\r\\n    ) internal onlyInitializing {\\r\\n        _globalBlacklist = GlobalBlacklist(globalBlacklist_);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Retrieves the address of GlobalBlacklist contract.\\r\\n     * @return The address of the GlobalBlacklist contract.\\r\\n     */\\r\\n    function globalBlacklist() public view returns (address) {\\r\\n        return address(_globalBlacklist);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Reverts if the given account is blacklisted by the GlobalBlacklist contract.\\r\\n     * @param account Address to verify.\\r\\n     */\\r\\n    modifier notBlacklisted(address account) {\\r\\n        require(isBlacklisted(account) == false, \\\"L9\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Checks if the given account is blacklisted by the GlobalBlacklist contract.\\r\\n     * @param account Address to verify.\\r\\n     * @return Whether the account is blacklisted.\\r\\n     */\\r\\n    function isBlacklisted(address account) internal view returns (bool) {\\r\\n        return _globalBlacklist.isBlacklisted(account);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev This empty reserved space is put in place to allow future versions to add\\r\\n     * new variables without shifting down storage in the inheritance chain.\\r\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\r\\n     */\\r\\n    uint256[50] private __gap;\\r\\n}\\r\\n\",\"keccak256\":\"0x1dd38517b55974515a49e451cbafcf39119bfc8d33899bedc24d477651b370a4\",\"license\":\"MIT\"},\"contracts/src/abstracts/InvestUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.18;\\r\\n\\r\\n// Contracts\\r\\nimport {Initializable} from \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\r\\nimport {GlobalOwnableUpgradeable} from \\\"./GlobalOwnableUpgradeable.sol\\\";\\r\\nimport {GlobalPausableUpgradeable} from \\\"./GlobalPausableUpgradeable.sol\\\";\\r\\nimport {GlobalRestrictableUpgradeable} from \\\"./GlobalRestrictableUpgradeable.sol\\\";\\r\\nimport \\\"./base/BaseUpgradeable.sol\\\";\\r\\nimport {RecoverableUpgradeable} from \\\"../abstracts/RecoverableUpgradeable.sol\\\";\\r\\n\\r\\n// Libraries\\r\\nimport {SafeERC20Upgradeable} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\\\";\\r\\nimport {APRHistory as APRH} from \\\"../libs/APRHistory.sol\\\";\\r\\nimport {SUD} from \\\"../libs/SUD.sol\\\";\\r\\n\\r\\n// Interfaces\\r\\nimport {IERC20Upgradeable} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\r\\nimport {IERC20MetadataUpgradeable} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title InvestUpgradeable\\r\\n * @author Lila Rest (https://lila.rest)\\r\\n * @custom:security-contact security@ledgity.com\\r\\n *\\r\\n * @notice Derived contracts are provided with utilities to manage an invested token,\\r\\n * users' investment periods, rewards calculations, virtual balances, and auto-compounding.\\r\\n *\\r\\n * @dev Intuition:\\r\\n * This contract primarily exists for code splitting and reusability. It unburdens the\\r\\n * LToken contract code, making it easier to understand and maintain.\\r\\n *\\r\\n * This contract is generic because it may be used in the LDYStaking contract in the future.\\r\\n *\\r\\n * @dev Definitions:\\r\\n * - Investment: The act of depositing or investing tokens into the contract.\\r\\n * - Investment period: Time between the start of an investment or the last rewards\\r\\n *                      distribution for an account to the present.\\r\\n * - Virtual balance: Temporary storage for account rewards, used when those can't be\\r\\n *                    distributed between investment periods.\\r\\n * - Rewards redirection: Mechanism allowing an account to redirect its rewards to another.\\r\\n *\\r\\n * @dev Derived contract must:\\r\\n *  - Set invested token during initialization\\r\\n *  - Implement _investmentOf() function\\r\\n *  - Implement _distributeRewards() function (optional)\\r\\n *\\r\\n * @dev For further details, see \\\"InvestmentUpgradeable\\\" section of whitepaper.\\r\\n * @custom:security-contact security@ledgity.com\\r\\n */\\r\\nabstract contract InvestUpgradeable is BaseUpgradeable {\\r\\n    using SafeERC20Upgradeable for IERC20Upgradeable;\\r\\n    using APRH for APRH.Pack[];\\r\\n\\r\\n    /**\\r\\n     * @notice Represents an account's investment period.\\r\\n     * @param timestamp The timestamp of the most recent rewards distribution.\\r\\n     * @param ref The reference of the last APR checkpoint at that timestamp.\\r\\n     */\\r\\n    struct InvestmentPeriod {\\r\\n        uint40 timestamp; // Supports dates up to 20/02/36812\\r\\n        APRH.Reference ref;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Represents the investment details of an account.\\r\\n     * @param period The current investment period of the account.\\r\\n     * @param virtualBalance May hold a part of account rewards until they are claimed.\\r\\n     */\\r\\n    struct AccountDetails {\\r\\n        InvestmentPeriod period;\\r\\n        uint256 virtualBalance;\\r\\n    }\\r\\n\\r\\n    /// @notice Holds a reference to the invested token's contract.\\r\\n    IERC20Upgradeable private _invested;\\r\\n\\r\\n    /// @notice Holds investment details of each account.\\r\\n    mapping(address => AccountDetails) internal accountsDetails;\\r\\n\\r\\n    /// @notice Holds an history of the APR value over time (see APRHistory.sol).\\r\\n    APRH.Pack[] private _aprHistory;\\r\\n\\r\\n    /// @notice Holds active rewards redirections in both from->to and to->from[] ways.\\r\\n    mapping(address => address) public rewardsRedirectsFromTo;\\r\\n    mapping(address => address[]) public rewardsRedirectsToFrom;\\r\\n\\r\\n    /// @notice Is used to prevent infinite loop in _beforeInvestmentChange().\\r\\n    bool private _isClaiming;\\r\\n\\r\\n    /**\\r\\n     * @notice Emitted to inform listeners about a change in the APR's value.\\r\\n     * @param newAPRUD7x3 The new APR in UD7x3 format.\\r\\n     */\\r\\n    event APRChangeEvent(uint16 newAPRUD7x3);\\r\\n\\r\\n    /**\\r\\n     * @notice Initializer functions of the contract. They replace the constructor()\\r\\n     * function in the context of upgradeable contracts.\\r\\n     * @dev See: https://docs.openzeppelin.com/contracts/4.x/upgradeable\\r\\n     * @param globalOwner_ The address of the GlobalOwner contract.\\r\\n     * @param globalPause_ The address of the GlobalPause contract.\\r\\n     * @param globalBlacklist_ The address of the GlobalBlacklist contract.\\r\\n     * @param invested_ The address of the invested token contract.\\r\\n     */\\r\\n    function __Invest_init(\\r\\n        address globalOwner_,\\r\\n        address globalPause_,\\r\\n        address globalBlacklist_,\\r\\n        address invested_\\r\\n    ) internal onlyInitializing {\\r\\n        __Base_init(globalOwner_, globalPause_, globalBlacklist_);\\r\\n        __Invest_init_unchained(invested_);\\r\\n    }\\r\\n\\r\\n    function __Invest_init_unchained(address invested_) internal onlyInitializing {\\r\\n        // Set invested token\\r\\n        _invested = IERC20Upgradeable(invested_);\\r\\n\\r\\n        // Define initial APR to 0%. This would prevent getAPR() from reverting because\\r\\n        // of an empty APR history\\r\\n        _aprHistory.setAPR(0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Retrieves the reference to the invested token contract.\\r\\n     * @return The reference to the invested token contract.\\r\\n     */\\r\\n    function invested() public view returns (IERC20Upgradeable) {\\r\\n        return _invested;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Updates the investment APR. Restricted to owner.\\r\\n     * @param aprUD7x3 The new APR in UD7x3 format.\\r\\n     */\\r\\n    function setAPR(uint16 aprUD7x3) public onlyOwner {\\r\\n        _aprHistory.setAPR(aprUD7x3);\\r\\n        emit APRChangeEvent(aprUD7x3);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Retrieves the most recently set APR.\\r\\n     * @return The current APR in UD7x3 format.\\r\\n     */\\r\\n    function getAPR() public view returns (uint16) {\\r\\n        return _aprHistory.getAPR();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Enables redirection of rewards from one account to another.\\r\\n     * @param from The address of the account to redirect rewards from.\\r\\n     * @param to The address of the account to redirect rewards to.\\r\\n     */\\r\\n    function startRewardsRedirection(\\r\\n        address from,\\r\\n        address to\\r\\n    ) public whenNotPaused notBlacklisted(from) notBlacklisted(to) {\\r\\n        // Ensure the address is not already redirecting rewards\\r\\n        require(rewardsRedirectsFromTo[from] == address(0), \\\"L62\\\");\\r\\n\\r\\n        // Ensure neither 'from' nor 'to' are the zero address\\r\\n        require(from != address(0), \\\"L12\\\");\\r\\n        require(to != address(0), \\\"L13\\\");\\r\\n\\r\\n        // Ensure 'from' and 'to' addresses are distinct\\r\\n        require(from != to, \\\"L14\\\");\\r\\n\\r\\n        // Ensure function caller is either the owner or the 'from' address\\r\\n        require(_msgSender() == owner() || _msgSender() == from, \\\"L15\\\");\\r\\n\\r\\n        // Distribute current rewards and reset investment periods of both accounts\\r\\n        _beforeInvestmentChange(from, true);\\r\\n        _beforeInvestmentChange(to, true);\\r\\n\\r\\n        // Activate rewards redirection\\r\\n        rewardsRedirectsFromTo[from] = to;\\r\\n        rewardsRedirectsToFrom[to].push(from);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Disable an active rewards redirection.\\r\\n     * @param from The address of the account to stop redirecting rewards from.\\r\\n     * @param to The address of the account to stop redirecting rewards to.\\r\\n     */\\r\\n    function stopRewardsRedirection(\\r\\n        address from,\\r\\n        address to\\r\\n    ) public whenNotPaused notBlacklisted(from) notBlacklisted(to) {\\r\\n        // Ensure neither 'from' nor 'to' are the zero address\\r\\n        require(from != address(0), \\\"L16\\\");\\r\\n        require(to != address(0), \\\"L17\\\");\\r\\n\\r\\n        // Ensure function caller is either the owner or the 'from' address\\r\\n        require(_msgSender() == owner() || _msgSender() == from, \\\"L18\\\");\\r\\n\\r\\n        // Ensure a rewards redirection was active\\r\\n        require(rewardsRedirectsFromTo[from] == to, \\\"L19\\\");\\r\\n\\r\\n        // Distribute current rewards and reset investment periods of both accounts\\r\\n        _beforeInvestmentChange(from, true);\\r\\n        _beforeInvestmentChange(to, true);\\r\\n\\r\\n        // Retrieve 'from' index in the redirection array of 'to'\\r\\n        int256 fromIndex = -1;\\r\\n        for (uint256 i = 0; i < rewardsRedirectsToFrom[to].length; i++) {\\r\\n            if (rewardsRedirectsToFrom[to][i] == from) {\\r\\n                fromIndex = int256(i);\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // fromIndex should never be -1 at this point\\r\\n        assert(fromIndex >= 0);\\r\\n\\r\\n        // Deactivate rewards redirection\\r\\n        rewardsRedirectsFromTo[from] = address(0);\\r\\n        rewardsRedirectsToFrom[to][uint256(fromIndex)] = rewardsRedirectsToFrom[to][\\r\\n            rewardsRedirectsToFrom[to].length - 1\\r\\n        ];\\r\\n        rewardsRedirectsToFrom[to].pop();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Retrieves the total amount of tokens invested by the given account.\\r\\n     * @dev Derived contracts must implement this function.\\r\\n     * @param account The account to get the investment of.\\r\\n     * @return The total amount of tokens invested by the given account.\\r\\n     */\\r\\n    function _investmentOf(address account) internal view virtual returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @notice Distributes a specified amount of rewards to a given account.\\r\\n     * @dev Derived contracts may optionally implement this function.\\r\\n     * @dev Implementations must return true to indicate a successful distribution, and\\r\\n     * false otherwise. If it returns false, the rewards will be added to the account's\\r\\n     * virtual balance, in order to be claimed later.\\r\\n     * @param account The account to claim the rewards of.\\r\\n     * @param amount The amount of rewards to claim.\\r\\n     * @return Whether the rewards distribution was successfull.\\r\\n     */\\r\\n    function _distributeRewards(address account, uint256 amount) internal virtual returns (bool) {\\r\\n        account; // Silence unused variables warning\\r\\n        amount;\\r\\n        return false;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Computes the rewards accrued over a specified period of time, based on a\\r\\n     * given APR and amount of invested tokens.\\r\\n     * @dev For further details, see \\\"InvestUpgradeable > Rewards calculation\\\" section of\\r\\n     * the whitepaper.\\r\\n     * @param beginTimestamp The moment the period commenced.\\r\\n     * @param endTimestamp The moment the period concluded.\\r\\n     * @param aprUD7x3 The APR during this period, in UD7x3 format.\\r\\n     * @param investedAmount The amount of tokens deposited/invested during the period.\\r\\n     * @return The amount of rewards generated during the period.\\r\\n     */\\r\\n    function _calculatePeriodRewards(\\r\\n        uint40 beginTimestamp,\\r\\n        uint40 endTimestamp,\\r\\n        uint16 aprUD7x3,\\r\\n        uint256 investedAmount\\r\\n    ) internal view returns (uint256) {\\r\\n        // Cache invested token's decimals number\\r\\n        uint256 d = SUD.decimalsOf(address(invested()));\\r\\n\\r\\n        // Compute the number of elapsed years\\r\\n        uint256 elapsedTimeSUD = SUD.fromInt(endTimestamp - beginTimestamp, d);\\r\\n        uint256 elapsedYearsSUD = (elapsedTimeSUD * SUD.fromInt(1, d)) / SUD.fromInt(365 days, d);\\r\\n\\r\\n        // Compute the growth in invested amount (thanks to rewards)\\r\\n        uint256 aprSUD = SUD.fromRate(aprUD7x3, d);\\r\\n        uint256 growthSUD = (elapsedYearsSUD * aprSUD) / SUD.fromInt(1, d);\\r\\n\\r\\n        // Compute and return the rewards\\r\\n        uint256 investedAmountSUD = SUD.fromAmount(investedAmount, d);\\r\\n        uint256 rewardsSUD = (investedAmountSUD * growthSUD) / SUD.fromInt(100, d);\\r\\n        return SUD.toAmount(rewardsSUD, d);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Computes the sum of given account's invested amount, plus invested amount\\r\\n     * of all accounts that recursively redirect rewards to this account.\\r\\n     * @param account The account to calculate the deep investment of.\\r\\n     * @return deepInvestedAmount The deep invested amount.\\r\\n     */\\r\\n    function _deepInvestmentOf(address account) internal view returns (uint256 deepInvestedAmount) {\\r\\n        // Consider account's direct investment\\r\\n        deepInvestedAmount += _investmentOf(account);\\r\\n\\r\\n        // But also the deep investments of all accounts redirecting rewards to this account\\r\\n        for (uint256 i = 0; i < rewardsRedirectsToFrom[account].length; i++) {\\r\\n            deepInvestedAmount += _deepInvestmentOf(rewardsRedirectsToFrom[account][i]);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Computes the amount of unclaimed/undistributed rewards of a given account.\\r\\n     * @dev For further details, see \\\"InvestUpgradeable > Rewards calculation\\\" section of\\r\\n     * the whitepaper.\\r\\n     * @param account The account to calculate the unclaimed rewards of.\\r\\n     * @param autocompound Whether to autocompound the rewards between APR checkpoints.\\r\\n     * @return rewards The amount of unclaimed/undistributed rewards of the given account.\\r\\n     */\\r\\n    function _rewardsOf(\\r\\n        address account,\\r\\n        bool autocompound\\r\\n    ) internal view returns (uint256 rewards) {\\r\\n        // Retrieve account's investment details\\r\\n        AccountDetails memory details = accountsDetails[account];\\r\\n\\r\\n        // Retrieve account's deep invested amount\\r\\n        uint256 investedAmount = _deepInvestmentOf(account);\\r\\n\\r\\n        // Return 0 if the account has never invested or has no invested amount\\r\\n        if (details.period.timestamp == 0 || investedAmount == 0) return 0;\\r\\n\\r\\n        // Retrieve reference and data of APR checkpoint at which started investment period\\r\\n        APRH.Reference memory currRef = details.period.ref;\\r\\n        APRH.CheckpointData memory currCheckpoint = _aprHistory.getDataFromReference(currRef);\\r\\n\\r\\n        // Retrieve reference of latest APR checkpoint\\r\\n        APRH.Reference memory latestRef = _aprHistory.getLatestReference();\\r\\n\\r\\n        // 1) Fill rewards with virtual balance (rewards not claimed/distributed yet)\\r\\n        // See \\\"InvestUpgradeable > Rewards calculation > 1)\\\" section of the whitepaper\\r\\n        rewards = details.virtualBalance;\\r\\n\\r\\n        // If start checkpoint is not the latest one\\r\\n        if (!APRH.eq(currRef, latestRef)) {\\r\\n            // Retrieve reference and data of APR checkpoint that comes after start checkpoint\\r\\n            APRH.Reference memory nextRef = APRH.incrementReference(currRef);\\r\\n            APRH.CheckpointData memory nextCheckpoint = _aprHistory.getDataFromReference(nextRef);\\r\\n\\r\\n            // 2) Calculate rewards from investment period start to next checkpoint\\r\\n            // See \\\"InvestUpgradeable > Rewards calculation > 2)\\\" section of the whitepaper\\r\\n            rewards += _calculatePeriodRewards(\\r\\n                details.period.timestamp,\\r\\n                nextCheckpoint.timestamp,\\r\\n                currCheckpoint.aprUD7x3,\\r\\n                investedAmount + (autocompound ? rewards : 0)\\r\\n            );\\r\\n\\r\\n            // 3) Calculate rewards for each crossed pair of checkpoints\\r\\n            // See \\\"InvestUpgradeable > Rewards calculation > 3)\\\" section of the whitepaper\\r\\n            while (true) {\\r\\n                // Set next checkpoint as the current one\\r\\n                currRef = nextRef;\\r\\n                currCheckpoint = nextCheckpoint;\\r\\n\\r\\n                // Break if current checkpoint is the latest one\\r\\n                if (APRH.eq(currRef, latestRef)) break;\\r\\n\\r\\n                // Else, retrieve the new next checkpoint\\r\\n                nextRef = APRH.incrementReference(currRef);\\r\\n                nextCheckpoint = _aprHistory.getDataFromReference(nextRef);\\r\\n\\r\\n                // Calculate rewards between the current pair of checkpoints\\r\\n                rewards += _calculatePeriodRewards(\\r\\n                    currCheckpoint.timestamp,\\r\\n                    nextCheckpoint.timestamp,\\r\\n                    currCheckpoint.aprUD7x3,\\r\\n                    investedAmount + (autocompound ? rewards : 0)\\r\\n                );\\r\\n            }\\r\\n\\r\\n            // 4) Calculate rewards from the latest checkpoint to now\\r\\n            // See \\\"InvestUpgradeable > Rewards calculation > 4)\\\" section of the whitepaper\\r\\n            rewards += _calculatePeriodRewards(\\r\\n                currCheckpoint.timestamp,\\r\\n                uint40(block.timestamp),\\r\\n                currCheckpoint.aprUD7x3,\\r\\n                investedAmount + (autocompound ? rewards : 0)\\r\\n            );\\r\\n        } else {\\r\\n            // 2.bis) Calculate rewards from investment period start to now\\r\\n            // See \\\"InvestUpgradeable > Rewards calculation > 2.bis)\\\" section of the whitepaper\\r\\n            rewards += _calculatePeriodRewards(\\r\\n                details.period.timestamp,\\r\\n                uint40(block.timestamp),\\r\\n                currCheckpoint.aprUD7x3,\\r\\n                investedAmount + (autocompound ? rewards : 0)\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Recursively resets the investment period of the specified account and of\\r\\n     * all accounts that directly or indirectly redirect rewards to this account.\\r\\n     * @param account The account to deeply reset the investment period of.\\r\\n     */\\r\\n    function _deepResetInvestmentPeriodOf(address account) internal {\\r\\n        // Reset account investment period timestamp and APR checkpoint to latest ones\\r\\n        accountsDetails[account].period.timestamp = uint40(block.timestamp);\\r\\n        accountsDetails[account].period.ref = _aprHistory.getLatestReference();\\r\\n\\r\\n        // Also reset the ones of all accounts that recursively redirect rewards to this account\\r\\n        for (uint256 i = 0; i < rewardsRedirectsToFrom[account].length; i++) {\\r\\n            _deepResetInvestmentPeriodOf(rewardsRedirectsToFrom[account][i]);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Hook to be invoked before the invested amount of an account changes. It\\r\\n     * ensures that rewards are distributed and that account's investment period is reset.\\r\\n     * @param account The account whose invested amount is going to change.\\r\\n     * @param autocompound Whether to autocompound the rewards between APR checkpoints.\\r\\n     */\\r\\n    function _beforeInvestmentChange(address account, bool autocompound) internal {\\r\\n        // This hook is called inside LToken._beforeTokenTransfer() and as new tokens are\\r\\n        // minted in LToken._distributeRewards(), this guards against infinite loop.\\r\\n        if (_isClaiming) return;\\r\\n\\r\\n        // LToken._beforeTokenTransfer() calls this hook for both involved addresses.\\r\\n        // As first call will treat both addresses, the second call would be redundant.\\r\\n        // Therefore, we skip accounts already processed in this block to save up some gas.\\r\\n        if (accountsDetails[account].period.timestamp == uint40(block.timestamp)) return;\\r\\n\\r\\n        // If account redirects its rewards\\r\\n        address redirectRewardsTo = rewardsRedirectsFromTo[account];\\r\\n        if (redirectRewardsTo != address(0)) {\\r\\n            // Call hook on redirection target (this will indirectly reset the investment\\r\\n            // of this source account) and return\\r\\n            _beforeInvestmentChange(redirectRewardsTo, autocompound);\\r\\n            return;\\r\\n        }\\r\\n\\r\\n        // Else, compute account's undistributed/unclaimed rewards\\r\\n        uint256 rewards = _rewardsOf(account, autocompound);\\r\\n\\r\\n        // If there are some rewards\\r\\n        if (rewards > 0) {\\r\\n            // Try to distribute rewards to account\\r\\n            _isClaiming = true;\\r\\n            bool distributed = _distributeRewards(account, rewards);\\r\\n            _isClaiming = false;\\r\\n\\r\\n            // If rewards have not been distributed, accumulate them in account's virtual balance\\r\\n            if (!distributed) accountsDetails[account].virtualBalance = rewards;\\r\\n        }\\r\\n\\r\\n        // Finally, deeply reset investment period of the account\\r\\n        _deepResetInvestmentPeriodOf(account);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev This empty reserved space is put in place to allow future versions to add\\r\\n     * new variables without shifting down storage in the inheritance chain.\\r\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\r\\n     */\\r\\n    uint256[50] private __gap;\\r\\n}\\r\\n\",\"keccak256\":\"0x81408ebf7515885ccbb0eb8043f852b890ecc2a11a2dbcd28df4e8661e7ccfee\",\"license\":\"MIT\"},\"contracts/src/abstracts/RecoverableUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.18;\\r\\n\\r\\n// Conracts\\r\\nimport {Initializable} from \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\r\\nimport {GlobalOwnableUpgradeable} from \\\"./GlobalOwnableUpgradeable.sol\\\";\\r\\n\\r\\n// Libraries\\r\\nimport {SafeERC20Upgradeable} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\\\";\\r\\n\\r\\n// Interfaces\\r\\nimport {IERC20Upgradeable} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title RecoverableUpgradeable\\r\\n * @author Lila Rest (https://lila.rest)\\r\\n * @custom:security-contact security@ledgity.com\\r\\n *\\r\\n * @notice Derived contracts are provided with helpers functions that allow recovering\\r\\n * assets accidentally sent to them.\\r\\n *\\r\\n * @dev Note: This abstract contract currently supports only ERC20 tokens. Derived\\r\\n * contracts currently do not implement necessary functions to receive Ether or\\r\\n * ERC721/ERC1155 tokens.\\r\\n *\\r\\n * @dev For further details, see \\\"RecoverableUpgradeable\\\" section of whitepaper.\\r\\n * @custom:security-contact security@ledgity.com\\r\\n */\\r\\nabstract contract RecoverableUpgradeable is Initializable, GlobalOwnableUpgradeable {\\r\\n    using SafeERC20Upgradeable for IERC20Upgradeable;\\r\\n\\r\\n    /**\\r\\n     * @notice Initializer functions of the contract. They replace the constructor()\\r\\n     * function in the context of upgradeable contracts.\\r\\n     * @dev See: https://docs.openzeppelin.com/contracts/4.x/upgradeable\\r\\n     * @param globalOwner_ The address of the GlobalOwner contract.\\r\\n     */\\r\\n    function __Recoverable_init(address globalOwner_) internal onlyInitializing {\\r\\n        __GlobalOwnable_init(globalOwner_);\\r\\n        __Recoverable_init_unchained();\\r\\n    }\\r\\n\\r\\n    function __Recoverable_init_unchained() internal onlyInitializing {}\\r\\n\\r\\n    /**\\r\\n     * @notice Recovers a specified amount of a given token address. Will fail if the\\r\\n     * contract doesn't hold enough tokens.\\r\\n     * @param tokenAddress The address of the token to recover.\\r\\n     * @param amount The amount of token to recover.\\r\\n     */\\r\\n    function recoverERC20(address tokenAddress, uint256 amount) public virtual onlyOwner {\\r\\n        // Ensure the specified amount is not zero\\r\\n        require(amount > 0, \\\"L10\\\");\\r\\n\\r\\n        // Create a reference to token's contract\\r\\n        IERC20Upgradeable tokenContract = IERC20Upgradeable(tokenAddress);\\r\\n\\r\\n        // Ensure there is enough token to recover\\r\\n        require(tokenContract.balanceOf(address(this)) >= amount, \\\"L11\\\");\\r\\n\\r\\n        // Transfer the recovered token amount to the sender\\r\\n        tokenContract.safeTransfer(_msgSender(), amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev This empty reserved space is put in place to allow future versions to add\\r\\n     * new variables without shifting down storage in the inheritance chain.\\r\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\r\\n     */\\r\\n    uint256[50] private __gap;\\r\\n}\\r\\n\",\"keccak256\":\"0xd16711b7e8352cb8d7cfbae7a50f4065c9b6173c0240d06d925b406268a1ca9c\",\"license\":\"MIT\"},\"contracts/src/abstracts/base/BaseUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.18;\\r\\n\\r\\nimport {Initializable} from \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\r\\nimport {UUPSUpgradeable} from \\\"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\\\";\\r\\nimport {GlobalPausableUpgradeable} from \\\"../GlobalPausableUpgradeable.sol\\\";\\r\\nimport {GlobalOwnableUpgradeable} from \\\"../GlobalOwnableUpgradeable.sol\\\";\\r\\nimport {GlobalRestrictableUpgradeable} from \\\"../GlobalRestrictableUpgradeable.sol\\\";\\r\\nimport {RecoverableUpgradeable} from \\\"../RecoverableUpgradeable.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title BaseUpgradeable\\r\\n * @author Lila Rest (https://lila.rest)\\r\\n * @custom:security-contact security@ledgity.com\\r\\n *\\r\\n * @notice This abstract contract acts as a base for numerous contracts contract in this\\r\\n * codebase, minimizing code repetition and enhancing readability and maintainability.\\r\\n *\\r\\n * @dev For further details, see \\\"Base\\\" section of whitepaper.\\r\\n * @custom:security-contact security@ledgity.com\\r\\n */\\r\\nabstract contract BaseUpgradeable is\\r\\n    Initializable,\\r\\n    UUPSUpgradeable,\\r\\n    GlobalOwnableUpgradeable,\\r\\n    GlobalPausableUpgradeable,\\r\\n    GlobalRestrictableUpgradeable,\\r\\n    RecoverableUpgradeable\\r\\n{\\r\\n    /**\\r\\n     * @notice Prevents implementation contract from being initialized as recommended by\\r\\n     * OpenZeppelin.\\r\\n     * @dev See: https://docs.openzeppelin.com/contracts/4.x/api/proxy#Initializable-_disableInitializers--\\r\\n     * @custom:oz-upgrades-unsafe-allow constructor\\r\\n     */\\r\\n    constructor() {\\r\\n        _disableInitializers();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Initializer functions of the contract. They replace the constructor()\\r\\n     * function in the context of upgradeable contracts.\\r\\n     * @dev See: https://docs.openzeppelin.com/contracts/4.x/upgradeable\\r\\n     * @param globalOwner_ The address of the GlobalOwner contract.\\r\\n     * @param globalPause_ The address of the GlobalPause contract.\\r\\n     * @param globalBlacklist_ The address of the GlobalBlacklist contract.\\r\\n     */\\r\\n    function __Base_init(\\r\\n        address globalOwner_,\\r\\n        address globalPause_,\\r\\n        address globalBlacklist_\\r\\n    ) internal onlyInitializing {\\r\\n        __UUPSUpgradeable_init();\\r\\n        __GlobalOwnable_init(globalOwner_);\\r\\n        __Pausable_init();\\r\\n        __GlobalPausable_init_unchained(globalPause_);\\r\\n        __GlobalRestrictable_init_unchained(globalBlacklist_);\\r\\n        __Recoverable_init_unchained();\\r\\n    }\\r\\n\\r\\n    function __Base_init_unchained() internal onlyInitializing {}\\r\\n\\r\\n    /**\\r\\n     * @notice Override of UUPSUpgradeable._authorizeUpgrade() function restricted to\\r\\n     * global owner. It is called by the proxy contract during an upgrade.\\r\\n     * @param newImplementation The address of the new implementation contract.\\r\\n     */\\r\\n    function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}\\r\\n\\r\\n    /**\\r\\n     * @dev This empty reserved space is put in place to allow future versions to add\\r\\n     * new variables without shifting down storage in the inheritance chain.\\r\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\r\\n     */\\r\\n    uint256[50] private __gap;\\r\\n}\\r\\n\",\"keccak256\":\"0x7cdc7bcbe55135f25bcd2fdf3e0c52bca1aeace1f9104c6c9edd6185ee75fc60\",\"license\":\"MIT\"},\"contracts/src/abstracts/base/ERC20BaseUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.18;\\r\\n\\r\\nimport {ERC20Upgradeable} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\\\";\\r\\nimport {ERC20PausableUpgradeable} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20PausableUpgradeable.sol\\\";\\r\\nimport {PausableUpgradeable} from \\\"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\\\";\\r\\nimport \\\"./BaseUpgradeable.sol\\\";\\r\\nimport {GlobalPausableUpgradeable} from \\\"../GlobalPausableUpgradeable.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title ERC20BaseUpgradeable\\r\\n * @author Lila Rest (https://lila.rest)\\r\\n * @custom:security-contact security@ledgity.com\\r\\n *\\r\\n * @notice This abstract contracts is an extension of BaseUpgradeable intended to be used\\r\\n * as a base for ERC20 tokens contracts.\\r\\n *\\r\\n * @dev For further details, see \\\"ERC20BaseUpgradeable\\\" section of whitepaper.\\r\\n * @custom:security-contact security@ledgity.com\\r\\n */\\r\\nabstract contract ERC20BaseUpgradeable is\\r\\n    ERC20Upgradeable,\\r\\n    BaseUpgradeable,\\r\\n    ERC20PausableUpgradeable\\r\\n{\\r\\n    /**\\r\\n     * @notice Initializer functions of the contract. They replace the constructor()\\r\\n     * function in the context of upgradeable contracts.\\r\\n     * @dev See: https://docs.openzeppelin.com/contracts/4.x/upgradeable\\r\\n     * @param globalOwner_ The address of the GlobalOwner contract.\\r\\n     * @param globalPause_ The address of the GlobalPause contract.\\r\\n     * @param globalBlacklist_ The address of the GlobalBlacklist contract.\\r\\n     * @param name_ The display name of the token.\\r\\n     * @param symbol_ The symbol of the token.\\r\\n     */\\r\\n    function __ERC20Base_init(\\r\\n        address globalOwner_,\\r\\n        address globalPause_,\\r\\n        address globalBlacklist_,\\r\\n        string memory name_,\\r\\n        string memory symbol_\\r\\n    ) internal onlyInitializing {\\r\\n        __Base_init(globalOwner_, globalPause_, globalBlacklist_);\\r\\n        __ERC20_init(name_, symbol_);\\r\\n        __ERC20Pausable_init_unchained();\\r\\n    }\\r\\n\\r\\n    function __ERC20Base_init_unchained() internal onlyInitializing {}\\r\\n\\r\\n    /**\\r\\n     * @notice Required override of paused() which is implemented by both\\r\\n     * GlobalPausableUpgradeable and PausableUpgradeable parent contracts.\\r\\n     * The GlobalPausableUpgradeable version is preferred because it checks the pause\\r\\n     * state from the GlobalPause contract.\\r\\n     * @inheritdoc GlobalPausableUpgradeable\\r\\n     */\\r\\n    function paused()\\r\\n        public\\r\\n        view\\r\\n        virtual\\r\\n        override(GlobalPausableUpgradeable, PausableUpgradeable)\\r\\n        returns (bool)\\r\\n    {\\r\\n        return GlobalPausableUpgradeable.paused();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Required override of _beforeTokenTransfer() which is implemented by both\\r\\n     * ERC20PausableUpgradeable and ERC20Upgradeable parent contracts.\\r\\n     * The ERC20PausableUpgradeable version is preferred because it also checks that\\r\\n     * the contract is not paused before allowing the transfer.\\r\\n     * @inheritdoc ERC20PausableUpgradeable\\r\\n     */\\r\\n    function _beforeTokenTransfer(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    )\\r\\n        internal\\r\\n        virtual\\r\\n        override(ERC20PausableUpgradeable, ERC20Upgradeable)\\r\\n        whenNotPaused\\r\\n        notBlacklisted(from)\\r\\n        notBlacklisted(to)\\r\\n    {\\r\\n        ERC20PausableUpgradeable._beforeTokenTransfer(from, to, amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev This empty reserved space is put in place to allow future versions to add\\r\\n     * new variables without shifting down storage in the inheritance chain.\\r\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\r\\n     */\\r\\n    uint256[50] private __gap;\\r\\n}\\r\\n\",\"keccak256\":\"0x204f187757cb5c3d79b8edc12f4ea52756f2975ebf173d338d6b331102f6f156\",\"license\":\"MIT\"},\"contracts/src/interfaces/ITransfersListener.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.18;\\r\\n\\r\\ninterface ITransfersListener {\\r\\n    function onLTokenTransfer(address from, address to, uint256 amount) external;\\r\\n}\\r\\n\",\"keccak256\":\"0x9764edcd2106059a31e1fabdeb249913bf282eee57f8a83b6cd2c81b0dd17749\",\"license\":\"MIT\"},\"contracts/src/libs/APRHistory.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.18;\\r\\n\\r\\n/**\\r\\n * @title APRHistory\\r\\n * @author Lila Rest (https://lila.rest)\\r\\n * @custom:security-contact security@ledgity.com\\r\\n *\\r\\n * @notice This library offers utilities to efficiently maintain on chain, the history of\\r\\n * an APR (Annual Percentage Rate). Each entry in this history is called a \\\"checkpoint\\\".\\r\\n *\\r\\n * @dev Intuition:\\r\\n * Each checkpoint in an APR history consists in two data:\\r\\n * - the creation timestamp\\r\\n * - the APR at that time\\r\\n *\\r\\n * Given that reads and writes to storage slots are among the most costly operations in\\r\\n * Solidity, this library provides a way to store those data on chain in a way that\\r\\n * minimizes the number of used storage slots.\\r\\n *\\r\\n * Instead of storing each checkpoint in a separate storage slot, this library\\r\\n * facilitates the packing of up to 4 checkpoints in a single storage slot.\\r\\n *\\r\\n * @dev Definitions:\\r\\n * - Checkpoint: A record of an APR change\\r\\n * - Pack: A collection of 4 checkpoints stored in a single storage slot\\r\\n * - History: A dynamic array of packs\\r\\n * - Reference: A storage pointer to a checkpoint in the APR history\\r\\n * - CheckpointData: An in-memory representation of a checkpoint data\\r\\n *\\r\\n * @dev Limitation: This library can accommodate APRs only up to 65.536%. This is however\\r\\n * sufficient for APR in LToken contract, which is expected to remain below 10%.\\r\\n *\\r\\n * @dev For further details, see \\\"APRHistory\\\" section of whitepaper.\\r\\n * @custom:security-contact security@ledgity.com\\r\\n */\\r\\nlibrary APRHistory {\\r\\n    /**\\r\\n     * @notice Represents data of a checkpoint extracted from the on-chain history.\\r\\n     * For on-chain representation see \\\"Pack\\\" struct.\\r\\n     * @param aprUD7x3 APR in UD7x3 format (e.g., 12345 = 12.345%).\\r\\n     * @param timestamp Timestamp of the checkpoint's creation.\\r\\n     */\\r\\n    struct CheckpointData {\\r\\n        uint16 aprUD7x3; // Allows up to 65.536%\\r\\n        uint40 timestamp; // Supports dates up to 20/02/36812\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Represents how APR checkpoints are stored on chain. Each pack can contain\\r\\n     * the data 4 checkpoints. Packs are then stored in a dynamic array (the history).\\r\\n     * @param aprsUD7x3 Array of checkpoints' APRs.\\r\\n     * @param timestamps Array of checkpoints' timestamps.\\r\\n     * @param cursor Index of the next checkpoint to be written.\\r\\n     */\\r\\n    struct Pack {\\r\\n        uint16[4] aprsUD7x3;\\r\\n        uint40[4] timestamps;\\r\\n        uint32 cursor;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Represents a storage pointer to a specific checkpoint in the history.\\r\\n     * @param packIndex Index of the pack the checkpoint belongs to.\\r\\n     * @param cursorIndex Index of the checkpoint in this pack (between 0 and 3).\\r\\n     */\\r\\n    struct Reference {\\r\\n        uint256 packIndex;\\r\\n        uint32 cursorIndex;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Compares two checkpoints references.\\r\\n     * @param ref1 The first reference to compare.\\r\\n     * @param ref2 The second reference to compare.\\r\\n     * @return Whether the two references points to the same checkpoint.\\r\\n     */\\r\\n    function eq(Reference memory ref1, Reference memory ref2) external pure returns (bool) {\\r\\n        return ref1.packIndex == ref2.packIndex && ref1.cursorIndex == ref2.cursorIndex;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Returns the reference of the checkpoint that should come right after the\\r\\n     * referenced checkpoint in the APR history.\\r\\n     * @param ref The reference to be incremented.\\r\\n     * @return The incremented reference.\\r\\n     */\\r\\n    function incrementReference(Reference memory ref) public pure returns (Reference memory) {\\r\\n        // Ensure cursor index of the given ref is within valid range [0, 3]\\r\\n        require(ref.cursorIndex <= 3, \\\"L1\\\");\\r\\n\\r\\n        // If the given ref is the last slot in its pack, return ref of next pack's first slot\\r\\n        if (ref.cursorIndex == 3) return Reference(ref.packIndex + 1, 0);\\r\\n        //\\r\\n        // Else, return ref of next slot in current pack\\r\\n        else return Reference(ref.packIndex, ref.cursorIndex + 1);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Extracts checkpoint data from a given reference and in APR history.\\r\\n     * @param self The APR history to extract the checkpoint from.\\r\\n     * @param ref The reference of the checkpoint data to extract.\\r\\n     * @return The extracted checkpoint's data.\\r\\n     */\\r\\n    function getDataFromReference(\\r\\n        Pack[] storage self,\\r\\n        Reference memory ref\\r\\n    ) public view returns (CheckpointData memory) {\\r\\n        // Ensure cursor index of the given ref is within valid range [0, 3]\\r\\n        require(ref.cursorIndex <= 3, \\\"L2\\\");\\r\\n\\r\\n        // Ensure pack index of the given ref exists in history\\r\\n        require(ref.packIndex < self.length, \\\"L3\\\");\\r\\n\\r\\n        // Retrieve pack data from history\\r\\n        Pack memory pack = self[ref.packIndex];\\r\\n\\r\\n        // Ensure cursor index of the given ref has been written\\r\\n        require(ref.cursorIndex < pack.cursor, \\\"L4\\\");\\r\\n\\r\\n        // Build and return the checkpoint data\\r\\n        return\\r\\n            CheckpointData({\\r\\n                aprUD7x3: pack.aprsUD7x3[ref.cursorIndex],\\r\\n                timestamp: pack.timestamps[ref.cursorIndex]\\r\\n            });\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Retrieves the reference to the most recently added checkpoint in the APR history.\\r\\n     * @param self The history to extract the reference from.\\r\\n     * @return The reference of the latest checkpoint.\\r\\n     */\\r\\n    function getLatestReference(Pack[] storage self) public view returns (Reference memory) {\\r\\n        // Ensure the given history is not empty\\r\\n        require(self.length != 0, \\\"L5\\\");\\r\\n\\r\\n        // Retrieve latest pack's index and cursor\\r\\n        uint256 packIndex = self.length - 1;\\r\\n        uint32 packCursor = self[packIndex].cursor;\\r\\n\\r\\n        // If this is the first pack ever, ensure it is not empty\\r\\n        if (packIndex == 0) require(packCursor != 0, \\\"L6\\\");\\r\\n\\r\\n        // If the pack is empty, return ref of previous pack's latest slot\\r\\n        if (packCursor == 0) return Reference(packIndex - 1, 3);\\r\\n        //\\r\\n        // Else, return ref of previous slot in current pack\\r\\n        else return Reference(packIndex, packCursor - 1);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Appends a new empty pack to the end of the given APR history array.\\r\\n     * @param self The APR history to append an empty to.\\r\\n     */\\r\\n    function newBlankPack(Pack[] storage self) internal {\\r\\n        // If history is not empty, ensure the latest pack is full\\r\\n        require(self.length == 0 || getLatestReference(self).cursorIndex == 3, \\\"L7\\\");\\r\\n\\r\\n        // Push a new blank pack to the history array\\r\\n        self.push(\\r\\n            Pack({\\r\\n                aprsUD7x3: [uint16(0), uint16(0), uint16(0), uint16(0)],\\r\\n                timestamps: [uint40(0), uint40(0), uint40(0), uint40(0)],\\r\\n                cursor: 0\\r\\n            })\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Write a new APR checkpoint at the end of the given history array.\\r\\n     * @param self The array of packs to write the new checkpoint to.\\r\\n     * @param aprUD7x3 The new APR in UD7x3 format.\\r\\n     */\\r\\n    function setAPR(Pack[] storage self, uint16 aprUD7x3) external {\\r\\n        // Determine the reference where the new checkpoint should be written\\r\\n        Reference memory newRef = self.length == 0\\r\\n            ? Reference(0, 0)\\r\\n            : incrementReference(getLatestReference(self));\\r\\n\\r\\n        // If pack to be written doesn't exist yet, push a new blank pack in history\\r\\n        if (newRef.packIndex >= self.length) newBlankPack(self);\\r\\n\\r\\n        // Retrieve the pack where the new checkpoint will be stored\\r\\n        Pack memory pack = self[newRef.packIndex];\\r\\n\\r\\n        // Add new checkpoint's data to the pack\\r\\n        pack.aprsUD7x3[newRef.cursorIndex] = aprUD7x3;\\r\\n        pack.timestamps[newRef.cursorIndex] = uint40(block.timestamp);\\r\\n\\r\\n        // Increment the pack's cursor\\r\\n        pack.cursor++;\\r\\n\\r\\n        // Write the updated pack in storage\\r\\n        self[newRef.packIndex] = pack;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Retrieves the APR of the latest checkpoint written in the APR history.\\r\\n     * @param self The history array to read APR from.\\r\\n     * @return The latest checkpoint's APR.\\r\\n     */\\r\\n    function getAPR(Pack[] storage self) public view returns (uint16) {\\r\\n        // Retrieve the latest checkpoint data\\r\\n        Reference memory ref = getLatestReference(self);\\r\\n        CheckpointData memory data = getDataFromReference(self, ref);\\r\\n\\r\\n        // Return the latest checkpoint's APR\\r\\n        return data.aprUD7x3;\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0xd583afa417f5f23acec6efcb52a723b2ceaef767a698cd0c5c8996c92c02ee21\",\"license\":\"MIT\"},\"contracts/src/libs/SUD.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.18;\\r\\n\\r\\nimport {IERC20MetadataUpgradeable} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title SUD\\r\\n * @author Lila Rest (https://lila.rest)\\r\\n * @custom:security-contact security@ledgity.com\\r\\n *\\r\\n * @notice SUD serves as an intermediary number format for calculations within this\\r\\n * codebase. It ensures consistency and reduces precision losses. This library\\r\\n * facilitates conversions between various number formats and the SUD format.\\r\\n *\\r\\n * @dev Intuition:\\r\\n * This codebase employs UD (unsigned decimal fixed-point numbers) format to represent\\r\\n * both percentage rates and tokens amounts.\\r\\n *\\r\\n * Rates are expressed in UD7x3 format, whereas the format for tokens amounts depends on\\r\\n * the decimals() value of the involved tokens.\\r\\n *\\r\\n * Three challenges arise from this:\\r\\n *   1) To compute values together, it's essential that they are in the same format\\r\\n *   2) Calculations involving consecutive divisions on UD numbers lead to accumulated\\r\\n *      precision loss (because division shrinks). A common approach is to scale up and\\r\\n *      down values by a few decimals before and after performing calculations.\\r\\n *   3) Given that rates use the UD7x3 format, if we decided to scale them to and from\\r\\n *      the number of decimals of the involved token, 1 to 3 of the rates' decimals would\\r\\n *      be shrinked in case token's decimals number is in [0, 2].\\r\\n *\\r\\n * To address these challenges, this library provides the SUD format, which acts as a\\r\\n * consistent and scaled intermediate format to perform calculations on.\\r\\n *\\r\\n * SUD is an acronym for either \\\"Scaled UD\\\" or \\\"Safe UD\\\".\\r\\n *\\r\\n * @dev Definitions:\\r\\n * - Integer: A number without fractional part, e.g., block.timestamp\\r\\n * - UD: A decimal unsigned fixed-point number. The \\\"UD\\\" notation is inspired from\\r\\n *       libraries like [prb-math](https://github.com/PaulRBerg/prb-math/)\\r\\n * - Amount: An UD with an unknown (at writing time) repartition of digits between\\r\\n *           integral and fractional parts. Represents a token amount.\\r\\n * - Rate: An UD with 7 integral digits and 3 fractional ones (a.k.a UD7x3).\\r\\n *         Represents a percentage rate.\\r\\n * - SUD: An UD with 3 more decimals than the involved rate or amount with the highest\\r\\n *        decimals number. As rates are represented by UD7x3, a SUD number has at least 6\\r\\n *        decimals (3+3) and so ranges from UD71x6 to UD0x77 formats.\\r\\n *        Used as an intermediate format to perform calculations.\\r\\n *\\r\\n * @dev This library provides utilities to perform the following conversions:\\r\\n * - Amount       <--> SUD\\r\\n * - Rate (UD7x3) <--> SUD\\r\\n * - Integer      <--> SUD\\r\\n *\\r\\n * @dev Why scaling by 3 decimals?\\r\\n * - It provides an adequate degree of precision for this codebase,\\r\\n * - It enables the conversion of a UD7x3 rate to SUD format by merely scaling it up by\\r\\n *   the involved token's decimal number.\\r\\n *\\r\\n * @dev Optimization note: The functions of this library are not set to external because\\r\\n * incorporating them directly into contracts is more gas-efficient. Given their minimal\\r\\n * size and frequent usage in the InvestUpgradeable, LDYStaking, and LToken contracts,\\r\\n * any bytecode savings from making them external are negated by the additional bytecode\\r\\n * required for external calls to this library.\\r\\n * The can be observed by comparing the output of `pnpm cc:size` when those functions's\\r\\n * visibility is set to external or internal.\\r\\n *\\r\\n * @dev Precision note: While this library mitigates precision loss during calculations\\r\\n * on UD numbers, it's important to note that tokens with lower decimal counts and supply\\r\\n * inherently suffer more from precision loss. Conversely, tokens with higher decimal\\r\\n * counts and supply will experience less precision loss.\\r\\n *\\r\\n * @dev For further details, see \\\"SUD\\\" section of whitepaper.\\r\\n * @custom:security-contact security@ledgity.com\\r\\n */\\r\\nlibrary SUD {\\r\\n    /**\\r\\n     * @notice Retrieves decimals number of the given ERC20 contract address.\\r\\n     * @param tokenAddress The address to retrieve decimals number from.\\r\\n     * @return decimals The decimals number of the given ERC20 contract address.\\r\\n     */\\r\\n    function decimalsOf(address tokenAddress) internal view returns (uint256 decimals) {\\r\\n        return IERC20MetadataUpgradeable(tokenAddress).decimals();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Convert a given token amount into SUD format.\\r\\n     * @param nAmount The token amount to convert.\\r\\n     * @param decimals The decimals number of the involved ERC20 token.\\r\\n     * @return nSUD The amount in SUD format\\r\\n     */\\r\\n    function fromAmount(uint256 nAmount, uint256 decimals) internal pure returns (uint256 nSUD) {\\r\\n        // If token decimals < 3, return a UD71x6 number\\r\\n        if (decimals < 3) return nAmount * 10 ** (6 - decimals);\\r\\n\\r\\n        // Else return a number with decimals+3 fractional digits\\r\\n        return nAmount * 10 ** 3;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Convert a given SUD number into token amount format.\\r\\n     * @param nSUD The SUD number to convert.\\r\\n     * @param decimals The decimals number of the involved ERC20 token.\\r\\n     * @return nAmount The number in amount format\\r\\n     */\\r\\n    function toAmount(uint256 nSUD, uint256 decimals) internal pure returns (uint256 nAmount) {\\r\\n        // If token decimals < 3, convert from a UD71x6 number\\r\\n        if (decimals < 3) return nSUD / 10 ** (6 - decimals);\\r\\n\\r\\n        // Else, convert from a number with decimals+3 fractional digits\\r\\n        return nSUD / 10 ** 3;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Converts a given UD7x3 rate into SUD format.\\r\\n     * @param nUD7x3 The UD7x3 rate to convert.\\r\\n     * @param decimals The decimals number of the involved ERC20 token.\\r\\n     * @return nSUD The rate in SUD format.\\r\\n     */\\r\\n    function fromRate(uint256 nUD7x3, uint256 decimals) internal pure returns (uint256 nSUD) {\\r\\n        // If token decimals < 3, return a UD71x6 number\\r\\n        if (decimals < 3) return nUD7x3 * 10 ** 3;\\r\\n\\r\\n        // Else, return a number with decimals+3 fractional digits\\r\\n        return nUD7x3 * 10 ** decimals;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Converts a given SUD number into a UD7x3 rate.\\r\\n     * @param nSUD The SUD number to convert.\\r\\n     * @param decimals The decimals number of the involved ERC20 token.\\r\\n     * @return nUD7x3 The number in UD7x3 rate format.\\r\\n     */\\r\\n    function toRate(uint256 nSUD, uint256 decimals) internal pure returns (uint256 nUD7x3) {\\r\\n        // If token decimals < 3, convert from a UD71x6 number\\r\\n        if (decimals < 3) return nSUD / 10 ** 3;\\r\\n\\r\\n        // Else, convert from a number with decimals+3 fractional digits\\r\\n        return nSUD / 10 ** decimals;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Converts a given integer into SUD format.\\r\\n     * @param n The integer to convert.\\r\\n     * @param decimals The decimals number of the involved ERC20 token.\\r\\n     * @return nSUD The integer in SUD format.\\r\\n     */\\r\\n    function fromInt(uint256 n, uint256 decimals) internal pure returns (uint256 nSUD) {\\r\\n        // If token decimals < 3, return a UD71x6 number\\r\\n        if (decimals < 3) return n * 10 ** 6;\\r\\n\\r\\n        // Else, return a number with decimals+3 fractional digits\\r\\n        return n * 10 ** (decimals + 3);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Converts a given SUD number as an integer (all decimals shrinked).\\r\\n     * @param nSUD The SUD number to convert.\\r\\n     * @param decimals The decimals number of the involved ERC20 token.\\r\\n     * @return n The SUD number as an integer.\\r\\n     */\\r\\n    function toInt(uint256 nSUD, uint256 decimals) internal pure returns (uint256 n) {\\r\\n        // If token decimals < 3, convert from a UD71x6 number\\r\\n        if (decimals < 3) return nSUD / 10 ** 6;\\r\\n\\r\\n        // Else, convert from a number with decimals+3 fractional digits\\r\\n        return nSUD / 10 ** (decimals + 3);\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0xf73e9380b9df21d58eba638fca4ac1b71ade2f6ee2f37f740531a9e503cac778\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x6101806040523480156200001257600080fd5b50604051620024943803806200249483398101604081905262000035916200022d565b620000403362000186565b6001805460ff60a01b1916815560ff841610156200008b5760405162461bcd60e51b8152602060048201526003602482015262261b9960e91b60448201526064015b60405180910390fd5b8160ff168360ff161115620000c95760405162461bcd60e51b81526020600482015260036024820152624c373360e81b604482015260640162000082565b6001600160a01b03861661012081905260408051636f307dc360e01b81529051636f307dc3916004808201926020929091908290030181865afa15801562000115573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906200013b91906200029f565b6001600160a01b03166101405260a0849052608085905260ff80841660c05282811660e081905290821661010052620001759085620002c6565b6101605250620002f2945050505050565b600180546001600160a01b0319169055620001ad81620001b0602090811b620017cb17901c565b50565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b6001600160a01b0381168114620001ad57600080fd5b805160ff811681146200022857600080fd5b919050565b60008060008060008060c087890312156200024757600080fd5b8651620002548162000200565b6020880151604089015191975095509350620002736060880162000216565b9250620002836080880162000216565b91506200029360a0880162000216565b90509295509295509295565b600060208284031215620002b257600080fd5b8151620002bf8162000200565b9392505050565b8082028115828204841417620002ec57634e487b7160e01b600052601160045260246000fd5b92915050565b60805160a05160c05160e051610100516101205161014051610160516120be620003d6600039600081816106b301528181611740015261177101526000818161043a015281816110460152818161136301528181611398015281816114e1015261159201526000818161023101528181610c9601528181610fdd015281816113ba01526113f50152600081816103d401528181610816015261090301526000818161067f0152818161093701526111300152600081816106e701526110ff01526000818161054b015261118d0152600081816102a4015261179601526120be6000f3fe60806040526004361061021a5760003560e01c8063747dbf06116101235780639c3857a7116100ab578063e30c39781161006f578063e30c397814610709578063ed75a3ab14610727578063eddd21431461073d578063f2fde38b14610752578063fe98988a1461077257600080fd5b80639c3857a714610643578063a1568d4b14610658578063a16cdbb11461066d578063a8b0bb83146106a1578063d6a298e9146106d557600080fd5b80638980f11f116100f25780638980f11f146105b15780638acc764e146105d15780638da5cb5b146105e65780638f6a32a214610604578063998e42421461062357600080fd5b8063747dbf061461053957806379ba50971461056d578063828ed046146105825780638456cb591461059c57600080fd5b8063276a5699116101a6578063568914121161017557806356891412146104bb57806356e19a2c146104d15780635c975abb146104d95780635fd6218914610504578063715018a61461052457600080fd5b8063276a56991461045c57806330de5b3c14610471578063372500ab146104915780633f4ba83a146104a657600080fd5b80630da45188116101ed5780630da451881461038c57806312f60d3c146103ac5780631514617e146103c257806321ed3195146104085780632495a5991461042857600080fd5b8063010ee1841461021f578063085defc4146102705780630b441d6f146102925780630beea97a146102d4575b600080fd5b34801561022b57600080fd5b506102537f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b0390911681526020015b60405180910390f35b34801561027c57600080fd5b5061029061028b366004611dfa565b610792565b005b34801561029e57600080fd5b506102c67f000000000000000000000000000000000000000000000000000000000000000081565b604051908152602001610267565b3480156102e057600080fd5b506103436102ef366004611dfa565b600360205260009081526040902080546001909101546001600160f01b0382169160ff600160f01b8204811692600160f81b90920416906001600160d81b0381169064ffffffffff600160d81b9091041685565b604080516001600160f01b03909616865260ff9094166020860152911515928401929092526001600160d81b03909116606083015264ffffffffff16608082015260a001610267565b34801561039857600080fd5b506102c66103a7366004611dfa565b6107ff565b3480156103b857600080fd5b506102c660065481565b3480156103ce57600080fd5b506103f67f000000000000000000000000000000000000000000000000000000000000000081565b60405160ff9091168152602001610267565b34801561041457600080fd5b50600254610253906001600160a01b031681565b34801561043457600080fd5b506102537f000000000000000000000000000000000000000000000000000000000000000081565b34801561046857600080fd5b506102906108b1565b34801561047d57600080fd5b5061025361048c366004611e15565b610a20565b34801561049d57600080fd5b50610290610a4a565b3480156104b257600080fd5b50610290610b07565b3480156104c757600080fd5b506102c660045481565b610290610b19565b3480156104e557600080fd5b50600154600160a01b900460ff165b6040519015158152602001610267565b34801561051057600080fd5b506005546104f49062010000900460ff1681565b34801561053057600080fd5b50610290610cff565b34801561054557600080fd5b506102c67f000000000000000000000000000000000000000000000000000000000000000081565b34801561057957600080fd5b50610290610d11565b34801561058e57600080fd5b506005546104f49060ff1681565b3480156105a857600080fd5b50610290610d88565b3480156105bd57600080fd5b506102906105cc366004611e2e565b610d98565b3480156105dd57600080fd5b50610290610e97565b3480156105f257600080fd5b506000546001600160a01b0316610253565b34801561061057600080fd5b506005546104f490610100900460ff1681565b34801561062f57600080fd5b5061029061063e366004611e58565b61106f565b34801561064f57600080fd5b5061029061145f565b34801561066457600080fd5b506102906115da565b34801561067957600080fd5b506103f67f000000000000000000000000000000000000000000000000000000000000000081565b3480156106ad57600080fd5b506102c67f000000000000000000000000000000000000000000000000000000000000000081565b3480156106e157600080fd5b506103f67f000000000000000000000000000000000000000000000000000000000000000081565b34801561071557600080fd5b506001546001600160a01b0316610253565b34801561073357600080fd5b506102c660085481565b34801561074957600080fd5b506102906115f1565b34801561075e57600080fd5b5061029061076d366004611dfa565b61168a565b34801561077e57600080fd5b506102c661078d366004611dfa565b6116fb565b61079a61181b565b600554610100900460ff16156107dd5760405162461bcd60e51b8152602060048201526003602482015262130dcd60ea1b60448201526064015b60405180910390fd5b600280546001600160a01b0319166001600160a01b0392909216919091179055565b60008061080b836116fb565b9050600061083f60ff7f00000000000000000000000000000000000000000000000000000000000000001662278d00611ea4565b90506000600654426108519190611ec1565b90508181111561085e5750805b60008261086b8386611ea4565b6108759190611ed4565b6001600160a01b0387166000908152600360205260409020600101549091506108a7906001600160d81b031682611ec1565b9695505050505050565b6108b961181b565b600554610100900460ff166108f65760405162461bcd60e51b81526020600482015260036024820152624c373960e81b60448201526064016107d4565b6276a700600061092c60ff7f00000000000000000000000000000000000000000000000000000000000000001662278d00611ea4565b9050600061096060ff7f00000000000000000000000000000000000000000000000000000000000000001662278d00611ea4565b9050600083836006546109739190611ef6565b61097d9190611ef6565b9050804210156109b55760405162461bcd60e51b815260206004820152600360248201526204c38360ec1b60448201526064016107d4565b600084836006546109c69190611ef6565b6109d09190611ef6565b905080421015610a085760405162461bcd60e51b81526020600482015260036024820152624c383160e81b60448201526064016107d4565b50506005805462ff0000191662010000179055505050565b60078181548110610a3057600080fd5b6000918252602090912001546001600160a01b0316905081565b610a52611875565b600554610100900460ff16610a8f5760405162461bcd60e51b81526020600482015260036024820152624c383760e81b60448201526064016107d4565b6000610a9a336107ff565b33600090815260036020526040812060010180549293508392909190610aca9084906001600160d81b0316611f09565b82546001600160d81b039182166101009390930a928302919092021990911617905550600254610b04906001600160a01b031633836118c2565b50565b610b0f61181b565b610b17611925565b565b610b21611875565b3360009081526003602052604090206001015442600160d81b90910464ffffffffff161115610b785760405162461bcd60e51b81526020600482015260036024820152620986c760eb1b60448201526064016107d4565b33600090815260036020526040902054600160f81b900460ff1615610bc55760405162461bcd60e51b81526020600482015260036024820152624c363960e81b60448201526064016107d4565b336000908152600360205260409020546001600160f01b0316610c105760405162461bcd60e51b815260206004820152600360248201526204c37360ec1b60448201526064016107d4565b336000818152600360205260409081902080546001600160f81b0316600160f81b17815560078054600181019091557fa66cc928b5edb82af9bd49922954155ab7b0942694bea4ce44661d9a8736c6880180546001600160a01b031916909317909255905490516313dccf3d60e31b81526001600160f01b0390911660048201819052907f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031690639ee679e89034906024016000604051808303818588803b158015610ce357600080fd5b505af1158015610cf7573d6000803e3d6000fd5b505050505050565b610d0761181b565b610b17600061197a565b60015433906001600160a01b03168114610d7f5760405162461bcd60e51b815260206004820152602960248201527f4f776e61626c6532537465703a2063616c6c6572206973206e6f7420746865206044820152683732bb9037bbb732b960b91b60648201526084016107d4565b610b048161197a565b610d9061181b565b610b17611993565b610da061181b565b60055462010000900460ff16610dde5760405162461bcd60e51b8152602060048201526003602482015262261c1960e91b60448201526064016107d4565b6040516370a0823160e01b8152306004820152829082906001600160a01b038316906370a0823190602401602060405180830381865afa158015610e26573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610e4a9190611f30565b1015610e7e5760405162461bcd60e51b81526020600482015260036024820152624c383360e81b60448201526064016107d4565b610e926001600160a01b03821633846118c2565b505050565b610e9f611875565b3360009081526003602052604090206001015442600160d81b90910464ffffffffff161115610ef65760405162461bcd60e51b81526020600482015260036024820152620986c760eb1b60448201526064016107d4565b33600090815260036020526040902054600160f81b900460ff1615610f435760405162461bcd60e51b81526020600482015260036024820152624c363960e81b60448201526064016107d4565b336000908152600360205260409020546001600160f01b0316610f8e5760405162461bcd60e51b815260206004820152600360248201526204c37360ec1b60448201526064016107d4565b33600090815260036020526040908190208054600160f81b6001600160f81b038216179091559051634134bee960e01b81526001600160f01b0390911660048201819052906001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001690634134bee990602401600060405180830381600087803b15801561102157600080fd5b505af1158015611035573d6000803e3d6000fd5b50610b049250506001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016905033836118c2565b611077611875565b60055460ff16156110b05760405162461bcd60e51b8152602060048201526003602482015262130e0d60ea1b60448201526064016107d4565b33600090815260036020526040902054600160f81b900460ff16156110fd5760405162461bcd60e51b81526020600482015260036024820152624c373160e81b60448201526064016107d4565b7f000000000000000000000000000000000000000000000000000000000000000060ff168160ff161015801561115957507f000000000000000000000000000000000000000000000000000000000000000060ff168160ff1611155b61118b5760405162461bcd60e51b81526020600482015260036024820152624c383560e81b60448201526064016107d4565b7f0000000000000000000000000000000000000000000000000000000000000000826004546111ba9190611ef6565b11156111ee5760405162461bcd60e51b8152602060048201526003602482015262261c1b60e91b60448201526064016107d4565b33600090815260036020526040812080548492906112169084906001600160f01b0316611f49565b92506101000a8154816001600160f01b0302191690836001600160f01b03160217905550816004600082825461124c9190611ef6565b90915550503360009081526003602052604081205460ff600160f01b909104811691908316821161127d578261127f565b815b336000908152600360205260409020805460ff60f01b1916600160f01b60ff8416908102919091179091559091506112ba9062278d00611f69565b6112cb9064ffffffffff1642611ef6565b3360008181526003602052604090819020600101805464ffffffffff94909416600160d81b026001600160d81b039094169390931790925590517f111750799d4c0d4634f6bcaaeb8596889f0c1c9c36ae900df00617890266ac5990611340908790859091825260ff16602082015260400190565b60405180910390a2836000036113565750505050565b61138b6001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000163330876119d6565b6113df6001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000167f000000000000000000000000000000000000000000000000000000000000000086611a14565b60405163b6b55f2560e01b8152600481018590527f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03169063b6b55f2590602401600060405180830381600087803b15801561144157600080fd5b505af1158015611455573d6000803e3d6000fd5b5050505050505050565b61146761181b565b6008545b6007548110156115d55761afc85a106115d55760006007828154811061149357611493611f92565b60009182526020808320909101546001600160a01b031680835260039091526040909120549091506001600160f01b031681156115c1576040516370a0823160e01b815230600482015281907f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316906370a0823190602401602060405180830381865afa158015611530573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906115549190611f30565b1015611561575050600855565b6007838154811061157457611574611f92565b600091825260209091200180546001600160a01b03191690556115c17f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031683836118c2565b826115cb81611fa8565b935050505061146b565b600855565b6115e261181b565b6005805460ff19166001179055565b6115f961181b565b600554610100900460ff16156116375760405162461bcd60e51b8152602060048201526003602482015262261b9b60e91b60448201526064016107d4565b6002546001600160a01b03166116755760405162461bcd60e51b81526020600482015260036024820152624c373760e81b60448201526064016107d4565b6005805461ff00191661010017905542600655565b61169261181b565b600180546001600160a01b0383166001600160a01b031990911681179091556116c36000546001600160a01b031690565b6001600160a01b03167f38d16b8cac22d99fc7c124b9cd0de2d3fa1faef420bfe791d8c362d765e2270060405160405180910390a350565b6001600160a01b03811660009081526003602052604081205481906117339060ff600160f01b820416906001600160f01b0316611fc1565b6001600160f01b031690507f000000000000000000000000000000000000000000000000000000000000000060000361176f5750600092915050565b7f00000000000000000000000000000000000000000000000000000000000000006117ba827f0000000000000000000000000000000000000000000000000000000000000000611ea4565b6117c49190611ed4565b9392505050565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b6000546001600160a01b03163314610b175760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e657260448201526064016107d4565b600154600160a01b900460ff1615610b175760405162461bcd60e51b815260206004820152601060248201526f14185d5cd8589b194e881c185d5cd95960821b60448201526064016107d4565b6040516001600160a01b038316602482015260448101829052610e9290849063a9059cbb60e01b906064015b60408051601f198184030181529190526020810180516001600160e01b03166001600160e01b031990931692909217909152611b29565b61192d611bfe565b6001805460ff60a01b191690557f5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa335b6040516001600160a01b03909116815260200160405180910390a1565b600180546001600160a01b0319169055610b04816117cb565b61199b611875565b6001805460ff60a01b1916600160a01b1790557f62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a25861195d3390565b6040516001600160a01b0380851660248301528316604482015260648101829052611a0e9085906323b872dd60e01b906084016118ee565b50505050565b801580611a8e5750604051636eb1769f60e11b81523060048201526001600160a01b03838116602483015284169063dd62ed3e90604401602060405180830381865afa158015611a68573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611a8c9190611f30565b155b611af95760405162461bcd60e51b815260206004820152603660248201527f5361666545524332303a20617070726f76652066726f6d206e6f6e2d7a65726f60448201527520746f206e6f6e2d7a65726f20616c6c6f77616e636560501b60648201526084016107d4565b6040516001600160a01b038316602482015260448101829052610e9290849063095ea7b360e01b906064016118ee565b6000611b7e826040518060400160405280602081526020017f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c6564815250856001600160a01b0316611c4e9092919063ffffffff16565b9050805160001480611b9f575080806020019051810190611b9f9190611ff3565b610e925760405162461bcd60e51b815260206004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e6044820152691bdd081cdd58d8d9595960b21b60648201526084016107d4565b600154600160a01b900460ff16610b175760405162461bcd60e51b815260206004820152601460248201527314185d5cd8589b194e881b9bdd081c185d5cd95960621b60448201526064016107d4565b6060611c5d8484600085611c65565b949350505050565b606082471015611cc65760405162461bcd60e51b815260206004820152602660248201527f416464726573733a20696e73756666696369656e742062616c616e636520666f6044820152651c8818d85b1b60d21b60648201526084016107d4565b600080866001600160a01b03168587604051611ce29190612039565b60006040518083038185875af1925050503d8060008114611d1f576040519150601f19603f3d011682016040523d82523d6000602084013e611d24565b606091505b5091509150611d3587838387611d40565b979650505050505050565b60608315611daf578251600003611da8576001600160a01b0385163b611da85760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e747261637400000060448201526064016107d4565b5081611c5d565b611c5d8383815115611dc45781518083602001fd5b8060405162461bcd60e51b81526004016107d49190612055565b80356001600160a01b0381168114611df557600080fd5b919050565b600060208284031215611e0c57600080fd5b6117c482611dde565b600060208284031215611e2757600080fd5b5035919050565b60008060408385031215611e4157600080fd5b611e4a83611dde565b946020939093013593505050565b60008060408385031215611e6b57600080fd5b82359150602083013560ff81168114611e8357600080fd5b809150509250929050565b634e487b7160e01b600052601160045260246000fd5b8082028115828204841417611ebb57611ebb611e8e565b92915050565b81810381811115611ebb57611ebb611e8e565b600082611ef157634e487b7160e01b600052601260045260246000fd5b500490565b80820180821115611ebb57611ebb611e8e565b6001600160d81b03818116838216019080821115611f2957611f29611e8e565b5092915050565b600060208284031215611f4257600080fd5b5051919050565b6001600160f01b03818116838216019080821115611f2957611f29611e8e565b64ffffffffff818116838216028082169190828114611f8a57611f8a611e8e565b505092915050565b634e487b7160e01b600052603260045260246000fd5b600060018201611fba57611fba611e8e565b5060010190565b6001600160f01b03828116828216818102831692918115828504821417611fea57611fea611e8e565b50505092915050565b60006020828403121561200557600080fd5b815180151581146117c457600080fd5b60005b83811015612030578181015183820152602001612018565b50506000910152565b6000825161204b818460208701612015565b9190910192915050565b6020815260008251806020840152612074816040850160208701612015565b601f01601f1916919091016040019291505056fea2646970667358221220a5179b17a2339dc849fd2a3fe45683ff5f9445fb0e12d679c8bd39c17d761df164736f6c63430008120033",
  "deployedBytecode": "0x60806040526004361061021a5760003560e01c8063747dbf06116101235780639c3857a7116100ab578063e30c39781161006f578063e30c397814610709578063ed75a3ab14610727578063eddd21431461073d578063f2fde38b14610752578063fe98988a1461077257600080fd5b80639c3857a714610643578063a1568d4b14610658578063a16cdbb11461066d578063a8b0bb83146106a1578063d6a298e9146106d557600080fd5b80638980f11f116100f25780638980f11f146105b15780638acc764e146105d15780638da5cb5b146105e65780638f6a32a214610604578063998e42421461062357600080fd5b8063747dbf061461053957806379ba50971461056d578063828ed046146105825780638456cb591461059c57600080fd5b8063276a5699116101a6578063568914121161017557806356891412146104bb57806356e19a2c146104d15780635c975abb146104d95780635fd6218914610504578063715018a61461052457600080fd5b8063276a56991461045c57806330de5b3c14610471578063372500ab146104915780633f4ba83a146104a657600080fd5b80630da45188116101ed5780630da451881461038c57806312f60d3c146103ac5780631514617e146103c257806321ed3195146104085780632495a5991461042857600080fd5b8063010ee1841461021f578063085defc4146102705780630b441d6f146102925780630beea97a146102d4575b600080fd5b34801561022b57600080fd5b506102537f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b0390911681526020015b60405180910390f35b34801561027c57600080fd5b5061029061028b366004611dfa565b610792565b005b34801561029e57600080fd5b506102c67f000000000000000000000000000000000000000000000000000000000000000081565b604051908152602001610267565b3480156102e057600080fd5b506103436102ef366004611dfa565b600360205260009081526040902080546001909101546001600160f01b0382169160ff600160f01b8204811692600160f81b90920416906001600160d81b0381169064ffffffffff600160d81b9091041685565b604080516001600160f01b03909616865260ff9094166020860152911515928401929092526001600160d81b03909116606083015264ffffffffff16608082015260a001610267565b34801561039857600080fd5b506102c66103a7366004611dfa565b6107ff565b3480156103b857600080fd5b506102c660065481565b3480156103ce57600080fd5b506103f67f000000000000000000000000000000000000000000000000000000000000000081565b60405160ff9091168152602001610267565b34801561041457600080fd5b50600254610253906001600160a01b031681565b34801561043457600080fd5b506102537f000000000000000000000000000000000000000000000000000000000000000081565b34801561046857600080fd5b506102906108b1565b34801561047d57600080fd5b5061025361048c366004611e15565b610a20565b34801561049d57600080fd5b50610290610a4a565b3480156104b257600080fd5b50610290610b07565b3480156104c757600080fd5b506102c660045481565b610290610b19565b3480156104e557600080fd5b50600154600160a01b900460ff165b6040519015158152602001610267565b34801561051057600080fd5b506005546104f49062010000900460ff1681565b34801561053057600080fd5b50610290610cff565b34801561054557600080fd5b506102c67f000000000000000000000000000000000000000000000000000000000000000081565b34801561057957600080fd5b50610290610d11565b34801561058e57600080fd5b506005546104f49060ff1681565b3480156105a857600080fd5b50610290610d88565b3480156105bd57600080fd5b506102906105cc366004611e2e565b610d98565b3480156105dd57600080fd5b50610290610e97565b3480156105f257600080fd5b506000546001600160a01b0316610253565b34801561061057600080fd5b506005546104f490610100900460ff1681565b34801561062f57600080fd5b5061029061063e366004611e58565b61106f565b34801561064f57600080fd5b5061029061145f565b34801561066457600080fd5b506102906115da565b34801561067957600080fd5b506103f67f000000000000000000000000000000000000000000000000000000000000000081565b3480156106ad57600080fd5b506102c67f000000000000000000000000000000000000000000000000000000000000000081565b3480156106e157600080fd5b506103f67f000000000000000000000000000000000000000000000000000000000000000081565b34801561071557600080fd5b506001546001600160a01b0316610253565b34801561073357600080fd5b506102c660085481565b34801561074957600080fd5b506102906115f1565b34801561075e57600080fd5b5061029061076d366004611dfa565b61168a565b34801561077e57600080fd5b506102c661078d366004611dfa565b6116fb565b61079a61181b565b600554610100900460ff16156107dd5760405162461bcd60e51b8152602060048201526003602482015262130dcd60ea1b60448201526064015b60405180910390fd5b600280546001600160a01b0319166001600160a01b0392909216919091179055565b60008061080b836116fb565b9050600061083f60ff7f00000000000000000000000000000000000000000000000000000000000000001662278d00611ea4565b90506000600654426108519190611ec1565b90508181111561085e5750805b60008261086b8386611ea4565b6108759190611ed4565b6001600160a01b0387166000908152600360205260409020600101549091506108a7906001600160d81b031682611ec1565b9695505050505050565b6108b961181b565b600554610100900460ff166108f65760405162461bcd60e51b81526020600482015260036024820152624c373960e81b60448201526064016107d4565b6276a700600061092c60ff7f00000000000000000000000000000000000000000000000000000000000000001662278d00611ea4565b9050600061096060ff7f00000000000000000000000000000000000000000000000000000000000000001662278d00611ea4565b9050600083836006546109739190611ef6565b61097d9190611ef6565b9050804210156109b55760405162461bcd60e51b815260206004820152600360248201526204c38360ec1b60448201526064016107d4565b600084836006546109c69190611ef6565b6109d09190611ef6565b905080421015610a085760405162461bcd60e51b81526020600482015260036024820152624c383160e81b60448201526064016107d4565b50506005805462ff0000191662010000179055505050565b60078181548110610a3057600080fd5b6000918252602090912001546001600160a01b0316905081565b610a52611875565b600554610100900460ff16610a8f5760405162461bcd60e51b81526020600482015260036024820152624c383760e81b60448201526064016107d4565b6000610a9a336107ff565b33600090815260036020526040812060010180549293508392909190610aca9084906001600160d81b0316611f09565b82546001600160d81b039182166101009390930a928302919092021990911617905550600254610b04906001600160a01b031633836118c2565b50565b610b0f61181b565b610b17611925565b565b610b21611875565b3360009081526003602052604090206001015442600160d81b90910464ffffffffff161115610b785760405162461bcd60e51b81526020600482015260036024820152620986c760eb1b60448201526064016107d4565b33600090815260036020526040902054600160f81b900460ff1615610bc55760405162461bcd60e51b81526020600482015260036024820152624c363960e81b60448201526064016107d4565b336000908152600360205260409020546001600160f01b0316610c105760405162461bcd60e51b815260206004820152600360248201526204c37360ec1b60448201526064016107d4565b336000818152600360205260409081902080546001600160f81b0316600160f81b17815560078054600181019091557fa66cc928b5edb82af9bd49922954155ab7b0942694bea4ce44661d9a8736c6880180546001600160a01b031916909317909255905490516313dccf3d60e31b81526001600160f01b0390911660048201819052907f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031690639ee679e89034906024016000604051808303818588803b158015610ce357600080fd5b505af1158015610cf7573d6000803e3d6000fd5b505050505050565b610d0761181b565b610b17600061197a565b60015433906001600160a01b03168114610d7f5760405162461bcd60e51b815260206004820152602960248201527f4f776e61626c6532537465703a2063616c6c6572206973206e6f7420746865206044820152683732bb9037bbb732b960b91b60648201526084016107d4565b610b048161197a565b610d9061181b565b610b17611993565b610da061181b565b60055462010000900460ff16610dde5760405162461bcd60e51b8152602060048201526003602482015262261c1960e91b60448201526064016107d4565b6040516370a0823160e01b8152306004820152829082906001600160a01b038316906370a0823190602401602060405180830381865afa158015610e26573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610e4a9190611f30565b1015610e7e5760405162461bcd60e51b81526020600482015260036024820152624c383360e81b60448201526064016107d4565b610e926001600160a01b03821633846118c2565b505050565b610e9f611875565b3360009081526003602052604090206001015442600160d81b90910464ffffffffff161115610ef65760405162461bcd60e51b81526020600482015260036024820152620986c760eb1b60448201526064016107d4565b33600090815260036020526040902054600160f81b900460ff1615610f435760405162461bcd60e51b81526020600482015260036024820152624c363960e81b60448201526064016107d4565b336000908152600360205260409020546001600160f01b0316610f8e5760405162461bcd60e51b815260206004820152600360248201526204c37360ec1b60448201526064016107d4565b33600090815260036020526040908190208054600160f81b6001600160f81b038216179091559051634134bee960e01b81526001600160f01b0390911660048201819052906001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001690634134bee990602401600060405180830381600087803b15801561102157600080fd5b505af1158015611035573d6000803e3d6000fd5b50610b049250506001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016905033836118c2565b611077611875565b60055460ff16156110b05760405162461bcd60e51b8152602060048201526003602482015262130e0d60ea1b60448201526064016107d4565b33600090815260036020526040902054600160f81b900460ff16156110fd5760405162461bcd60e51b81526020600482015260036024820152624c373160e81b60448201526064016107d4565b7f000000000000000000000000000000000000000000000000000000000000000060ff168160ff161015801561115957507f000000000000000000000000000000000000000000000000000000000000000060ff168160ff1611155b61118b5760405162461bcd60e51b81526020600482015260036024820152624c383560e81b60448201526064016107d4565b7f0000000000000000000000000000000000000000000000000000000000000000826004546111ba9190611ef6565b11156111ee5760405162461bcd60e51b8152602060048201526003602482015262261c1b60e91b60448201526064016107d4565b33600090815260036020526040812080548492906112169084906001600160f01b0316611f49565b92506101000a8154816001600160f01b0302191690836001600160f01b03160217905550816004600082825461124c9190611ef6565b90915550503360009081526003602052604081205460ff600160f01b909104811691908316821161127d578261127f565b815b336000908152600360205260409020805460ff60f01b1916600160f01b60ff8416908102919091179091559091506112ba9062278d00611f69565b6112cb9064ffffffffff1642611ef6565b3360008181526003602052604090819020600101805464ffffffffff94909416600160d81b026001600160d81b039094169390931790925590517f111750799d4c0d4634f6bcaaeb8596889f0c1c9c36ae900df00617890266ac5990611340908790859091825260ff16602082015260400190565b60405180910390a2836000036113565750505050565b61138b6001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000163330876119d6565b6113df6001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000167f000000000000000000000000000000000000000000000000000000000000000086611a14565b60405163b6b55f2560e01b8152600481018590527f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03169063b6b55f2590602401600060405180830381600087803b15801561144157600080fd5b505af1158015611455573d6000803e3d6000fd5b5050505050505050565b61146761181b565b6008545b6007548110156115d55761afc85a106115d55760006007828154811061149357611493611f92565b60009182526020808320909101546001600160a01b031680835260039091526040909120549091506001600160f01b031681156115c1576040516370a0823160e01b815230600482015281907f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316906370a0823190602401602060405180830381865afa158015611530573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906115549190611f30565b1015611561575050600855565b6007838154811061157457611574611f92565b600091825260209091200180546001600160a01b03191690556115c17f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031683836118c2565b826115cb81611fa8565b935050505061146b565b600855565b6115e261181b565b6005805460ff19166001179055565b6115f961181b565b600554610100900460ff16156116375760405162461bcd60e51b8152602060048201526003602482015262261b9b60e91b60448201526064016107d4565b6002546001600160a01b03166116755760405162461bcd60e51b81526020600482015260036024820152624c373760e81b60448201526064016107d4565b6005805461ff00191661010017905542600655565b61169261181b565b600180546001600160a01b0383166001600160a01b031990911681179091556116c36000546001600160a01b031690565b6001600160a01b03167f38d16b8cac22d99fc7c124b9cd0de2d3fa1faef420bfe791d8c362d765e2270060405160405180910390a350565b6001600160a01b03811660009081526003602052604081205481906117339060ff600160f01b820416906001600160f01b0316611fc1565b6001600160f01b031690507f000000000000000000000000000000000000000000000000000000000000000060000361176f5750600092915050565b7f00000000000000000000000000000000000000000000000000000000000000006117ba827f0000000000000000000000000000000000000000000000000000000000000000611ea4565b6117c49190611ed4565b9392505050565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b6000546001600160a01b03163314610b175760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e657260448201526064016107d4565b600154600160a01b900460ff1615610b175760405162461bcd60e51b815260206004820152601060248201526f14185d5cd8589b194e881c185d5cd95960821b60448201526064016107d4565b6040516001600160a01b038316602482015260448101829052610e9290849063a9059cbb60e01b906064015b60408051601f198184030181529190526020810180516001600160e01b03166001600160e01b031990931692909217909152611b29565b61192d611bfe565b6001805460ff60a01b191690557f5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa335b6040516001600160a01b03909116815260200160405180910390a1565b600180546001600160a01b0319169055610b04816117cb565b61199b611875565b6001805460ff60a01b1916600160a01b1790557f62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a25861195d3390565b6040516001600160a01b0380851660248301528316604482015260648101829052611a0e9085906323b872dd60e01b906084016118ee565b50505050565b801580611a8e5750604051636eb1769f60e11b81523060048201526001600160a01b03838116602483015284169063dd62ed3e90604401602060405180830381865afa158015611a68573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611a8c9190611f30565b155b611af95760405162461bcd60e51b815260206004820152603660248201527f5361666545524332303a20617070726f76652066726f6d206e6f6e2d7a65726f60448201527520746f206e6f6e2d7a65726f20616c6c6f77616e636560501b60648201526084016107d4565b6040516001600160a01b038316602482015260448101829052610e9290849063095ea7b360e01b906064016118ee565b6000611b7e826040518060400160405280602081526020017f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c6564815250856001600160a01b0316611c4e9092919063ffffffff16565b9050805160001480611b9f575080806020019051810190611b9f9190611ff3565b610e925760405162461bcd60e51b815260206004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e6044820152691bdd081cdd58d8d9595960b21b60648201526084016107d4565b600154600160a01b900460ff16610b175760405162461bcd60e51b815260206004820152601460248201527314185d5cd8589b194e881b9bdd081c185d5cd95960621b60448201526064016107d4565b6060611c5d8484600085611c65565b949350505050565b606082471015611cc65760405162461bcd60e51b815260206004820152602660248201527f416464726573733a20696e73756666696369656e742062616c616e636520666f6044820152651c8818d85b1b60d21b60648201526084016107d4565b600080866001600160a01b03168587604051611ce29190612039565b60006040518083038185875af1925050503d8060008114611d1f576040519150601f19603f3d011682016040523d82523d6000602084013e611d24565b606091505b5091509150611d3587838387611d40565b979650505050505050565b60608315611daf578251600003611da8576001600160a01b0385163b611da85760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e747261637400000060448201526064016107d4565b5081611c5d565b611c5d8383815115611dc45781518083602001fd5b8060405162461bcd60e51b81526004016107d49190612055565b80356001600160a01b0381168114611df557600080fd5b919050565b600060208284031215611e0c57600080fd5b6117c482611dde565b600060208284031215611e2757600080fd5b5035919050565b60008060408385031215611e4157600080fd5b611e4a83611dde565b946020939093013593505050565b60008060408385031215611e6b57600080fd5b82359150602083013560ff81168114611e8357600080fd5b809150509250929050565b634e487b7160e01b600052601160045260246000fd5b8082028115828204841417611ebb57611ebb611e8e565b92915050565b81810381811115611ebb57611ebb611e8e565b600082611ef157634e487b7160e01b600052601260045260246000fd5b500490565b80820180821115611ebb57611ebb611e8e565b6001600160d81b03818116838216019080821115611f2957611f29611e8e565b5092915050565b600060208284031215611f4257600080fd5b5051919050565b6001600160f01b03818116838216019080821115611f2957611f29611e8e565b64ffffffffff818116838216028082169190828114611f8a57611f8a611e8e565b505092915050565b634e487b7160e01b600052603260045260246000fd5b600060018201611fba57611fba611e8e565b5060010190565b6001600160f01b03828116828216818102831692918115828504821417611fea57611fea611e8e565b50505092915050565b60006020828403121561200557600080fd5b815180151581146117c457600080fd5b60005b83811015612030578181015183820152602001612018565b50506000910152565b6000825161204b818460208701612015565b9190910192915050565b6020815260008251806020840152612074816040850160208701612015565b601f01601f1916919091016040019291505056fea2646970667358221220a5179b17a2339dc849fd2a3fe45683ff5f9445fb0e12d679c8bd39c17d761df164736f6c63430008120033",
  "devdoc": {
    "author": "Lila Rest (https://lila.rest)",
    "custom:security-contact": "security@ledgity.comsecurity@ledgity.com",
    "details": "Intuition  Lifecycle of a lockdrop pool is composed by 3 main phases: 1) Deposit: During this phase, users can lock their underlying tokens. 2) Claim: During this phase, users can claim their LDY rewards. 3) Recovery: During this phase, owner can recover remaining ERC20 on the contract.  Transitioning between two phases is manually triggered by contract's owner. To ensure fair usage of this power and prevent potential misuse: - the Recovery phase cannot start before 3 months after the end of rewards vesting, - the Recovery phase cannot start before 3 months after the maximum lock end.  Finally, note that this contract proxies main L-Token contract's functions: - lock() --> deposit() - instantUnlock() --> instantWithdrawal() - requestUnlock() --> requestWithdrawal() This design enables users to interact with the PreMining contract in a similar fashion to the L-Token contract. Definitions: - Locker: An account that has locked underlying tokens in the pool. ",
    "events": {
      "Paused(address)": {
        "details": "Emitted when the pause is triggered by `account`."
      },
      "Unpaused(address)": {
        "details": "Emitted when the pause is lifted by `account`."
      }
    },
    "kind": "dev",
    "methods": {
      "acceptOwnership()": {
        "details": "The new owner accepts the ownership transfer."
      },
      "availableToClaim(address)": {
        "details": "This function considers vesting and already claimed rewards.",
        "params": {
          "account": "The account to compute the available rewards of."
        },
        "returns": {
          "_0": "The amount of LDY rewards available to claim."
        }
      },
      "constructor": {
        "params": {
          "lTokenAddress_": "Address of the L-Token contract to use.",
          "lockedHardCap_": "Maximum total amount of L-Tokens that can be locked.",
          "maxDistributedLDY_": "Amount of LDY to be distributed to lockers.",
          "maxLockDuration_": "Maximum possible lock duration (in months).",
          "minLockDuration_": "Minimum possible lock duration (in months).",
          "vestingDuration_": "Duration of LDY rewards vesting (in months)."
        }
      },
      "eligibleRewardsOf(address)": {
        "details": "Note: This function neither considers vesting nor already claimed rewards.",
        "params": {
          "account": "The account to compute the eligible rewards of."
        },
        "returns": {
          "_0": "The total amount of LDY rewards that the account is eligible to."
        }
      },
      "instantUnlock()": {
        "details": "In order to save some gas and time to users, frontends should propose this function to users only when it has been verified that it will not revert. They should propose the requestUnlock() function otherwise."
      },
      "lock(uint256,uint8)": {
        "details": "This function proxies LToken.deposit()Lockers can extend their lock duration by calling this function again with a greater duration and 0 as amount.",
        "params": {
          "amount": "Amount of underlying tokens to lock.",
          "duration": "Duration of the lock (in months)."
        }
      },
      "owner()": {
        "details": "Returns the address of the current owner."
      },
      "paused()": {
        "details": "Returns true if the contract is paused, and false otherwise."
      },
      "pendingOwner()": {
        "details": "Returns the address of the pending owner."
      },
      "recoverERC20(address,uint256)": {
        "params": {
          "amount": "The amount of token to recover.",
          "tokenAddress": "The address of the token to recover."
        }
      },
      "renounceOwnership()": {
        "details": "Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner."
      },
      "requestUnlock()": {
        "details": "The sender must attach 0.003 ETH to pre-pay the future processing gas fees paid by the withdrawer wallet."
      },
      "setLDYToken(address)": {
        "details": "As the first Ledgity Yield lockdrop campaigns will start before the LDY TGE, this function allows the contract's owner to set the LDY token address once it becomes available.",
        "params": {
          "ldyTokenAddress": "Address of the LDY token contract."
        }
      },
      "transferOwnership(address)": {
        "details": "Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one. Can only be called by the current owner."
      }
    },
    "title": "PreMining",
    "version": 1
  },
  "userdoc": {
    "events": {
      "Lock(address,uint256,uint8)": {
        "notice": "Emitted to inform about a new lock/deposit."
      }
    },
    "kind": "user",
    "methods": {
      "accountsLocks(address)": {
        "notice": "Holds lockers' participations informations."
      },
      "availableToClaim(address)": {
        "notice": "Computes the amount of LDY rewards available to claim for a given account."
      },
      "claimPhaseStartTimestamp()": {
        "notice": "Holds the timestamp at which the Claim phase started."
      },
      "claimRewards()": {
        "notice": "Allows the caller to claim its available LDY rewards."
      },
      "constructor": {
        "notice": "This constructor function etches the lockdrop terms in immutable states. Ensuring that those terms cannot be modified after deployment."
      },
      "eligibleRewardsOf(address)": {
        "notice": "Compute the total amount of LDY rewards that a given account is eligible to."
      },
      "endDepositPhase()": {
        "notice": "Closes the Deposit phase. After calling this function, account won't be able to lock additional underlying tokens anymore."
      },
      "hasClaimPhaseStarted()": {
        "notice": "Holds whether the Claim phase has started."
      },
      "hasDepositPhaseEnded()": {
        "notice": "Holds whether the Deposit phase has ended."
      },
      "hasRecoveryPhaseStarted()": {
        "notice": "Holds whether the Recovery phase has started."
      },
      "instantUnlock()": {
        "notice": "Allows the caller to instaneously unlock its locked amount of underlying tokens."
      },
      "lToken()": {
        "notice": "Holds a reference to the locked L-Token contract."
      },
      "ldyToken()": {
        "notice": "Holds a reference to the LDY token contract."
      },
      "lock(uint256,uint8)": {
        "notice": "Allows locking a specified amount of underlying tokens for a given duration. By locking, an account became eligible to a portion of the distributed LDY rewards."
      },
      "lockedHardCap()": {
        "notice": "Holds the maximum total amount of L-Tokens that can be locked."
      },
      "maxDistributedLDY()": {
        "notice": "Holds the amount of LDY to be distributed to lockers."
      },
      "maxLockDuration()": {
        "notice": "Holds the maximum possible lock duration (in months)."
      },
      "maxWeight()": {
        "notice": "Holds the max pool weight."
      },
      "minLockDuration()": {
        "notice": "Holds the minimum possible lock duration (in months)."
      },
      "pause()": {
        "notice": "Public implementation of Pausable's pausing and unpausing functions, but restricted to contract's owner."
      },
      "processUnlockRequests()": {
        "notice": "Processes queued unlock requests until there is else no more requests, else not enough underlying tokens to continue."
      },
      "recoverERC20(address,uint256)": {
        "notice": "Recovers a specified amount of a given token address. Will revert if recovery phase has not started yet or if the contract doesn't hold enough tokens."
      },
      "requestUnlock()": {
        "notice": "Allows the call to request for the unlocking of its locked amount of underlying tokens. The request will be automatically processed later."
      },
      "setLDYToken(address)": {
        "notice": "Updates the LDY token contract address."
      },
      "startClaimPhase()": {
        "notice": "Opens the Claim phase. After calling this function, lockers will be able to start claiming their LDY rewards."
      },
      "startRecoveryPhase()": {
        "notice": "Opens the Recovery phase. After calling this function, the contract owner will be able to recover remaining ERC20 tokens on the contract. Note that this won't close the Claim phase and lockers will still be able to claim their LDY rewards."
      },
      "totalLocked()": {
        "notice": "Holds the total amount of locked underlying tokens."
      },
      "underlyingToken()": {
        "notice": "Holds a reference to the L-Token underlying stablecoin."
      },
      "unlockRequests(uint256)": {
        "notice": "Holds an ordered queue of accounts that requested to unlock their tokens."
      },
      "unlockRequestsCursor()": {
        "notice": "Holds the index of the first request in the queue (a.k.a, next one to be processed)."
      },
      "vestingDuration()": {
        "notice": "Holds the duration of LDY rewards vesting (in months)."
      }
    },
    "notice": "PreMining pool contract, allowing accounts to lock underlying tokens in a  pre-defined L-Token contract, over a given duration (in months), in exchange of  vested LDY rewards. ",
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 2904,
        "contract": "contracts/src/PreMining.sol:PreMining",
        "label": "_owner",
        "offset": 0,
        "slot": "0",
        "type": "t_address"
      },
      {
        "astId": 3017,
        "contract": "contracts/src/PreMining.sol:PreMining",
        "label": "_pendingOwner",
        "offset": 0,
        "slot": "1",
        "type": "t_address"
      },
      {
        "astId": 3110,
        "contract": "contracts/src/PreMining.sol:PreMining",
        "label": "_paused",
        "offset": 20,
        "slot": "1",
        "type": "t_bool"
      },
      {
        "astId": 6941,
        "contract": "contracts/src/PreMining.sol:PreMining",
        "label": "ldyToken",
        "offset": 0,
        "slot": "2",
        "type": "t_contract(IERC20)3865"
      },
      {
        "astId": 6947,
        "contract": "contracts/src/PreMining.sol:PreMining",
        "label": "accountsLocks",
        "offset": 0,
        "slot": "3",
        "type": "t_mapping(t_address,t_struct(AccountLock)6911_storage)"
      },
      {
        "astId": 6950,
        "contract": "contracts/src/PreMining.sol:PreMining",
        "label": "totalLocked",
        "offset": 0,
        "slot": "4",
        "type": "t_uint256"
      },
      {
        "astId": 6953,
        "contract": "contracts/src/PreMining.sol:PreMining",
        "label": "hasDepositPhaseEnded",
        "offset": 0,
        "slot": "5",
        "type": "t_bool"
      },
      {
        "astId": 6956,
        "contract": "contracts/src/PreMining.sol:PreMining",
        "label": "hasClaimPhaseStarted",
        "offset": 1,
        "slot": "5",
        "type": "t_bool"
      },
      {
        "astId": 6959,
        "contract": "contracts/src/PreMining.sol:PreMining",
        "label": "hasRecoveryPhaseStarted",
        "offset": 2,
        "slot": "5",
        "type": "t_bool"
      },
      {
        "astId": 6962,
        "contract": "contracts/src/PreMining.sol:PreMining",
        "label": "claimPhaseStartTimestamp",
        "offset": 0,
        "slot": "6",
        "type": "t_uint256"
      },
      {
        "astId": 6966,
        "contract": "contracts/src/PreMining.sol:PreMining",
        "label": "unlockRequests",
        "offset": 0,
        "slot": "7",
        "type": "t_array(t_address)dyn_storage"
      },
      {
        "astId": 6969,
        "contract": "contracts/src/PreMining.sol:PreMining",
        "label": "unlockRequestsCursor",
        "offset": 0,
        "slot": "8",
        "type": "t_uint256"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_array(t_address)dyn_storage": {
        "base": "t_address",
        "encoding": "dynamic_array",
        "label": "address[]",
        "numberOfBytes": "32"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_contract(IERC20)3865": {
        "encoding": "inplace",
        "label": "contract IERC20",
        "numberOfBytes": "20"
      },
      "t_mapping(t_address,t_struct(AccountLock)6911_storage)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => struct PreMining.AccountLock)",
        "numberOfBytes": "32",
        "value": "t_struct(AccountLock)6911_storage"
      },
      "t_struct(AccountLock)6911_storage": {
        "encoding": "inplace",
        "label": "struct PreMining.AccountLock",
        "members": [
          {
            "astId": 6902,
            "contract": "contracts/src/PreMining.sol:PreMining",
            "label": "amount",
            "offset": 0,
            "slot": "0",
            "type": "t_uint240"
          },
          {
            "astId": 6904,
            "contract": "contracts/src/PreMining.sol:PreMining",
            "label": "duration",
            "offset": 30,
            "slot": "0",
            "type": "t_uint8"
          },
          {
            "astId": 6906,
            "contract": "contracts/src/PreMining.sol:PreMining",
            "label": "hasUnlocked",
            "offset": 31,
            "slot": "0",
            "type": "t_bool"
          },
          {
            "astId": 6908,
            "contract": "contracts/src/PreMining.sol:PreMining",
            "label": "claimedRewards",
            "offset": 0,
            "slot": "1",
            "type": "t_uint216"
          },
          {
            "astId": 6910,
            "contract": "contracts/src/PreMining.sol:PreMining",
            "label": "lockEndTimestamp",
            "offset": 27,
            "slot": "1",
            "type": "t_uint40"
          }
        ],
        "numberOfBytes": "64"
      },
      "t_uint216": {
        "encoding": "inplace",
        "label": "uint216",
        "numberOfBytes": "27"
      },
      "t_uint240": {
        "encoding": "inplace",
        "label": "uint240",
        "numberOfBytes": "30"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      },
      "t_uint40": {
        "encoding": "inplace",
        "label": "uint40",
        "numberOfBytes": "5"
      },
      "t_uint8": {
        "encoding": "inplace",
        "label": "uint8",
        "numberOfBytes": "1"
      }
    }
  }
}