{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable2Step.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./OwnableUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership} and {acceptOwnership}.\n *\n * This module is used through inheritance. It will make available all functions\n * from parent (Ownable).\n */\nabstract contract Ownable2StepUpgradeable is Initializable, OwnableUpgradeable {\n    function __Ownable2Step_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable2Step_init_unchained() internal onlyInitializing {\n    }\n    address private _pendingOwner;\n\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Returns the address of the pending owner.\n     */\n    function pendingOwner() public view virtual returns (address) {\n        return _pendingOwner;\n    }\n\n    /**\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\n        _pendingOwner = newOwner;\n        emit OwnershipTransferStarted(owner(), newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual override {\n        delete _pendingOwner;\n        super._transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev The new owner accepts the ownership transfer.\n     */\n    function acceptOwnership() public virtual {\n        address sender = _msgSender();\n        require(pendingOwner() == sender, \"Ownable2Step: caller is not the new owner\");\n        _transferOwnership(sender);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/interfaces/draft-IERC1822Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822ProxiableUpgradeable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/interfaces/IERC1967Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC1967.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC-1967: Proxy Storage Slots. This interface contains the events defined in the ERC.\n *\n * _Available since v4.8.3._\n */\ninterface IERC1967Upgradeable {\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Emitted when the beacon is changed.\n     */\n    event BeaconUpgraded(address indexed beacon);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/beacon/IBeaconUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeaconUpgradeable {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/ERC1967/ERC1967UpgradeUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeaconUpgradeable.sol\";\nimport \"../../interfaces/IERC1967Upgradeable.sol\";\nimport \"../../interfaces/draft-IERC1822Upgradeable.sol\";\nimport \"../../utils/AddressUpgradeable.sol\";\nimport \"../../utils/StorageSlotUpgradeable.sol\";\nimport \"../utils/Initializable.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n */\nabstract contract ERC1967UpgradeUpgradeable is Initializable, IERC1967Upgradeable {\n    function __ERC1967Upgrade_init() internal onlyInitializing {\n    }\n\n    function __ERC1967Upgrade_init_unchained() internal onlyInitializing {\n    }\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(AddressUpgradeable.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822ProxiableUpgradeable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\n            } catch {\n                revert(\"ERC1967Upgrade: new implementation is not UUPS\");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(AddressUpgradeable.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/UUPSUpgradeable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../interfaces/draft-IERC1822Upgradeable.sol\";\nimport \"../ERC1967/ERC1967UpgradeUpgradeable.sol\";\nimport \"./Initializable.sol\";\n\n/**\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\n *\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\n * `UUPSUpgradeable` with a custom implementation of upgrades.\n *\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\n *\n * _Available since v4.1._\n */\nabstract contract UUPSUpgradeable is Initializable, IERC1822ProxiableUpgradeable, ERC1967UpgradeUpgradeable {\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\n    address private immutable __self = address(this);\n\n    /**\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\n     * fail.\n     */\n    modifier onlyProxy() {\n        require(address(this) != __self, \"Function must be called through delegatecall\");\n        require(_getImplementation() == __self, \"Function must be called through active proxy\");\n        _;\n    }\n\n    /**\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\n     * callable on the implementing contract but not through proxies.\n     */\n    modifier notDelegated() {\n        require(address(this) == __self, \"UUPSUpgradeable: must not be called through delegatecall\");\n        _;\n    }\n\n    /**\n     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\n     * implementation. It is used to validate the implementation's compatibility when performing an upgrade.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\n     */\n    function proxiableUUID() external view virtual override notDelegated returns (bytes32) {\n        return _IMPLEMENTATION_SLOT;\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     *\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\n     */\n    function upgradeTo(address newImplementation) public virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, new bytes(0), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\n     * encoded in `data`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     *\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\n     * {upgradeTo} and {upgradeToAndCall}.\n     *\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\n     *\n     * ```solidity\n     * function _authorizeUpgrade(address) internal override onlyOwner {}\n     * ```\n     */\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20Upgradeable.sol\";\nimport \"./extensions/IERC20MetadataUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[45] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/ERC20Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20Upgradeable.sol\";\nimport \"../../../security/PausableUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev ERC20 token with pausable token transfers, minting and burning.\n *\n * Useful for scenarios such as preventing trades until the end of an evaluation\n * period, or having an emergency switch for freezing all token transfers in the\n * event of a large bug.\n *\n * IMPORTANT: This contract does not include public pause and unpause functions. In\n * addition to inheriting this contract, you must define both functions, invoking the\n * {Pausable-_pause} and {Pausable-_unpause} internal functions, with appropriate\n * access control, e.g. using {AccessControl} or {Ownable}. Not doing so will\n * make the contract unpausable.\n */\nabstract contract ERC20PausableUpgradeable is Initializable, ERC20Upgradeable, PausableUpgradeable {\n    function __ERC20Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __ERC20Pausable_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {ERC20-_beforeTokenTransfer}.\n     *\n     * Requirements:\n     *\n     * - the contract must not be paused.\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override {\n        super._beforeTokenTransfer(from, to, amount);\n\n        require(!paused(), \"ERC20Pausable: token transfer while paused\");\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20WrapperUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/ERC20Wrapper.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20Upgradeable.sol\";\nimport \"../utils/SafeERC20Upgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of the ERC20 token contract to support token wrapping.\n *\n * Users can deposit and withdraw \"underlying tokens\" and receive a matching number of \"wrapped tokens\". This is useful\n * in conjunction with other modules. For example, combining this wrapping mechanism with {ERC20Votes} will allow the\n * wrapping of an existing \"basic\" ERC20 into a governance token.\n *\n * _Available since v4.2._\n *\n * @custom:storage-size 51\n */\nabstract contract ERC20WrapperUpgradeable is Initializable, ERC20Upgradeable {\n    IERC20Upgradeable private _underlying;\n\n    function __ERC20Wrapper_init(IERC20Upgradeable underlyingToken) internal onlyInitializing {\n        __ERC20Wrapper_init_unchained(underlyingToken);\n    }\n\n    function __ERC20Wrapper_init_unchained(IERC20Upgradeable underlyingToken) internal onlyInitializing {\n        require(underlyingToken != this, \"ERC20Wrapper: cannot self wrap\");\n        _underlying = underlyingToken;\n    }\n\n    /**\n     * @dev See {ERC20-decimals}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        try IERC20MetadataUpgradeable(address(_underlying)).decimals() returns (uint8 value) {\n            return value;\n        } catch {\n            return super.decimals();\n        }\n    }\n\n    /**\n     * @dev Returns the address of the underlying ERC-20 token that is being wrapped.\n     */\n    function underlying() public view returns (IERC20Upgradeable) {\n        return _underlying;\n    }\n\n    /**\n     * @dev Allow a user to deposit underlying tokens and mint the corresponding number of wrapped tokens.\n     */\n    function depositFor(address account, uint256 amount) public virtual returns (bool) {\n        address sender = _msgSender();\n        require(sender != address(this), \"ERC20Wrapper: wrapper can't deposit\");\n        SafeERC20Upgradeable.safeTransferFrom(_underlying, sender, address(this), amount);\n        _mint(account, amount);\n        return true;\n    }\n\n    /**\n     * @dev Allow a user to burn a number of wrapped tokens and withdraw the corresponding number of underlying tokens.\n     */\n    function withdrawTo(address account, uint256 amount) public virtual returns (bool) {\n        _burn(_msgSender(), amount);\n        SafeERC20Upgradeable.safeTransfer(_underlying, account, amount);\n        return true;\n    }\n\n    /**\n     * @dev Mint wrapped token to cover any underlyingTokens that would have been transferred by mistake. Internal\n     * function that can be exposed with access control if desired.\n     */\n    function _recover(address account) internal virtual returns (uint256) {\n        uint256 value = _underlying.balanceOf(address(this)) - totalSupply();\n        _mint(account, value);\n        return value;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20PermitUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20PermitUpgradeable {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\nimport \"../extensions/IERC20PermitUpgradeable.sol\";\nimport \"../../../utils/AddressUpgradeable.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20Upgradeable {\n    using AddressUpgradeable for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20Upgradeable token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20Upgradeable token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20PermitUpgradeable token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20Upgradeable token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && AddressUpgradeable.isContract(address(token));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StorageSlotUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, `uint256`._\n * _Available since v4.9 for `string`, `bytes`._\n */\nlibrary StorageSlotUpgradeable {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/extensions/ERC20Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\nimport \"../../../utils/Context.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20Burnable is Context, ERC20 {\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n    function burnFrom(address account, uint256 amount) public virtual {\n        _spendAllowance(account, _msgSender(), amount);\n        _burn(account, amount);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/src/abstracts/base/BaseUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport {GlobalPausableUpgradeable} from \"../GlobalPausableUpgradeable.sol\";\nimport {GlobalOwnableUpgradeable} from \"../GlobalOwnableUpgradeable.sol\";\nimport {GlobalRestrictableUpgradeable} from \"../GlobalRestrictableUpgradeable.sol\";\nimport {RecoverableUpgradeable} from \"../RecoverableUpgradeable.sol\";\n\n/**\n * @title BaseUpgradeable\n * @author Lila Rest (https://lila.rest)\n * @custom:security-contact security@ledgity.com\n *\n * @notice This abstract contract acts as a base for numerous contracts contract in this\n * codebase, minimizing code repetition and enhancing readability and maintainability.\n *\n * @dev For further details, see \"Base\" section of whitepaper.\n * @custom:security-contact security@ledgity.com\n */\nabstract contract BaseUpgradeable is\n    Initializable,\n    UUPSUpgradeable,\n    GlobalOwnableUpgradeable,\n    GlobalPausableUpgradeable,\n    GlobalRestrictableUpgradeable,\n    RecoverableUpgradeable\n{\n    /**\n     * @notice Prevents implementation contract from being initialized as recommended by\n     * OpenZeppelin.\n     * @dev See: https://docs.openzeppelin.com/contracts/4.x/api/proxy#Initializable-_disableInitializers--\n     * @custom:oz-upgrades-unsafe-allow constructor\n     */\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @notice Initializer functions of the contract. They replace the constructor()\n     * function in the context of upgradeable contracts.\n     * @dev See: https://docs.openzeppelin.com/contracts/4.x/upgradeable\n     * @param globalOwner_ The address of the GlobalOwner contract.\n     * @param globalPause_ The address of the GlobalPause contract.\n     * @param globalBlacklist_ The address of the GlobalBlacklist contract.\n     */\n    function __Base_init(\n        address globalOwner_,\n        address globalPause_,\n        address globalBlacklist_\n    ) internal onlyInitializing {\n        __UUPSUpgradeable_init();\n        __GlobalOwnable_init(globalOwner_);\n        __Pausable_init();\n        __GlobalPausable_init_unchained(globalPause_);\n        __GlobalRestrictable_init_unchained(globalBlacklist_);\n        __Recoverable_init_unchained();\n    }\n\n    function __Base_init_unchained() internal onlyInitializing {}\n\n    /**\n     * @notice Override of UUPSUpgradeable._authorizeUpgrade() function restricted to\n     * global owner. It is called by the proxy contract during an upgrade.\n     * @param newImplementation The address of the new implementation contract.\n     */\n    function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add\n     * new variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/src/abstracts/base/ERC20BaseUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport {ERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport {ERC20PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20PausableUpgradeable.sol\";\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport \"./BaseUpgradeable.sol\";\nimport {GlobalPausableUpgradeable} from \"../GlobalPausableUpgradeable.sol\";\n\n/**\n * @title ERC20BaseUpgradeable\n * @author Lila Rest (https://lila.rest)\n * @custom:security-contact security@ledgity.com\n *\n * @notice This abstract contracts is an extension of BaseUpgradeable intended to be used\n * as a base for ERC20 tokens contracts.\n *\n * @dev For further details, see \"ERC20BaseUpgradeable\" section of whitepaper.\n * @custom:security-contact security@ledgity.com\n */\nabstract contract ERC20BaseUpgradeable is\n    ERC20Upgradeable,\n    BaseUpgradeable,\n    ERC20PausableUpgradeable\n{\n    /**\n     * @notice Initializer functions of the contract. They replace the constructor()\n     * function in the context of upgradeable contracts.\n     * @dev See: https://docs.openzeppelin.com/contracts/4.x/upgradeable\n     * @param globalOwner_ The address of the GlobalOwner contract.\n     * @param globalPause_ The address of the GlobalPause contract.\n     * @param globalBlacklist_ The address of the GlobalBlacklist contract.\n     * @param name_ The display name of the token.\n     * @param symbol_ The symbol of the token.\n     */\n    function __ERC20Base_init(\n        address globalOwner_,\n        address globalPause_,\n        address globalBlacklist_,\n        string memory name_,\n        string memory symbol_\n    ) internal onlyInitializing {\n        __Base_init(globalOwner_, globalPause_, globalBlacklist_);\n        __ERC20_init(name_, symbol_);\n        __ERC20Pausable_init_unchained();\n    }\n\n    function __ERC20Base_init_unchained() internal onlyInitializing {}\n\n    /**\n     * @notice Required override of paused() which is implemented by both\n     * GlobalPausableUpgradeable and PausableUpgradeable parent contracts.\n     * The GlobalPausableUpgradeable version is preferred because it checks the pause\n     * state from the GlobalPause contract.\n     * @inheritdoc GlobalPausableUpgradeable\n     */\n    function paused()\n        public\n        view\n        virtual\n        override(GlobalPausableUpgradeable, PausableUpgradeable)\n        returns (bool)\n    {\n        return GlobalPausableUpgradeable.paused();\n    }\n\n    /**\n     * @dev Required override of _beforeTokenTransfer() which is implemented by both\n     * ERC20PausableUpgradeable and ERC20Upgradeable parent contracts.\n     * The ERC20PausableUpgradeable version is preferred because it also checks that\n     * the contract is not paused before allowing the transfer.\n     * @inheritdoc ERC20PausableUpgradeable\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    )\n        internal\n        virtual\n        override(ERC20PausableUpgradeable, ERC20Upgradeable)\n        whenNotPaused\n        notBlacklisted(from)\n        notBlacklisted(to)\n    {\n        ERC20PausableUpgradeable._beforeTokenTransfer(from, to, amount);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add\n     * new variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/src/abstracts/GlobalOwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {GlobalOwner} from \"../GlobalOwner.sol\";\n\n/**\n * @title GlobalOwnableUpgradeable\n * @author Lila Rest (https://lila.rest)\n * @custom:security-contact security@ledgity.com\n *\n * @notice Derived contracts will inherit ownership from the specified GlobalOwner\n * contract (see GlobalOwner.sol). This design facilitates centralized management\n * of ownership for all the Ledgity Yield contracts.\n *\n * @dev Note: The _globalOwner state must be set at initialization-time and for evident\n * security reasons cannot be changed afterwards.\n *\n * @dev For further details, see \"GlobalOwnableUpgradeable\" section of whitepaper.\n * @custom:security-contact security@ledgity.com\n */\nabstract contract GlobalOwnableUpgradeable is Initializable, OwnableUpgradeable {\n    /**\n     * @notice The GlobalOwner contract the ownership will be inherited from.\n     * @dev This state is private so derived contracts cannot change its value.\n     */\n    GlobalOwner private _globalOwner;\n\n    /**\n     * @notice Initializer functions of the contract. They replace the constructor()\n     * function in the context of upgradeable contracts.\n     * @dev See: https://docs.openzeppelin.com/contracts/4.x/upgradeable\n     * @param globalOwner_ The address of the GlobalOwner contract.\n     */\n    function __GlobalOwnable_init(address globalOwner_) internal onlyInitializing {\n        __GlobalOwnable_init_unchained(globalOwner_);\n        // Note: __Ownable_init() doesn't have to be called as the overriden owner()\n        // function no longer rely on the _owner state. Since __Ownable_init() only sets\n        // the initial _owner value, calling it would have no effect.\n    }\n\n    function __GlobalOwnable_init_unchained(address globalOwner_) internal onlyInitializing {\n        _globalOwner = GlobalOwner(globalOwner_);\n    }\n\n    /**\n     * @notice Retrieves the address of GlobalOwner contract.\n     * @return The address of the GlobalOwner contract.\n     */\n    function globalOwner() public view returns (address) {\n        return address(_globalOwner);\n    }\n\n    /**\n     * @notice Override of OwnableUpgradeable.owner() that retrieves the owner's address\n     * from the GlobalOwner contract instead.\n     * @return The address of the owner\n     */\n    function owner() public view override returns (address) {\n        return _globalOwner.owner();\n    }\n\n    /**\n     * @notice Override of OwnableUpgradeable.transferOwnership() that always reverts.\n     * Ownership is managed by the GlobalOwner contract and must be modified there.\n     */\n    function transferOwnership(address newOwner) public view override onlyOwner {\n        newOwner; // Silence unused variable compiler warning\n        revert(\"L8\");\n    }\n\n    /**\n     * @notice Override of OwnableUpgradeable.renounceOwnership() that always reverts.\n     * Ownership is managed by the GlobalOwner contract and must be modified there.\n     */\n    function renounceOwnership() public view override onlyOwner {\n        revert(\"L65\");\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add\n     * new variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/src/abstracts/GlobalPausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport {GlobalPause} from \"../GlobalPause.sol\";\n\n/**\n * @title GlobalPausableUpgradeable\n * @author Lila Rest (https://lila.rest)\n * @custom:security-contact security@ledgity.com\n *\n * @notice Derived contracts will inherit pause state from the specified GlobalPause\n * contract (see GlobalPause.sol). This design facilitates centralized management of\n * pause state for all the Ledgity Yield contracts.\n *\n * @dev Note: The _globalPause state must be set at initialization-time and for evident\n * security reasons cannot be changed afterwards.\n *\n * @dev For further details, see \"GlobalPausableUpgradeable\" section of whitepaper.\n * @custom:security-contact security@ledgity.com\n */\nabstract contract GlobalPausableUpgradeable is Initializable, PausableUpgradeable {\n    /**\n     * @notice The GlobalPause contract the pause state will be inherited from.\n     * @dev This state is private so derived contracts cannot change its value.\n     */\n    GlobalPause private _globalPause;\n\n    /**\n     * @notice Initializer functions of the contract. They replace the constructor()\n     * function in the context of upgradeable contracts.\n     * @dev See: https://docs.openzeppelin.com/contracts/4.x/upgradeable\n     * @param globalPause_ The address of the GlobalPause contract.\n     */\n    function __GlobalPausable_init(address globalPause_) internal onlyInitializing {\n        __Pausable_init();\n        __GlobalPausable_init_unchained(globalPause_);\n    }\n\n    function __GlobalPausable_init_unchained(address globalPause_) internal onlyInitializing {\n        _globalPause = GlobalPause(globalPause_);\n    }\n\n    /**\n     * @notice Retrieves the address of GlobalPause contract.\n     * @return The address of the GlobalPause contract.\n     */\n    function globalPause() public view returns (address) {\n        return address(_globalPause);\n    }\n\n    /**\n     * @notice Override of PausableUpgradeable.pause() that retrieves the pause state\n     * from the GlobalPause contract instead.\n     * @return Whether the contract is paused or not.\n     */\n    function paused() public view virtual override returns (bool) {\n        return _globalPause.paused();\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add\n     * new variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/src/abstracts/GlobalRestrictableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {GlobalBlacklist} from \"../GlobalBlacklist.sol\";\n\n/**\n * @title GlobalRestrictableUpgradeable\n * @author Lila Rest (https://lila.rest)\n * @custom:security-contact security@ledgity.com\n *\n * @notice Derived contracts will inherit blacklist state from the specified\n * GlobalBlacklist contract (see GlobalBlacklist.sol). This design facilitates\n * centralized management of a blacklist for all the Ledgity Yield contracts.\n *\n * @dev Note: The _globalBlacklist state must be set at initialization-time and for\n * evident security reasons cannot be changed afterwards.\n *\n * @dev For further details, see \"GlobalRestrictableUpgradeable\" section of whitepaper.\n * @custom:security-contact security@ledgity.com\n */\nabstract contract GlobalRestrictableUpgradeable is Initializable {\n    /**\n     * @notice The GlobalBlacklist contract the blacklist state will be inherited from.\n     * @dev This state is private so derived contracts cannot change its value.\n     */\n    GlobalBlacklist private _globalBlacklist;\n\n    /**\n     * @notice Initializer functions of the contract. They replace the constructor()\n     * function in the context of upgradeable contracts.\n     * @dev See: https://docs.openzeppelin.com/contracts/4.x/upgradeable\n     * @param globalBlacklist_ The address of the GlobalBlacklist contract.\n     */\n    function __GlobalRestrictable_init(address globalBlacklist_) internal onlyInitializing {\n        __GlobalRestrictable_init_unchained(globalBlacklist_);\n    }\n\n    function __GlobalRestrictable_init_unchained(\n        address globalBlacklist_\n    ) internal onlyInitializing {\n        _globalBlacklist = GlobalBlacklist(globalBlacklist_);\n    }\n\n    /**\n     * @notice Retrieves the address of GlobalBlacklist contract.\n     * @return The address of the GlobalBlacklist contract.\n     */\n    function globalBlacklist() public view returns (address) {\n        return address(_globalBlacklist);\n    }\n\n    /**\n     * @notice Reverts if the given account is blacklisted by the GlobalBlacklist contract.\n     * @param account Address to verify.\n     */\n    modifier notBlacklisted(address account) {\n        require(isBlacklisted(account) == false, \"L9\");\n        _;\n    }\n\n    /**\n     * @notice Checks if the given account is blacklisted by the GlobalBlacklist contract.\n     * @param account Address to verify.\n     * @return Whether the account is blacklisted.\n     */\n    function isBlacklisted(address account) internal view returns (bool) {\n        return _globalBlacklist.isBlacklisted(account);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add\n     * new variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/src/abstracts/InvestUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\n// Contracts\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {GlobalOwnableUpgradeable} from \"./GlobalOwnableUpgradeable.sol\";\nimport {GlobalPausableUpgradeable} from \"./GlobalPausableUpgradeable.sol\";\nimport {GlobalRestrictableUpgradeable} from \"./GlobalRestrictableUpgradeable.sol\";\nimport \"./base/BaseUpgradeable.sol\";\nimport {RecoverableUpgradeable} from \"../abstracts/RecoverableUpgradeable.sol\";\n\n// Libraries\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {APRHistory as APRH} from \"../libs/APRHistory.sol\";\nimport {SUD} from \"../libs/SUD.sol\";\n\n// Interfaces\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {IERC20MetadataUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\n\n/**\n * @title InvestUpgradeable\n * @author Lila Rest (https://lila.rest)\n * @custom:security-contact security@ledgity.com\n *\n * @notice Derived contracts are provided with a bunch of utilities to manage an invested\n * token, users' investment periods, rewards calculation, virtual balances, and\n * auto-compounding.\n *\n * @dev Intuition:\n *\n * @dev Definitions:\n *\n * @dev Derived contract must:\n *  - Set invested token during initialization\n *  - Implement _investmentOf() function\n *  - Implement _distributeRewards() function (optional)\n *\n * @dev For further details, see \"InvestmentUpgradeable\" section of whitepaper.\n * @custom:security-contact security@ledgity.com\n */\nabstract contract InvestUpgradeable is BaseUpgradeable {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using APRH for APRH.Pack[];\n\n    /**\n     * @notice Represents an account's investment period.\n     * @param timestamp The timestamp of the most recent rewards distribution.\n     * @param ref The reference of the last APR checkpoint at that timestamp.\n     */\n    struct InvestmentPeriod {\n        uint40 timestamp; // Supports dates up to 20/02/36812\n        APRH.Reference ref;\n    }\n\n    /**\n     * @notice Represents the investment details of an account.\n     * @param period The current investment period of the account.\n     * @param virtualBalance May hold a part of account rewards until they are claimed.\n     */\n    struct AccountDetails {\n        InvestmentPeriod period;\n        uint256 virtualBalance;\n    }\n\n    /// @notice Holds a reference to the invested token's contract.\n    IERC20Upgradeable private _invested;\n\n    /// @notice Holds investment details of each account.\n    mapping(address => AccountDetails) internal accountsDetails;\n\n    /// @notice Holds an history of the APR value over time (see APRHistory.sol).\n    APRH.Pack[] private _aprHistory;\n\n    /// @notice Holds active rewards redirections in both from->to and to->from[] ways.\n    mapping(address => address) public rewardsRedirectsFromTo;\n    mapping(address => address[]) public rewardsRedirectsToFrom;\n\n    /// @notice Is used to prevent infinite loop in _beforeInvestmentChange().\n    bool private _isClaiming;\n\n    /**\n     * @notice Emitted to inform listeners about a change in the APR's value.\n     * @param newAPRUD7x3 The new APR in UD7x3 format.\n     */\n    event APRChangeEvent(uint16 newAPRUD7x3);\n\n    /**\n     * @notice Initializer functions of the contract. They replace the constructor()\n     * function in the context of upgradeable contracts.\n     * @dev See: https://docs.openzeppelin.com/contracts/4.x/upgradeable\n     * @param globalOwner_ The address of the GlobalOwner contract.\n     * @param globalPause_ The address of the GlobalPause contract.\n     * @param globalBlacklist_ The address of the GlobalBlacklist contract.\n     * @param invested_ The address of the invested token contract.\n     */\n    function __Invest_init(\n        address globalOwner_,\n        address globalPause_,\n        address globalBlacklist_,\n        address invested_\n    ) internal onlyInitializing {\n        __Base_init(globalOwner_, globalPause_, globalBlacklist_);\n        __Invest_init_unchained(invested_);\n    }\n\n    function __Invest_init_unchained(address invested_) internal onlyInitializing {\n        _invested = IERC20Upgradeable(invested_);\n    }\n\n    /**\n     * @notice Retrieves the reference to the invested token contract.\n     * @return The reference to the invested token contract.\n     */\n    function invested() public view returns (IERC20Upgradeable) {\n        return _invested;\n    }\n\n    /**\n     * @notice Updates the investment APR. Restricted to owner.\n     * @param aprUD7x3 The new APR in UD7x3 format.\n     */\n    function setAPR(uint16 aprUD7x3) public onlyOwner {\n        _aprHistory.setAPR(aprUD7x3);\n        emit APRChangeEvent(aprUD7x3);\n    }\n\n    /**\n     * @notice Retrieves the most recently set APR.\n     * @return The current APR in UD7x3 format.\n     */\n    function getAPR() public view returns (uint16) {\n        return _aprHistory.getAPR();\n    }\n\n    /**\n     * @notice Enables redirection of rewards from one account to another.\n     * @param from The address of the account to redirect rewards from.\n     * @param to The address of the account to redirect rewards to.\n     */\n    function startRewardsRedirection(\n        address from,\n        address to\n    ) public whenNotPaused notBlacklisted(from) notBlacklisted(to) {\n        // Ensure the address is not already redirecting rewards\n        require(rewardsRedirectsFromTo[from] == address(0), \"L62\");\n\n        // Ensure neither 'from' nor 'to' are the zero address\n        require(from != address(0), \"L12\");\n        require(to != address(0), \"L13\");\n\n        // Ensure 'from' and 'to' addresses are distinct\n        require(from != to, \"L14\");\n\n        // Ensure function caller is either the owner or the 'from' address\n        require(_msgSender() == owner() || _msgSender() == from, \"L15\");\n\n        // Distribute current rewards and reset investment periods of both accounts\n        _beforeInvestmentChange(from, true);\n        _beforeInvestmentChange(to, true);\n\n        // Activate rewards redirection\n        rewardsRedirectsFromTo[from] = to;\n        rewardsRedirectsToFrom[to].push(from);\n    }\n\n    /**\n     * @notice Disable an active rewards redirection.\n     * @param from The address of the account to stop redirecting rewards from.\n     * @param to The address of the account to stop redirecting rewards to.\n     */\n    function stopRewardsRedirection(\n        address from,\n        address to\n    ) public whenNotPaused notBlacklisted(from) notBlacklisted(to) {\n        // Ensure neither 'from' nor 'to' are the zero address\n        require(from != address(0), \"L16\");\n        require(to != address(0), \"L17\");\n\n        // Ensure function caller is either the owner or the 'from' address\n        require(_msgSender() == owner() || _msgSender() == from, \"L18\");\n\n        // Ensure a rewards redirection was active\n        require(rewardsRedirectsFromTo[from] == to, \"L19\");\n\n        // Distribute current rewards and reset investment periods of both accounts\n        _beforeInvestmentChange(from, true);\n        _beforeInvestmentChange(to, true);\n\n        // Retrieve 'from' index in the redirection array of 'to'\n        int256 fromIndex = -1;\n        for (uint256 i = 0; i < rewardsRedirectsToFrom[to].length; i++) {\n            if (rewardsRedirectsToFrom[to][i] == from) {\n                fromIndex = int256(i);\n                break;\n            }\n        }\n\n        // fromIndex should never be -1 at this point\n        assert(fromIndex >= 0);\n\n        // Deactivate rewards redirection\n        rewardsRedirectsFromTo[from] = address(0);\n        rewardsRedirectsToFrom[to][uint256(fromIndex)] = rewardsRedirectsToFrom[to][\n            rewardsRedirectsToFrom[to].length - 1\n        ];\n        rewardsRedirectsToFrom[to].pop();\n    }\n\n    /**\n     * @notice Retrieves the total amount of tokens invested by the given account.\n     * @dev Derived contracts must implement this function.\n     * @param account The account to get the investment of.\n     * @return The total amount of tokens invested by the given account.\n     */\n    function _investmentOf(address account) internal view virtual returns (uint256);\n\n    /**\n     * @notice Distributes a specified amount of rewards to a given account.\n     * @dev Derived contracts may optionally implement this function.\n     * @dev Implementations must return true to indicate a successful distribution, and\n     * false otherwise. If it returns false, the rewards will be added to the account's\n     * virtual balance, in order to be claimed later.\n     * @param account The account to claim the rewards of.\n     * @param amount The amount of rewards to claim.\n     * @return Whether the rewards distribution was successfull.\n     */\n    function _distributeRewards(address account, uint256 amount) internal virtual returns (bool) {\n        account; // Silence unused variables warning\n        amount;\n        return false;\n    }\n\n    /**\n     * @notice Computes the rewards accrued over a specified period of time, based on a\n     * given APR and amount of invested tokens.\n     * @dev For further details, see \"InvestUpgradeable > Rewards calculation\" section of\n     * the whitepaper.\n     * @param beginTimestamp The moment the period commenced.\n     * @param endTimestamp The moment the period concluded.\n     * @param aprUD7x3 The APR during this period, in UD7x3 format.\n     * @param investedAmount The amount of tokens deposited/invested during the period.\n     * @return The amount of rewards generated during the period.\n     */\n    function _calculatePeriodRewards(\n        uint40 beginTimestamp,\n        uint40 endTimestamp,\n        uint16 aprUD7x3,\n        uint256 investedAmount\n    ) internal view returns (uint256) {\n        // Cache invested token's decimals number\n        uint256 d = SUD.decimalsOf(address(invested()));\n\n        // Compute the number of elapsed years\n        uint256 elapsedTimeSUD = SUD.fromInt(endTimestamp - beginTimestamp, d);\n        uint256 elapsedYearsSUD = (elapsedTimeSUD * SUD.fromInt(1, d)) / SUD.fromInt(365 days, d);\n\n        // Compute the growth in invested amount (thanks to rewards)\n        uint256 aprSUD = SUD.fromRate(aprUD7x3, d);\n        uint256 growthSUD = (elapsedYearsSUD * aprSUD) / SUD.fromInt(1, d);\n\n        // Compute and return the rewards\n        uint256 investedAmountSUD = SUD.fromAmount(investedAmount, d);\n        uint256 rewardsSUD = (investedAmountSUD * growthSUD) / SUD.fromInt(100, d);\n        return SUD.toAmount(rewardsSUD, d);\n    }\n\n    /**\n     * @notice Computes the sum of given account's invested amount, plus invested amount\n     * of all accounts that recursively redirect rewards to this account.\n     * @param account The account to calculate the deep investment of.\n     * @return deepInvestedAmount The deep invested amount.\n     */\n    function _deepInvestmentOf(address account) internal view returns (uint256 deepInvestedAmount) {\n        // Consider account's direct investment\n        deepInvestedAmount += _investmentOf(account);\n\n        // But also the deep investments of all accounts redirecting rewards to this account\n        for (uint256 i = 0; i < rewardsRedirectsToFrom[account].length; i++) {\n            deepInvestedAmount += _deepInvestmentOf(rewardsRedirectsToFrom[account][i]);\n        }\n    }\n\n    /**\n     * @notice Computes the amount of unclaimed/undistributed rewards of a given account.\n     * @dev For further details, see \"InvestUpgradeable > Rewards calculation\" section of\n     * the whitepaper.\n     * @param account The account to calculate the unclaimed rewards of.\n     * @param autocompound Whether to autocompound the rewards between APR checkpoints.\n     * @return rewards The amount of unclaimed/undistributed rewards of the given account.\n     */\n    function _rewardsOf(\n        address account,\n        bool autocompound\n    ) internal view returns (uint256 rewards) {\n        // Retrieve account's investment details\n        AccountDetails memory details = accountsDetails[account];\n\n        // Retrieve account's deep invested amount\n        uint256 investedAmount = _deepInvestmentOf(account);\n\n        // Return 0 if the account has never invested or has no invested amount\n        if (details.period.timestamp == 0 || investedAmount == 0) return 0;\n\n        // Retrieve reference and data of APR checkpoint at which started investment period\n        APRH.Reference memory currRef = details.period.ref;\n        APRH.CheckpointData memory currCheckpoint = _aprHistory.getDataFromReference(currRef);\n\n        // Retrieve reference of latest APR checkpoint\n        APRH.Reference memory latestRef = _aprHistory.getLatestReference();\n\n        // 1) Fill rewards with virtual balance (rewards not claimed/distributed yet)\n        // See \"InvestUpgradeable > Rewards calculation > 1)\" section of the whitepaper\n        rewards = details.virtualBalance;\n\n        // If start checkpoint is not the latest one\n        if (!APRH.eq(currRef, latestRef)) {\n            // Retrieve reference and data of APR checkpoint that comes after start checkpoint\n            APRH.Reference memory nextRef = APRH.incrementReference(currRef);\n            APRH.CheckpointData memory nextCheckpoint = _aprHistory.getDataFromReference(nextRef);\n\n            // 2) Calculate rewards from investment period start to next checkpoint\n            // See \"InvestUpgradeable > Rewards calculation > 2)\" section of the whitepaper\n            rewards += _calculatePeriodRewards(\n                details.period.timestamp,\n                nextCheckpoint.timestamp,\n                currCheckpoint.aprUD7x3,\n                investedAmount + (autocompound ? rewards : 0)\n            );\n\n            // 3) Calculate rewards for each crossed pair of checkpoints\n            // See \"InvestUpgradeable > Rewards calculation > 3)\" section of the whitepaper\n            while (true) {\n                // Set next checkpoint as the current one\n                currRef = nextRef;\n                currCheckpoint = nextCheckpoint;\n\n                // Break if current checkpoint is the latest one\n                if (APRH.eq(currRef, latestRef)) break;\n\n                // Else, retrieve the new next checkpoint\n                nextRef = APRH.incrementReference(currRef);\n                nextCheckpoint = _aprHistory.getDataFromReference(nextRef);\n\n                // Calculate rewards between the current pair of checkpoints\n                rewards += _calculatePeriodRewards(\n                    currCheckpoint.timestamp,\n                    nextCheckpoint.timestamp,\n                    currCheckpoint.aprUD7x3,\n                    investedAmount + (autocompound ? rewards : 0)\n                );\n            }\n\n            // 4) Calculate rewards from the latest checkpoint to now\n            // See \"InvestUpgradeable > Rewards calculation > 4)\" section of the whitepaper\n            rewards += _calculatePeriodRewards(\n                currCheckpoint.timestamp,\n                uint40(block.timestamp),\n                currCheckpoint.aprUD7x3,\n                investedAmount + (autocompound ? rewards : 0)\n            );\n        } else {\n            // 2.bis) Calculate rewards from investment period start to now\n            // See \"InvestUpgradeable > Rewards calculation > 2.bis)\" section of the whitepaper\n            rewards += _calculatePeriodRewards(\n                details.period.timestamp,\n                uint40(block.timestamp),\n                currCheckpoint.aprUD7x3,\n                investedAmount + (autocompound ? rewards : 0)\n            );\n        }\n    }\n\n    /**\n     * @notice Recursively resets the investment period of the specified account and of\n     * all accounts that directly or indirectly redirect rewards to this account.\n     * @param account The account to deeply reset the investment period of.\n     */\n    function _deepResetInvestmentPeriodOf(address account) internal {\n        // Reset account investment period timestamp and APR checkpoint to latest ones\n        accountsDetails[account].period.timestamp = uint40(block.timestamp);\n        accountsDetails[account].period.ref = _aprHistory.getLatestReference();\n\n        // Also reset the ones of all accounts that recursively redirect rewards to this account\n        for (uint256 i = 0; i < rewardsRedirectsToFrom[account].length; i++) {\n            _deepResetInvestmentPeriodOf(rewardsRedirectsToFrom[account][i]);\n        }\n    }\n\n    /**\n     * @notice Hook to be invoked before the invested amount of an account changes. It\n     * ensures that rewards are distributed and that account's investment period is reset.\n     * @param account The account whose invested amount is going to change.\n     * @param autocompound Whether to autocompound the rewards between APR checkpoints.\n     */\n    function _beforeInvestmentChange(address account, bool autocompound) internal {\n        // This hook is called inside LToken._beforeTokenTransfer() and as new tokens are\n        // minted in LToken._distributeRewards(), this guards against infinite loop.\n        if (_isClaiming) return;\n\n        // LToken._beforeTokenTransfer() calls this hook for both involved addresses.\n        // As first call will treat both addresses, the second call would be redundant.\n        // Therefore, we skip accounts already processed in this block to save up some gas.\n        if (accountsDetails[account].period.timestamp == uint40(block.timestamp)) return;\n\n        // If account redirects its rewards\n        address redirectRewardsTo = rewardsRedirectsFromTo[account];\n        if (redirectRewardsTo != address(0)) {\n            // Call hook on redirection target (this will indirectly reset the investment\n            // of this source account) and return\n            _beforeInvestmentChange(redirectRewardsTo, autocompound);\n            return;\n        }\n\n        // Else, compute account's undistributed/unclaimed rewards\n        uint256 rewards = _rewardsOf(account, autocompound);\n\n        // If there are some rewards\n        if (rewards > 0) {\n            // Try to distribute rewards to account\n            _isClaiming = true;\n            bool distributed = _distributeRewards(account, rewards);\n            _isClaiming = false;\n\n            // If rewards have not been distributed, accumulate them in account's virtual balance\n            if (!distributed) accountsDetails[account].virtualBalance = rewards;\n        }\n\n        // Finally, deeply reset investment period of the account\n        _deepResetInvestmentPeriodOf(account);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add\n     * new variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/src/abstracts/RecoverableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\n// Conracts\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {GlobalOwnableUpgradeable} from \"./GlobalOwnableUpgradeable.sol\";\n\n// Libraries\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\n// Interfaces\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\n/**\n * @title RecoverableUpgradeable\n * @author Lila Rest (https://lila.rest)\n * @custom:security-contact security@ledgity.com\n *\n * @notice Derived contracts are provided with helpers functions that allow recovering\n * assets accidentally sent to them.\n *\n * @dev Note: This abstract contract currently supports only ERC20 tokens. Derived\n * contracts currently do not implement necessary functions to receive Ether or\n * ERC721/ERC1155 tokens.\n *\n * @dev For further details, see \"RecoverableUpgradeable\" section of whitepaper.\n * @custom:security-contact security@ledgity.com\n */\nabstract contract RecoverableUpgradeable is Initializable, GlobalOwnableUpgradeable {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /**\n     * @notice Initializer functions of the contract. They replace the constructor()\n     * function in the context of upgradeable contracts.\n     * @dev See: https://docs.openzeppelin.com/contracts/4.x/upgradeable\n     * @param globalOwner_ The address of the GlobalOwner contract.\n     */\n    function __Recoverable_init(address globalOwner_) internal onlyInitializing {\n        __GlobalOwnable_init(globalOwner_);\n        __Recoverable_init_unchained();\n    }\n\n    function __Recoverable_init_unchained() internal onlyInitializing {}\n\n    /**\n     * @notice Recovers a specified amount of a given token address. Will fail if the\n     * contract doesn't hold enough tokens.\n     * @param tokenAddress The address of the token to recover.\n     * @param amount The amount of token to recover.\n     */\n    function recoverERC20(address tokenAddress, uint256 amount) public virtual onlyOwner {\n        // Ensure the specified amount is not zero\n        require(amount > 0, \"L10\");\n\n        // Create a reference to token's contract\n        IERC20Upgradeable tokenContract = IERC20Upgradeable(tokenAddress);\n\n        // Ensure there is enough token to recover\n        require(tokenContract.balanceOf(address(this)) >= amount, \"L11\");\n\n        // Transfer the recovered token amount to the sender\n        tokenContract.safeTransfer(_msgSender(), amount);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add\n     * new variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/src/GenericERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {ERC20Burnable} from \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\n\n/**\n * @notice Used for testing purposes only.\n * It represents:\n * - a FIAT-based stablecoin when used to test the LToken contract,\n * - the $LDY token when used to test the LDYStaking contract.\n * This contract accept decimals as constructor argument, so it can be used to to\n * easily test different decimals scenarios.\n */\ncontract GenericERC20 is ERC20, ERC20Burnable {\n    uint8 private _decimals;\n\n    constructor(string memory name, string memory symbol, uint8 decimals_) ERC20(name, symbol) {\n        _decimals = decimals_;\n    }\n\n    function mint(uint256 amount) public {\n        _mint(msg.sender, amount);\n    }\n\n    function decimals() public view virtual override returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * Used in tests to test different decimals scenarios.\n     */\n    function setDecimals(uint8 decimals_) public {\n        _decimals = decimals_;\n    }\n}\n"
    },
    "contracts/src/dev/LDYStaking.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\n// Contracts\nimport \"../abstracts/base/BaseUpgradeable.sol\";\nimport {InvestUpgradeable} from \"../abstracts/InvestUpgradeable.sol\";\nimport {SUD} from \"../libs/SUD.sol\";\nimport {ERC20Burnable} from \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\n\n// Libraries & interfaces\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\n/**\n * @title LDYStaking\n * @author Lila Rest (lila@ledgity.com)\n * @notice This contract powers the $LDY staking mechanism of the Ledgity Yield app. It allows\n * users to stake their $LDY tokens and earn rewards in $LDY.\n * @dev\n * Security note: InvestmentUpgradeable.AccountInfos.virtualBalance (uint88) allows storing up\n * to 309,485,009 $LDY which is far enough because it represents more than 3 times $LDY max\n * supply.\n *\n * Design note: This contract considers that tiers start at 1, 0 is considered as not elligible\n * to any tier.\n *\n * @dev WARNING: This contract assumes that the $LDY has 18 decimals and is not designed\n * to work with other decimals numbers.\n *\n * @dev For further details, see \"LDYStaking\" section of whitepaper.\n * @custom:security-contact security@ledgity.com\n * @custom:oz-upgrades-unsafe-allow external-library-linking\n */\ncontract WIP_LDYStaking is BaseUpgradeable, InvestUpgradeable {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /**\n     * @dev Represents the stake infos of an account.\n     * @param amount The amount of staked $LDY\n     * @param lockEnd The timestamp at which the stake is unlocked\n     */\n    struct AccountStake {\n        uint216 amount; // Allows storing more $LDY than its max supply\n        uint40 lockEnd; // Allows datetime up to 20/02/36812\n    }\n\n    /// @dev Hundred in UD60x18 format\n    uint256 private constant HUNDRED_UD60x18 = 100 * 1e18;\n\n    /// @dev Holds the time (in seconds) during which staked $LDY are locked\n    uint40 public stakeLockDuration;\n\n    /// @dev Holds the fees rate (in SUD format) taxed when account requests prematurate unlock\n    uint32 public unlockFeesRateUD7x3;\n\n    /// @dev Holds a mapping of account's stake infos\n    mapping(address => AccountStake) private accountsStakes;\n\n    /// @dev Holds amount of $LDY to be elligible to staking tier\n    uint256[] _tiers;\n\n    /// @dev Holds the total amount staked\n    uint256 public totalStaked;\n\n    /// @dev Holds the total amount of $LDY to be distributed as rewards\n    uint256 public rewardsReserve;\n\n    /**\n     * @dev Emitted to inform listeners of a change in the total amount staked\n     * @param newTotalStaked The new total amount staked\n     */\n    event TotalStakedUpdateEvent(uint256 newTotalStaked);\n\n    /**\n     * @dev Replaces the constructor() function in context of an upgradeable contract.\n     * See: https://docs.openzeppelin.com/contracts/4.x/upgradeable\n     * @param globalOwner_ The address of the GlobalOwner contract\n     * @param globalPause_ The address of the GlobalPauser contract\n     * @param globalBlacklist_ The address of the GlobalBlacklist contract\n     * @param ldyTokenAddress The address of the $LDY token\n     */\n    function initialize(\n        address globalOwner_,\n        address globalPause_,\n        address globalBlacklist_,\n        address ldyTokenAddress\n    ) public initializer {\n        __Base_init(globalOwner_, globalPause_, globalBlacklist_);\n        __Invest_init_unchained(ldyTokenAddress);\n\n        // Initialize stakeLockDuration to 90 days\n        stakeLockDuration = 90 days;\n    }\n\n    /**\n     * @dev Override of RecoverableUpgradeable.recoverERC20() that prevents recovered\n     * token from being the invested $LDY token.\n     * @inheritdoc RecoverableUpgradeable\n     */\n    function recoverERC20(address tokenAddress, uint256 amount) public override onlyOwner {\n        // Ensure the token is not the $LDY token\n        require(tokenAddress != address(invested()), \"L21\");\n        super.recoverERC20(tokenAddress, amount);\n    }\n\n    /**\n     * @dev Allows recovering $LDY tokenS accidentally sent to this contract. To prevent\n     * owner from draining funds from the contract, this function only allows recovering\n     * \"recoverable\" underlying tokens, i.e., tokens that have neither been deposited\n     * through `stake()` function nor through the `fund()` one.\n     */\n    function recoverLDY() public onlyOwner {\n        // Compute the amount of $LDY that can be recovered by taking the difference between\n        // the contract's $LDY balance and the total amount staked plus the rewards reserve\n        uint256 recoverableAmount = invested().balanceOf(address(this)) -\n            (totalStaked + rewardsReserve);\n\n        // Revert if there are no recoverable $LDY\n        require(recoverableAmount > 0, \"L22\");\n\n        // Else transfer the recoverable $LDY to the owner\n        super.recoverERC20(address(invested()), recoverableAmount);\n    }\n\n    /**\n     * @dev Implementation of InvestUpgradeable._investmentOf(). Required by parent contract\n     * to calculate rewards of an account. In this contract the investment of an account is\n     * equal to the amount of $LDY staked by the given account.\n     * @inheritdoc InvestUpgradeable\n     */\n    function _investmentOf(address account) internal view override returns (uint256) {\n        return stakeOf(account);\n    }\n\n    /**\n     * @dev External implementation of InvestmentUpgradeable._rewardsOf() allowing\n     * off-chain apps to easily compute the unclaimed rewards of a given account.\n     * @param account The account to check the rewards of\n     * @return The amount of unclaimed rewards of the account\n     */\n    function rewardsOf(address account) external view returns (uint256) {\n        return _rewardsOf(account, false);\n    }\n\n    /**\n     * @dev Getter that reads and return the amount staked by a given account.\n     * @param account The account to check the stake of\n     */\n    function stakeOf(address account) public view returns (uint256) {\n        return accountsStakes[account].amount;\n    }\n\n    /**\n     * @dev Getter that reads and return the lock end of a given account.\n     * @param account The account to check the lock end of\n     */\n    function lockEndOf(address account) public view returns (uint40) {\n        return accountsStakes[account].lockEnd;\n    }\n\n    /**\n     * @notice Computes the increases of tier lock time for a given account extending\n     * its staking by a given \"added amount\".\n     * @dev SUD is not used as precision loss on lock duration increase are acceptable.\n     * Not using it allows to save gas and make code less complex.\n     * @param account The account to check the lock end increase of\n     * @param addedAmount The amount of $LDY added by the account to its stake\n     */\n    function _getLockDurationIncrease(\n        address account,\n        uint256 addedAmount\n    ) internal view returns (uint40 lockDurationIncrease) {\n        // Retrieve account's stake infos\n        AccountStake memory accountStake = accountsStakes[account];\n\n        // If the account has no previous stake, return a full lock duration\n        if (accountStake.amount == 0) return stakeLockDuration;\n\n        // Convert added amount, account stake and stake lock duration to SUD\n        uint256 addedAmountSUD = SUD.fromAmount(addedAmount, 18);\n        uint256 accountStakeSUD = SUD.fromAmount(accountStake.amount, 18);\n        uint256 stakeLockDurationSUD = SUD.fromInt(stakeLockDuration, 18);\n\n        // Calculate the stake growth\n        uint256 growthRateSUD = (addedAmountSUD * SUD.fromInt(100, 18)) / accountStakeSUD;\n\n        // Compute the lock end increase proportionnally to stake growth\n        uint256 lockDurationIncreaseSUD = (stakeLockDurationSUD * growthRateSUD) /\n            SUD.fromInt(100, 18);\n        uint256 _lockDurationIncrease = SUD.toInt(lockDurationIncreaseSUD, 18);\n\n        // Cast _lockDurationIncrease to uint40.\n        // If the lock end is going to overflow uint40, set it to the uint40 max value\n        lockDurationIncrease = _lockDurationIncrease > type(uint40).max\n            ? type(uint40).max\n            : uint40(_lockDurationIncrease);\n\n        // Compute the remaining lock duration of the account\n        // If the lock end is in the past, the remaining lock duration is 0\n        uint40 remainingLockDuration = accountStake.lockEnd < uint40(block.timestamp)\n            ? 0\n            : accountStake.lockEnd - uint40(block.timestamp);\n\n        // Compute the sum of remaining and new lock durations\n        // uint256 is used to avoid overflow\n        uint256 lockDurationsSum = uint256(remainingLockDuration) + uint256(lockDurationIncrease);\n\n        // Ensure the new lock duration will not exceed the stakeLockDuration\n        lockDurationIncrease = lockDurationsSum > stakeLockDuration\n            ? stakeLockDuration - remainingLockDuration\n            : lockDurationIncrease;\n    }\n\n    /**\n     * @dev Computes the new lock end timestamp of a given account and amount added to\n     * its stake.\n     * @param account The account to check the new lock end of\n     * @param addedAmount The amount of $LDY added by the account to its stake\n     */\n    function getNewLockEndFor(address account, uint216 addedAmount) public view returns (uint40) {\n        return uint40(block.timestamp) + _getLockDurationIncrease(account, addedAmount);\n    }\n\n    /**\n     * @dev Setter for the prematurate unlock fees/tax rate. Restricted to owner.\n     * @param unlockFeesRateUD7x3_  The new unlock fees rate in UD7x3 format\n     */\n    function setUnlockFeesRate(uint32 unlockFeesRateUD7x3_) public onlyOwner {\n        unlockFeesRateUD7x3 = unlockFeesRateUD7x3_;\n    }\n\n    /**\n     * @dev Setter for the stake lock duration. Restricted to owner.\n     * @param stakeLockDuration_  The new stake lock duration\n     */\n    function setStakeLockDuration(uint40 stakeLockDuration_) public onlyOwner {\n        stakeLockDuration = stakeLockDuration_;\n    }\n\n    /**\n     * @dev Allows the owner to fill the $LDY rewards reserve (used to reward stakers).\n     * @param amount The amount of $LDY to deposit\n     */\n    function fuel(uint256 amount) external onlyOwner {\n        // Ensure the amount is not 0\n        require(amount > 0, \"L23\");\n\n        // Increase rewards reserve amount\n        rewardsReserve += amount;\n\n        // Transfer $LDY tokens from the caller to this contract\n        invested().safeTransferFrom(_msgSender(), address(this), amount);\n    }\n\n    /**\n     * @dev Prematurely unlocks the stake of the caller against a fee rate defined\n     * by unlockFeesRateUD7x3. The entire fee is burned as a way to support the token's\n     * ecosystem.\n     */\n    function unlock() external whenNotPaused notBlacklisted(_msgSender()) {\n        // Retrieve account stake infos\n        AccountStake memory accountStake = accountsStakes[_msgSender()];\n\n        // Ensure the account has a locked stake\n        require(accountStake.lockEnd > block.timestamp, \"L24\");\n\n        // Unlock stake by setting lock time to now\n        accountStake.lockEnd = uint40(block.timestamp);\n\n        // Calculate unlock fees/tax\n        uint256 unlockFeesRateSUD = SUD.fromRate(unlockFeesRateUD7x3, 18);\n        uint256 accountStakeSUD = SUD.fromAmount(accountStake.amount, 18);\n        uint256 feesSUD = (accountStakeSUD * unlockFeesRateSUD) / SUD.fromInt(100, 18);\n        uint256 fees = SUD.toAmount(feesSUD, 18);\n\n        // Remove fees from the account stake\n        accountStake.amount -= uint216(fees);\n\n        // Write the new account stake infos\n        accountsStakes[_msgSender()] = accountStake;\n\n        // Burn unlock fees\n        ERC20Burnable(address(invested())).burn(fees);\n    }\n\n    /**\n     * @dev Allows a user to stake a given amount of $LDY tokens.\n     * @param amount The amount of $LDY tokens to stake\n     */\n    function stake(uint216 amount) public whenNotPaused notBlacklisted(_msgSender()) {\n        // Ensure the amount is not 0\n        require(amount > 0, \"L25\");\n\n        // Ensure the account has enough $LDY tokens to stake\n        require(invested().balanceOf(_msgSender()) >= amount, \"L26\");\n\n        // Reset account's investment period\n        _beforeInvestmentChange(_msgSender(), false);\n\n        // Retrieve account stake infos\n        AccountStake memory accountStake = accountsStakes[_msgSender()];\n\n        // Update the amount staked by the account and the total amount staked\n        accountStake.amount += amount;\n        totalStaked += amount;\n\n        // Inform listeners about the change in total staked amount\n        emit TotalStakedUpdateEvent(totalStaked);\n\n        // Update the end of the lock period\n        accountStake.lockEnd = getNewLockEndFor(_msgSender(), amount);\n\n        // Write the new account stake infos\n        accountsStakes[_msgSender()] = accountStake;\n\n        // Transfer staked $LDY tokens to the contract\n        invested().safeTransferFrom(_msgSender(), address(this), amount);\n    }\n\n    /**\n     * @dev Allows a user to unstaking (withdraw) a given amount of $LDY tokens.\n     * @param amount The amount of $LDY tokens to unstake\n     */\n    function unstake(uint216 amount) external whenNotPaused notBlacklisted(_msgSender()) {\n        // Ensure the amount is not 0\n        require(amount > 0, \"L27\");\n\n        // Ensure the account has enough $LDY tokens to unstake\n        require(stakeOf(_msgSender()) >= amount, \"L28\");\n\n        // Retrieve account stake infos\n        AccountStake memory accountStake = accountsStakes[_msgSender()];\n\n        // Ensure the account is not in lock period\n        require(accountStake.lockEnd <= block.timestamp, \"L29\");\n\n        // Reset its investment period\n        _beforeInvestmentChange(_msgSender(), false);\n\n        // Update the amount staked by the account and the total amount staked\n        accountStake.amount -= amount;\n        totalStaked -= amount;\n\n        // Inform listeners about the change in total staked amount\n        emit TotalStakedUpdateEvent(totalStaked);\n\n        // Write the new account stake infos\n        accountsStakes[_msgSender()] = accountStake;\n\n        // Transfer withdrawn $LDY tokens to the account\n        invested().safeTransfer(_msgSender(), amount);\n    }\n\n    /**\n     * @dev Allows the caller to claim its currently unclaimed rewards.\n     */\n    function claim() public whenNotPaused notBlacklisted(_msgSender()) {\n        // Reset account investment period. This will accumualte current unclaimed\n        // rewards into the account's virtual balance.\n        _beforeInvestmentChange(_msgSender(), false);\n\n        // Retrieve and reset account's unclaimed rewards from virtual balance\n        uint256 rewards = accountsDetails[_msgSender()].virtualBalance;\n\n        // Ensure there are some rewards to claim\n        require(rewards > 0, \"L30\");\n\n        // Reset account's virtual balance\n        accountsDetails[_msgSender()].virtualBalance = 0;\n\n        // Ensure the contract has enough rewards to distribute\n        require(rewardsReserve >= rewards, \"L31\");\n\n        // Decreases the total amount of remaining rewards to distribute\n        rewardsReserve -= rewards;\n\n        // Transfer rewards to the account\n        invested().safeTransfer(_msgSender(), rewards);\n    }\n\n    /**\n     * @dev Allows the caller to compound its currently unclaimed rewards to its stake.\n     * Note that we don't update the lock end here, as it applies only to $LDY deposited\n     * through the stake() function, not to rewards.\n     */\n    function compound() external whenNotPaused notBlacklisted(_msgSender()) {\n        // Retrieve account stake infos\n        AccountStake memory accountStake = accountsStakes[_msgSender()];\n\n        // Reset account investment period. This will accumualte current unclaimed\n        // rewards into the account's virtual balance.\n        _beforeInvestmentChange(_msgSender(), false);\n\n        // Retrieve and reset account's unclaimed rewards from virtual balance\n        uint256 rewards = accountsDetails[_msgSender()].virtualBalance;\n\n        // Ensure there are some rewards to claim\n        require(rewards > 0, \"L32\");\n\n        // Reset account's virtual balance\n        accountsDetails[_msgSender()].virtualBalance = 0;\n\n        // Ensure the contract has enough rewards to distribute\n        require(rewardsReserve >= rewards, \"L33\");\n\n        // Decreases the total amount of remaining rewards to distribute\n        rewardsReserve -= rewards;\n\n        // Update the amount staked by the account and the total amount staked\n        accountStake.amount += uint216(rewards);\n        totalStaked += rewards;\n\n        // Inform listeners about the change in total staked amount\n        emit TotalStakedUpdateEvent(totalStaked);\n\n        // Write the new account stake infos\n        accountsStakes[_msgSender()] = accountStake;\n    }\n\n    /**\n     * @dev Sets the amount of $LDY tokens that must be staked to be elligible to a given\n     * staking tier.\n     * @param tier The tier number (not its index in the array)\n     * @param amount The amount of $LDY tokens to stake to be elligible to the tier\n     */\n    function setTier(uint256 tier, uint256 amount) public onlyOwner {\n        // Ensure the tier is > 0 (as it shouldn't be an index)\n        require(tier > 0, \"L34\");\n\n        // Retrieve tier index from tier number\n        uint256 tierIndex = tier - 1;\n\n        // Create missing tiers in the tiers array\n        for (uint256 i = _tiers.length; i < tier; i++) {\n            _tiers.push(0);\n        }\n\n        // Ensure tier amount is not greater than next tier one (if next tier exists)\n        if (tier != _tiers.length) {\n            require(amount <= _tiers[tierIndex + 1], \"L35\");\n        }\n\n        // Ensure tier amount is not lower than previous tier one (if previous tier exists)\n        if (tier != 1) {\n            require(amount >= _tiers[tierIndex - 1], \"L36\");\n        }\n\n        // Set the new tier value\n        _tiers[tierIndex] = amount;\n    }\n\n    /**\n     * @dev Returns the amount of $LDY tokens that must be staked to be elligible to a given\n     * staking tier.\n     * @param tier The tier number (not its index in the array)\n     * @return The amount of $LDY tokens to stake to be elligible to the tier\n     */\n    function getTier(uint256 tier) public view returns (uint256) {\n        // Ensure the tier is > 0 (as it shouldn't be an index)\n        require(tier > 0, \"L37\");\n\n        // Ensure the staking tier exists\n        require(tier <= _tiers.length, \"L38\");\n\n        // Return the tier value\n        return _tiers[tier - 1];\n    }\n\n    /**\n     * @dev Returns the staking a given account is ellible to.\n     * @param account The account to check the tier of\n     * @return tier The tier number (not its index in the array)\n     */\n    function tierOf(address account) public view returns (uint256 tier) {\n        // Retrieve user stake\n        uint256 stakedAmount = stakeOf(account);\n\n        // If first tier is not set or account is not elligible to it, return 0\n        if (_tiers.length < 1 || stakedAmount < getTier(1)) return 0;\n\n        // Else tier is at least equal to 1\n        tier = 1;\n\n        // Finally increment tier until there is no more tier or the staked amount doesn't fit in next one\n        while (tier + 1 <= _tiers.length && stakedAmount >= getTier(tier + 1)) tier++;\n    }\n}\n"
    },
    "contracts/src/DummyLDYStaking.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\n/**\n * @title LDYStaking\n * @author Lila Rest (lila@ledgity.com)\n * @notice This contract will replace the LDYStaking contract in L-Tokens contracts until\n * the $LDY token is available and the real LDYStaking contract is deployed so.\n * This contract only implements tierOf() function of LDYStaking as it is the only one\n * the LToken contract relies on.\n * @custom:security-contact security@ledgity.com\n */\ncontract LDYStaking {\n    /**\n     * @dev Dummy tierOf() function that always return that the given account is not\n     * ellgible to any LDY staking tier.\n     * @param account @\n     */\n    function tierOf(address account) public pure returns (uint256 tier) {\n        account; // Silence unused variable compiler warning\n        return 0;\n    }\n}\n"
    },
    "contracts/src/GlobalBlacklist.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport {GlobalOwnableUpgradeable} from \"./abstracts/GlobalOwnableUpgradeable.sol\";\n\n/**\n * @title GlobalBlacklist\n * @author Lila Rest (lila@ledgity.com)\n * @notice This contract is used to maintain a mapping of blacklisted accounts on chain.\n * It is then read by all contracts that inherit from GlobalRestrictableUpgradeable abstract\n * contract to restrict access to some functions to non-blacklisted accounts.\n * @dev For further details, see \"GlobalBlacklist\" section of whitepaper.\n * @custom:security-contact security@ledgity.com\n */\ncontract GlobalBlacklist is Initializable, UUPSUpgradeable, GlobalOwnableUpgradeable {\n    /**\n     * @dev This mapping is made private and the getter function isBlacklisted() function is\n     * used instead to read it. This helps saving gas in some scenario. See isBlacklisted()\n     * documentation for more details.\n     */\n    mapping(address => bool) private _list;\n\n    /**\n     * @dev Prevents implementation contract from being initialized as recommended by\n     * OpenZeppelin.\n     * See: https://docs.openzeppelin.com/contracts/4.x/api/proxy#Initializable-_disableInitializers--\n     * @custom:oz-upgrades-unsafe-allow constructor\n     */\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @dev Replaces the constructor() function in context of an upgradeable contract.\n     * See: https://docs.openzeppelin.com/contracts/4.x/upgradeable\n     * @param globalOwner_ The address of the GlobalOwner contract\n     */\n    function initialize(address globalOwner_) public initializer {\n        __GlobalOwnable_init(globalOwner_);\n        __UUPSUpgradeable_init();\n    }\n\n    /**\n     * @dev Override of UUPSUpgradeable._authorizeUpgrade() function restricted to the global\n     * owner. Note that this function is called by the proxy contract while upgrading.\n     * @param newImplementation The address of the new implementation contract\n     */\n    function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}\n\n    /**\n     * @dev Sets a given account as blacklisted.\n     * @param account The account's address to blacklist\n     */\n    function blacklist(address account) external onlyOwner {\n        require(account != address(0), \"L20\");\n        _list[account] = true;\n    }\n\n    /**\n     * @dev Removes a given account from blacklist.\n     * @param account The account's address to unblacklist\n     */\n    function unBlacklist(address account) external onlyOwner {\n        _list[account] = false;\n    }\n\n    /**\n     * @dev Checks if given account is blacklisted.\n     * @param account The account to check\n     * @return 'true' if the account is blacklisted, 'false' otherwise\n     */\n    function isBlacklisted(address account) external view returns (bool) {\n        // Avoir reading chain storage if account is the zero address (e.g, during a mint or a burn)\n        if (account == address(0)) return false;\n        // Else return current blacklist status of the account\n        return _list[account];\n    }\n}\n"
    },
    "contracts/src/GlobalOwner.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.18;\n\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport {Ownable2StepUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\n\n/**\n * @title GlobalOwner\n * @author Lila Rest (lila@ledgity.com)\n * @notice This contract is used to maintain an owner account shared by all contracts of this\n * codebase. It is then read by all contracts that inherit from GlobalOwnableUpgradeable abstract\n * contract to restrict access to some functions to owner of this contract.\n * @dev For further details, see \"GlobalOwner\" section of whitepaper.\n * @custom:security-contact security@ledgity.com\n */\ncontract GlobalOwner is Initializable, UUPSUpgradeable, Ownable2StepUpgradeable {\n    /**\n     * @dev Prevents implementation contract from being initialized as recommended by\n     * OpenZeppelin.\n     * See: https://docs.openzeppelin.com/contracts/4.x/api/proxy#Initializable-_disableInitializers--\n     * @custom:oz-upgrades-unsafe-allow constructor\n     */\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @dev Replaces the constructor() function in context of an upgradeable contract.\n     * See: https://docs.openzeppelin.com/contracts/4.x/upgradeable\n     */\n    function initialize() public initializer {\n        __Ownable2Step_init();\n        __UUPSUpgradeable_init();\n    }\n\n    /**\n     * @dev Override of UUPSUpgradeable._authorizeUpgrade() function restricted to the global\n     * owner. Note that this function is called by the proxy contract while upgrading.\n     * @param newImplementation The address of the new implementation contract\n     */\n    function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}\n}\n"
    },
    "contracts/src/GlobalPause.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.18;\n\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport {GlobalOwnableUpgradeable} from \"./abstracts/GlobalOwnableUpgradeable.sol\";\n\n/**\n * @title GlobalPause\n * @author Lila Rest (lila@ledgity.com)\n * @notice This contract is used to maintain a pause state shared by all contracts of this\n * codebase. It is then read by all contracts that inherit from GlobalPausableUpgradeable\n * abstract contract to restrict execution of some functions when this contract is not paused.\n * @dev For further details, see \"GlobalPause\" section of whitepaper.\n * @custom:security-contact security@ledgity.com\n */\ncontract GlobalPause is\n    Initializable,\n    UUPSUpgradeable,\n    GlobalOwnableUpgradeable,\n    PausableUpgradeable\n{\n    /**\n     * @dev Prevents implementation contract from being initialized as recommended by\n     * OpenZeppelin.\n     * See: https://docs.openzeppelin.com/contracts/4.x/api/proxy#Initializable-_disableInitializers--\n     * @custom:oz-upgrades-unsafe-allow constructor\n     */\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @dev Replaces the constructor() function in context of an upgradeable contract.\n     * See: https://docs.openzeppelin.com/contracts/4.x/upgradeable\n     * @param globalOwner_ The address of the GlobalOwner contract\n     */\n    function initialize(address globalOwner_) public initializer {\n        __GlobalOwnable_init(globalOwner_);\n        __Pausable_init();\n        __UUPSUpgradeable_init();\n    }\n\n    /**\n     * @dev Override of UUPSUpgradeable._authorizeUpgrade() function restricted to the global\n     * owner. Note that this function is called by the proxy contract while upgrading.\n     * @param newImplementation The address of the new implementation contract\n     */\n    function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}\n\n    /**\n     * @dev Public implementation of PausableUpgradeable's pausing and unpausing functions\n     * but restricted to contract's owner.\n     */\n    function pause() public onlyOwner {\n        _pause();\n    }\n\n    function unpause() public onlyOwner {\n        _unpause();\n    }\n}\n"
    },
    "contracts/src/interfaces/ITransfersListener.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\ninterface ITransfersListener {\n    function onLTokenTransfer(address from, address to, uint256 amount) external;\n}\n"
    },
    "contracts/src/libs/APRHistory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\n/**\n * @title APRHistory\n * @author Lila Rest (https://lila.rest)\n * @custom:security-contact security@ledgity.com\n *\n * @notice This library offers utilities to efficiently maintain on chain, the history of\n * an APR (Annual Percentage Rate). Each entry in this history is called a \"checkpoint\".\n *\n * @dev Intuition:\n * Each checkpoint in an APR history consists in two data:\n * - the creation timestamp\n * - the APR at that time\n *\n * Given that reads and writes to storage slots are among the most costly operations in\n * Solidity, this library provides a way to store those data on chain in a way that\n * minimizes the number of used storage slots.\n *\n * Instead of storing each checkpoint in a separate storage slot, this library\n * facilitates the packing of up to 4 checkpoints in a single storage slot.\n *\n * @dev Definitions:\n * - Checkpoint: A record of an APR change\n * - Pack: A collection of 4 checkpoints stored in a single storage slot\n * - History: A dynamic array of packs\n * - Reference: A storage pointer to a checkpoint in the APR history\n * - CheckpointData: An in-memory representation of a checkpoint data\n *\n * @dev Limitation: This library can accommodate APRs only up to 65.536%. This is however\n * sufficient for APR in LToken contract, which is expected to remain below 10%.\n *\n * @dev For further details, see \"APRHistory\" section of whitepaper.\n * @custom:security-contact security@ledgity.com\n */\nlibrary APRHistory {\n    /**\n     * @notice Represents data of a checkpoint extracted from the on-chain history.\n     * For on-chain representation see \"Pack\" struct.\n     * @param aprUD7x3 APR in UD7x3 format (e.g., 12345 = 12.345%).\n     * @param timestamp Timestamp of the checkpoint's creation.\n     */\n    struct CheckpointData {\n        uint16 aprUD7x3; // Allows up to 65.536%\n        uint40 timestamp; // Supports dates up to 20/02/36812\n    }\n\n    /**\n     * @notice Represents how APR checkpoints are stored on chain. Each pack can contain\n     * the data 4 checkpoints. Packs are then stored in a dynamic array (the history).\n     * @param aprsUD7x3 Array of checkpoints' APRs.\n     * @param timestamps Array of checkpoints' timestamps.\n     * @param cursor Index of the next checkpoint to be written.\n     */\n    struct Pack {\n        uint16[4] aprsUD7x3;\n        uint40[4] timestamps;\n        uint32 cursor;\n    }\n\n    /**\n     * @notice Represents a storage pointer to a specific checkpoint in the history.\n     * @param packIndex Index of the pack the checkpoint belongs to.\n     * @param cursorIndex Index of the checkpoint in this pack (between 0 and 3).\n     */\n    struct Reference {\n        uint256 packIndex;\n        uint32 cursorIndex;\n    }\n\n    /**\n     * @notice Compares two checkpoints references.\n     * @param ref1 The first reference to compare.\n     * @param ref2 The second reference to compare.\n     * @return Whether the two references points to the same checkpoint.\n     */\n    function eq(Reference memory ref1, Reference memory ref2) external pure returns (bool) {\n        return ref1.packIndex == ref2.packIndex && ref1.cursorIndex == ref2.cursorIndex;\n    }\n\n    /**\n     * @notice Returns the reference of the checkpoint that should come right after the\n     * referenced checkpoint in the APR history.\n     * @param ref The reference to be incremented.\n     * @return The incremented reference.\n     */\n    function incrementReference(Reference memory ref) public pure returns (Reference memory) {\n        // Ensure cursor index of the given ref is within valid range [0, 3]\n        require(ref.cursorIndex <= 3, \"L1\");\n\n        // If the given ref is the last slot in its pack, return ref of next pack's first slot\n        if (ref.cursorIndex == 3) return Reference(ref.packIndex + 1, 0);\n        //\n        // Else, return ref of next slot in current pack\n        else return Reference(ref.packIndex, ref.cursorIndex + 1);\n    }\n\n    /**\n     * @notice Extracts checkpoint data from a given reference and in APR history.\n     * @param self The APR history to extract the checkpoint from.\n     * @param ref The reference of the checkpoint data to extract.\n     * @return The extracted checkpoint's data.\n     */\n    function getDataFromReference(\n        Pack[] storage self,\n        Reference memory ref\n    ) public view returns (CheckpointData memory) {\n        // Ensure cursor index of the given ref is within valid range [0, 3]\n        require(ref.cursorIndex <= 3, \"L2\");\n\n        // Ensure pack index of the given ref exists in history\n        require(ref.packIndex < self.length, \"L3\");\n\n        // Retrieve pack data from history\n        Pack memory pack = self[ref.packIndex];\n\n        // Ensure cursor index of the given ref has been written\n        require(ref.cursorIndex < pack.cursor, \"L4\");\n\n        // Build and return the checkpoint data\n        return\n            CheckpointData({\n                aprUD7x3: pack.aprsUD7x3[ref.cursorIndex],\n                timestamp: pack.timestamps[ref.cursorIndex]\n            });\n    }\n\n    /**\n     * @notice Retrieves the reference to the most recently added checkpoint in the APR history.\n     * @param self The history to extract the reference from.\n     * @return The reference of the latest checkpoint.\n     */\n    function getLatestReference(Pack[] storage self) public view returns (Reference memory) {\n        // Ensure the given history is not empty\n        require(self.length != 0, \"L5\");\n\n        // Retrieve latest pack's index and cursor\n        uint256 packIndex = self.length - 1;\n        uint32 packCursor = self[packIndex].cursor;\n\n        // If this is the first pack ever, ensure it is not empty\n        if (packIndex == 0) require(packCursor != 0, \"L6\");\n\n        // If the pack is empty, return ref of previous pack's latest slot\n        if (packCursor == 0) return Reference(packIndex - 1, 3);\n        //\n        // Else, return ref of previous slot in current pack\n        else return Reference(packIndex, packCursor - 1);\n    }\n\n    /**\n     * @notice Appends a new empty pack to the end of the given APR history array.\n     * @param self The APR history to append an empty to.\n     */\n    function newBlankPack(Pack[] storage self) internal {\n        // If history is not empty, ensure the latest pack is full\n        require(self.length == 0 || getLatestReference(self).cursorIndex == 3, \"L7\");\n\n        // Push a new blank pack to the history array\n        self.push(\n            Pack({\n                aprsUD7x3: [uint16(0), uint16(0), uint16(0), uint16(0)],\n                timestamps: [uint40(0), uint40(0), uint40(0), uint40(0)],\n                cursor: 0\n            })\n        );\n    }\n\n    /**\n     * @notice Write a new APR checkpoint at the end of the given history array.\n     * @param self The array of packs to write the new checkpoint to.\n     * @param aprUD7x3 The new APR in UD7x3 format.\n     */\n    function setAPR(Pack[] storage self, uint16 aprUD7x3) external {\n        // Determine the reference where the new checkpoint should be written\n        Reference memory newRef = self.length == 0\n            ? Reference(0, 0)\n            : incrementReference(getLatestReference(self));\n\n        // If pack to be written doesn't exist yet, push a new blank pack in history\n        if (newRef.packIndex >= self.length) newBlankPack(self);\n\n        // Retrieve the pack where the new checkpoint will be stored\n        Pack memory pack = self[newRef.packIndex];\n\n        // Add new checkpoint's data to the pack\n        pack.aprsUD7x3[newRef.cursorIndex] = aprUD7x3;\n        pack.timestamps[newRef.cursorIndex] = uint40(block.timestamp);\n\n        // Increment the pack's cursor\n        pack.cursor++;\n\n        // Write the updated pack in storage\n        self[newRef.packIndex] = pack;\n    }\n\n    /**\n     * @notice Retrieves the APR of the latest checkpoint written in the APR history.\n     * @param self The history array to read APR from.\n     * @return The latest checkpoint's APR.\n     */\n    function getAPR(Pack[] storage self) public view returns (uint16) {\n        // Retrieve the latest checkpoint data\n        Reference memory ref = getLatestReference(self);\n        CheckpointData memory data = getDataFromReference(self, ref);\n\n        // Return the latest checkpoint's APR\n        return data.aprUD7x3;\n    }\n}\n"
    },
    "contracts/src/libs/SUD.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport {IERC20MetadataUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\n\n/**\n * @title SUD\n * @author Lila Rest (https://lila.rest)\n * @custom:security-contact security@ledgity.com\n *\n * @notice SUD serves as an intermediary number format for calculations within this\n * codebase. It ensures consistency and reduces precision losses. This library\n * facilitates conversions between various number formats and the SUD format.\n *\n * @dev Intuition:\n * This codebase employs UD (unsigned decimal fixed-point numbers) format to represent\n * both percentage rates and tokens amounts.\n *\n * Rates are expressed in UD7x3 format, whereas the format for tokens amounts depends on\n * the decimals() value of the involved tokens.\n *\n * Three challenges arise from this:\n *   1) To compute values together, it's essential that they are in the same format\n *   2) Calculations involving consecutive divisions on UD numbers lead to accumulated\n *      precision loss (because division shrinks). A common approach is to scale up and\n *      down values by a few decimals before and after performing calculations.\n *   3) Given that rates use the UD7x3 format, if we decided to scale them to and from\n *      the number of decimals of the involved token, 1 to 3 of the rates' decimals would\n *      be shrinked in case token's decimals number is in [0, 2].\n *\n * To address these challenges, this library provides the SUD format, which acts as a\n * consistent and scaled intermediate format to perform calculations on.\n *\n * SUD is an acronym for either \"Scaled UD\" or \"Safe UD\".\n *\n * @dev Definitions:\n * - Integer: A number without fractional part, e.g., block.timestamp\n *\n * - UD: A decimal unsigned fixed-point number. The \"UD\" notation is inspired from\n *       libraries like [prb-math](https://github.com/PaulRBerg/prb-math/)\n *\n * - Amount: An UD with an unknown (at writing time) repartition of digits between\n *           integral and fractional parts. Represents a token amount.\n *\n * - Rate: An UD with 7 integral digits and 3 fractional ones (a.k.a UD7x3).\n *         Represents a percentage rate.\n *\n * - SUD: An UD with 3 more decimals than the involved rate or amount with the highest\n *        decimals number. As rates are represented by UD7x3, a SUD number has at least 6\n *        decimals (3+3) and so ranges from UD71x6 to UD0x77 formats.\n *        Used as an intermediate format to perform calculations.\n *\n * @dev This library provides utilities to perform the following conversions:\n * - Amount       <--> SUD\n * - Rate (UD7x3) <--> SUD\n * - Integer      <--> SUD\n *\n * @dev Why scaling by 3 decimals?\n * - It provides an adequate degree of precision for this codebase,\n * - It enables the conversion of a UD7x3 rate to SUD format by merely scaling it up by\n *   the involved token's decimal number.\n *\n * @dev Optimization note: The functions of this library are not set to external because\n * incorporating them directly into contracts is more gas-efficient. Given their minimal\n * size and frequent usage in the InvestUpgradeable, LDYStaking, and LToken contracts,\n * any bytecode savings from making them external are negated by the additional bytecode\n * required for external calls to this library.\n * The can be observed by comparing the output of `pnpm cc:size` when those functions's\n * visibility is set to external or internal.\n *\n * @dev Precision note: While this library mitigates precision loss during calculations\n * on UD numbers, it's important to note that tokens with lower decimal counts and supply\n * inherently suffer more from precision loss. Conversely, tokens with higher decimal\n * counts and supply will experience less precision loss.\n *\n * @dev For further details, see \"SUD\" section of whitepaper.\n * @custom:security-contact security@ledgity.com\n */\nlibrary SUD {\n    /**\n     * @notice Retrieves decimals number of the given ERC20 contract address.\n     * @param tokenAddress The address to retrieve decimals number from.\n     * @return decimals The decimals number of the given ERC20 contract address.\n     */\n    function decimalsOf(address tokenAddress) internal view returns (uint256 decimals) {\n        return IERC20MetadataUpgradeable(tokenAddress).decimals();\n    }\n\n    /**\n     * @notice Convert a given token amount into SUD format.\n     * @param nAmount The token amount to convert.\n     * @param decimals The decimals number of the involved ERC20 token.\n     * @return nSUD The amount in SUD format\n     */\n    function fromAmount(uint256 nAmount, uint256 decimals) internal pure returns (uint256 nSUD) {\n        // If token decimals < 3, return a UD71x6 number\n        if (decimals < 3) return nAmount * 10 ** (6 - decimals);\n\n        // Else return a number with decimals+3 fractional digits\n        return nAmount * 10 ** 3;\n    }\n\n    /**\n     * @notice Convert a given SUD number into token amount format.\n     * @param nSUD The SUD number to convert.\n     * @param decimals The decimals number of the involved ERC20 token.\n     * @return nAmount The number in amount format\n     */\n    function toAmount(uint256 nSUD, uint256 decimals) internal pure returns (uint256 nAmount) {\n        // If token decimals < 3, convert from a UD71x6 number\n        if (decimals < 3) return nSUD / 10 ** (6 - decimals);\n\n        // Else, convert from a number with decimals+3 fractional digits\n        return nSUD / 10 ** 3;\n    }\n\n    /**\n     * @notice Converts a given UD7x3 rate into SUD format.\n     * @param nUD7x3 The UD7x3 rate to convert.\n     * @param decimals The decimals number of the involved ERC20 token.\n     * @return nSUD The rate in SUD format.\n     */\n    function fromRate(uint256 nUD7x3, uint256 decimals) internal pure returns (uint256 nSUD) {\n        // If token decimals < 3, return a UD71x6 number\n        if (decimals < 3) return nUD7x3 * 10 ** 3;\n\n        // Else, return a number with decimals+3 fractional digits\n        return nUD7x3 * 10 ** decimals;\n    }\n\n    /**\n     * @notice Converts a given SUD number into a UD7x3 rate.\n     * @param nSUD The SUD number to convert.\n     * @param decimals The decimals number of the involved ERC20 token.\n     * @return nUD7x3 The number in UD7x3 rate format.\n     */\n    function toRate(uint256 nSUD, uint256 decimals) internal pure returns (uint256 nUD7x3) {\n        // If token decimals < 3, convert from a UD71x6 number\n        if (decimals < 3) return nSUD / 10 ** 3;\n\n        // Else, convert from a number with decimals+3 fractional digits\n        return nSUD / 10 ** decimals;\n    }\n\n    /**\n     * @notice Converts a given integer into SUD format.\n     * @param n The integer to convert.\n     * @param decimals The decimals number of the involved ERC20 token.\n     * @return nSUD The integer in SUD format.\n     */\n    function fromInt(uint256 n, uint256 decimals) internal pure returns (uint256 nSUD) {\n        // If token decimals < 3, return a UD71x6 number\n        if (decimals < 3) return n * 10 ** 6;\n\n        // Else, return a number with decimals+3 fractional digits\n        return n * 10 ** (decimals + 3);\n    }\n\n    /**\n     * @notice Converts a given SUD number as an integer (all decimals shrinked).\n     * @param nSUD The SUD number to convert.\n     * @param decimals The decimals number of the involved ERC20 token.\n     * @return n The SUD number as an integer.\n     */\n    function toInt(uint256 nSUD, uint256 decimals) internal pure returns (uint256 n) {\n        // If token decimals < 3, convert from a UD71x6 number\n        if (decimals < 3) return nSUD / 10 ** 6;\n\n        // Else, convert from a number with decimals+3 fractional digits\n        return nSUD / 10 ** (decimals + 3);\n    }\n}\n"
    },
    "contracts/src/LToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\n// Contracts\nimport {ERC20WrapperUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20WrapperUpgradeable.sol\";\nimport \"./abstracts/base/ERC20BaseUpgradeable.sol\";\nimport {InvestUpgradeable} from \"./abstracts/InvestUpgradeable.sol\";\nimport {LDYStaking} from \"./DummyLDYStaking.sol\";\n\n// Libraries\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {SUD} from \"./libs/SUD.sol\";\n\n// Interfaces\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {IERC20MetadataUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\nimport {ITransfersListener} from \"./interfaces/ITransfersListener.sol\";\n\n/**\n * @title LToken\n * @author Lila Rest (https://lila.rest)\n * @custom:security-contact security@ledgity.com\n *\n * @notice Main contract of the Ledgity Yield protocol. It powers every L-Token (i.e,\n * investment pools backed by RWA). An L-Token is an ERC20 wrapper around a stablecoin.\n * As soon as a wallet holds some L-Tokens, it starts receiving rewards in\n * the form of additional L-Tokens, which are auto-compounded over time.\n *\n * @dev Intuition:\n *\n *\n * @dev Definitions:\n * - (withdrawal) request: A request to withdraw some underlying tokens from some L-Tokens.\n * - (withdrawal) queue: Array containing all withdrawal requests.\n * - Request ID: The index of a withdrawal request in the queue.\n *\n * Note that words between parentheses are sometimes omitted for brevity.\n *\n * @dev Security: This contract can safely receive funds immediately after initialization.\n * It is however required to set a non-zero APR for users to start receiving rewards.\n *\n * @dev For further details, see \"LToken\" section of whitepaper.\n * @custom:oz-upgrades-unsafe-allow external-library-linking\n * @custom:security-contact security@ledgity.com\n */\ncontract LToken is ERC20BaseUpgradeable, InvestUpgradeable, ERC20WrapperUpgradeable {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /// @dev Represents type of actions triggering ActivityEvent events.\n    enum Action {\n        Deposit,\n        Withdraw\n    }\n\n    /// @dev Represents different status of actions triggering ActivityEvent events.\n    enum Status {\n        Queued,\n        Cancelled,\n        Success\n    }\n\n    /**\n     * @notice Represents a withdrawal request in the queue.\n     * @dev A request fits in a single storage slot (32 bytes).\n     * @param account The account that initiated the request.\n     * @param amount The amount of underlying tokens requested.\n     */\n    struct WithdrawalRequest {\n        address account; // 20 bytes\n        uint96 amount; // 12 bytes\n    }\n\n    /// @notice Upper limit of retention rate.\n    uint32 private constant MAX_RETENTION_RATE_UD7x3 = 10 * 10 ** 3; // 10%\n\n    /// @notice Used in activity events to represent the absence of request ID.\n    int256 private constant NO_ID = -1;\n\n    /// @notice Holds a reference to the LDYStaking contract.\n    LDYStaking public ldyStaking;\n\n    /// @notice Holds address of withdrawer wallet (managed by withdrawal server).\n    address payable public withdrawer;\n\n    /// @notice Holds address of fund wallet (managed by Ledgity financial team).\n    address public fund;\n\n    /// @notice Holds the withdrawal fees rate in UD7x3 format (e.g., 350 = 0.350%).\n    uint32 public feesRateUD7x3;\n\n    /// @notice Holds the retention rate in UD7x3 format.\n    uint32 public retentionRateUD7x3;\n\n    /// @notice Holds the amount of withdrawal fees not yet claimed by contract's owner.\n    uint256 public unclaimedFees;\n\n    /// @notice Holds the amount of L-Tokens currently in the withdrawal queue.\n    uint256 public totalQueued;\n\n    /**\n     * @notice Holds the amount of underlying tokens considered as usable by the contract.\n     * @dev Are usable, only underlying tokens deposit through deposit() or fund() functions.\n     */\n    uint256 public usableUnderlyings;\n\n    /// @notice Holds an ordered list of active withdrawal requests.\n    WithdrawalRequest[] public withdrawalQueue;\n\n    /// @notice Holds the index of the next withdrawal request to process in the queue.\n    uint256 public withdrawalQueueCursor;\n\n    /**\n     * @notice Holds a list of all currently frozen withdrawal requests.\n     * @dev If a request emitter as been blacklisted, its request is moved here to prevent\n     * it from blocking the queue.\n     */\n    WithdrawalRequest[] public frozenRequests;\n\n    /**\n     * @notice Holds a list of contracts' references that are listening to L-Tokens transfers.\n     * @dev onLTokenTransfer() functions of those contracts will be called on each transfer.\n     */\n    ITransfersListener[] public transfersListeners;\n\n    /**\n     * @notice Emitted to inform listeners about a change in the contract's TVL.\n     * @dev TVL = realTotalSupply()\n     * @param newTVL The new TVL of the contract.\n     */\n    event TVLChangeEvent(uint256 newTVL);\n\n    /**\n     * @notice Emitted to inform listerners about an activity related to deposits and withdrawals.\n     * @param id ID of the involved withdrawal request or NO_ID (-1) if not applicable.\n     * @param account The account involved in the activity.\n     * @param action The type of activity.\n     * @param amount The amount of underlying tokens involved in the activity.\n     * @param newStatus The new status of the activity.\n     */\n    event ActivityEvent(\n        int256 indexed id,\n        address indexed account,\n        Action indexed action,\n        uint256 amount,\n        uint256 amountAfterFees,\n        Status newStatus\n    );\n\n    /**\n     * @notice Emitted to inform listeners that some rewards have been minted.\n     * @param account The account that received the rewards.\n     * @param balanceBefore The balance of the account before the minting.\n     * @param rewards The amount of minted rewards.\n     */\n    event MintedRewardsEvent(address indexed account, uint256 balanceBefore, uint256 rewards);\n\n    /// @notice Reverts if the function caller is not the withdrawer wallet.\n    modifier onlyWithdrawer() {\n        require(_msgSender() == withdrawer, \"L39\");\n        _;\n    }\n\n    /// @notice Reverts if the function caller is not the fund wallet.\n    modifier onlyFund() {\n        require(_msgSender() == fund, \"L40\");\n        _;\n    }\n\n    /**\n     * @notice Initializer function of the contract. It replaces the constructor()\n     * function in the context of upgradeable contracts.\n     * @dev See: https://docs.openzeppelin.com/contracts/4.x/upgradeable\n     * @param globalOwner_ The address of the GlobalOwner contract.\n     * @param globalPause_ The address of the GlobalPause contract.\n     * @param globalBlacklist_ The address of the GlobalBlacklist contract.\n     * @param underlyingToken The address of the underlying stablecoin ERC20 token.\n     */\n    function initialize(\n        address globalOwner_,\n        address globalPause_,\n        address globalBlacklist_,\n        address ldyStaking_,\n        address underlyingToken\n    ) public initializer {\n        // Retrieve underlying token metadata\n        // IERC20MetadataUpgradeable underlyingMetadata = IERC20MetadataUpgradeable(underlyingToken);\n        // // Initialize ancestors contracts\n        // __ERC20Base_init(\n        //     globalOwner_,\n        //     globalPause_,\n        //     globalBlacklist_,\n        //     string(abi.encodePacked(\"Ledgity \", underlyingMetadata.name())),\n        //     string(abi.encodePacked(\"L\", underlyingMetadata.symbol()))\n        // );\n        // __ERC20Wrapper_init(IERC20Upgradeable(underlyingToken));\n        // __Invest_init_unchained(address(this));\n        // // Set LDYStaking contract\n        // setLDYStaking(ldyStaking_);\n        // // Set initial withdrawal fees rate to 0.3%\n        // setFeesRate(300);\n        // // Set initial retention rate to 5%\n        // setRetentionRate(5000);\n        // // Set initial APR to 0%\n        // setAPR(0);\n        // // Default withdrawer and fund wallet to contract owner address. This prevents\n        // // any loss of funds if a deposit/withdrawal is made before those are manually set.\n        // setWithdrawer(payable(globalOwner_));\n        // setFund(payable(globalOwner_));\n    }\n\n    /**\n     * @notice Required override of decimals() which is implemented by both\n     * ERC20Upgradeable and ERC20WrapperUpgradeable parent contracts.\n     * @dev The ERC20WrapperUpgradeable version is preferred because it mirrors the\n     * decimals amount of the underlying stablecoin token.\n     * @inheritdoc ERC20WrapperUpgradeable\n     */\n    function decimals()\n        public\n        view\n        override(ERC20Upgradeable, ERC20WrapperUpgradeable)\n        returns (uint8)\n    {\n        return ERC20WrapperUpgradeable.decimals();\n    }\n\n    /**\n     * @notice Required override of paused() which is implemented by both\n     * GlobalPausableUpgradeable and ERC20BaseUpgradeable parent contracts.\n     * @dev Both version are the same as ERC20BaseUpgradeable.paused() mirrors\n     * GlobalPausableUpgradeable.paused(), so a random one is chosen.\n     * @inheritdoc GlobalPausableUpgradeable\n     */\n    function paused()\n        public\n        view\n        virtual\n        override(GlobalPausableUpgradeable, ERC20BaseUpgradeable)\n        returns (bool)\n    {\n        return GlobalPausableUpgradeable.paused();\n    }\n\n    /**\n     * @notice Updates the current withdrawal fee rate.\n     * @param feesRateUD7x3_ The new withdrawal fee rate in UD7x3 format.\n     */\n    function setFeesRate(uint32 feesRateUD7x3_) public onlyOwner {\n        feesRateUD7x3 = feesRateUD7x3_;\n    }\n\n    /**\n     * @notice Updates the current underlying token retention rate.\n     * @dev The retention rate is capped at 10%, which ensures that no more than 10% of\n     * deposited assets will ever be exposed in this contract (reduces attack surface).\n     * @param retentionRateUD7x3_ The new retention rate in UD7x3 format.\n     */\n    function setRetentionRate(uint32 retentionRateUD7x3_) public onlyOwner {\n        require(retentionRateUD7x3_ <= MAX_RETENTION_RATE_UD7x3, \"L41\");\n        retentionRateUD7x3 = retentionRateUD7x3_;\n    }\n\n    /**\n     * @notice Updates the address of LDYStaking contract.\n     * @param ldyStakingAddress The address of the new LDYStaking contract.\n     */\n    function setLDYStaking(address ldyStakingAddress) public onlyOwner {\n        ldyStaking = LDYStaking(ldyStakingAddress);\n    }\n\n    /**\n     * @notice Updates the address of the withdrawer wallet.\n     * @param withdrawer_ The address of the new withdrawer wallet.\n     */\n    function setWithdrawer(address payable withdrawer_) public onlyOwner {\n        // Ensure address is not the zero address (pre-processing fees would be lost else)\n        require(withdrawer_ != address(0), \"L63\");\n\n        // Set new withdrawer wallet's address\n        withdrawer = withdrawer_;\n    }\n\n    /**\n     * @notice Updates the address of the fund wallet.\n     * @param fund_ The address of the new fund wallet.\n     */\n    function setFund(address payable fund_) public onlyOwner {\n        // Ensure address is not the zero address (deposited tokens would be lost else)\n        require(fund_ != address(0), \"L64\");\n\n        // Set new fund wallet's address\n        fund = fund_;\n    }\n\n    /**\n     * @notice Adds a new contract to the L-Token transfers list.\n     * @dev Each time a transfer occurs, the onLTokenTransfer() function of the\n     * specified contract will be called.\n     * @dev IMPORTANT SECURITY NOTE: This method is not intended to be used with\n     * contracts that are not owned by the Ledgity team.\n     * @param listenerContract The address of the new transfers listener contract.\n     */\n    function listenToTransfers(address listenerContract) public onlyOwner {\n        transfersListeners.push(ITransfersListener(listenerContract));\n    }\n\n    /**\n     * @notice Removes a contract from the L-Token transfers list.\n     * @dev The onLTokenTransfer() function of the specified contract will not be called\n     * anymore each time a L-Token transfer occurs.\n     * @param listenerContract The address of the listener contract.\n     */\n    function unlistenToTransfers(address listenerContract) public onlyOwner {\n        // Find index of listener contract in transferListeners array\n        int256 index = -1;\n        uint256 transfersListenersLength = transfersListeners.length;\n        for (uint256 i = 0; i < transfersListenersLength; i++) {\n            if (address(transfersListeners[i]) == listenerContract) {\n                index = int256(i);\n                break;\n            }\n        }\n\n        // Revert if given contract wasn't listening to transfers\n        require(index > -1, \"L42\");\n\n        // Else, remove transfers listener contract from listeners array\n        transfersListeners[uint256(index)] = transfersListeners[transfersListenersLength - 1];\n        transfersListeners.pop();\n    }\n\n    /**\n     * @notice Retrieves the amount of given account's not yet minted rewards.\n     * @dev This is a public implementation of InvestUpgradeable_rewardsOf(). In the\n     * context of LToken, this function returns the amount of rewards that have not been\n     * distributed/minted yet to the specified account.\n     * @dev This is particularly useful for off-chain services to display charts and\n     * statistics, as seen in the Ledgity Yield's frontend.\n     * @param account The account to check the unminted rewards of.\n     * @return The amount of account's unminted rewards.\n     */\n    function unmintedRewardsOf(address account) public view returns (uint256) {\n        return _rewardsOf(account, true);\n    }\n\n    /**\n     * @notice Retrieves the \"real\" balance of an account, i.e., excluding its not yet\n     * minted/distributed rewards.\n     * @param account The account to check the real balance of.\n     * @return The real balance of the account.\n     */\n    function realBalanceOf(address account) public view returns (uint256) {\n        return super.balanceOf(account);\n    }\n\n    /**\n     * @notice Retrieves the total balance of L-Tokens that belong to the account.\n     * @dev This is an oOverride of ERC20Upgradeable.balanceOf() that rewards that have\n     * not been yet minted to the specified account.\n     * @param account The account to check the total balance of.\n     * @return The total balance of the account.\n     */\n    function balanceOf(address account) public view override returns (uint256) {\n        return realBalanceOf(account) + unmintedRewardsOf(account);\n    }\n\n    /**\n     * @notice Returns the \"real\" amount of existing L-Tokens, i.e., excluding not yet\n     * minted withdrawal fees and L-Tokens currently in the withdrawal queue.\n     * @return The real total supply of L-Tokens.\n     */\n    function realTotalSupply() public view returns (uint256) {\n        return super.totalSupply();\n    }\n\n    /**\n     * @notice Retrives the total supply of L-Tokens, including not yet minted withdrawal\n     * fees and L-Tokens currently in the withdrawal queue.\n     * @return The total supply of L-Tokens.\n     */\n    function totalSupply() public view override returns (uint256) {\n        return realTotalSupply() + totalQueued + unclaimedFees;\n    }\n\n    /**\n     * @notice Recovers a specified amount of a given token address.\n     * @dev This override of RecoverableUpgradeable.recoverERC20() prevents the recovered\n     * token from being the underlying token.\n     * @inheritdoc RecoverableUpgradeable\n     */\n    function recoverERC20(address tokenAddress, uint256 amount) public override onlyOwner {\n        // Ensure the token is not the underlying token\n        require(tokenAddress != address(underlying()), \"L43\");\n\n        // Proceed to recovery\n        super.recoverERC20(tokenAddress, amount);\n    }\n\n    /**\n     * @notice Recovers underlying tokens accidentally sent to the contract.\n     * @dev To prevent owner from being able to drain the contract, this function only\n     * allows recovering \"unusable\" underlying tokens, i.e., tokens that have not been\n     * sent through fund() or deposit() functions.\n     */\n    function recoverUnderlying() external onlyOwner {\n        // Compute the recoverable amount by taking the difference between the contract's\n        // balance and the amount of usable underlying tokens\n        uint256 recoverableAmount = underlying().balanceOf(address(this)) - usableUnderlyings;\n\n        // Revert if there is nothing to recover\n        require(recoverableAmount > 0, \"L44\");\n\n        // Else, proceed to underlying tokens recovery\n        super.recoverERC20(address(underlying()), recoverableAmount);\n    }\n\n    /**\n     * @notice Retrieves the amount of underlying tokens invested by the given account.\n     * @dev Implementing this function is required by the InvestUpgradeable contract. In\n     * LToken contract, the investment of an account is equal to its real balance.\n     * @inheritdoc InvestUpgradeable\n     */\n    function _investmentOf(address account) internal view override returns (uint256) {\n        return realBalanceOf(account);\n    }\n\n    /**\n     * @notice Distributes a specified amount of rewards (in L-Tokens) to a given account.\n     * @dev Implementing this function is required by the InvestUpgradeable contract so\n     * it can distribute rewards to accounts before each period reset.\n     * @dev InvestUpgradeable contract already ensure that amount > 0.\n     * @inheritdoc InvestUpgradeable\n     */\n    function _distributeRewards(address account, uint256 amount) internal override returns (bool) {\n        // Inform listeners of the rewards minting\n        emit MintedRewardsEvent(account, realBalanceOf(account), amount);\n\n        // Mint L-Tokens rewards to account\n        _mint(account, amount);\n\n        // Return true indicating to InvestUpgradeable that the rewards have been distributed\n        return true;\n    }\n\n    /**\n     * @notice Override of ERC20._beforeTokenTransfer() to integrate with InvestUpgradeable.\n     * @dev This overriden version ensure that _beforeInvestmentChange() hook is properly\n     * called each time an account's balance is going to change.\n     * @dev Note: whenNotPaused and notBlacklisted modifiers are not set as they are\n     * already included in ERC20BaseUpgradeable._beforeTokenTransfer().\n     * @inheritdoc ERC20BaseUpgradeable\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal override(ERC20Upgradeable, ERC20BaseUpgradeable) {\n        ERC20BaseUpgradeable._beforeTokenTransfer(from, to, amount);\n\n        // Invoke _beforeInvestmentChange() hook for non-zero accounts\n        if (from != address(0)) _beforeInvestmentChange(from, true);\n        if (to != address(0)) _beforeInvestmentChange(to, true);\n\n        // If some L-Token are being burned/minted, inform listeners of a TVL change\n        if (from == address(0) || to == address(0)) emit TVLChangeEvent(totalSupply());\n    }\n\n    /**\n     * @notice Override of ERC20._afterTokenTransfer() to notify all transfers listeners.\n     * @dev This overriden version will trigger onLTokenTransfer() functions of all\n     * transfers listeners.\n     * @dev Note: whenNotPaused and notBlacklisted modifiers are not set as they are\n     * already checked in _beforeTokenTransfer().\n     * @inheritdoc ERC20Upgradeable\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal override {\n        super._afterTokenTransfer(from, to, amount);\n\n        // Trigger onLTokenTransfer() functions of all the transfers listeners\n        for (uint256 i = 0; i < transfersListeners.length; i++) {\n            transfersListeners[i].onLTokenTransfer(from, to, amount);\n        }\n    }\n\n    /**\n     * @notice Computes the maximum amount of underlying tokens that should be retained\n     * by the contract (based on retention rate).\n     * @return amount The expected amount of retained underlying tokens.\n     */\n    function getExpectedRetained() public view returns (uint256 amount) {\n        // Cache invested token's decimals number\n        uint256 d = SUD.decimalsOf(address(invested()));\n\n        // Convert totalSupply and retentionRate to SUD\n        uint256 totalSupplySUD = SUD.fromAmount(totalSupply(), d);\n        uint256 retentionRateSUD = SUD.fromRate(retentionRateUD7x3, d);\n\n        // Compute and return expected retained amount\n        uint256 expectedRetainedSUD = (totalSupplySUD * retentionRateSUD) / SUD.fromInt(100, d);\n        return SUD.toAmount(expectedRetainedSUD, d);\n    }\n\n    /// @notice Transfers underlying tokens exceeding the retention rate to the fund wallet.\n    function _transferExceedingToFund() internal {\n        // Retrieve the expected amount retained\n        uint256 expectedRetained = getExpectedRetained();\n\n        // If usable underlyings are less than or equal to expected retained, return\n        if (usableUnderlyings <= expectedRetained) return;\n\n        // Else, exceeding amount is equal to difference between those values\n        uint256 exceedingAmount = usableUnderlyings - expectedRetained;\n\n        // Decrease usable underlyings amount accordingly\n        usableUnderlyings -= exceedingAmount;\n\n        // Transfer the exceeding amount to the fund wallet\n        underlying().safeTransfer(fund, exceedingAmount);\n    }\n\n    /**\n     * @notice Override of ERC20WrapperUpgradeable.withdrawTo() that reverts.\n     * Use instantWithdrawal() or requestWithdrawal() functions instead.\n     * @inheritdoc ERC20WrapperUpgradeable\n     */\n    function withdrawTo(address account, uint256 amount) public pure override returns (bool) {\n        account; // Silence unused variable compiler warning\n        amount;\n        revert(\"L45\");\n    }\n\n    /**\n     * @notice Override of ERC20WrapperUpgradeable.depositFor() that reverts.\n     * Use deposit() function instead.\n     * @inheritdoc ERC20WrapperUpgradeable\n     */\n    function depositFor(address account, uint256 amount) public pure override returns (bool) {\n        account; // Silence unused variable compiler warning\n        amount;\n        revert(\"L46\");\n    }\n\n    /**\n     * @notice Allows exchanging some underlying tokens for the same amount of L-Tokens.\n     * @param amount The amount of underlying tokens to deposit.\n     */\n    function deposit(uint256 amount) public whenNotPaused notBlacklisted(_msgSender()) {\n        // Ensure the account has enough underlying tokens to deposit\n        require(underlying().balanceOf(_msgSender()) >= amount, \"L47\");\n\n        // Update usable underlyings balance accordingly\n        usableUnderlyings += amount;\n\n        // Inform listeners of the deposit activity event\n        emit ActivityEvent(NO_ID, _msgSender(), Action.Deposit, amount, amount, Status.Success);\n\n        // Receive underlying tokens and mint L-Tokens to the account in a 1:1 ratio\n        super.depositFor(_msgSender(), amount);\n\n        // Transfer exceeding underlying tokens to the fund wallet\n        _transferExceedingToFund();\n    }\n\n    /**\n     * @notice Computes fees and net withdrawn amount for a given account withdrawing a\n     * given amount.\n     * @param account The account initiating the withdrawal.\n     * @param amount The amount of the withdrawal.\n     */\n    function getWithdrawnAmountAndFees(\n        address account,\n        uint256 amount\n    ) public view returns (uint256 withdrawnAmount, uint256 fees) {\n        // If the account is eligible to staking tier 2, no fees are applied\n        if (ldyStaking.tierOf(account) >= 2) return (amount, 0);\n\n        // Cache invested token's decimals number\n        uint256 d = SUD.decimalsOf(address(invested()));\n\n        // Convert amount and fees rate to SUD\n        uint256 amountSUD = SUD.fromAmount(amount, d);\n        uint256 feesRateSUD = SUD.fromRate(feesRateUD7x3, d);\n\n        // Compute fees and withdrawn amount (initial amount minus fees)\n        uint256 feesSUD = (amountSUD * feesRateSUD) / SUD.fromInt(100, d);\n        fees = SUD.toAmount(feesSUD, d);\n        withdrawnAmount = amount - fees;\n    }\n\n    /**\n     * @notice Allows instaneously exchanging a given amount of L-Tokens for the same\n     * amount of underlying tokens. It will fail if the contract currently doesn't hold\n     * enough underlying tokens to cover the withdrawal.\n     * @dev In order to save some gas and time to users, frontends should propose this\n     * function to users only when it has been verified that it will not revert. They\n     * should propose the requestWithdrawal() function otherwise.\n     * @param amount The amount L-Tokens to withdraw.\n     */\n    function instantWithdrawal(uint256 amount) external whenNotPaused notBlacklisted(_msgSender()) {\n        // Ensure the account has enough L-Tokens to withdraw\n        require(amount <= balanceOf(_msgSender()), \"L48\");\n\n        // Can the contract cover this withdrawal plus all already queued requests?\n        bool cond1 = totalQueued + amount <= usableUnderlyings;\n\n        // Is caller eligible to staking tier 2 and the contract can cover this withdrawal?\n        bool cond2 = ldyStaking.tierOf(_msgSender()) >= 2 && amount <= usableUnderlyings;\n\n        // Revert if conditions are not met for the withdrawal to be processed instantaneously\n        if (!(cond1 || cond2)) revert(\"L49\");\n\n        // Else, retrieve withdrawal fees and net withdrawn amount\n        (uint256 withdrawnAmount, uint256 fees) = getWithdrawnAmountAndFees(_msgSender(), amount);\n\n        // Increase unclaimed fees amount accordingly\n        unclaimedFees += fees;\n\n        // Decrease usable underlyings balance accordingly\n        usableUnderlyings -= withdrawnAmount;\n\n        // Inform listeners of this instant withdrawal activity event\n        emit ActivityEvent(\n            NO_ID,\n            _msgSender(),\n            Action.Withdraw,\n            amount,\n            withdrawnAmount,\n            Status.Success\n        );\n\n        // Burn withdrawal fees from the account\n        _burn(_msgSender(), fees);\n\n        // Burn account's withdrawn L-Tokens and transfer to it underlying tokens in a 1:1 ratio\n        super.withdrawTo(_msgSender(), withdrawnAmount);\n    }\n\n    /**\n     * @notice Allows requesting the exchange of a given amount of L-Tokens for the same\n     * amount of underlying tokens. The request will be automatically processed later.\n     * @dev The sender must attach 0.003 ETH to pre-pay the future processing gas fees\n     * paid by the withdrawer wallet.\n     * @param amount The amount L-Tokens to withdraw.\n     */\n    function requestWithdrawal(\n        uint256 amount\n    ) public payable whenNotPaused notBlacklisted(_msgSender()) {\n        // Ensure the account has enough L-Tokens to withdraw\n        require(amount <= balanceOf(_msgSender()), \"L53\");\n\n        // Ensure the requested amount doesn't overflow uint96\n        require(amount <= type(uint96).max, \"L54\");\n\n        // Ensure the sender attached the pre-paid processing gas fees\n        require(msg.value == 0.003 * 10 ** 18, \"L55\");\n\n        // Create withdrawal request data\n        WithdrawalRequest memory request = WithdrawalRequest({\n            account: _msgSender(),\n            amount: uint96(amount)\n        });\n\n        // Will hold the request ID\n        uint256 requestId;\n\n        // Append request to the withdrawal queue:\n        // - At the beginning, if account is eligible to staking tier 2 and cursor is not 0\n        if (ldyStaking.tierOf(_msgSender()) >= 2 && withdrawalQueueCursor > 0) {\n            withdrawalQueueCursor--;\n            requestId = withdrawalQueueCursor;\n            withdrawalQueue[requestId] = request;\n        }\n        // - At the end else\n        else {\n            withdrawalQueue.push(request);\n            requestId = withdrawalQueue.length - 1;\n        }\n\n        // Increase total amount queued accordingly\n        totalQueued += amount;\n\n        // Inform listeners of this new queued withdrawal activity event\n        emit ActivityEvent(\n            int256(requestId),\n            _msgSender(),\n            Action.Withdraw,\n            amount,\n            amount,\n            Status.Queued\n        );\n\n        // Burn withdrawal L-Tokens amount from account's balance\n        _burn(_msgSender(), amount);\n\n        // Forward pre-paid processing gas fees to the withdrawer wallet\n        (bool sent, ) = withdrawer.call{value: msg.value}(\"\");\n        require(sent, \"L56\");\n    }\n\n    /**\n     * @notice Processes queued withdrawal requests until there is else no more requests,\n     * else not enough underlying tokens to continue.\n     * @dev For further details, see \"LToken  > Withdrawals\" section of whitepaper.\n     */\n    function processQueuedRequests() external onlyWithdrawer whenNotPaused {\n        // Accumulators variables, will be written on-chain after the loop\n        uint256 cumulatedFees = 0;\n        uint256 cumulatedWithdrawnAmount = 0;\n        uint256 nextRequestId = withdrawalQueueCursor;\n\n        // Cache queue length to avoid multiple SLOADs and avoid infinite loop as big\n        // requests are increasing the queue length when moved at the end of the queue.\n        uint256 queueLength = withdrawalQueue.length;\n\n        // Iterate over requests to be processed\n        while (nextRequestId < queueLength) {\n            // Stop processing requests if there is not enough gas left to continue the\n            // loop and properly end the function call. This prevents an attacker from\n            // blocking the withdrawal processing by creating a ton of tiny requests so\n            // this function call cannot fit anymore in block gas limit.\n            if (gasleft() < 200_000) break;\n\n            // Retrieve request data\n            WithdrawalRequest memory request = withdrawalQueue[nextRequestId];\n\n            // Skip empty request (processed big requests or cancelled requests)\n            if (request.account == address(0)) {}\n            //\n            // If account has been blacklisted since request emission\n            else if (isBlacklisted(request.account)) {\n                // Remove request from queue\n                delete withdrawalQueue[nextRequestId];\n\n                // Append request in the frozen requests list\n                frozenRequests.push(request);\n            }\n            //\n            // Or if request is a big request, move it at the end of the queue for now.\n            // This request will be processed manually later using processBigQueuedRequest()\n            else if (request.amount > getExpectedRetained() / 2) {\n                // Remove request from queue\n                delete withdrawalQueue[nextRequestId];\n\n                // Append request at the end of the queue\n                withdrawalQueue.push(request);\n            }\n            //\n            // Else, continue request processing\n            else {\n                // Retrieve withdrawal fees and net withdrawn amount\n                (uint256 withdrawnAmount, uint256 fees) = getWithdrawnAmountAndFees(\n                    request.account,\n                    request.amount\n                );\n\n                // Break if the contract doesn't hold enough funds to cover the request\n                if (withdrawnAmount > usableUnderlyings - cumulatedWithdrawnAmount) break;\n\n                // Accumulate fees and withdrawn amount\n                cumulatedFees += fees;\n                cumulatedWithdrawnAmount += withdrawnAmount;\n\n                // Inform listeners of this queued withdrawal processing activity event\n                emit ActivityEvent(\n                    int256(nextRequestId),\n                    request.account,\n                    Action.Withdraw,\n                    request.amount,\n                    withdrawnAmount,\n                    Status.Success\n                );\n\n                // Remove request from queue\n                delete withdrawalQueue[nextRequestId];\n\n                // Transfer underlying tokens to account. Burning L-Tokens is not required\n                // as equestWithdrawal() already did it.\n                // Security note: Re-entrancy warning are disabled as the request has\n                // just been deleted from the queue, it will so be skipped if trying to\n                // process it again.\n                // slither-disable-next-line reentrancy-no-eth\n                underlying().safeTransfer(request.account, withdrawnAmount);\n            }\n\n            // Increment next request ID\n            nextRequestId++;\n        }\n\n        // Increase unclaimed fees by the amount of cumulated fees\n        unclaimedFees += cumulatedFees;\n\n        // Decrease usable underlyings by the cumulated amount of withdrawn underlyings\n        usableUnderlyings -= cumulatedWithdrawnAmount;\n\n        // Decrease total amount queued by the cumulated amount requested\n        totalQueued -= cumulatedWithdrawnAmount + cumulatedFees;\n\n        // Update new queue cursor\n        withdrawalQueueCursor = nextRequestId;\n    }\n\n    /**\n     * @notice Processes a given queued big withdrawal request (one that exceeds half of\n     * the retention rate).\n     * @dev In contrast to non-big requests processing, this function will uses to fund\n     * wallet's balance to fill the request. This allows processing requests that are\n     * greater than retention rate without having to exceed this rate on the contract.\n     * @param requestId The ID of the big request to process.\n     */\n    function processBigQueuedRequest(uint256 requestId) external onlyFund whenNotPaused {\n        // Retrieve request data\n        WithdrawalRequest memory request = withdrawalQueue[requestId];\n\n        // Ensure the request is active\n        require(request.account != address(0), \"L66\");\n\n        // Ensure the request emitter has not been blacklisted since request emission\n        require(!isBlacklisted(request.account), \"L50\");\n\n        // Ensure this is indeed a big request\n        require(request.amount > getExpectedRetained() / 2, \"L51\");\n\n        // Retrieve withdrawal fees and net withdrawn amount\n        (uint256 withdrawnAmount, uint256 fees) = getWithdrawnAmountAndFees(\n            request.account,\n            request.amount\n        );\n\n        // Ensure withdrawn amount can be covered by contract + fund wallet balances\n        uint256 fundBalance = underlying().balanceOf(fund);\n        require(withdrawnAmount <= usableUnderlyings + fundBalance, \"L52\");\n\n        // Increase amount of unclaimed fees accordingly\n        unclaimedFees += fees;\n\n        // Decrease total queued amount by request amount\n        totalQueued -= request.amount;\n\n        // Increment queue cursor if request was the next request to be processed\n        if (requestId == withdrawalQueueCursor) withdrawalQueueCursor++;\n\n        // Inform listeners of this queued withdrawal processing activity event\n        emit ActivityEvent(\n            int256(requestId),\n            request.account,\n            Action.Withdraw,\n            request.amount,\n            withdrawnAmount,\n            Status.Success\n        );\n\n        // Remove request from queue\n        delete withdrawalQueue[requestId];\n\n        // If fund wallet's balance can cover request, rely on it only\n        if (withdrawnAmount <= fundBalance) {\n            underlying().safeTransferFrom(_msgSender(), request.account, withdrawnAmount);\n        }\n        // Else, cover request from both fund wallet and contract balances\n        else {\n            // Compute amount missing from fund wallet to cover request\n            uint256 missingAmount = withdrawnAmount - fundBalance;\n\n            // Decrease usable amount of underlying tokens accordingly\n            usableUnderlyings -= missingAmount;\n\n            // Transfer entire fund balance to request's emitter\n            underlying().safeTransferFrom(_msgSender(), request.account, fundBalance);\n\n            // Transfer missing amount from contract balance to request emitter\n            underlying().safeTransfer(request.account, missingAmount);\n        }\n    }\n\n    /**\n     * @notice Cancels a given withdrawal request. The request emitter receive back its\n     * L-Tokens and no fees will be charged.\n     * @param requestId The ID of the withdrawal request to cancel.\n     */\n    function cancelWithdrawalRequest(\n        uint256 requestId\n    ) public whenNotPaused notBlacklisted(_msgSender()) {\n        // Retrieve request data\n        WithdrawalRequest memory request = withdrawalQueue[requestId];\n\n        // Ensure request belongs to caller\n        require(_msgSender() == request.account, \"L57\");\n\n        // Mint back L-Tokens to account\n        _mint(request.account, uint256(request.amount));\n\n        // Decrease total amount queued accordingly\n        totalQueued -= request.amount;\n\n        // Delete the withdrawal request from queue\n        delete withdrawalQueue[requestId];\n\n        // Inform listeners of this cancelled withdrawal request activity event\n        emit ActivityEvent(\n            int256(requestId),\n            request.account,\n            Action.Withdraw,\n            request.amount,\n            request.amount,\n            Status.Cancelled\n        );\n    }\n\n    /**\n     * @notice Used by the fund wallet to repatriate underlying tokens on the contract\n     * whenever those are required to fulfill some withdrawal requests.\n     * @dev The function will revert if repatriated amount makes the contract exceeding\n     * the retention rate.\n     * @param amount The amount of underlying tokens to repatriate.\n     */\n    function repatriate(uint256 amount) external onlyFund whenNotPaused {\n        // Ensure the fund wallet has enough funds to repatriate\n        require(amount <= underlying().balanceOf(fund), \"L58\");\n\n        // Calculate new contract usable balance\n        uint256 newBalance = usableUnderlyings + amount;\n\n        // Ensure the new balance doesn't exceed the retention rate\n        require(newBalance <= getExpectedRetained(), \"L59\");\n\n        // Increase usable underlyings amount by repatriated amount\n        usableUnderlyings += amount;\n\n        // Transfer amount from fund wallet to contract\n        underlying().safeTransferFrom(_msgSender(), address(this), amount);\n    }\n\n    /// @notice Used by owner to claim fees generated from successful withdrawal.\n    function claimFees() external onlyOwner {\n        // Ensure there are some fees to claim\n        require(unclaimedFees > 0, \"L60\");\n\n        // Ensure the contract holds enough underlying tokens to cover fees\n        require(usableUnderlyings >= unclaimedFees, \"L61\");\n\n        // Decrease usable underlyings amount accordingly\n        usableUnderlyings -= unclaimedFees;\n\n        // Store fees amount in memory and reset unclaimed fees amount\n        uint256 fees = unclaimedFees;\n        unclaimedFees = 0;\n\n        // Transfer unclaimed fees to owner\n        underlying().safeTransfer(owner(), fees);\n    }\n}\n"
    },
    "contracts/src/LTokenSignaler.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport {GlobalOwnableUpgradeable} from \"./abstracts/GlobalOwnableUpgradeable.sol\";\nimport {LToken} from \"./LToken.sol\";\n\n/**\n * @title LTokenSignaler\n * @author Lila Rest (lila@ledgity.com)\n * @dev This contract is used to signal a L-Token contract to the TheGraph subgraph\n * of the current chain. If the L-Token contract wasn't already indexed, it will\n * start being indexed after this signal. Else, the signal will be ignored.\n */\ncontract LTokenSignaler is Initializable, UUPSUpgradeable, GlobalOwnableUpgradeable {\n    /**\n     * @dev Emitted to inform subgraph of the existence of a new L-Token contract.\n     * @param lTokenAddress The address of the L-Token contract to signal\n     */\n    event LTokenSignalEvent(address indexed lTokenAddress);\n\n    /**\n     * @dev Prevents implementation contract from being initialized as recommended by\n     * OpenZeppelin.\n     * See: https://docs.openzeppelin.com/contracts/4.x/api/proxy#Initializable-_disableInitializers--\n     * @custom:oz-upgrades-unsafe-allow constructor\n     */\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @dev Replaces the constructor() function in context of an upgradeable contract.\n     * See: https://docs.openzeppelin.com/contracts/4.x/upgradeable\n     * @param globalOwner_ The address of the GlobalOwner contract\n     */\n    function initialize(address globalOwner_) public initializer {\n        __GlobalOwnable_init(globalOwner_);\n        __UUPSUpgradeable_init();\n    }\n\n    /**\n     * @dev Override of UUPSUpgradeable._authorizeUpgrade() function restricted to the global\n     * owner. Note that this function is called by the proxy contract while upgrading.\n     * @param newImplementation The address of the new implementation contract\n     */\n    function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}\n\n    /**\n     * @dev Signals a LToken contract to the TheGraph subgraph of the current chain.\n     * @param lTokenAddress The address of the LToken contract to signal\n     */\n    function signalLToken(address lTokenAddress) external onlyOwner {\n        // Signal the LToken contract\n        emit LTokenSignalEvent(lTokenAddress);\n    }\n}\n"
    }
  },
  "settings": {
    "evmVersion": "london",
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": ["ast"]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}
