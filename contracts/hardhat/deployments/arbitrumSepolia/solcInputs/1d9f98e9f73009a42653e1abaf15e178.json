{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable2Step.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./OwnableUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership} and {acceptOwnership}.\n *\n * This module is used through inheritance. It will make available all functions\n * from parent (Ownable).\n */\nabstract contract Ownable2StepUpgradeable is Initializable, OwnableUpgradeable {\n    function __Ownable2Step_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable2Step_init_unchained() internal onlyInitializing {\n    }\n    address private _pendingOwner;\n\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Returns the address of the pending owner.\n     */\n    function pendingOwner() public view virtual returns (address) {\n        return _pendingOwner;\n    }\n\n    /**\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\n        _pendingOwner = newOwner;\n        emit OwnershipTransferStarted(owner(), newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual override {\n        delete _pendingOwner;\n        super._transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev The new owner accepts the ownership transfer.\n     */\n    function acceptOwnership() public virtual {\n        address sender = _msgSender();\n        require(pendingOwner() == sender, \"Ownable2Step: caller is not the new owner\");\n        _transferOwnership(sender);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/interfaces/draft-IERC1822Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822ProxiableUpgradeable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/interfaces/IERC1967Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC1967.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC-1967: Proxy Storage Slots. This interface contains the events defined in the ERC.\n *\n * _Available since v4.8.3._\n */\ninterface IERC1967Upgradeable {\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Emitted when the beacon is changed.\n     */\n    event BeaconUpgraded(address indexed beacon);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/beacon/IBeaconUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeaconUpgradeable {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/ERC1967/ERC1967UpgradeUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeaconUpgradeable.sol\";\nimport \"../../interfaces/IERC1967Upgradeable.sol\";\nimport \"../../interfaces/draft-IERC1822Upgradeable.sol\";\nimport \"../../utils/AddressUpgradeable.sol\";\nimport \"../../utils/StorageSlotUpgradeable.sol\";\nimport \"../utils/Initializable.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n */\nabstract contract ERC1967UpgradeUpgradeable is Initializable, IERC1967Upgradeable {\n    function __ERC1967Upgrade_init() internal onlyInitializing {\n    }\n\n    function __ERC1967Upgrade_init_unchained() internal onlyInitializing {\n    }\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(AddressUpgradeable.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822ProxiableUpgradeable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\n            } catch {\n                revert(\"ERC1967Upgrade: new implementation is not UUPS\");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(AddressUpgradeable.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/UUPSUpgradeable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../interfaces/draft-IERC1822Upgradeable.sol\";\nimport \"../ERC1967/ERC1967UpgradeUpgradeable.sol\";\nimport \"./Initializable.sol\";\n\n/**\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\n *\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\n * `UUPSUpgradeable` with a custom implementation of upgrades.\n *\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\n *\n * _Available since v4.1._\n */\nabstract contract UUPSUpgradeable is Initializable, IERC1822ProxiableUpgradeable, ERC1967UpgradeUpgradeable {\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\n    address private immutable __self = address(this);\n\n    /**\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\n     * fail.\n     */\n    modifier onlyProxy() {\n        require(address(this) != __self, \"Function must be called through delegatecall\");\n        require(_getImplementation() == __self, \"Function must be called through active proxy\");\n        _;\n    }\n\n    /**\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\n     * callable on the implementing contract but not through proxies.\n     */\n    modifier notDelegated() {\n        require(address(this) == __self, \"UUPSUpgradeable: must not be called through delegatecall\");\n        _;\n    }\n\n    /**\n     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\n     * implementation. It is used to validate the implementation's compatibility when performing an upgrade.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\n     */\n    function proxiableUUID() external view virtual override notDelegated returns (bytes32) {\n        return _IMPLEMENTATION_SLOT;\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     *\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\n     */\n    function upgradeTo(address newImplementation) public virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, new bytes(0), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\n     * encoded in `data`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     *\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\n     * {upgradeTo} and {upgradeToAndCall}.\n     *\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\n     *\n     * ```solidity\n     * function _authorizeUpgrade(address) internal override onlyOwner {}\n     * ```\n     */\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20Upgradeable.sol\";\nimport \"./extensions/IERC20MetadataUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[45] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/ERC20Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20Upgradeable.sol\";\nimport \"../../../security/PausableUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev ERC20 token with pausable token transfers, minting and burning.\n *\n * Useful for scenarios such as preventing trades until the end of an evaluation\n * period, or having an emergency switch for freezing all token transfers in the\n * event of a large bug.\n *\n * IMPORTANT: This contract does not include public pause and unpause functions. In\n * addition to inheriting this contract, you must define both functions, invoking the\n * {Pausable-_pause} and {Pausable-_unpause} internal functions, with appropriate\n * access control, e.g. using {AccessControl} or {Ownable}. Not doing so will\n * make the contract unpausable.\n */\nabstract contract ERC20PausableUpgradeable is Initializable, ERC20Upgradeable, PausableUpgradeable {\n    function __ERC20Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __ERC20Pausable_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {ERC20-_beforeTokenTransfer}.\n     *\n     * Requirements:\n     *\n     * - the contract must not be paused.\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override {\n        super._beforeTokenTransfer(from, to, amount);\n\n        require(!paused(), \"ERC20Pausable: token transfer while paused\");\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20WrapperUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/ERC20Wrapper.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20Upgradeable.sol\";\nimport \"../utils/SafeERC20Upgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of the ERC20 token contract to support token wrapping.\n *\n * Users can deposit and withdraw \"underlying tokens\" and receive a matching number of \"wrapped tokens\". This is useful\n * in conjunction with other modules. For example, combining this wrapping mechanism with {ERC20Votes} will allow the\n * wrapping of an existing \"basic\" ERC20 into a governance token.\n *\n * _Available since v4.2._\n *\n * @custom:storage-size 51\n */\nabstract contract ERC20WrapperUpgradeable is Initializable, ERC20Upgradeable {\n    IERC20Upgradeable private _underlying;\n\n    function __ERC20Wrapper_init(IERC20Upgradeable underlyingToken) internal onlyInitializing {\n        __ERC20Wrapper_init_unchained(underlyingToken);\n    }\n\n    function __ERC20Wrapper_init_unchained(IERC20Upgradeable underlyingToken) internal onlyInitializing {\n        require(underlyingToken != this, \"ERC20Wrapper: cannot self wrap\");\n        _underlying = underlyingToken;\n    }\n\n    /**\n     * @dev See {ERC20-decimals}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        try IERC20MetadataUpgradeable(address(_underlying)).decimals() returns (uint8 value) {\n            return value;\n        } catch {\n            return super.decimals();\n        }\n    }\n\n    /**\n     * @dev Returns the address of the underlying ERC-20 token that is being wrapped.\n     */\n    function underlying() public view returns (IERC20Upgradeable) {\n        return _underlying;\n    }\n\n    /**\n     * @dev Allow a user to deposit underlying tokens and mint the corresponding number of wrapped tokens.\n     */\n    function depositFor(address account, uint256 amount) public virtual returns (bool) {\n        address sender = _msgSender();\n        require(sender != address(this), \"ERC20Wrapper: wrapper can't deposit\");\n        SafeERC20Upgradeable.safeTransferFrom(_underlying, sender, address(this), amount);\n        _mint(account, amount);\n        return true;\n    }\n\n    /**\n     * @dev Allow a user to burn a number of wrapped tokens and withdraw the corresponding number of underlying tokens.\n     */\n    function withdrawTo(address account, uint256 amount) public virtual returns (bool) {\n        _burn(_msgSender(), amount);\n        SafeERC20Upgradeable.safeTransfer(_underlying, account, amount);\n        return true;\n    }\n\n    /**\n     * @dev Mint wrapped token to cover any underlyingTokens that would have been transferred by mistake. Internal\n     * function that can be exposed with access control if desired.\n     */\n    function _recover(address account) internal virtual returns (uint256) {\n        uint256 value = _underlying.balanceOf(address(this)) - totalSupply();\n        _mint(account, value);\n        return value;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20PermitUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20PermitUpgradeable {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\nimport \"../extensions/IERC20PermitUpgradeable.sol\";\nimport \"../../../utils/AddressUpgradeable.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20Upgradeable {\n    using AddressUpgradeable for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20Upgradeable token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20Upgradeable token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Compatible with tokens that require the approval to be set to\n     * 0 before setting it to a non-zero value.\n     */\n    function forceApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20PermitUpgradeable token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20Upgradeable token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && AddressUpgradeable.isContract(address(token));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StorageSlotUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, `uint256`._\n * _Available since v4.9 for `string`, `bytes`._\n */\nlibrary StorageSlotUpgradeable {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable2Step.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable2Step.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./Ownable.sol\";\n\n/**\n * @dev Contract module which provides access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership} and {acceptOwnership}.\n *\n * This module is used through inheritance. It will make available all functions\n * from parent (Ownable).\n */\nabstract contract Ownable2Step is Ownable {\n    address private _pendingOwner;\n\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Returns the address of the pending owner.\n     */\n    function pendingOwner() public view virtual returns (address) {\n        return _pendingOwner;\n    }\n\n    /**\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\n        _pendingOwner = newOwner;\n        emit OwnershipTransferStarted(owner(), newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual override {\n        delete _pendingOwner;\n        super._transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev The new owner accepts the ownership transfer.\n     */\n    function acceptOwnership() public virtual {\n        address sender = _msgSender();\n        require(pendingOwner() == sender, \"Ownable2Step: caller is not the new owner\");\n        _transferOwnership(sender);\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/extensions/ERC20Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\nimport \"../../../utils/Context.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20Burnable is Context, ERC20 {\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n    function burnFrom(address account, uint256 amount) public virtual {\n        _spendAllowance(account, _msgSender(), amount);\n        _burn(account, amount);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Compatible with tokens that require the approval to be set to\n     * 0 before setting it to a non-zero value.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/src/abstracts/base/BaseUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.18;\n\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport {GlobalPausableUpgradeable} from \"../GlobalPausableUpgradeable.sol\";\nimport {GlobalOwnableUpgradeable} from \"../GlobalOwnableUpgradeable.sol\";\nimport {GlobalRestrictableUpgradeable} from \"../GlobalRestrictableUpgradeable.sol\";\nimport {RecoverableUpgradeable} from \"../RecoverableUpgradeable.sol\";\n\n/**\n * @title BaseUpgradeable\n * @author Lila Rest (https://lila.rest)\n * @custom:security-contact security@ledgity.com\n *\n * @notice This abstract contract acts as a base for numerous contracts in this codebase,\n * minimizing code repetition and enhancing readability and maintainability.\n *\n * @dev For further details, see \"Base\" section of whitepaper.\n * @custom:security-contact security@ledgity.com\n */\nabstract contract BaseUpgradeable is\n    Initializable,\n    UUPSUpgradeable,\n    GlobalOwnableUpgradeable,\n    GlobalPausableUpgradeable,\n    GlobalRestrictableUpgradeable,\n    RecoverableUpgradeable\n{\n    /**\n     * @notice Prevents implementation contract from being initialized as recommended by\n     * OpenZeppelin.\n     * @dev See: https://docs.openzeppelin.com/contracts/4.x/api/proxy#Initializable-_disableInitializers--\n     * @custom:oz-upgrades-unsafe-allow constructor\n     */\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @notice Initializer functions of the contract. They replace the constructor()\n     * function in the context of upgradeable contracts.\n     * @dev See: https://docs.openzeppelin.com/contracts/4.x/upgradeable\n     * @param globalOwner_ The address of the GlobalOwner contract.\n     * @param globalPause_ The address of the GlobalPause contract.\n     * @param globalBlacklist_ The address of the GlobalBlacklist contract.\n     */\n    function __Base_init(\n        address globalOwner_,\n        address globalPause_,\n        address globalBlacklist_\n    ) internal onlyInitializing {\n        __UUPSUpgradeable_init();\n        __GlobalOwnable_init(globalOwner_);\n        __Pausable_init();\n        __GlobalPausable_init_unchained(globalPause_);\n        __GlobalRestrictable_init_unchained(globalBlacklist_);\n        __Recoverable_init_unchained();\n    }\n\n    function __Base_init_unchained() internal onlyInitializing {}\n\n    /**\n     * @notice Override of UUPSUpgradeable._authorizeUpgrade() function restricted to\n     * global owner. It is called by the proxy contract during an upgrade.\n     * @param newImplementation The address of the new implementation contract.\n     */\n    function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add\n     * new variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/src/abstracts/base/ERC20BaseUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.18;\n\nimport {ERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport {ERC20PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20PausableUpgradeable.sol\";\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport \"./BaseUpgradeable.sol\";\nimport {GlobalPausableUpgradeable} from \"../GlobalPausableUpgradeable.sol\";\n\n/**\n * @title ERC20BaseUpgradeable\n * @author Lila Rest (https://lila.rest)\n * @custom:security-contact security@ledgity.com\n *\n * @notice This abstract contract is an extension of BaseUpgradeable intended to be used\n * as a base for ERC20 tokens contracts.\n *\n * @dev For further details, see \"ERC20BaseUpgradeable\" section of whitepaper.\n * @custom:security-contact security@ledgity.com\n */\nabstract contract ERC20BaseUpgradeable is\n    ERC20Upgradeable,\n    BaseUpgradeable,\n    ERC20PausableUpgradeable\n{\n    /**\n     * @notice Initializer functions of the contract. They replace the constructor()\n     * function in the context of upgradeable contracts.\n     * @dev See: https://docs.openzeppelin.com/contracts/4.x/upgradeable\n     * @param globalOwner_ The address of the GlobalOwner contract.\n     * @param globalPause_ The address of the GlobalPause contract.\n     * @param globalBlacklist_ The address of the GlobalBlacklist contract.\n     * @param name_ The display name of the token.\n     * @param symbol_ The symbol of the token.\n     */\n    function __ERC20Base_init(\n        address globalOwner_,\n        address globalPause_,\n        address globalBlacklist_,\n        string memory name_,\n        string memory symbol_\n    ) internal onlyInitializing {\n        __Base_init(globalOwner_, globalPause_, globalBlacklist_);\n        __ERC20_init(name_, symbol_);\n        __ERC20Pausable_init_unchained();\n    }\n\n    function __ERC20Base_init_unchained() internal onlyInitializing {}\n\n    /**\n     * @notice Required override of paused() which is implemented by both\n     * GlobalPausableUpgradeable and PausableUpgradeable parent contracts.\n     * The GlobalPausableUpgradeable version is preferred because it checks the pause\n     * state from the GlobalPause contract.\n     * @inheritdoc GlobalPausableUpgradeable\n     */\n    function paused()\n        public\n        view\n        virtual\n        override(GlobalPausableUpgradeable, PausableUpgradeable)\n        returns (bool)\n    {\n        return GlobalPausableUpgradeable.paused();\n    }\n\n    /**\n     * @dev Required override of _beforeTokenTransfer() which is implemented by both\n     * ERC20PausableUpgradeable and ERC20Upgradeable parent contracts.\n     * The ERC20PausableUpgradeable version is preferred because it also checks that\n     * the contract is not paused before allowing the transfer.\n     * @inheritdoc ERC20PausableUpgradeable\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    )\n        internal\n        virtual\n        override(ERC20PausableUpgradeable, ERC20Upgradeable)\n        whenNotPaused\n        notBlacklisted(from)\n        notBlacklisted(to)\n    {\n        ERC20PausableUpgradeable._beforeTokenTransfer(from, to, amount);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add\n     * new variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/src/abstracts/GlobalOwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.18;\n\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {GlobalOwner} from \"../GlobalOwner.sol\";\n\n/**\n * @title GlobalOwnableUpgradeable\n * @author Lila Rest (https://lila.rest)\n * @custom:security-contact security@ledgity.com\n *\n * @notice Derived contracts will inherit ownership from the specified GlobalOwner\n * contract (see GlobalOwner.sol). This design facilitates centralized management\n * of ownership for all the Ledgity Yield contracts.\n *\n * @dev Security measure:\n * The _globalOwner state must be set at initialization time and, for evident security\n * reasons, cannot be changed afterward.\n *\n * @dev For further details, see \"GlobalOwnableUpgradeable\" section of whitepaper.\n * @custom:security-contact security@ledgity.com\n */\nabstract contract GlobalOwnableUpgradeable is Initializable, OwnableUpgradeable {\n    /**\n     * @notice The GlobalOwner contract the ownership will be inherited from.\n     * @dev This state is private so derived contracts cannot change its value.\n     */\n    GlobalOwner private _globalOwner;\n\n    /**\n     * @notice Initializer functions of the contract. They replace the constructor()\n     * function in the context of upgradeable contracts.\n     * @dev See: https://docs.openzeppelin.com/contracts/4.x/upgradeable\n     * @param globalOwner_ The address of the GlobalOwner contract.\n     */\n    function __GlobalOwnable_init(address globalOwner_) internal onlyInitializing {\n        __GlobalOwnable_init_unchained(globalOwner_);\n        // Note: __Ownable_init() doesn't have to be called as the overriden owner()\n        // function no longer rely on the _owner state. Since __Ownable_init() only sets\n        // the initial _owner value, calling it would have no effect.\n    }\n\n    function __GlobalOwnable_init_unchained(address globalOwner_) internal onlyInitializing {\n        _globalOwner = GlobalOwner(globalOwner_);\n    }\n\n    /**\n     * @notice Retrieves the address of GlobalOwner contract.\n     * @return The address of the GlobalOwner contract.\n     */\n    function globalOwner() public view returns (address) {\n        return address(_globalOwner);\n    }\n\n    /**\n     * @notice Override of OwnableUpgradeable.owner() that retrieves the owner's address\n     * from the GlobalOwner contract instead.\n     * @return The address of the owner\n     */\n    function owner() public view override returns (address) {\n        return _globalOwner.owner();\n    }\n\n    /**\n     * @notice Override of OwnableUpgradeable.transferOwnership() that always reverts.\n     * Ownership is managed by the GlobalOwner contract and must be modified there.\n     */\n    function transferOwnership(address newOwner) public view override onlyOwner {\n        newOwner; // Silence unused variable compiler warning\n        revert(\"L8\");\n    }\n\n    /**\n     * @notice Override of OwnableUpgradeable.renounceOwnership() that always reverts.\n     * Ownership is managed by the GlobalOwner contract and must be modified there.\n     */\n    function renounceOwnership() public view override onlyOwner {\n        revert(\"L65\");\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add\n     * new variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/src/abstracts/GlobalPausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.18;\n\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport {GlobalPause} from \"../GlobalPause.sol\";\n\n/**\n * @title GlobalPausableUpgradeable\n * @author Lila Rest (https://lila.rest)\n * @custom:security-contact security@ledgity.com\n *\n * @notice Derived contracts will inherit a pause state from the specified GlobalPause\n * contract (see GlobalPause.sol). This design facilitates centralized management of\n * pause state for all the Ledgity Yield contracts.\n *\n * @dev Security measure\n * The _globalPause state must be set at initialization time and, for evident security\n * reasons, cannot be changed afterward.\n *\n * @dev For further details, see \"GlobalPausableUpgradeable\" section of whitepaper.\n * @custom:security-contact security@ledgity.com\n */\nabstract contract GlobalPausableUpgradeable is Initializable, PausableUpgradeable {\n    /**\n     * @notice The GlobalPause contract the pause state will be inherited from.\n     * @dev This state is private so derived contracts cannot change its value.\n     */\n    GlobalPause private _globalPause;\n\n    /**\n     * @notice Initializer functions of the contract. They replace the constructor()\n     * function in the context of upgradeable contracts.\n     * @dev See: https://docs.openzeppelin.com/contracts/4.x/upgradeable\n     * @param globalPause_ The address of the GlobalPause contract.\n     */\n    function __GlobalPausable_init(address globalPause_) internal onlyInitializing {\n        __Pausable_init();\n        __GlobalPausable_init_unchained(globalPause_);\n    }\n\n    function __GlobalPausable_init_unchained(address globalPause_) internal onlyInitializing {\n        _globalPause = GlobalPause(globalPause_);\n    }\n\n    /**\n     * @notice Retrieves the address of GlobalPause contract.\n     * @return The address of the GlobalPause contract.\n     */\n    function globalPause() public view returns (address) {\n        return address(_globalPause);\n    }\n\n    /**\n     * @notice Override of PausableUpgradeable.pause() that retrieves the pause state\n     * from the GlobalPause contract instead.\n     * @return Whether the contract is paused or not.\n     */\n    function paused() public view virtual override returns (bool) {\n        return _globalPause.paused();\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add\n     * new variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/src/abstracts/GlobalRestrictableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.18;\n\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {GlobalBlacklist} from \"../GlobalBlacklist.sol\";\n\n/**\n * @title GlobalRestrictableUpgradeable\n * @author Lila Rest (https://lila.rest)\n * @custom:security-contact security@ledgity.com\n *\n * @notice Derived contracts will inherit a blacklist state from the specified\n * GlobalBlacklist contract (see GlobalBlacklist.sol). This design facilitates\n * centralized management of a blacklist for all the Ledgity Yield contracts.\n *\n * @dev Security measure:\n * The _globalBlacklist state must be set at initialization time and, for evident\n * security reasons, cannot be changed afterward.\n *\n * @dev For further details, see \"GlobalRestrictableUpgradeable\" section of whitepaper.\n * @custom:security-contact security@ledgity.com\n */\nabstract contract GlobalRestrictableUpgradeable is Initializable {\n    /**\n     * @notice The GlobalBlacklist contract the blacklist state will be inherited from.\n     * @dev This state is private so derived contracts cannot change its value.\n     */\n    GlobalBlacklist private _globalBlacklist;\n\n    /**\n     * @notice Initializer functions of the contract. They replace the constructor()\n     * function in the context of upgradeable contracts.\n     * @dev See: https://docs.openzeppelin.com/contracts/4.x/upgradeable\n     * @param globalBlacklist_ The address of the GlobalBlacklist contract.\n     */\n    function __GlobalRestrictable_init(address globalBlacklist_) internal onlyInitializing {\n        __GlobalRestrictable_init_unchained(globalBlacklist_);\n    }\n\n    function __GlobalRestrictable_init_unchained(\n        address globalBlacklist_\n    ) internal onlyInitializing {\n        _globalBlacklist = GlobalBlacklist(globalBlacklist_);\n    }\n\n    /**\n     * @notice Retrieves the address of GlobalBlacklist contract.\n     * @return The address of the GlobalBlacklist contract.\n     */\n    function globalBlacklist() public view returns (address) {\n        return address(_globalBlacklist);\n    }\n\n    /**\n     * @notice Reverts if the given account is blacklisted by the GlobalBlacklist contract.\n     * @param account Address to verify.\n     */\n    modifier notBlacklisted(address account) {\n        require(isBlacklisted(account) == false, \"L9\");\n        _;\n    }\n\n    /**\n     * @notice Checks if the given account is blacklisted by the GlobalBlacklist contract.\n     * @param account Address to verify.\n     * @return Whether the account is blacklisted.\n     */\n    function isBlacklisted(address account) internal view returns (bool) {\n        return _globalBlacklist.isBlacklisted(account);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add\n     * new variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/src/abstracts/InvestUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.18;\n\n// Contracts\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {GlobalOwnableUpgradeable} from \"./GlobalOwnableUpgradeable.sol\";\nimport {GlobalPausableUpgradeable} from \"./GlobalPausableUpgradeable.sol\";\nimport {GlobalRestrictableUpgradeable} from \"./GlobalRestrictableUpgradeable.sol\";\nimport \"./base/BaseUpgradeable.sol\";\nimport {RecoverableUpgradeable} from \"../abstracts/RecoverableUpgradeable.sol\";\n\n// Libraries\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {APRHistory as APRH} from \"../libs/APRHistory.sol\";\nimport {SUD} from \"../libs/SUD.sol\";\n\n// Interfaces\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {IERC20MetadataUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\n\n/**\n * @title InvestUpgradeable\n * @author Lila Rest (https://lila.rest)\n * @custom:security-contact security@ledgity.com\n *\n * @notice Derived contracts are provided with utilities to manage an invested token,\n * users' investment periods, rewards calculations, virtual balances, and auto-compounding.\n *\n * @dev Intuition:\n * This contract primarily exists for code splitting and reusability. It unburdens the\n * LToken contract code, making it easier to understand and maintain.\n *\n * This contract is generic because it may be used in the LDYStaking contract in the future.\n *\n * @dev Definitions:\n * - Investment: The act of depositing or investing tokens into the contract.\n * - Investment period: Time between the last invested amount change and the present.\n * - Virtual balance: Temporary storage for account rewards, used when those can't be\n *                    distributed between investment periods.\n * - Rewards redirection: Mechanism allowing an account to redirect its rewards to another.\n *\n * @dev Derived contract must:\n *  - Set invested token during initialization\n *  - Implement _investmentOf() function\n *  - (optionally) Implement _distributeRewards() function\n *\n * @dev For further details, see \"InvestmentUpgradeable\" section of whitepaper.\n * @custom:security-contact security@ledgity.com\n */\nabstract contract InvestUpgradeable is BaseUpgradeable {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using APRH for APRH.Pack[];\n\n    /**\n     * @notice Represents an account's investment period.\n     * @param timestamp The timestamp of the most recent rewards distribution.\n     * @param ref The reference of the last APR checkpoint at that timestamp.\n     */\n    struct InvestmentPeriod {\n        uint40 timestamp; // Supports dates up to 20/02/36812\n        APRH.Reference ref;\n    }\n\n    /**\n     * @notice Represents the investment details of an account.\n     * @param period The current investment period of the account.\n     * @param virtualBalance May hold a part of account rewards until they are claimed.\n     */\n    struct AccountDetails {\n        InvestmentPeriod period;\n        uint256 virtualBalance;\n    }\n\n    /// @notice Holds a reference to the invested token's contract.\n    IERC20Upgradeable private _invested;\n\n    /// @notice Holds investment details of each account.\n    mapping(address => AccountDetails) internal accountsDetails;\n\n    /// @notice Holds an history of the APR value over time (see APRHistory.sol).\n    APRH.Pack[] private _aprHistory;\n\n    /// @notice Holds active rewards redirections in both from->to and to->from[] ways.\n    mapping(address => address) public rewardsRedirectsFromTo;\n    mapping(address => address[]) public rewardsRedirectsToFrom;\n\n    /// @notice Is used to prevent infinite loop in _beforeInvestmentChange().\n    bool private _isClaiming;\n\n    /**\n     * @notice Emitted to inform listeners about a change in the APR's value.\n     * @param newAPRUD7x3 The new APR in UD7x3 format.\n     */\n    event APRChangeEvent(uint16 newAPRUD7x3);\n\n    /**\n     * @notice Initializer functions of the contract. They replace the constructor()\n     * function in the context of upgradeable contracts.\n     * @dev See: https://docs.openzeppelin.com/contracts/4.x/upgradeable\n     * @param globalOwner_ The address of the GlobalOwner contract.\n     * @param globalPause_ The address of the GlobalPause contract.\n     * @param globalBlacklist_ The address of the GlobalBlacklist contract.\n     * @param invested_ The address of the invested token contract.\n     */\n    function __Invest_init(\n        address globalOwner_,\n        address globalPause_,\n        address globalBlacklist_,\n        address invested_\n    ) internal onlyInitializing {\n        __Base_init(globalOwner_, globalPause_, globalBlacklist_);\n        __Invest_init_unchained(invested_);\n    }\n\n    function __Invest_init_unchained(address invested_) internal onlyInitializing {\n        // Set invested token\n        _invested = IERC20Upgradeable(invested_);\n\n        // Define initial APR to 0%. This would prevent getAPR() from reverting because\n        // of an empty APR history\n        _aprHistory.setAPR(0);\n    }\n\n    /**\n     * @notice Retrieves the reference to the invested token contract.\n     * @return The reference to the invested token contract.\n     */\n    function invested() public view returns (IERC20Upgradeable) {\n        return _invested;\n    }\n\n    /**\n     * @notice Updates the investment APR. Restricted to owner.\n     * @param aprUD7x3 The new APR in UD7x3 format.\n     */\n    function setAPR(uint16 aprUD7x3) public onlyOwner {\n        _aprHistory.setAPR(aprUD7x3);\n        emit APRChangeEvent(aprUD7x3);\n    }\n\n    /**\n     * @notice Retrieves the most recently set APR.\n     * @return The current APR in UD7x3 format.\n     */\n    function getAPR() public view returns (uint16) {\n        return _aprHistory.getAPR();\n    }\n\n    /**\n     * @notice Enables redirection of rewards from one account to another.\n     * @param from The address of the account to redirect rewards from.\n     * @param to The address of the account to redirect rewards to.\n     */\n    function startRewardsRedirection(\n        address from,\n        address to\n    ) public whenNotPaused notBlacklisted(from) notBlacklisted(to) {\n        // Ensure the address is not already redirecting rewards\n        require(rewardsRedirectsFromTo[from] == address(0), \"L62\");\n\n        // Ensure neither 'from' nor 'to' are the zero address\n        require(from != address(0), \"L12\");\n        require(to != address(0), \"L13\");\n\n        // Ensure 'from' and 'to' addresses are distinct\n        require(from != to, \"L14\");\n\n        // Ensure function caller is either the owner or the 'from' address\n        require(_msgSender() == owner() || _msgSender() == from, \"L15\");\n\n        // Distribute current rewards and reset investment periods of both accounts\n        _beforeInvestmentChange(from, true);\n        _beforeInvestmentChange(to, true);\n\n        // Activate rewards redirection\n        rewardsRedirectsFromTo[from] = to;\n        rewardsRedirectsToFrom[to].push(from);\n    }\n\n    /**\n     * @notice Disable an active rewards redirection.\n     * @param from The address of the account to stop redirecting rewards from.\n     * @param to The address of the account to stop redirecting rewards to.\n     */\n    function stopRewardsRedirection(\n        address from,\n        address to\n    ) public whenNotPaused notBlacklisted(from) notBlacklisted(to) {\n        // Ensure neither 'from' nor 'to' are the zero address\n        require(from != address(0), \"L16\");\n        require(to != address(0), \"L17\");\n\n        // Ensure function caller is either the owner or the 'from' address\n        require(_msgSender() == owner() || _msgSender() == from, \"L18\");\n\n        // Ensure a rewards redirection was active\n        require(rewardsRedirectsFromTo[from] == to, \"L19\");\n\n        // Distribute current rewards and reset investment periods of both accounts\n        _beforeInvestmentChange(from, true);\n        _beforeInvestmentChange(to, true);\n\n        // Retrieve 'from' index in the redirection array of 'to'\n        int256 fromIndex = -1;\n        for (uint256 i = 0; i < rewardsRedirectsToFrom[to].length; i++) {\n            if (rewardsRedirectsToFrom[to][i] == from) {\n                fromIndex = int256(i);\n                break;\n            }\n        }\n\n        // fromIndex should never be -1 at this point\n        assert(fromIndex >= 0);\n\n        // Deactivate rewards redirection\n        rewardsRedirectsFromTo[from] = address(0);\n        rewardsRedirectsToFrom[to][uint256(fromIndex)] = rewardsRedirectsToFrom[to][\n            rewardsRedirectsToFrom[to].length - 1\n        ];\n        rewardsRedirectsToFrom[to].pop();\n    }\n\n    /**\n     * @notice Retrieves the total amount of tokens invested by the given account.\n     * @dev Derived contracts must implement this function.\n     * @param account The account to get the investment of.\n     * @return The total amount of tokens invested by the given account.\n     */\n    function _investmentOf(address account) internal view virtual returns (uint256);\n\n    /**\n     * @notice Distributes a specified amount of rewards to a given account.\n     * @dev Derived contracts may optionally implement this function.\n     * @dev Implementations must return true to indicate a successful distribution, and\n     * false otherwise. If it returns false, the rewards will be added to the account's\n     * virtual balance, in order to be claimed later.\n     * @param account The account to claim the rewards of.\n     * @param amount The amount of rewards to claim.\n     * @return Whether the rewards distribution was successfull.\n     */\n    function _distributeRewards(address account, uint256 amount) internal virtual returns (bool) {\n        account; // Silence unused variables warning\n        amount;\n        return false;\n    }\n\n    /**\n     * @notice Computes the rewards accrued over a specified period of time, based on a\n     * given APR and amount of invested tokens.\n     * @dev For further details, see \"InvestUpgradeable > Rewards calculation\" section of\n     * the whitepaper.\n     * @param beginTimestamp The moment the period commenced.\n     * @param endTimestamp The moment the period concluded.\n     * @param aprUD7x3 The APR during this period, in UD7x3 format.\n     * @param investedAmount The amount of tokens deposited/invested during the period.\n     * @return The amount of rewards generated during the period.\n     */\n    function _calculatePeriodRewards(\n        uint40 beginTimestamp,\n        uint40 endTimestamp,\n        uint16 aprUD7x3,\n        uint256 investedAmount\n    ) internal view returns (uint256) {\n        // Cache invested token's decimals number\n        uint256 d = SUD.decimalsOf(address(invested()));\n\n        // Compute the number of elapsed years\n        uint256 elapsedTimeSUD = SUD.fromInt(endTimestamp - beginTimestamp, d);\n        uint256 elapsedYearsSUD = (elapsedTimeSUD * SUD.fromInt(1, d)) / SUD.fromInt(365 days, d);\n\n        // Compute the growth in invested amount (thanks to rewards)\n        uint256 aprSUD = SUD.fromRate(aprUD7x3, d);\n        uint256 growthSUD = (elapsedYearsSUD * aprSUD) / SUD.fromInt(1, d);\n\n        // Compute and return the rewards\n        uint256 investedAmountSUD = SUD.fromAmount(investedAmount, d);\n        uint256 rewardsSUD = (investedAmountSUD * growthSUD) / SUD.fromInt(100, d);\n        return SUD.toAmount(rewardsSUD, d);\n    }\n\n    /**\n     * @notice Computes the sum of given account's invested amount, plus invested amount\n     * of all accounts that recursively redirect rewards to this account.\n     * @param account The account to calculate the deep investment of.\n     * @return deepInvestedAmount The deep invested amount.\n     */\n    function _deepInvestmentOf(address account) internal view returns (uint256 deepInvestedAmount) {\n        // Consider account's direct investment\n        deepInvestedAmount += _investmentOf(account);\n\n        // But also the deep investments of all accounts redirecting rewards to this account\n        for (uint256 i = 0; i < rewardsRedirectsToFrom[account].length; i++) {\n            deepInvestedAmount += _deepInvestmentOf(rewardsRedirectsToFrom[account][i]);\n        }\n    }\n\n    /**\n     * @notice Computes the amount of unclaimed/undistributed rewards of a given account.\n     * @dev For further details, see \"InvestUpgradeable > Rewards calculation\" section of\n     * the whitepaper.\n     * @param account The account to calculate the unclaimed rewards of.\n     * @param autocompound Whether to autocompound the rewards between APR checkpoints.\n     * @return rewards The amount of unclaimed/undistributed rewards of the given account.\n     */\n    function _rewardsOf(\n        address account,\n        bool autocompound\n    ) internal view returns (uint256 rewards) {\n        // Retrieve account's investment details\n        AccountDetails memory details = accountsDetails[account];\n\n        // Retrieve account's deep invested amount\n        uint256 investedAmount = _deepInvestmentOf(account);\n\n        // Return 0 if the account has never invested or has no invested amount\n        if (details.period.timestamp == 0 || investedAmount == 0) return 0;\n\n        // Retrieve reference and data of APR checkpoint at which started investment period\n        APRH.Reference memory currRef = details.period.ref;\n        APRH.CheckpointData memory currCheckpoint = _aprHistory.getDataFromReference(currRef);\n\n        // Retrieve reference of latest APR checkpoint\n        APRH.Reference memory latestRef = _aprHistory.getLatestReference();\n\n        // 1) Fill rewards with virtual balance (rewards not claimed/distributed yet)\n        // See \"InvestUpgradeable > Yield calculation > 1)\" section of the whitepaper\n        rewards = details.virtualBalance;\n\n        // If start checkpoint is not the latest one\n        if (!APRH.eq(currRef, latestRef)) {\n            // Retrieve reference and data of APR checkpoint that comes after start checkpoint\n            APRH.Reference memory nextRef = APRH.incrementReference(currRef);\n            APRH.CheckpointData memory nextCheckpoint = _aprHistory.getDataFromReference(nextRef);\n\n            // 2) Calculate rewards from investment period start to next checkpoint\n            // See \"InvestUpgradeable > Yield calculation > 2)\" section of the whitepaper\n            rewards += _calculatePeriodRewards(\n                details.period.timestamp,\n                nextCheckpoint.timestamp,\n                currCheckpoint.aprUD7x3,\n                investedAmount + (autocompound ? rewards : 0)\n            );\n\n            // 3) Calculate rewards for each crossed pair of checkpoints\n            // See \"InvestUpgradeable > Yield calculation > 3)\" section of the whitepaper\n            while (true) {\n                // Set next checkpoint as the current one\n                currRef = nextRef;\n                currCheckpoint = nextCheckpoint;\n\n                // Break if current checkpoint is the latest one\n                if (APRH.eq(currRef, latestRef)) break;\n\n                // Else, retrieve the new next checkpoint\n                nextRef = APRH.incrementReference(currRef);\n                nextCheckpoint = _aprHistory.getDataFromReference(nextRef);\n\n                // Calculate rewards between the current pair of checkpoints\n                rewards += _calculatePeriodRewards(\n                    currCheckpoint.timestamp,\n                    nextCheckpoint.timestamp,\n                    currCheckpoint.aprUD7x3,\n                    investedAmount + (autocompound ? rewards : 0)\n                );\n            }\n\n            // 4) Calculate rewards from the latest checkpoint to now\n            // See \"InvestUpgradeable > Yield calculation > 4)\" section of the whitepaper\n            rewards += _calculatePeriodRewards(\n                currCheckpoint.timestamp,\n                uint40(block.timestamp),\n                currCheckpoint.aprUD7x3,\n                investedAmount + (autocompound ? rewards : 0)\n            );\n        } else {\n            // 2.bis) Calculate rewards from investment period start to now\n            // See \"InvestUpgradeable > Yield calculation > 2.bis)\" section of the whitepaper\n            rewards += _calculatePeriodRewards(\n                details.period.timestamp,\n                uint40(block.timestamp),\n                currCheckpoint.aprUD7x3,\n                investedAmount + (autocompound ? rewards : 0)\n            );\n        }\n    }\n\n    /**\n     * @notice Recursively resets the investment period of the specified account and of\n     * all accounts that directly or indirectly redirect rewards to this account.\n     * @param account The account to deeply reset the investment period of.\n     */\n    function _deepResetInvestmentPeriodOf(address account) internal {\n        // Reset account investment period timestamp and APR checkpoint to latest ones\n        accountsDetails[account].period.timestamp = uint40(block.timestamp);\n        accountsDetails[account].period.ref = _aprHistory.getLatestReference();\n\n        // Also reset the ones of all accounts that recursively redirect rewards to this account\n        for (uint256 i = 0; i < rewardsRedirectsToFrom[account].length; i++) {\n            _deepResetInvestmentPeriodOf(rewardsRedirectsToFrom[account][i]);\n        }\n    }\n\n    /**\n     * @notice Hook to be invoked before the invested amount of an account changes. It\n     * ensures that rewards are distributed and that account's investment period is reset.\n     * @param account The account whose invested amount is going to change.\n     * @param autocompound Whether to autocompound the rewards between APR checkpoints.\n     */\n    function _beforeInvestmentChange(address account, bool autocompound) internal {\n        // This hook is called inside LToken._beforeTokenTransfer() and as new tokens are\n        // minted in LToken._distributeRewards(), this guards against infinite loop.\n        if (_isClaiming) return;\n\n        // LToken._beforeTokenTransfer() calls this hook for both involved addresses.\n        // As first call will treat both addresses, the second call would be redundant.\n        // Therefore, we skip accounts already processed in this block to save up some gas.\n        if (accountsDetails[account].period.timestamp == uint40(block.timestamp)) return;\n\n        // If account redirects its rewards\n        address redirectRewardsTo = rewardsRedirectsFromTo[account];\n        if (redirectRewardsTo != address(0)) {\n            // Call hook on redirection target (this will indirectly reset the investment\n            // of this source account) and return\n            _beforeInvestmentChange(redirectRewardsTo, autocompound);\n            return;\n        }\n\n        // Else, compute account's undistributed/unclaimed rewards\n        uint256 rewards = _rewardsOf(account, autocompound);\n\n        // If there are some rewards\n        if (rewards > 0) {\n            // Try to distribute rewards to account\n            _isClaiming = true;\n            bool distributed = _distributeRewards(account, rewards);\n            _isClaiming = false;\n\n            // If rewards have not been distributed, accumulate them in account's virtual balance\n            if (!distributed) accountsDetails[account].virtualBalance = rewards;\n        }\n\n        // Finally, deeply reset investment period of the account\n        _deepResetInvestmentPeriodOf(account);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add\n     * new variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/src/abstracts/RecoverableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.18;\n\n// Conracts\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {GlobalOwnableUpgradeable} from \"./GlobalOwnableUpgradeable.sol\";\n\n// Libraries\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\n// Interfaces\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\n/**\n * @title RecoverableUpgradeable\n * @author Lila Rest (https://lila.rest)\n * @custom:security-contact security@ledgity.com\n *\n * @notice Derived contracts are provided with helper functions allowing the recovery of\n * assets accidentally sent to them.\n *\n * @dev Where are utilities Ether, ERC721, etc.?\n * This abstract contract currently supports only ERC20 tokens. Derived contracts\n * in this codebase currently do not implement the necessary functions to receive Ether\n * or ERC721/ERC1155 tokens, so no recovery functions are provided for these assets.\n *\n * @dev For further details, see \"RecoverableUpgradeable\" section of whitepaper.\n * @custom:security-contact security@ledgity.com\n */\nabstract contract RecoverableUpgradeable is Initializable, GlobalOwnableUpgradeable {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /**\n     * @notice Initializer functions of the contract. They replace the constructor()\n     * function in the context of upgradeable contracts.\n     * @dev See: https://docs.openzeppelin.com/contracts/4.x/upgradeable\n     * @param globalOwner_ The address of the GlobalOwner contract.\n     */\n    function __Recoverable_init(address globalOwner_) internal onlyInitializing {\n        __GlobalOwnable_init(globalOwner_);\n        __Recoverable_init_unchained();\n    }\n\n    function __Recoverable_init_unchained() internal onlyInitializing {}\n\n    /**\n     * @notice Recovers a specified amount of a given token address. Will fail if the\n     * contract doesn't hold enough tokens.\n     * @param tokenAddress The address of the token to recover.\n     * @param amount The amount of token to recover.\n     */\n    function recoverERC20(address tokenAddress, uint256 amount) public virtual onlyOwner {\n        // Ensure the specified amount is not zero\n        require(amount > 0, \"L10\");\n\n        // Create a reference to token's contract\n        IERC20Upgradeable tokenContract = IERC20Upgradeable(tokenAddress);\n\n        // Ensure there is enough token to recover\n        require(tokenContract.balanceOf(address(this)) >= amount, \"L11\");\n\n        // Transfer the recovered token amount to the sender\n        tokenContract.safeTransfer(_msgSender(), amount);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add\n     * new variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/src/GenericERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.18;\n\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {ERC20Burnable} from \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\n\n/**\n * @notice Used for testing purposes only, and used to generate ABIs for Wagmi contracts calls.\n * It represents:\n * - a FIAT-based stablecoin when used to test the LToken contract,\n * - the $LDY token when used to test the LDYStaking contract.\n * This contract accept decimals as constructor argument, so it can be used to to\n * easily test different decimals scenarios.\n */\ncontract GenericERC20 is ERC20, ERC20Burnable {\n    uint8 private _decimals;\n\n    constructor(string memory name, string memory symbol, uint8 decimals_) ERC20(name, symbol) {\n        _decimals = decimals_;\n    }\n\n    function mint(uint256 amount) public {\n        _mint(msg.sender, amount);\n    }\n\n    function decimals() public view virtual override returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * Used in tests to test different decimals scenarios.\n     */\n    function setDecimals(uint8 decimals_) public {\n        _decimals = decimals_;\n    }\n}\n"
    },
    "contracts/src/GlobalBlacklist.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.18;\n\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport {GlobalOwnableUpgradeable} from \"./abstracts/GlobalOwnableUpgradeable.sol\";\n\n/**\n * @title GlobalBlacklist\n * @author Lila Rest (https://lila.rest)\n * @custom:security-contact security@ledgity.com\n *\n * @notice Holds a global mapping of blacklisted accounts shared by all contracts of the\n * Ledgity Yield codebase.\n *\n * @dev Specifically, some contracts within the codebase inherit from the\n * GlobalRestrictableUpgradeable abstract contract. This provides them with modifiers\n * and getter functions to easily check against this global blacklist.\n *\n * @dev For further details, see \"GlobalBlacklist\" section of whitepaper.\n * @custom:security-contact security@ledgity.com\n */\ncontract GlobalBlacklist is Initializable, UUPSUpgradeable, GlobalOwnableUpgradeable {\n    /**\n     * @notice Mapping of accounts to their blacklist status.\n     * @dev This mapping is made private and isBlacklisted() should be used instead.This\n     * helps saving gas in some scenario. See isBlacklisted() documentation for more details.\n     */\n    mapping(address => bool) private _list;\n\n    /// @dev Emitted when `account` is blacklisted.\n    event Blacklisted(address account);\n\n    /// @dev Emitted when `account` is unblacklisted.\n    event Unblacklisted(address account);\n\n    /**\n     * @notice Prevents implementation contract from being initialized as recommended by\n     * OpenZeppelin.\n     * @dev See: https://docs.openzeppelin.com/contracts/4.x/api/proxy#Initializable-_disableInitializers--\n     * @custom:oz-upgrades-unsafe-allow constructor\n     */\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @notice Initializer function of the contract. It replaces the constructor()\n     * function in the context of upgradeable contracts.\n     * @dev See: https://docs.openzeppelin.com/contracts/4.x/upgradeable\n     * @param globalOwner_ The address of the GlobalOwner contract.\n     */\n    function initialize(address globalOwner_) public initializer {\n        __GlobalOwnable_init(globalOwner_);\n        __UUPSUpgradeable_init();\n    }\n\n    /**\n     * @notice Override of UUPSUpgradeable._authorizeUpgrade() function restricted to\n     * global owner. It is called by the proxy contract during an upgrade.\n     * @param newImplementation The address of the new implementation contract.\n     */\n    function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}\n\n    /**\n     * @notice Adds a given account to the blacklist.\n     * @param account The account's address to be blacklisted.\n     */\n    function blacklist(address account) external onlyOwner {\n        require(account != address(0), \"L20\");\n        _list[account] = true;\n        emit Blacklisted(account);\n    }\n\n    /**\n     * @notice Removes a given account from the blacklist.\n     * @param account The account's address to be un-blacklisted.\n     */\n    function unBlacklist(address account) external onlyOwner {\n        _list[account] = false;\n        emit Unblacklisted(account);\n    }\n\n    /**\n     * @notice Checks whether a given account is blacklisted.\n     * @param account Address of the account to check.\n     * @return 'true' if the account is blacklisted, 'false' otherwise\n     */\n    function isBlacklisted(address account) external view returns (bool) {\n        // Gas optimization: Avoid accessing storage if account is the zero address\n        // (e.g, during a mint or a burn of tokens)\n        if (account == address(0)) return false;\n\n        // Else, return current account's blacklist status\n        return _list[account];\n    }\n}\n"
    },
    "contracts/src/GlobalOwner.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.18;\n\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport {Ownable2StepUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\n\n/**\n * @title GlobalOwner\n * @author Lila Rest (https://lila.rest)\n * @custom:security-contact security@ledgity.com\n *\n * @notice Holds the address of a global owner account shared by all contracts of the\n * Ledgity Yield's codebase.\n *\n * @dev Specifically, some contracts within the codebase inherit from the\n * GlobalOwnableUpgradeable abstract contract. This provides them with an overriden\n * owner() function that retrieves the owner's address from this contract instead.\n *\n * @dev For further details, see \"GlobalOwner\" section of whitepaper.\n * @custom:security-contact security@ledgity.com\n */\ncontract GlobalOwner is Initializable, UUPSUpgradeable, Ownable2StepUpgradeable {\n    /**\n     * @notice Prevents implementation contract from being initialized as recommended by\n     * OpenZeppelin.\n     * @dev See: https://docs.openzeppelin.com/contracts/4.x/api/proxy#Initializable-_disableInitializers--\n     * @custom:oz-upgrades-unsafe-allow constructor\n     */\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @notice Initializer function of the contract. It replaces the constructor()\n     * function in the context of upgradeable contracts.\n     * @dev See: https://docs.openzeppelin.com/contracts/4.x/upgradeable\n     */\n    function initialize() public initializer {\n        __Ownable2Step_init();\n        __UUPSUpgradeable_init();\n    }\n\n    /**\n     * @notice Override of UUPSUpgradeable._authorizeUpgrade() function restricted to\n     * global owner. It is called by the proxy contract during an upgrade.\n     * @param newImplementation The address of the new implementation contract.\n     */\n    function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}\n}\n"
    },
    "contracts/src/GlobalPause.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.18;\n\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport {GlobalOwnableUpgradeable} from \"./abstracts/GlobalOwnableUpgradeable.sol\";\n\n/**\n * @title GlobalPause\n * @author Lila Rest (https://lila.rest)\n * @custom:security-contact security@ledgity.com\n *\n * @notice Holds a global pause state shared by all contracts of the Ledgity Yield\n * codebase.\n *\n * @dev Specifically, some contracts within the codebase inherit from the\n * GlobalPausableUpgradeable abstract contract. This provides them with an overriden\n * paused() function that retrieves the pause state from this contract instead.\n *\n * @dev For further details, see \"GlobalPause\" section of whitepaper.\n * @custom:security-contact security@ledgity.com\n */\ncontract GlobalPause is\n    Initializable,\n    UUPSUpgradeable,\n    GlobalOwnableUpgradeable,\n    PausableUpgradeable\n{\n    /**\n     * @notice Prevents implementation contract from being initialized as recommended by\n     * OpenZeppelin.\n     * @dev See: https://docs.openzeppelin.com/contracts/4.x/api/proxy#Initializable-_disableInitializers--\n     * @custom:oz-upgrades-unsafe-allow constructor\n     */\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @notice Initializer function of the contract. It replaces the constructor()\n     * function in the context of upgradeable contracts.\n     * @dev See: https://docs.openzeppelin.com/contracts/4.x/upgradeable\n     * @param globalOwner_ The address of the GlobalOwner contract.\n     */\n    function initialize(address globalOwner_) public initializer {\n        __GlobalOwnable_init(globalOwner_);\n        __Pausable_init();\n        __UUPSUpgradeable_init();\n    }\n\n    /**\n     * @notice Override of UUPSUpgradeable._authorizeUpgrade() function restricted to\n     * global owner. It is called by the proxy contract during an upgrade.\n     * @param newImplementation The address of the new implementation contract.\n     */\n    function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}\n\n    /**\n     * @dev Public implementation of PausableUpgradeable's pausing and unpausing functions\n     * but restricted to contract's owner.\n     */\n    function pause() public onlyOwner {\n        _pause();\n    }\n\n    function unpause() public onlyOwner {\n        _unpause();\n    }\n}\n"
    },
    "contracts/src/interfaces/ITransfersListener.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.18;\n\ninterface ITransfersListener {\n    function onLTokenTransfer(address from, address to, uint256 amount) external;\n}\n"
    },
    "contracts/src/LDY.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.18;\n\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {ERC20Burnable} from \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\n\n/**\n * @title LDY\n * @author Lila Rest (lila@ledgity.com)\n * @dev The $LDY is the utility and governance token of the entire Ledgity ecosystem.\n *\n * This contract has been kept as minimal as possible to enforce stakeholders safety\n * but also to pave the way for sensitive use cases like cross-chain bridging, use in\n * governance scenarios, and compatibility with 3rd party DApps.\n *\n * It is non-upgradeable, non-ownable, non-pausable, non-mintable, and non-restrictable.\n * It implements nothing more than what is provided by its OpenZepellin ancestors.\n *\n * Moreover, to eliminate the need for ownership and complex vesting functions, the\n * entire supply is minted at deployment-time. Vesting of allocated tokens is then\n * managed via Sablier streams that anyone can verify on this page:\n * https://docs.ledgity.finance/tokenomics/vesting-proofs\n *\n * Specifications:\n * - Name: Ledgity Token\n * - Symbol: LDY\n * - Decimals: 18\n * - Total supply: 75,000,000\n *\n * @custom:security-contact security@ledgity.com\n */\ncontract LDY is ERC20, ERC20Burnable {\n    constructor() ERC20(\"Ledgity Token\", \"LDY\") {\n        _mint(msg.sender, 75_000_000 * 10 ** decimals());\n    }\n}\n"
    },
    "contracts/src/LDYStaking.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.18;\n\n// Contracts\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {BaseUpgradeable} from \"./abstracts/base/BaseUpgradeable.sol\";\n\n// Libraries\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\n// Interfaces\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\n/**\n * @title LDYStaking\n * @custom:security-contact security@ledgity.com\n *\n * @dev This contract implements tierOf() function from LDYStaking as it's the only\n * one the LToken contract relies on.\n *\n * @custom:security-contact security@ledgity.com\n */\ncontract LDYStaking is BaseUpgradeable, ReentrancyGuardUpgradeable {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /**\n     * @notice Represents a user staking info in array.\n     * @param stakedAmount Amount of the stake.\n     * @param unStakeAt Unstake at.\n     * @param duration Staking period in seconds.\n     * @param rewardPerTokenPaid Reward per token paid.\n     * @param rewards Rewards to be claimed.\n     */\n    struct StakingInfo {\n        uint256 stakedAmount;\n        uint256 unStakeAt;\n        uint256 duration;\n        uint256 rewardPerTokenPaid;\n        uint256 rewards;\n    }\n\n    /**\n     * @notice Represent duration and multiplier per each stake option.\n     * @param duration Staking period in seconds.\n     * @param multiplier Token weight\n     */\n    struct StakeDurationInfo {\n        uint256 duration;\n        uint256 multiplier;\n    }\n\n    /// @notice Decimals of multiplier\n    uint256 public constant MULTIPLIER_BASIS = 1e4;\n\n    /// @notice Stake and Reward token.\n    IERC20Upgradeable public stakeRewardToken;\n\n    /// @notice Minimal stake duration for perks.\n    uint256 public stakeDurationForPerks;\n\n    /// @notice Minimal stake amount for perks.\n    uint256 public stakeAmountForPerks;\n\n    /// @notice Stake durations info array.\n    StakeDurationInfo[] public stakeDurationInfos;\n\n    /// @notice Duration of the rewards (in seconds).\n    uint256 public rewardsDuration;\n\n    /// @notice Timestamp of when the rewards finish.\n    uint256 public finishAt;\n\n    /// @notice Timestamp of the reward updated.\n    uint256 public lastUpdateTime;\n\n    /// @notice Reward per second(total rewards / duration).\n    uint256 public rewardRatePerSec;\n\n    /// @notice Reward per token stored, sum of (reward rate * dt * 1e18 / total supply).\n    uint256 public rewardPerTokenStored;\n\n    /// @notice Total staked amounts.\n    uint256 public totalStaked;\n\n    // Total staked amounts with multiplier applied\n    uint256 public totalWeightedStake;\n\n    /// @notice User stakingInfo map, user address => array of the staking info\n    mapping(address => StakingInfo[]) public userStakingInfo;\n\n    /// @notice Total rewards amount.\n    uint256 public totalRewards;\n\n    /**\n     * @notice Emitted when users stake token\n     * @param user User address\n     * @param stakeIndex Latest index of user staking pool\n     * @param amount Staked amount\n     */\n    event Staked(address indexed user, uint256 stakeIndex, uint256 amount);\n\n    /**\n     * @notice Emitted when users unstake token\n     * @param user User address\n     * @param stakeIndex User staking pool index\n     * @param amount Staked amount\n     */\n    event Unstaked(address indexed user, uint256 stakeIndex, uint256 amount);\n\n    /**\n     * @notice Emitted when users claim rewards\n     * @param user User address\n     * @param stakeIndex User staking pool index\n     * @param reward Reward token amount\n     */\n    event RewardPaid(address indexed user, uint256 stakeIndex, uint256 reward);\n\n    /**\n     * @notice Emitted when admin add rewards.\n     * @param rewardAmount Reward amount added by admin.\n     * @param rewardPerSec RewardRatePerSec updated.\n     */\n    event NotifiedRewardAmount(uint256 rewardAmount, uint256 rewardPerSec);\n\n    /**\n     * @notice Holds a mapping of addresses that default to the highest staking tier.\n     * @dev This is notably used to allow PreMining contracts to benefit from 0%\n     * withdrawal fees in L-Tokens contracts, when accounts unlock their funds.\n     */\n    mapping(address => bool) public highTierAccounts;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @notice Initializes the contract and sets the initial state variables. This is called by the proxy and should only be called once.\n     * @dev This function is intended for setting initial values for the contract's state variables.\n     * @param globalOwner_ The address of the GlobalOwner contract.\n     * @param globalPause_ The address of the GlobalPause contract.\n     * @param globalBlacklist_ The address of the GlobalBlacklist contract.\n     * @param stakeRewardToken_ The address of stake and reward token(LDY token).\n     * @param stakeDurationInfos_ Available Staking Durations.\n     * @param stakeDurationForPerks_ Minimal staking duration for perks.\n     * @param stakeAmountForPerks_ Minimal staking amount for perks.\n     */\n    function initialize(\n        address globalOwner_,\n        address globalPause_,\n        address globalBlacklist_,\n        address stakeRewardToken_,\n        StakeDurationInfo[] memory stakeDurationInfos_,\n        uint256 stakeDurationForPerks_,\n        uint256 stakeAmountForPerks_\n    ) public initializer {\n        __Base_init(globalOwner_, globalPause_, globalBlacklist_);\n        stakeRewardToken = IERC20Upgradeable(stakeRewardToken_);\n        uint stakeDurationInfosLength = stakeDurationInfos_.length;\n        for (uint256 i = 0; i < stakeDurationInfosLength; i++) {\n            stakeDurationInfos.push(stakeDurationInfos_[i]);\n        }\n        stakeDurationForPerks = stakeDurationForPerks_;\n        stakeAmountForPerks = stakeAmountForPerks_;\n    }\n\n    // --------------------\n    //  MUTATIVE FUNCTIONS\n    // --------------------\n\n    /**\n     * @notice Staked tokens cannot be withdrawn during the stakeDuration period and are eligible to claim rewards.\n     * @dev Emits a `Staked` event upon successful staking.\n     * @param amount The amount of tokens to stake.\n     * @param stakeDurationIndex The Index of stakeDurationInfos array.\n     */\n    function stake(\n        uint256 amount,\n        uint8 stakeDurationIndex\n    ) external nonReentrant whenNotPaused notBlacklisted(_msgSender()) {\n        require(amount > 0, \"amount = 0\");\n        require(stakeDurationIndex <= stakeDurationInfos.length - 1, \"Invalid staking period\");\n\n        _updateReward(address(0), 0);\n        StakeDurationInfo memory stakeDurationInfo = stakeDurationInfos[stakeDurationIndex];\n        StakingInfo memory stakingInfo = StakingInfo({\n            stakedAmount: amount,\n            unStakeAt: block.timestamp + stakeDurationInfo.duration,\n            duration: stakeDurationInfo.duration,\n            rewardPerTokenPaid: rewardPerTokenStored,\n            rewards: 0\n        });\n\n        // check whether account is eligible for benefit from the protocol\n        if (stakeDurationInfo.duration >= stakeDurationForPerks && amount >= stakeAmountForPerks) {\n            highTierAccounts[_msgSender()] = true;\n        }\n\n        userStakingInfo[_msgSender()].push(stakingInfo);\n\n        uint256 stakeIndex = userStakingInfo[_msgSender()].length - 1;\n        uint256 weightedStake = (amount * stakeDurationInfo.multiplier) / MULTIPLIER_BASIS;\n        totalWeightedStake += weightedStake;\n        totalStaked += amount;\n\n        stakeRewardToken.safeTransferFrom(_msgSender(), address(this), amount);\n\n        emit Staked(_msgSender(), stakeIndex, amount);\n    }\n\n    /**\n     * @notice Withdraw staked tokens after stakeDuration has passed.\n     * @dev Emits a `Unstaked` event upon successful withdrawal.\n     * On full withdrawal, userStakingInfo removes stake pool for stakeIndex.\n     * @param amount The amount of tokens to withdraw.\n     * @param stakeIndex The index of user staking pool\n     */\n    function unstake(\n        uint256 amount,\n        uint256 stakeIndex\n    ) external nonReentrant notBlacklisted(_msgSender()) {\n        require(amount > 0, \"amount = 0\");\n        require(userStakingInfo[_msgSender()].length >= stakeIndex + 1, \"Invalid stakeIndex\");\n        require(\n            block.timestamp >= userStakingInfo[_msgSender()][stakeIndex].unStakeAt,\n            \"Cannot unstake during staking period\"\n        );\n        require(\n            amount <= userStakingInfo[_msgSender()][stakeIndex].stakedAmount,\n            \"Insufficient unstake amount\"\n        );\n\n        _updateReward(_msgSender(), stakeIndex);\n\n        uint256 multiplier = _getMultiplier(userStakingInfo[_msgSender()][stakeIndex].duration);\n\n        uint256 currentWeightedStake = (amount * multiplier) / MULTIPLIER_BASIS;\n        totalWeightedStake -= currentWeightedStake;\n\n        totalStaked -= amount;\n        userStakingInfo[_msgSender()][stakeIndex].stakedAmount -= amount;\n\n        // check whether account is eligible for benefit from the protocol\n        if (\n            userStakingInfo[_msgSender()][stakeIndex].duration >= stakeDurationForPerks &&\n            userStakingInfo[_msgSender()][stakeIndex].stakedAmount < stakeAmountForPerks\n        ) {\n            highTierAccounts[_msgSender()] = false;\n        }\n\n        // remove staking info from array on full withdrawal\n        if (userStakingInfo[_msgSender()][stakeIndex].stakedAmount == 0) {\n            _claimReward(_msgSender(), stakeIndex);\n\n            userStakingInfo[_msgSender()][stakeIndex] = userStakingInfo[_msgSender()][\n                userStakingInfo[_msgSender()].length - 1\n            ];\n            userStakingInfo[_msgSender()].pop();\n        }\n        stakeRewardToken.safeTransfer(_msgSender(), amount);\n\n        emit Unstaked(_msgSender(), stakeIndex, amount);\n    }\n\n    /**\n     * @notice Claim pending rewards.\n     * @dev Emits a `RewardPaid` event upon successful reward claim.\n     * @param stakeIndex The index of user staking pool.\n     */\n    function getReward(uint256 stakeIndex) external nonReentrant notBlacklisted(_msgSender()) {\n        require(userStakingInfo[_msgSender()].length >= stakeIndex + 1, \"Invalid stakeIndex\");\n        _updateReward(_msgSender(), stakeIndex);\n        _claimReward(_msgSender(), stakeIndex);\n    }\n\n    // --------------------\n    // ADMIN CONFIGURATION\n    // --------------------\n\n    /**\n     * @notice Update Rewards Duration.\n     * @dev Only callable by owner, and setting available only after rewards period.\n     * @param duration New reward duration in seconds.\n     */\n    function setRewardsDuration(uint256 duration) external onlyOwner {\n        require(finishAt < block.timestamp, \"reward duration is not finished\");\n        rewardsDuration = duration;\n    }\n\n    /**\n     * @notice Update stakeDurationForPerks\n     * @dev Only callable by owner.\n     * @param stakeDurationForPerks_ New stakeDurationForPerks.\n     */\n    function setStakeDurationForPerks(uint256 stakeDurationForPerks_) external onlyOwner {\n        stakeDurationForPerks = stakeDurationForPerks_;\n    }\n\n    /**\n     * @notice Update stakeAmountForPerks\n     * @dev Only callable by owner.\n     * @param stakeAmountForPerks_ New stakeDurationForPerks.\n     */\n    function setStakeAmountForPerks(uint256 stakeAmountForPerks_) external onlyOwner {\n        stakeAmountForPerks = stakeAmountForPerks_;\n    }\n\n    /**\n     * @notice Push stakeDurationInfo\n     * @dev Only callable by owner.\n     */\n    function pushStakeDurationInfo(StakeDurationInfo memory durationInfo) external onlyOwner {\n        stakeDurationInfos.push(durationInfo);\n    }\n\n    /**\n     * @notice Notify the contract about the amount of rewards to be distributed and update reward parameters.\n     * @dev Only callable by owner.\n     * @param amount The amount of reward to be distributed.\n     */\n    function notifyRewardAmount(uint256 amount) external onlyOwner {\n        require(rewardsDuration > 0, \"rewards duration is not set\");\n        require(amount > 0, \"amount = 0\");\n\n        _updateReward(address(0), 0);\n\n        if (block.timestamp >= finishAt) {\n            rewardRatePerSec = amount / rewardsDuration;\n        } else {\n            uint256 remainingRewards = (finishAt - block.timestamp) * rewardRatePerSec;\n            rewardRatePerSec = (amount + remainingRewards) / rewardsDuration;\n        }\n\n        require(rewardRatePerSec > 0, \"reward rate = 0\");\n        require(\n            rewardRatePerSec <=\n                (stakeRewardToken.balanceOf(address(this)) + amount - totalStaked) /\n                    rewardsDuration,\n            \"reward amount > balance\"\n        );\n\n        finishAt = block.timestamp + rewardsDuration;\n        lastUpdateTime = block.timestamp;\n\n        totalRewards += amount;\n        stakeRewardToken.safeTransferFrom(_msgSender(), address(this), amount);\n\n        emit NotifiedRewardAmount(amount, rewardRatePerSec);\n    }\n\n    // --------------------\n    //    VIEW FUNCTIONS\n    // --------------------\n\n    /**\n     * @notice Get the last time when rewards were applicable for the specified reward token.\n     * @return Timestamp of the most recent rewards calculation.\n     */\n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return _min(finishAt, block.timestamp);\n    }\n\n    /**\n     * @notice Calculate the reward per token for a given reward token.\n     * @return Current reward per token.\n     */\n    function rewardPerToken() public view returns (uint256) {\n        if (totalStaked == 0) {\n            return rewardPerTokenStored;\n        }\n\n        return\n            rewardPerTokenStored +\n            ((rewardRatePerSec * (lastTimeRewardApplicable() - lastUpdateTime) * 1e18) /\n                totalWeightedStake);\n    }\n\n    /**\n     * @notice Calculate the user's stake pool earnings\n     * @param account Address of the user.\n     * @param stakeIndex Index of the stakePool\n     * @return Return earned amounts\n     */\n    function earned(address account, uint256 stakeIndex) public view returns (uint256) {\n        StakingInfo memory userInfo = userStakingInfo[account][stakeIndex];\n        uint256 multiplier = _getMultiplier(userInfo.duration);\n        uint256 weightedAmount = (userInfo.stakedAmount * multiplier) / MULTIPLIER_BASIS;\n        uint256 rewardsSinceLastUpdate = ((weightedAmount *\n            (rewardPerToken() - userInfo.rewardPerTokenPaid)) / 1e18);\n        return rewardsSinceLastUpdate + userInfo.rewards;\n    }\n\n    /**\n     * @notice Get the earned rewards array for a user.\n     * @param account Address of the user.\n     * @return Return earned rewards array for a user.\n     */\n    function getEarnedUser(address account) public view returns (uint256[] memory) {\n        uint256 numberOfPools = userStakingInfo[account].length;\n        uint256[] memory earnedArray = new uint256[](numberOfPools);\n        for (uint256 index; index < numberOfPools; index++) {\n            earnedArray[index] = earned(account, index);\n        }\n        return earnedArray;\n    }\n\n    /**\n     * @dev tierOf() function that always return that the given account is not\n     * elligible to any LDY staking tier, except if the account is in the\n     * highTierAccounts mapping.\n     * @param account The account to check the tier of.\n     */\n    function tierOf(address account) public view returns (uint256 tier) {\n        if (highTierAccounts[account]) return 3;\n        return 0;\n    }\n\n    /**\n     * @notice Get User Stake Data.\n     * @param account The address of user.\n     * @return StakingInfo array.\n     */\n    function getUserStakes(address account) external view returns (StakingInfo[] memory) {\n        return userStakingInfo[account];\n    }\n\n    /**\n     * @notice Get StakeDurationInfo.\n     * @param index Index of StakeDurationInfos.\n     * @return StakeDurationInfo.\n     */\n    function getStakeDurationInfo(uint256 index) external view returns (StakeDurationInfo memory) {\n        require(stakeDurationInfos.length - 1 >= index, \"wrong index\");\n        return stakeDurationInfos[index];\n    }\n\n    /**\n     * @notice Send rewards to user.\n     * @dev This is private function, called by getReward function.\n     * @param account The address of user.\n     * @param stakeIndex The index of user staking pool.\n     */\n    function _claimReward(address account, uint256 stakeIndex) private {\n        uint256 reward = userStakingInfo[account][stakeIndex].rewards;\n\n        if (reward > 0) {\n            userStakingInfo[account][stakeIndex].rewards = 0;\n            totalRewards -= reward;\n            stakeRewardToken.safeTransfer(account, reward);\n            emit RewardPaid(account, stakeIndex, reward);\n        }\n    }\n\n    /**\n     * @notice Calculate and update user rewards per stakeIndex.\n     * @dev this is private function, called by stake, unstake, getRewards, and notifyRewardAmount functions.\n     * @param account The address of user.\n     * @param stakeIndex The index of user staking pool.\n     */\n    function _updateReward(address account, uint256 stakeIndex) private {\n        rewardPerTokenStored = rewardPerToken();\n        lastUpdateTime = lastTimeRewardApplicable();\n\n        if (account != address(0)) {\n            userStakingInfo[account][stakeIndex].rewards = earned(account, stakeIndex);\n            userStakingInfo[account][stakeIndex].rewardPerTokenPaid = rewardPerTokenStored;\n        }\n    }\n\n    /**\n     * @notice Get multiplier from stakeDurationInfo based on duration\n     * @param duration Stake Duration\n     */\n    function _getMultiplier(uint256 duration) private view returns (uint256) {\n        uint256 stakeDurationInfosLength = stakeDurationInfos.length;\n        for (uint256 i = 0; i < stakeDurationInfosLength; i++) {\n            StakeDurationInfo memory stakeDurationInfo = stakeDurationInfos[i];\n            if (duration == stakeDurationInfo.duration) {\n                return stakeDurationInfo.multiplier;\n            }\n        }\n        return 0;\n    }\n\n    /**\n     * @notice Take minimum value between x and y.\n     */\n    function _min(uint256 x, uint256 y) private pure returns (uint256) {\n        return x <= y ? x : y;\n    }\n}\n"
    },
    "contracts/src/libs/APRHistory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.18;\n\n/**\n * @title APRHistory\n * @author Lila Rest (https://lila.rest)\n * @custom:security-contact security@ledgity.com\n *\n * @notice This library offers utilities to efficiently maintain the history of an\n * on-chain APR (Annual Percentage Rate) state. Each entry in this history is called\n * a \"checkpoint\".\n *\n * @dev Intuition:\n * Each checkpoint in an APR history consists of two data:\n * - the creation timestamp\n * - the APR at that time\n *\n * Given that reading and writing to storage slots are among the most costly operations\n * in Solidity, this library provides a way to store those data in a way that minimizes\n * the number of used storage slots.\n *\n * Instead of storing each checkpoint in a separate storage slot, this library\n * facilitates the packing of up to 4 checkpoints in a single storage slot.\n *\n * @dev Definitions:\n * - Checkpoint: A record of an APR change\n * - Pack: A collection of 4 checkpoints stored in a single storage slot\n * - History: A dynamic array of packs\n * - Reference: A storage pointer to a checkpoint in the APR history\n * - CheckpointData: An in-memory representation of a checkpoint data\n *\n * @dev Value limitation:\n * This library can accommodate APRs only up to 65.536%. This is however sufficient for\n * APR in LToken contract, which is expected to remain below 10%.\n *\n * @dev For further details, see \"APRHistory\" section of whitepaper.\n * @custom:security-contact security@ledgity.com\n */\nlibrary APRHistory {\n    /**\n     * @notice Represents data of a checkpoint extracted from the on-chain history.\n     * For on-chain representation see \"Pack\" struct.\n     * @param aprUD7x3 APR in UD7x3 format (e.g., 12345 = 12.345%).\n     * @param timestamp Timestamp of the checkpoint's creation.\n     */\n    struct CheckpointData {\n        uint16 aprUD7x3; // Allows up to 65.536%\n        uint40 timestamp; // Supports dates up to 20/02/36812\n    }\n\n    /**\n     * @notice Represents how APR checkpoints are stored on chain. Each pack can contain\n     * the data 4 checkpoints. Packs are then stored in a dynamic array (the history).\n     * @param aprsUD7x3 Array of checkpoints' APRs.\n     * @param timestamps Array of checkpoints' timestamps.\n     * @param cursor Index of the next checkpoint to be written.\n     */\n    struct Pack {\n        uint16[4] aprsUD7x3;\n        uint40[4] timestamps;\n        uint32 cursor;\n    }\n\n    /**\n     * @notice Represents a storage pointer to a specific checkpoint in the history.\n     * @param packIndex Index of the pack the checkpoint belongs to.\n     * @param cursorIndex Index of the checkpoint in this pack (between 0 and 3).\n     */\n    struct Reference {\n        uint256 packIndex;\n        uint32 cursorIndex;\n    }\n\n    /**\n     * @notice Compares two checkpoints references.\n     * @param ref1 The first reference to compare.\n     * @param ref2 The second reference to compare.\n     * @return Whether the two references points to the same checkpoint.\n     */\n    function eq(Reference memory ref1, Reference memory ref2) external pure returns (bool) {\n        return ref1.packIndex == ref2.packIndex && ref1.cursorIndex == ref2.cursorIndex;\n    }\n\n    /**\n     * @notice Returns the reference of the checkpoint that should come right after the\n     * referenced checkpoint in the APR history.\n     * @param ref The reference to be incremented.\n     * @return The incremented reference.\n     */\n    function incrementReference(Reference memory ref) public pure returns (Reference memory) {\n        // Ensure cursor index of the given ref is within valid range [0, 3]\n        require(ref.cursorIndex <= 3, \"L1\");\n\n        // If the given ref is the last slot in its pack, return ref of next pack's first slot\n        if (ref.cursorIndex == 3) return Reference(ref.packIndex + 1, 0);\n        //\n        // Else, return ref of next slot in current pack\n        else return Reference(ref.packIndex, ref.cursorIndex + 1);\n    }\n\n    /**\n     * @notice Extracts checkpoint data from a given reference and in APR history.\n     * @param self The APR history to extract the checkpoint from.\n     * @param ref The reference of the checkpoint data to extract.\n     * @return The extracted checkpoint's data.\n     */\n    function getDataFromReference(\n        Pack[] storage self,\n        Reference memory ref\n    ) public view returns (CheckpointData memory) {\n        // Ensure cursor index of the given ref is within valid range [0, 3]\n        require(ref.cursorIndex <= 3, \"L2\");\n\n        // Ensure pack index of the given ref exists in history\n        require(ref.packIndex < self.length, \"L3\");\n\n        // Retrieve pack data from history\n        Pack memory pack = self[ref.packIndex];\n\n        // Ensure cursor index of the given ref has been written\n        require(ref.cursorIndex < pack.cursor, \"L4\");\n\n        // Build and return the checkpoint data\n        return\n            CheckpointData({\n                aprUD7x3: pack.aprsUD7x3[ref.cursorIndex],\n                timestamp: pack.timestamps[ref.cursorIndex]\n            });\n    }\n\n    /**\n     * @notice Retrieves the reference to the most recently added checkpoint in the APR history.\n     * @param self The history to extract the reference from.\n     * @return The reference of the latest checkpoint.\n     */\n    function getLatestReference(Pack[] storage self) public view returns (Reference memory) {\n        // Ensure the given history is not empty\n        require(self.length != 0, \"L5\");\n\n        // Retrieve latest pack's index and cursor\n        uint256 packIndex = self.length - 1;\n        uint32 packCursor = self[packIndex].cursor;\n\n        // If this is the first pack ever, ensure it is not empty\n        if (packIndex == 0) require(packCursor != 0, \"L6\");\n\n        // If the pack is empty, return ref of previous pack's latest slot\n        if (packCursor == 0) return Reference(packIndex - 1, 3);\n        //\n        // Else, return ref of previous slot in current pack\n        else return Reference(packIndex, packCursor - 1);\n    }\n\n    /**\n     * @notice Appends a new empty pack to the end of the given APR history array.\n     * @param self The APR history to append an empty to.\n     */\n    function newBlankPack(Pack[] storage self) internal {\n        // If history is not empty, ensure the latest pack is full\n        require(self.length == 0 || getLatestReference(self).cursorIndex == 3, \"L7\");\n\n        // Push a new blank pack to the history array\n        self.push(\n            Pack({\n                aprsUD7x3: [uint16(0), uint16(0), uint16(0), uint16(0)],\n                timestamps: [uint40(0), uint40(0), uint40(0), uint40(0)],\n                cursor: 0\n            })\n        );\n    }\n\n    /**\n     * @notice Write a new APR checkpoint at the end of the given history array.\n     * @param self The array of packs to write the new checkpoint to.\n     * @param aprUD7x3 The new APR in UD7x3 format.\n     */\n    function setAPR(Pack[] storage self, uint16 aprUD7x3) external {\n        // Determine the reference where the new checkpoint should be written\n        Reference memory newRef = self.length == 0\n            ? Reference(0, 0)\n            : incrementReference(getLatestReference(self));\n\n        // If pack to be written doesn't exist yet, push a new blank pack in history\n        if (newRef.packIndex >= self.length) newBlankPack(self);\n\n        // Retrieve the pack where the new checkpoint will be stored\n        Pack memory pack = self[newRef.packIndex];\n\n        // Add new checkpoint's data to the pack\n        pack.aprsUD7x3[newRef.cursorIndex] = aprUD7x3;\n        pack.timestamps[newRef.cursorIndex] = uint40(block.timestamp);\n\n        // Increment the pack's cursor\n        pack.cursor++;\n\n        // Write the updated pack in storage\n        self[newRef.packIndex] = pack;\n    }\n\n    /**\n     * @notice Retrieves the APR of the latest checkpoint written in the APR history.\n     * @param self The history array to read APR from.\n     * @return The latest checkpoint's APR.\n     */\n    function getAPR(Pack[] storage self) public view returns (uint16) {\n        // Retrieve the latest checkpoint data\n        Reference memory ref = getLatestReference(self);\n        CheckpointData memory data = getDataFromReference(self, ref);\n\n        // Return the latest checkpoint's APR\n        return data.aprUD7x3;\n    }\n}\n"
    },
    "contracts/src/libs/SUD.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.18;\n\nimport {IERC20MetadataUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\n\n/**\n * @title SUD\n * @author Lila Rest (https://lila.rest)\n * @custom:security-contact security@ledgity.com\n *\n * @notice SUD serves as an intermediary number format for calculations within this\n * codebase. It ensures consistency and reduces precision losses. This library\n * facilitates conversions between various number formats and the SUD format.\n *\n * @dev Intuition:\n * This codebase employs the UD (unsigned decimal fixed-point numbers) format to\n * represent both percentage rates and tokens amounts.\n *\n * Rates are expressed in UD7x3 format, whereas the format for tokens amounts depends on\n * the decimals() value of the involved tokens.\n *\n * Three challenges arise from this:\n *   1) To compute values together, it's essential that they are in the same format\n *   2) Calculations involving consecutive divisions on UD numbers lead to accumulated\n *      precision loss (because division shrinks). A common approach is to scale up and\n *      down values by a few decimals before and after performing calculations.\n *   3) Given that rates use the UD7x3 format, if we decided to scale them to and from\n *      the number of decimals of the involved token, 1 to 3 of the rates' decimals would\n *      be shrunk in case token's decimals number is in [0, 2].\n *\n * To address these challenges, this library provides the SUD format, which acts as a\n * consistent and scaled intermediate format to perform calculations.\n *\n * SUD is an acronym for either \"Scaled UD\" or \"Safe UD\".\n *\n * @dev Definitions:\n * - Integer: A number without fractional part, e.g., block.timestamp\n * - UD: A decimal unsigned fixed-point number. The \"UD\" notation is inspired from\n *       libraries like [prb-math](https://github.com/PaulRBerg/prb-math/)\n * - Amount: A token amount. A UD with an unknown repartition of digits between integral\n *           and fractional parts (as token amounts have variable decimal numbers)\n * - Rate: A percentage rate. An UD with 7 integral digits and 3 fractional ones (= UD7x3)\n * - SUD: An intermediate format to perform calculations involving Rates and Amounts. A UD\n *        with 3 more decimals than the involved UD with the highest decimals number. As\n *        rates are represented by UD7x3, a SUD number has at least 6 decimals (3+3) and\n *        so ranges from UD71x6 to UD0x77 formats.\n *\n * @dev A conversion library:\n * This library provides utilities to perform the following conversions:\n * - Amount       <--> SUD\n * - Rate (UD7x3) <--> SUD\n * - Integer      <--> SUD\n *\n * @dev Why scaling by 3 decimals?\n * - It provides an adequate degree of precision for this codebase,\n * - It enables the conversion of a UD7x3 rate to SUD format by merely scaling it up by\n *   the involved token's decimal number, so is gas efficient.\n *\n * @dev Why internal functions?\n * The functions of this library are not set to external because incorporating them\n * directly into contracts is more gas-efficient. Given their minimal size and frequent\n * usage in the InvestUpgradeable, LDYStaking, and LToken contracts, any bytecode savings\n * from making them external are negated by the additional bytecode required for external\n * calls to this library. This can be observed by comparing the output of `bun cc:size`\n * when those functions's visibility is set to external or internal.\n *\n * @dev Precision warning:\n * While this library mitigates precision loss during calculations on UD numbers, it's\n * important to note that tokens with lower decimal counts and supply inherently suffer\n * more from precision loss. Conversely, tokens with higher decimal counts and supply\n * will experience less precision loss.\n *\n * @dev For further details, see \"SUD\" section of whitepaper.\n * @custom:security-contact security@ledgity.com\n */\nlibrary SUD {\n    /**\n     * @notice Retrieves decimals number of the given ERC20 contract address.\n     * @param tokenAddress The address to retrieve decimals number from.\n     * @return decimals The decimals number of the given ERC20 contract address.\n     */\n    function decimalsOf(address tokenAddress) internal view returns (uint256 decimals) {\n        return IERC20MetadataUpgradeable(tokenAddress).decimals();\n    }\n\n    /**\n     * @notice Convert a given token amount into SUD format.\n     * @param nAmount The token amount to convert.\n     * @param decimals The decimals number of the involved ERC20 token.\n     * @return nSUD The amount in SUD format\n     */\n    function fromAmount(uint256 nAmount, uint256 decimals) internal pure returns (uint256 nSUD) {\n        // If token decimals < 3, return a UD71x6 number\n        if (decimals < 3) return nAmount * 10 ** (6 - decimals);\n\n        // Else return a number with decimals+3 fractional digits\n        return nAmount * 10 ** 3;\n    }\n\n    /**\n     * @notice Convert a given SUD number into token amount format.\n     * @param nSUD The SUD number to convert.\n     * @param decimals The decimals number of the involved ERC20 token.\n     * @return nAmount The number in amount format\n     */\n    function toAmount(uint256 nSUD, uint256 decimals) internal pure returns (uint256 nAmount) {\n        // If token decimals < 3, convert from a UD71x6 number\n        if (decimals < 3) return nSUD / 10 ** (6 - decimals);\n\n        // Else, convert from a number with decimals+3 fractional digits\n        return nSUD / 10 ** 3;\n    }\n\n    /**\n     * @notice Converts a given UD7x3 rate into SUD format.\n     * @param nUD7x3 The UD7x3 rate to convert.\n     * @param decimals The decimals number of the involved ERC20 token.\n     * @return nSUD The rate in SUD format.\n     */\n    function fromRate(uint256 nUD7x3, uint256 decimals) internal pure returns (uint256 nSUD) {\n        // If token decimals < 3, return a UD71x6 number\n        if (decimals < 3) return nUD7x3 * 10 ** 3;\n\n        // Else, return a number with decimals+3 fractional digits\n        return nUD7x3 * 10 ** decimals;\n    }\n\n    /**\n     * @notice Converts a given SUD number into a UD7x3 rate.\n     * @param nSUD The SUD number to convert.\n     * @param decimals The decimals number of the involved ERC20 token.\n     * @return nUD7x3 The number in UD7x3 rate format.\n     */\n    function toRate(uint256 nSUD, uint256 decimals) internal pure returns (uint256 nUD7x3) {\n        // If token decimals < 3, convert from a UD71x6 number\n        if (decimals < 3) return nSUD / 10 ** 3;\n\n        // Else, convert from a number with decimals+3 fractional digits\n        return nSUD / 10 ** decimals;\n    }\n\n    /**\n     * @notice Converts a given integer into SUD format.\n     * @param n The integer to convert.\n     * @param decimals The decimals number of the involved ERC20 token.\n     * @return nSUD The integer in SUD format.\n     */\n    function fromInt(uint256 n, uint256 decimals) internal pure returns (uint256 nSUD) {\n        // If token decimals < 3, return a UD71x6 number\n        if (decimals < 3) return n * 10 ** 6;\n\n        // Else, return a number with decimals+3 fractional digits\n        return n * 10 ** (decimals + 3);\n    }\n\n    /**\n     * @notice Converts a given SUD number as an integer (all decimals shrinked).\n     * @param nSUD The SUD number to convert.\n     * @param decimals The decimals number of the involved ERC20 token.\n     * @return n The SUD number as an integer.\n     */\n    function toInt(uint256 nSUD, uint256 decimals) internal pure returns (uint256 n) {\n        // If token decimals < 3, convert from a UD71x6 number\n        if (decimals < 3) return nSUD / 10 ** 6;\n\n        // Else, convert from a number with decimals+3 fractional digits\n        return nSUD / 10 ** (decimals + 3);\n    }\n}\n"
    },
    "contracts/src/LToken.sol": {
<<<<<<<< HEAD:contracts/hardhat/deployments/localhost/solcInputs/08ddb93411e2a1f8f8b878ec7ebf111c.json
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.18;\n\n// Contracts\nimport {ERC20WrapperUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20WrapperUpgradeable.sol\";\nimport \"./abstracts/base/ERC20BaseUpgradeable.sol\";\nimport {InvestUpgradeable} from \"./abstracts/InvestUpgradeable.sol\";\nimport {LDYStaking} from \"./LDYStaking.sol\";\n\n// Libraries\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {SUD} from \"./libs/SUD.sol\";\n\n// Interfaces\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {IERC20MetadataUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\nimport {ITransfersListener} from \"./interfaces/ITransfersListener.sol\";\n\n/**\n * @title LToken\n * @author Lila Rest (https://lila.rest)\n * @custom:security-contact security@ledgity.com\n *\n * @notice Main contract of the Ledgity Yield protocol. It powers every L-Token (i.e.,\n * investment pools backed by RWA). An L-Token is an ERC20 wrapper around a stablecoin.\n * As soon as a wallet holds some L-Tokens, it starts receiving rewards in\n * the form of additional L-Tokens, which are auto-compounded over time.\n *\n * @dev Definitions:\n * - Deposit: Swap of underlying tokens for L-Tokens (1:1 ratio).\n * - Withdrawal: Swap of L-Tokens for underlying tokens (1:1 ratio, minus applicable fees).\n *   - Instant: Processed immediately.\n *   - Request: Queued for later processing.\n *   - Big Request: A requested withdrawal exceeding half of the retention rate.\n * - (Withdrawal) queue: A list of all requested withdrawals sorted by priority.\n * - Request ID: The index of a withdrawal request in the queue array.\n * - Retention rate: Maximum fraction of underlying tokens TVL the contract can retain.\n * - Fees Rate: Percentage of fees applied to successful withdrawals.\n * - Usable underlyings: Amount of underlying tokens that have been deposited through\n *                       expected ways and are so considered safe to use by the contract.\n * - Transfers listeners: External contracts listening on L-Tokens transfers.\n * - Fund wallet: Wallet managed by the Ledgity's financial team.\n * - Withdrawer wallet: Managed by an off-chain server to automate withdrawal request\n *                      processing.\n *\n * Note that words between parenthesis are sometimes omitted for brevity.\n *\n * @dev Deployment notice:\n * This contract can safely receive funds immediately after initialization. (i.e., there\n * is no way for funds to be sent to non-owned addresses). It is, however, recommended to\n * replace ASAP owner and fund wallets with multi-sig wallets.\n *\n * @dev For further details, see \"LToken\" section of whitepaper.\n * @custom:oz-upgrades-unsafe-allow external-library-linking\n * @custom:security-contact security@ledgity.com\n */\ncontract LToken is ERC20BaseUpgradeable, InvestUpgradeable, ERC20WrapperUpgradeable {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /// @dev Represents type of actions triggering ActivityEvent events.\n    enum Action {\n        Deposit,\n        Withdraw\n    }\n\n    /// @dev Represents different status of actions triggering ActivityEvent events.\n    enum Status {\n        Queued,\n        Cancelled,\n        Success,\n        Moved\n    }\n\n    /**\n     * @notice Represents a withdrawal request in the queue.\n     * @dev A request fits in a single storage slot (32 bytes).\n     * @param account The account that initiated the request.\n     * @param amount The amount of underlying tokens requested.\n     */\n    struct WithdrawalRequest {\n        address account; // 20 bytes\n        uint96 amount; // 12 bytes\n    }\n\n    /// @notice Upper limit of retention rate.\n    uint32 private constant MAX_RETENTION_RATE_UD7x3 = 10 * 10 ** 3; // 10%\n\n    /// @notice Upper limit of fees rate.\n    uint32 private constant MAX_FEES_RATE_UD7x3 = 20 * 10 ** 3; // 20%\n\n    /// @notice Used in activity events to represent the absence of request ID.\n    int256 private constant NO_ID = -1;\n\n    /// @notice Holds a reference to the LDYStaking contract.\n    LDYStaking public ldyStaking;\n\n    /// @notice Holds address of withdrawer wallet (managed by withdrawal server).\n    address payable public withdrawer;\n\n    /// @notice Holds address of fund wallet (managed by Ledgity financial team).\n    address public fund;\n\n    /// @notice Holds the withdrawal fees rate in UD7x3 format (e.g., 350 = 0.350%).\n    uint32 public feesRateUD7x3;\n\n    /// @notice Holds the retention rate in UD7x3 format.\n    uint32 public retentionRateUD7x3;\n\n    /// @notice Holds the amount of withdrawal fees not yet claimed by contract's owner.\n    uint256 public unclaimedFees;\n\n    /// @notice Holds the amount of L-Tokens currently in the withdrawal queue.\n    uint256 public totalQueued;\n\n    /**\n     * @notice Holds the amount of underlying tokens considered as usable by the contract.\n     * @dev Are usable, only underlying tokens deposit through deposit() or fund() functions.\n     */\n    uint256 public usableUnderlyings;\n\n    /// @notice Holds an ordered list of active withdrawal requests.\n    WithdrawalRequest[] public withdrawalQueue;\n\n    /// @notice Holds the index of the next withdrawal request to process in the queue.\n    uint256 public withdrawalQueueCursor;\n\n    /**\n     * @notice Holds a list of all currently frozen withdrawal requests.\n     * @dev If a request emitter as been blacklisted, its request is moved here to prevent\n     * it from blocking the queue.\n     */\n    WithdrawalRequest[] public frozenRequests;\n\n    /**\n     * @notice Holds a list of contracts' references that are listening to L-Tokens transfers.\n     * @dev onLTokenTransfer() functions of those contracts will be called on each transfer.\n     */\n    ITransfersListener[] public transfersListeners;\n\n    /**\n     * @notice Holds the withdrwalFee amount in ETH that will be sent to withdrawer wallet.\n     */\n    uint256 public withdrwalFeeInEth;\n\n    /**\n     * @notice Emitted to inform listeners about a change in the contract's TVL.\n     * @dev TVL = realTotalSupply()\n     * @param newTVL The new TVL of the contract.\n     */\n    event TVLChangeEvent(uint256 newTVL);\n\n    /**\n     * @notice Emitted to inform listerners about an activity related to deposits and withdrawals.\n     * @param id ID of the involved withdrawal request or NO_ID (-1) if not applicable.\n     * @param account The account involved in the activity.\n     * @param action The type of activity.\n     * @param amount The amount of underlying tokens involved in the activity.\n     * @param newStatus The new status of the activity.\n     * @param newId The new ID of the request if it has been moved in the queue.\n     */\n    event ActivityEvent(\n        int256 indexed id,\n        address indexed account,\n        Action indexed action,\n        uint256 amount,\n        uint256 amountAfterFees,\n        Status newStatus,\n        int256 newId\n    );\n\n    /**\n     * @notice Emitted to inform listeners that some rewards have been minted.\n     * @param account The account that received the rewards.\n     * @param balanceBefore The balance of the account before the minting.\n     * @param rewards The amount of minted rewards.\n     */\n    event MintedRewardsEvent(address indexed account, uint256 balanceBefore, uint256 rewards);\n\n    /// @notice Reverts if the function caller is not the withdrawer wallet.\n    modifier onlyWithdrawer() {\n        require(_msgSender() == withdrawer, \"L39\");\n        _;\n    }\n\n    /// @notice Reverts if the function caller is not the fund wallet.\n    modifier onlyFund() {\n        require(_msgSender() == fund, \"L40\");\n        _;\n    }\n\n    /**\n     * @notice Initializer function of the contract. It replaces the constructor()\n     * function in the context of upgradeable contracts.\n     * @dev See: https://docs.openzeppelin.com/contracts/4.x/upgradeable\n     * @param globalOwner_ The address of the GlobalOwner contract.\n     * @param globalPause_ The address of the GlobalPause contract.\n     * @param globalBlacklist_ The address of the GlobalBlacklist contract.\n     * @param underlyingToken The address of the underlying stablecoin ERC20 token.\n     */\n    function initialize(\n        address globalOwner_,\n        address globalPause_,\n        address globalBlacklist_,\n        address ldyStaking_,\n        address underlyingToken\n    ) public initializer {\n        // Initialize ERC20 base.\n        string memory underlyingSymbol = IERC20MetadataUpgradeable(underlyingToken).symbol();\n        __ERC20Base_init(\n            globalOwner_,\n            globalPause_,\n            globalBlacklist_,\n            string(abi.encodePacked(\"Ledgity \", underlyingSymbol)),\n            string(abi.encodePacked(\"L\", underlyingSymbol))\n        );\n\n        // IMPORTANT: Below calls must not be restricted to owner at any point.\n        // This is because the GlobalOwner contract may not be a fresh one, and so\n        // the contract deployer may not be the owner anymore after ERC20Base init.\n\n        // Initialize other parents contracts.\n        __ERC20Wrapper_init(IERC20Upgradeable(underlyingToken));\n        __Invest_init_unchained(address(this));\n\n        // Set LDYStaking contract\n        ldyStaking = LDYStaking(ldyStaking_);\n\n        // Set initial withdrawal fees rate to 0.3%\n        feesRateUD7x3 = 300;\n\n        // Set initial retention rate to 10%\n        retentionRateUD7x3 = 10_000;\n\n        // Default withdrawer and fund wallet to contract owner address. This prevents\n        // any loss of funds if a deposit/withdrawal is made before those are manually set.\n        withdrawer = payable(owner());\n        fund = payable(owner());\n\n        // Set initial withdrwalFeeInEth\n        withdrwalFeeInEth = 0.00075 * 1e18;\n    }\n\n    /**\n     * @notice Required override of decimals() which is implemented by both\n     * ERC20Upgradeable and ERC20WrapperUpgradeable parent contracts.\n     * @dev The ERC20WrapperUpgradeable version is preferred because it mirrors the\n     * decimals amount of the underlying stablecoin token.\n     * @inheritdoc ERC20WrapperUpgradeable\n     */\n    function decimals()\n        public\n        view\n        override(ERC20Upgradeable, ERC20WrapperUpgradeable)\n        returns (uint8)\n    {\n        return ERC20WrapperUpgradeable.decimals();\n    }\n\n    /**\n     * @notice Required override of paused() which is implemented by both\n     * GlobalPausableUpgradeable and ERC20BaseUpgradeable parent contracts.\n     * @dev Both version are the same as ERC20BaseUpgradeable.paused() mirrors\n     * GlobalPausableUpgradeable.paused(), so a random one is chosen.\n     * @inheritdoc GlobalPausableUpgradeable\n     */\n    function paused()\n        public\n        view\n        virtual\n        override(GlobalPausableUpgradeable, ERC20BaseUpgradeable)\n        returns (bool)\n    {\n        return GlobalPausableUpgradeable.paused();\n    }\n\n    /**\n     * @notice Updates the current withdrawal fee rate.\n     * @param feesRateUD7x3_ The new withdrawal fee rate in UD7x3 format.\n     */\n    function setFeesRate(uint32 feesRateUD7x3_) public onlyOwner {\n        require(feesRateUD7x3_ <= MAX_FEES_RATE_UD7x3, \"L88\");\n        feesRateUD7x3 = feesRateUD7x3_;\n    }\n\n    /**\n     * @notice Updates the current withdrawalFeeInETH.\n     * @param withdrwalFeeInEth_ The new withdrawalFee in ETH.\n     */\n    function setWithdrwalFeeInEth(uint256 withdrwalFeeInEth_) public onlyOwner {\n        require(withdrwalFeeInEth <= MAX_FEES_RATE_UD7x3, \"L88\");\n        withdrwalFeeInEth = withdrwalFeeInEth_;\n    }\n\n    /**\n     * @notice Updates the current underlying token retention rate.\n     * @dev The retention rate is capped at 10%, which ensures that no more than 10% of\n     * deposited assets will ever be exposed in this contract (reduces attack surface).\n     * @param retentionRateUD7x3_ The new retention rate in UD7x3 format.\n     */\n    function setRetentionRate(uint32 retentionRateUD7x3_) public onlyOwner {\n        require(retentionRateUD7x3_ <= MAX_RETENTION_RATE_UD7x3, \"L41\");\n        retentionRateUD7x3 = retentionRateUD7x3_;\n    }\n\n    /**\n     * @notice Updates the address of LDYStaking contract.\n     * @param ldyStakingAddress The address of the new LDYStaking contract.\n     */\n    function setLDYStaking(address ldyStakingAddress) public onlyOwner {\n        ldyStaking = LDYStaking(ldyStakingAddress);\n    }\n\n    /**\n     * @notice Updates the address of the withdrawer wallet.\n     * @param withdrawer_ The address of the new withdrawer wallet.\n     */\n    function setWithdrawer(address payable withdrawer_) public onlyOwner {\n        // Ensure address is not the zero address (pre-processing fees would be lost else)\n        require(withdrawer_ != address(0), \"L63\");\n\n        // Set new withdrawer wallet's address\n        withdrawer = withdrawer_;\n    }\n\n    /**\n     * @notice Updates the address of the fund wallet.\n     * @param fund_ The address of the new fund wallet.\n     */\n    function setFund(address payable fund_) public onlyOwner {\n        // Ensure address is not the zero address (deposited tokens would be lost else)\n        require(fund_ != address(0), \"L64\");\n\n        // Set new fund wallet's address\n        fund = fund_;\n    }\n\n    /**\n     * @notice Adds a new contract to the L-Token transfers list.\n     * @dev Each time a transfer occurs, the onLTokenTransfer() function of the\n     * specified contract will be called.\n     * @dev IMPORTANT SECURITY NOTE: This method is not intended to be used with\n     * contracts that are not owned by the Ledgity team.\n     * @param listenerContract The address of the new transfers listener contract.\n     */\n    function listenToTransfers(address listenerContract) public onlyOwner {\n        transfersListeners.push(ITransfersListener(listenerContract));\n    }\n\n    /**\n     * @notice Removes a contract from the L-Token transfers list.\n     * @dev The onLTokenTransfer() function of the specified contract will not be called\n     * anymore each time a L-Token transfer occurs.\n     * @param listenerContract The address of the listener contract.\n     */\n    function unlistenToTransfers(address listenerContract) public onlyOwner {\n        // Find index of listener contract in transferListeners array\n        int256 index = -1;\n        uint256 transfersListenersLength = transfersListeners.length;\n        for (uint256 i = 0; i < transfersListenersLength; i++) {\n            if (address(transfersListeners[i]) == listenerContract) {\n                index = int256(i);\n                break;\n            }\n        }\n\n        // Revert if given contract wasn't listening to transfers\n        require(index > -1, \"L42\");\n\n        // Else, remove transfers listener contract from listeners array\n        transfersListeners[uint256(index)] = transfersListeners[transfersListenersLength - 1];\n        transfersListeners.pop();\n    }\n\n    /**\n     * @notice Retrieves the amount of given account's not yet minted rewards.\n     * @dev This is a public implementation of InvestUpgradeable_rewardsOf(). In the\n     * context of LToken, this function returns the amount of rewards that have not been\n     * distributed/minted yet to the specified account.\n     * @dev This is particularly useful for off-chain services to display charts and\n     * statistics, as seen in the Ledgity Yield's frontend.\n     * @param account The account to check the unminted rewards of.\n     * @return The amount of account's unminted rewards.\n     */\n    function unmintedRewardsOf(address account) public view returns (uint256) {\n        return _rewardsOf(account, true);\n    }\n\n    /**\n     * @notice Retrieves the \"real\" balance of an account, i.e., excluding its not yet\n     * minted/distributed rewards.\n     * @param account The account to check the real balance of.\n     * @return The real balance of the account.\n     */\n    function realBalanceOf(address account) public view returns (uint256) {\n        return super.balanceOf(account);\n    }\n\n    /**\n     * @notice Retrieves the total balance of L-Tokens that belong to the account.\n     * @dev This is an oOverride of ERC20Upgradeable.balanceOf() that rewards that have\n     * not been yet minted to the specified account.\n     * @param account The account to check the total balance of.\n     * @return The total balance of the account.\n     */\n    function balanceOf(address account) public view override returns (uint256) {\n        return realBalanceOf(account) + unmintedRewardsOf(account);\n    }\n\n    /**\n     * @notice Returns the \"real\" amount of existing L-Tokens, i.e., excluding not yet\n     * minted withdrawal fees and L-Tokens currently in the withdrawal queue.\n     * @return The real total supply of L-Tokens.\n     */\n    function realTotalSupply() public view returns (uint256) {\n        return super.totalSupply();\n    }\n\n    /**\n     * @notice Retrives the total supply of L-Tokens, including not yet minted withdrawal\n     * fees and L-Tokens currently in the withdrawal queue.\n     * @return The total supply of L-Tokens.\n     */\n    function totalSupply() public view override returns (uint256) {\n        return realTotalSupply() + totalQueued + unclaimedFees;\n    }\n\n    /**\n     * @notice Recovers a specified amount of a given token address.\n     * @dev This override of RecoverableUpgradeable.recoverERC20() prevents the recovered\n     * token from being the underlying token.\n     * @inheritdoc RecoverableUpgradeable\n     */\n    function recoverERC20(address tokenAddress, uint256 amount) public override onlyOwner {\n        // Ensure the token is not the underlying token\n        require(tokenAddress != address(underlying()), \"L43\");\n\n        // Proceed to recovery\n        super.recoverERC20(tokenAddress, amount);\n    }\n\n    /**\n     * @notice Recovers underlying tokens accidentally sent to the contract.\n     * @dev To prevent owner from being able to drain the contract, this function only\n     * allows recovering \"unusable\" underlying tokens, i.e., tokens that have not been\n     * sent through fund() or deposit() functions.\n     */\n    function recoverUnderlying() external onlyOwner {\n        // Compute the recoverable amount by taking the difference between the contract's\n        // balance and the amount of usable underlying tokens\n        uint256 recoverableAmount = underlying().balanceOf(address(this)) - usableUnderlyings;\n\n        // Revert if there is nothing to recover\n        require(recoverableAmount > 0, \"L44\");\n\n        // Else, proceed to underlying tokens recovery\n        super.recoverERC20(address(underlying()), recoverableAmount);\n    }\n\n    /**\n     * @notice Retrieves the amount of underlying tokens invested by the given account.\n     * @dev Implementing this function is required by the InvestUpgradeable contract. In\n     * LToken contract, the investment of an account is equal to its real balance.\n     * @inheritdoc InvestUpgradeable\n     */\n    function _investmentOf(address account) internal view override returns (uint256) {\n        return realBalanceOf(account);\n    }\n\n    /**\n     * @notice Distributes a specified amount of rewards (in L-Tokens) to a given account.\n     * @dev Implementing this function is required by the InvestUpgradeable contract so\n     * it can distribute rewards to accounts before each period reset.\n     * @dev InvestUpgradeable contract already ensure that amount > 0.\n     * @inheritdoc InvestUpgradeable\n     */\n    function _distributeRewards(address account, uint256 amount) internal override returns (bool) {\n        // Inform listeners of the rewards minting\n        emit MintedRewardsEvent(account, realBalanceOf(account), amount);\n\n        // Mint L-Tokens rewards to account\n        _mint(account, amount);\n\n        // Return true indicating to InvestUpgradeable that the rewards have been distributed\n        return true;\n    }\n\n    /**\n     * @notice Override of ERC20._beforeTokenTransfer() to integrate with InvestUpgradeable.\n     * @dev This overriden version ensure that _beforeInvestmentChange() hook is properly\n     * called each time an account's balance is going to change.\n     * @dev Note: whenNotPaused and notBlacklisted modifiers are not set as they are\n     * already included in ERC20BaseUpgradeable._beforeTokenTransfer().\n     * @inheritdoc ERC20BaseUpgradeable\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal override(ERC20Upgradeable, ERC20BaseUpgradeable) {\n        ERC20BaseUpgradeable._beforeTokenTransfer(from, to, amount);\n\n        // Invoke _beforeInvestmentChange() hook for non-zero accounts\n        if (from != address(0)) _beforeInvestmentChange(from, true);\n        if (to != address(0)) _beforeInvestmentChange(to, true);\n    }\n\n    /**\n     * @notice Override of ERC20._afterTokenTransfer() to notify all transfers listeners.\n     * @dev This overriden version will trigger onLTokenTransfer() functions of all\n     * transfers listeners.\n     * @dev Note: whenNotPaused and notBlacklisted modifiers are not set as they are\n     * already checked in _beforeTokenTransfer().\n     * @inheritdoc ERC20Upgradeable\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal override {\n        super._afterTokenTransfer(from, to, amount);\n\n        // If some L-Token have been burned/minted, inform listeners of a TVL change\n        if (from == address(0) || to == address(0)) emit TVLChangeEvent(totalSupply());\n\n        // Trigger onLTokenTransfer() functions of all the transfers listeners\n        for (uint256 i = 0; i < transfersListeners.length; i++) {\n            transfersListeners[i].onLTokenTransfer(from, to, amount);\n        }\n    }\n\n    /**\n     * @notice Computes the maximum amount of underlying tokens that should be retained\n     * by the contract (based on retention rate).\n     * @return amount The expected amount of retained underlying tokens.\n     */\n    function getExpectedRetained() public view returns (uint256 amount) {\n        // Cache invested token's decimals number\n        uint256 d = SUD.decimalsOf(address(invested()));\n\n        // Convert totalSupply and retentionRate to SUD\n        uint256 totalSupplySUD = SUD.fromAmount(totalSupply(), d);\n        uint256 retentionRateSUD = SUD.fromRate(retentionRateUD7x3, d);\n\n        // Compute and return expected retained amount\n        uint256 expectedRetainedSUD = (totalSupplySUD * retentionRateSUD) / SUD.fromInt(100, d);\n        return SUD.toAmount(expectedRetainedSUD, d);\n    }\n\n    /// @notice Transfers underlying tokens exceeding the retention rate to the fund wallet.\n    function _transferExceedingToFund() internal {\n        // Retrieve the expected amount retained\n        uint256 expectedRetained = getExpectedRetained();\n\n        // If usable underlyings are less than or equal to expected retained, return\n        if (usableUnderlyings <= expectedRetained) return;\n\n        // Else, exceeding amount is equal to difference between those values\n        uint256 exceedingAmount = usableUnderlyings - expectedRetained;\n\n        // Decrease usable underlyings amount accordingly\n        usableUnderlyings -= exceedingAmount;\n\n        // Transfer the exceeding amount to the fund wallet\n        underlying().safeTransfer(fund, exceedingAmount);\n    }\n\n    /**\n     * @notice Override of ERC20WrapperUpgradeable.withdrawTo() that reverts.\n     * Use instantWithdrawal() or requestWithdrawal() functions instead.\n     * @inheritdoc ERC20WrapperUpgradeable\n     */\n    function withdrawTo(address account, uint256 amount) public pure override returns (bool) {\n        account; // Silence unused variable compiler warning\n        amount;\n        revert(\"L45\");\n    }\n\n    /**\n     * @notice Override of ERC20WrapperUpgradeable.depositFor() that reverts.\n     * Use deposit() function instead.\n     * @inheritdoc ERC20WrapperUpgradeable\n     */\n    function depositFor(address account, uint256 amount) public pure override returns (bool) {\n        account; // Silence unused variable compiler warning\n        amount;\n        revert(\"L46\");\n    }\n\n    /**\n     * @notice Allows exchanging some underlying tokens for the same amount of L-Tokens.\n     * @param amount The amount of underlying tokens to deposit.\n     */\n    function deposit(uint256 amount) public whenNotPaused notBlacklisted(_msgSender()) {\n        // Ensure the account has enough underlying tokens to deposit\n        require(underlying().balanceOf(_msgSender()) >= amount, \"L47\");\n\n        // Update usable underlyings balance accordingly\n        usableUnderlyings += amount;\n\n        // Inform listeners of the deposit activity event\n        emit ActivityEvent(\n            NO_ID,\n            _msgSender(),\n            Action.Deposit,\n            amount,\n            amount,\n            Status.Success,\n            NO_ID\n        );\n\n        // Receive underlying tokens and mint L-Tokens to the account in a 1:1 ratio\n        super.depositFor(_msgSender(), amount);\n\n        // Transfer exceeding underlying tokens to the fund wallet\n        _transferExceedingToFund();\n    }\n\n    /**\n     * @notice Computes fees and net withdrawn amount for a given account withdrawing a\n     * given amount.\n     * @param account The account initiating the withdrawal.\n     * @param amount The amount of the withdrawal.\n     */\n    function getWithdrawnAmountAndFees(\n        address account,\n        uint256 amount\n    ) public view returns (uint256 withdrawnAmount, uint256 fees) {\n        // If the account is eligible to staking tier 2, no fees are applied\n        if (ldyStaking.tierOf(account) >= 2) return (amount, 0);\n\n        // Cache invested token's decimals number\n        uint256 d = SUD.decimalsOf(address(invested()));\n\n        // Convert amount and fees rate to SUD\n        uint256 amountSUD = SUD.fromAmount(amount, d);\n        uint256 feesRateSUD = SUD.fromRate(feesRateUD7x3, d);\n\n        // Compute fees and withdrawn amount (initial amount minus fees)\n        uint256 feesSUD = (amountSUD * feesRateSUD) / SUD.fromInt(100, d);\n        fees = SUD.toAmount(feesSUD, d);\n        withdrawnAmount = amount - fees;\n    }\n\n    /**\n     * @notice Allows instaneously exchanging a given amount of L-Tokens for the same\n     * amount of underlying tokens. It will fail if the contract currently doesn't hold\n     * enough underlying tokens to cover the withdrawal.\n     * @dev In order to save some gas and time to users, frontends should propose this\n     * function to users only when it has been verified that it will not revert. They\n     * should propose the requestWithdrawal() function otherwise.\n     * @param amount The amount L-Tokens to withdraw.\n     */\n    function instantWithdrawal(uint256 amount) external whenNotPaused notBlacklisted(_msgSender()) {\n        // Ensure the account has enough L-Tokens to withdraw\n        require(amount <= balanceOf(_msgSender()), \"L48\");\n\n        // Can the contract cover this withdrawal plus all already queued requests?\n        bool cond1 = totalQueued + amount <= usableUnderlyings;\n\n        // Is caller eligible to staking tier 2 and the contract can cover this withdrawal?\n        bool cond2 = ldyStaking.tierOf(_msgSender()) >= 2 && amount <= usableUnderlyings;\n\n        // Revert if conditions are not met for the withdrawal to be processed instantaneously\n        if (!(cond1 || cond2)) revert(\"L49\");\n\n        // Else, retrieve withdrawal fees and net withdrawn amount\n        (uint256 withdrawnAmount, uint256 fees) = getWithdrawnAmountAndFees(_msgSender(), amount);\n\n        // Increase unclaimed fees amount accordingly\n        unclaimedFees += fees;\n\n        // Decrease usable underlyings balance accordingly\n        usableUnderlyings -= withdrawnAmount;\n\n        // Inform listeners of this instant withdrawal activity event\n        emit ActivityEvent(\n            NO_ID,\n            _msgSender(),\n            Action.Withdraw,\n            amount,\n            withdrawnAmount,\n            Status.Success,\n            NO_ID\n        );\n\n        // Burn withdrawal fees from the account\n        _burn(_msgSender(), fees);\n\n        // Burn account's withdrawn L-Tokens and transfer to it underlying tokens in a 1:1 ratio\n        super.withdrawTo(_msgSender(), withdrawnAmount);\n    }\n\n    /**\n     * @notice Allows requesting the exchange of a given amount of L-Tokens for the same\n     * amount of underlying tokens. The request will be automatically processed later.\n     * @dev The sender must attach withdrwalFeeInETH to pre-pay the future processing gas fees\n     * paid by the withdrawer wallet.\n     * @param amount The amount L-Tokens to withdraw.\n     */\n    function requestWithdrawal(\n        uint256 amount\n    ) public payable whenNotPaused notBlacklisted(_msgSender()) {\n        // Ensure the account has enough L-Tokens to withdraw\n        require(amount <= balanceOf(_msgSender()), \"L53\");\n\n        // Ensure the requested amount doesn't overflow uint96\n        require(amount <= type(uint96).max, \"L54\");\n\n        // Ensure the sender attached the pre-paid processing gas fees\n        require(msg.value == withdrwalFeeInEth, \"L55\");\n\n        // Create withdrawal request data\n        WithdrawalRequest memory request = WithdrawalRequest({\n            account: _msgSender(),\n            amount: uint96(amount)\n        });\n\n        // Will hold the request ID\n        uint256 requestId;\n\n        // Append request to the withdrawal queue:\n        // - At the beginning, if account is eligible to staking tier 2 and cursor is not 0\n        if (ldyStaking.tierOf(_msgSender()) >= 2 && withdrawalQueueCursor > 0) {\n            withdrawalQueueCursor--;\n            requestId = withdrawalQueueCursor;\n            withdrawalQueue[requestId] = request;\n        }\n        // - At the end else\n        else {\n            withdrawalQueue.push(request);\n            requestId = withdrawalQueue.length - 1;\n        }\n\n        // Increase total amount queued accordingly\n        totalQueued += amount;\n\n        // Inform listeners of this new queued withdrawal activity event\n        emit ActivityEvent(\n            int256(requestId),\n            _msgSender(),\n            Action.Withdraw,\n            amount,\n            amount,\n            Status.Queued,\n            NO_ID\n        );\n\n        // Burn withdrawal L-Tokens amount from account's balance\n        _burn(_msgSender(), amount);\n\n        // Forward pre-paid processing gas fees to the withdrawer wallet\n        (bool sent, ) = withdrawer.call{value: msg.value}(\"\");\n        require(sent, \"L56\");\n    }\n\n    /**\n     * @notice Processes queued withdrawal requests until there is else no more requests,\n     * else not enough underlying tokens to continue.\n     * @dev For further details, see \"LToken  > Withdrawals\" section of whitepaper.\n     */\n    function processQueuedRequests() external onlyWithdrawer whenNotPaused {\n        // Accumulators variables, will be written on-chain after the loop\n        uint256 cumulatedFees = 0;\n        uint256 cumulatedWithdrawnAmount = 0;\n        uint256 nextRequestId = withdrawalQueueCursor;\n\n        // Cache queue length to avoid multiple SLOADs and avoid infinite loop as big\n        // requests are increasing the queue length when moved at the end of the queue.\n        uint256 queueLength = withdrawalQueue.length;\n\n        // Iterate over requests to be processed\n        while (nextRequestId < queueLength) {\n            // Stop processing requests if there is not enough gas left to continue the\n            // loop and properly end the function call. This prevents an attacker from\n            // blocking the withdrawal processing by creating a ton of tiny requests so\n            // this function call cannot fit anymore in block gas limit.\n            if (gasleft() < 45000) break;\n\n            // Retrieve request data\n            WithdrawalRequest memory request = withdrawalQueue[nextRequestId];\n\n            // Skip empty request (processed big requests or cancelled requests)\n            if (request.account == address(0)) {}\n            //\n            // If account has been blacklisted since request emission\n            else if (isBlacklisted(request.account)) {\n                // Remove request from queue\n                delete withdrawalQueue[nextRequestId];\n\n                // Append request in the frozen requests list\n                frozenRequests.push(request);\n            }\n            //\n            // Or if request is a big request, move it at the end of the queue for now.\n            // This request will be processed manually later using processBigQueuedRequest()\n            else if (request.amount > getExpectedRetained() / 2) {\n                // Inform listeners of this queued request being moved at the end of the queue\n                emit ActivityEvent(\n                    int256(nextRequestId),\n                    _msgSender(),\n                    Action.Withdraw,\n                    request.amount,\n                    request.amount,\n                    Status.Moved,\n                    int256(withdrawalQueue.length)\n                );\n\n                // Remove request from queue\n                delete withdrawalQueue[nextRequestId];\n\n                // Append request at the end of the queue\n                withdrawalQueue.push(request);\n            }\n            //\n            // Else, continue request processing\n            else {\n                // Retrieve withdrawal fees and net withdrawn amount\n                (uint256 withdrawnAmount, uint256 fees) = getWithdrawnAmountAndFees(\n                    request.account,\n                    request.amount\n                );\n\n                // Break if the contract doesn't hold enough funds to cover the request\n                if (withdrawnAmount > usableUnderlyings - cumulatedWithdrawnAmount) break;\n\n                // Accumulate fees and withdrawn amount\n                cumulatedFees += fees;\n                cumulatedWithdrawnAmount += withdrawnAmount;\n\n                // Inform listeners of this queued withdrawal processing activity event\n                emit ActivityEvent(\n                    int256(nextRequestId),\n                    request.account,\n                    Action.Withdraw,\n                    request.amount,\n                    withdrawnAmount,\n                    Status.Success,\n                    NO_ID\n                );\n\n                // Remove request from queue\n                delete withdrawalQueue[nextRequestId];\n\n                // Transfer underlying tokens to account. Burning L-Tokens is not required\n                // as equestWithdrawal() already did it.\n                // Security note: Re-entrancy warning are disabled as the request has\n                // just been deleted from the queue, it will so be skipped if trying to\n                // process it again.\n                // slither-disable-next-line reentrancy-no-eth\n                underlying().safeTransfer(request.account, withdrawnAmount);\n            }\n\n            // Increment next request ID\n            nextRequestId++;\n        }\n\n        // Increase unclaimed fees by the amount of cumulated fees\n        unclaimedFees += cumulatedFees;\n\n        // Decrease usable underlyings by the cumulated amount of withdrawn underlyings\n        usableUnderlyings -= cumulatedWithdrawnAmount;\n\n        // Decrease total amount queued by the cumulated amount requested\n        totalQueued -= cumulatedWithdrawnAmount + cumulatedFees;\n\n        // Update new queue cursor\n        withdrawalQueueCursor = nextRequestId;\n\n        // Retention rate cannot exceeds as the withdrawal decreases both usable\n        // underlyings and expected retained amounts by the same number and as the\n        // expected retained amount is a subset of usable underlyings amount.\n    }\n\n    /**\n     * @notice Processes a given queued big withdrawal request (one that exceeds half of\n     * the retention rate).\n     * @dev In contrast to non-big requests processing, this function will uses to fund\n     * wallet's balance to fill the request. This allows processing requests that are\n     * greater than retention rate without having to exceed this rate on the contract.\n     * @param requestId The ID of the big request to process.\n     */\n    function processBigQueuedRequest(uint256 requestId) external onlyFund whenNotPaused {\n        // Retrieve request data\n        WithdrawalRequest memory request = withdrawalQueue[requestId];\n\n        // Ensure the request is active\n        require(request.account != address(0), \"L66\");\n\n        // Ensure the request emitter has not been blacklisted since request emission\n        require(!isBlacklisted(request.account), \"L50\");\n\n        // Ensure this is indeed a big request\n        require(request.amount > getExpectedRetained() / 2, \"L51\");\n\n        // Retrieve withdrawal fees and net withdrawn amount\n        (uint256 withdrawnAmount, uint256 fees) = getWithdrawnAmountAndFees(\n            request.account,\n            request.amount\n        );\n\n        // Ensure withdrawn amount can be covered by contract + fund wallet balances\n        uint256 fundBalance = underlying().balanceOf(fund);\n        require(withdrawnAmount <= usableUnderlyings + fundBalance, \"L52\");\n\n        // Increase amount of unclaimed fees accordingly\n        unclaimedFees += fees;\n\n        // Decrease total queued amount by request amount\n        totalQueued -= request.amount;\n\n        // Increment queue cursor if request was the next request to be processed\n        if (requestId == withdrawalQueueCursor) withdrawalQueueCursor++;\n\n        // Inform listeners of this queued withdrawal processing activity event\n        emit ActivityEvent(\n            int256(requestId),\n            request.account,\n            Action.Withdraw,\n            request.amount,\n            withdrawnAmount,\n            Status.Success,\n            NO_ID\n        );\n\n        // Remove request from queue\n        delete withdrawalQueue[requestId];\n\n        // If fund wallet's balance can cover request, rely on it only\n        if (withdrawnAmount <= fundBalance) {\n            underlying().safeTransferFrom(_msgSender(), request.account, withdrawnAmount);\n        }\n        // Else, cover request from both fund wallet and contract balances\n        else {\n            // Compute amount missing from fund wallet to cover request\n            uint256 missingAmount = withdrawnAmount - fundBalance;\n\n            // Decrease usable amount of underlying tokens accordingly\n            usableUnderlyings -= missingAmount;\n\n            // Transfer entire fund balance to request's emitter\n            underlying().safeTransferFrom(_msgSender(), request.account, fundBalance);\n\n            // Transfer missing amount from contract balance to request emitter\n            underlying().safeTransfer(request.account, missingAmount);\n        }\n\n        // Transfer exceeding underlying tokens to the fund wallet\n        _transferExceedingToFund();\n    }\n\n    /**\n     * @notice Cancels a given withdrawal request. The request emitter receive back its\n     * L-Tokens and no fees will be charged.\n     * @param requestId The ID of the withdrawal request to cancel.\n     */\n    function cancelWithdrawalRequest(\n        uint256 requestId\n    ) public whenNotPaused notBlacklisted(_msgSender()) {\n        // Retrieve request data\n        WithdrawalRequest memory request = withdrawalQueue[requestId];\n\n        // Ensure request belongs to caller\n        require(_msgSender() == request.account, \"L57\");\n\n        // Decrease total amount queued accordingly\n        totalQueued -= request.amount;\n\n        // Delete the withdrawal request from queue\n        delete withdrawalQueue[requestId];\n\n        // Inform listeners of this cancelled withdrawal request activity event\n        emit ActivityEvent(\n            int256(requestId),\n            request.account,\n            Action.Withdraw,\n            request.amount,\n            request.amount,\n            Status.Cancelled,\n            NO_ID\n        );\n\n        // Mint back L-Tokens to account\n        _mint(request.account, uint256(request.amount));\n    }\n\n    /**\n     * @notice Used by the fund wallet to repatriate underlying tokens on the contract\n     * whenever those are required to fulfill some withdrawal requests.\n     * @dev The function will revert if repatriated amount makes the contract exceeding\n     * the retention rate.\n     * @param amount The amount of underlying tokens to repatriate.\n     */\n    function repatriate(uint256 amount) external onlyFund whenNotPaused {\n        // Ensure the fund wallet has enough funds to repatriate\n        require(amount <= underlying().balanceOf(fund), \"L58\");\n\n        // Calculate new contract usable balance\n        uint256 newBalance = usableUnderlyings + amount;\n\n        // Ensure the new balance doesn't exceed the retention rate\n        require(newBalance <= getExpectedRetained(), \"L59\");\n\n        // Increase usable underlyings amount by repatriated amount\n        usableUnderlyings += amount;\n\n        // Transfer amount from fund wallet to contract\n        underlying().safeTransferFrom(_msgSender(), address(this), amount);\n    }\n\n    /// @notice Used by owner to claim fees generated from successful withdrawals.\n    function claimFees() external onlyOwner {\n        // Ensure there are some fees to claim\n        require(unclaimedFees > 0, \"L60\");\n\n        // Ensure the contract holds enough underlying tokens to cover fees\n        require(usableUnderlyings >= unclaimedFees, \"L61\");\n\n        // Decrease usable underlyings amount accordingly\n        usableUnderlyings -= unclaimedFees;\n\n        // Store fees amount in memory and reset unclaimed fees amount\n        uint256 fees = unclaimedFees;\n        unclaimedFees = 0;\n\n        // Transfer unclaimed fees to owner\n        underlying().safeTransfer(owner(), fees);\n    }\n}\n"
========
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.18;\n\n// Contracts\nimport {ERC20WrapperUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20WrapperUpgradeable.sol\";\nimport \"./abstracts/base/ERC20BaseUpgradeable.sol\";\nimport {InvestUpgradeable} from \"./abstracts/InvestUpgradeable.sol\";\nimport {LDYStaking} from \"./LDYStaking.sol\";\n\n// Libraries\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {SUD} from \"./libs/SUD.sol\";\n\n// Interfaces\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {IERC20MetadataUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\nimport {ITransfersListener} from \"./interfaces/ITransfersListener.sol\";\n\n/**\n * @title LToken\n * @author Lila Rest (https://lila.rest)\n * @custom:security-contact security@ledgity.com\n *\n * @notice Main contract of the Ledgity Yield protocol. It powers every L-Token (i.e.,\n * investment pools backed by RWA). An L-Token is an ERC20 wrapper around a stablecoin.\n * As soon as a wallet holds some L-Tokens, it starts receiving rewards in\n * the form of additional L-Tokens, which are auto-compounded over time.\n *\n * @dev Definitions:\n * - Deposit: Swap of underlying tokens for L-Tokens (1:1 ratio).\n * - Withdrawal: Swap of L-Tokens for underlying tokens (1:1 ratio, minus applicable fees).\n *   - Instant: Processed immediately.\n *   - Request: Queued for later processing.\n *   - Big Request: A requested withdrawal exceeding half of the retention rate.\n * - (Withdrawal) queue: A list of all requested withdrawals sorted by priority.\n * - Request ID: The index of a withdrawal request in the queue array.\n * - Retention rate: Maximum fraction of underlying tokens TVL the contract can retain.\n * - Fees Rate: Percentage of fees applied to successful withdrawals.\n * - Usable underlyings: Amount of underlying tokens that have been deposited through\n *                       expected ways and are so considered safe to use by the contract.\n * - Transfers listeners: External contracts listening on L-Tokens transfers.\n * - Fund wallet: Wallet managed by the Ledgity's financial team.\n * - Withdrawer wallet: Managed by an off-chain server to automate withdrawal request\n *                      processing.\n *\n * Note that words between parenthesis are sometimes omitted for brevity.\n *\n * @dev Deployment notice:\n * This contract can safely receive funds immediately after initialization. (i.e., there\n * is no way for funds to be sent to non-owned addresses). It is, however, recommended to\n * replace ASAP owner and fund wallets with multi-sig wallets.\n *\n * @dev For further details, see \"LToken\" section of whitepaper.\n * @custom:oz-upgrades-unsafe-allow external-library-linking\n * @custom:security-contact security@ledgity.com\n */\ncontract LToken is ERC20BaseUpgradeable, InvestUpgradeable, ERC20WrapperUpgradeable {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /// @dev Represents type of actions triggering ActivityEvent events.\n    enum Action {\n        Deposit,\n        Withdraw\n    }\n\n    /// @dev Represents different status of actions triggering ActivityEvent events.\n    enum Status {\n        Queued,\n        Cancelled,\n        Success,\n        Moved\n    }\n\n    /**\n     * @notice Represents a withdrawal request in the queue.\n     * @dev A request fits in a single storage slot (32 bytes).\n     * @param account The account that initiated the request.\n     * @param amount The amount of underlying tokens requested.\n     */\n    struct WithdrawalRequest {\n        address account; // 20 bytes\n        uint96 amount; // 12 bytes\n    }\n\n    /// @notice Upper limit of retention rate.\n    uint32 private constant MAX_RETENTION_RATE_UD7x3 = 10 * 10 ** 3; // 10%\n\n    /// @notice Upper limit of fees rate.\n    uint32 private constant MAX_FEES_RATE_UD7x3 = 20 * 10 ** 3; // 20%\n\n    /// @notice Used in activity events to represent the absence of request ID.\n    int256 private constant NO_ID = -1;\n\n    /// @notice Holds a reference to the LDYStaking contract.\n    LDYStaking public ldyStaking;\n\n    /// @notice Holds address of withdrawer wallet (managed by withdrawal server).\n    address payable public withdrawer;\n\n    /// @notice Holds address of fund wallet (managed by Ledgity financial team).\n    address public fund;\n\n    /// @notice Holds the withdrawal fees rate in UD7x3 format (e.g., 350 = 0.350%).\n    uint32 public feesRateUD7x3;\n\n    /// @notice Holds the retention rate in UD7x3 format.\n    uint32 public retentionRateUD7x3;\n\n    /// @notice Holds the amount of withdrawal fees not yet claimed by contract's owner.\n    uint256 public unclaimedFees;\n\n    /// @notice Holds the amount of L-Tokens currently in the withdrawal queue.\n    uint256 public totalQueued;\n\n    /**\n     * @notice Holds the amount of underlying tokens considered as usable by the contract.\n     * @dev Are usable, only underlying tokens deposit through deposit() or fund() functions.\n     */\n    uint256 public usableUnderlyings;\n\n    /// @notice Holds an ordered list of active withdrawal requests.\n    WithdrawalRequest[] public withdrawalQueue;\n\n    /// @notice Holds the index of the next withdrawal request to process in the queue.\n    uint256 public withdrawalQueueCursor;\n\n    /**\n     * @notice Holds a list of all currently frozen withdrawal requests.\n     * @dev If a request emitter as been blacklisted, its request is moved here to prevent\n     * it from blocking the queue.\n     */\n    WithdrawalRequest[] public frozenRequests;\n\n    /**\n     * @notice Holds a list of contracts' references that are listening to L-Tokens transfers.\n     * @dev onLTokenTransfer() functions of those contracts will be called on each transfer.\n     */\n    ITransfersListener[] public transfersListeners;\n\n    /**\n     * @notice Holds the withdrawalFee amount in ETH that will be sent to withdrawer wallet.\n     */\n    uint256 public withdrawalFeeInEth;\n\n    /**\n     * @notice Emitted to inform listeners about a change in the contract's TVL.\n     * @dev TVL = realTotalSupply()\n     * @param newTVL The new TVL of the contract.\n     */\n    event TVLChangeEvent(uint256 newTVL);\n\n    /**\n     * @notice Emitted to inform listerners about an activity related to deposits and withdrawals.\n     * @param id ID of the involved withdrawal request or NO_ID (-1) if not applicable.\n     * @param account The account involved in the activity.\n     * @param action The type of activity.\n     * @param amount The amount of underlying tokens involved in the activity.\n     * @param newStatus The new status of the activity.\n     * @param newId The new ID of the request if it has been moved in the queue.\n     */\n    event ActivityEvent(\n        int256 indexed id,\n        address indexed account,\n        Action indexed action,\n        uint256 amount,\n        uint256 amountAfterFees,\n        Status newStatus,\n        int256 newId,\n        string referralCode\n    );\n\n    /**\n     * @notice Emitted to inform listeners that some rewards have been minted.\n     * @param account The account that received the rewards.\n     * @param balanceBefore The balance of the account before the minting.\n     * @param rewards The amount of minted rewards.\n     */\n    event MintedRewardsEvent(address indexed account, uint256 balanceBefore, uint256 rewards);\n\n    /// @notice Reverts if the function caller is not the withdrawer wallet.\n    modifier onlyWithdrawer() {\n        require(_msgSender() == withdrawer, \"L39\");\n        _;\n    }\n\n    /// @notice Reverts if the function caller is not the fund wallet.\n    modifier onlyFund() {\n        require(_msgSender() == fund, \"L40\");\n        _;\n    }\n\n    /**\n     * @notice Initializer function of the contract. It replaces the constructor()\n     * function in the context of upgradeable contracts.\n     * @dev See: https://docs.openzeppelin.com/contracts/4.x/upgradeable\n     * @param globalOwner_ The address of the GlobalOwner contract.\n     * @param globalPause_ The address of the GlobalPause contract.\n     * @param globalBlacklist_ The address of the GlobalBlacklist contract.\n     * @param underlyingToken The address of the underlying stablecoin ERC20 token.\n     */\n    function initialize(\n        address globalOwner_,\n        address globalPause_,\n        address globalBlacklist_,\n        address ldyStaking_,\n        address underlyingToken\n    ) public initializer {\n        // Initialize ERC20 base.\n        string memory underlyingSymbol = IERC20MetadataUpgradeable(underlyingToken).symbol();\n        __ERC20Base_init(\n            globalOwner_,\n            globalPause_,\n            globalBlacklist_,\n            string(abi.encodePacked(\"Ledgity \", underlyingSymbol)),\n            string(abi.encodePacked(\"L\", underlyingSymbol))\n        );\n\n        // IMPORTANT: Below calls must not be restricted to owner at any point.\n        // This is because the GlobalOwner contract may not be a fresh one, and so\n        // the contract deployer may not be the owner anymore after ERC20Base init.\n\n        // Initialize other parents contracts.\n        __ERC20Wrapper_init(IERC20Upgradeable(underlyingToken));\n        __Invest_init_unchained(address(this));\n\n        // Set LDYStaking contract\n        ldyStaking = LDYStaking(ldyStaking_);\n\n        // Set initial withdrawal fees rate to 0.3%\n        feesRateUD7x3 = 300;\n\n        // Set initial retention rate to 10%\n        retentionRateUD7x3 = 10_000;\n\n        // Default withdrawer and fund wallet to contract owner address. This prevents\n        // any loss of funds if a deposit/withdrawal is made before those are manually set.\n        withdrawer = payable(owner());\n        fund = payable(owner());\n\n        // Set initial withdrawalFeeInEth\n        withdrawalFeeInEth = 0.00075 * 1e18;\n    }\n\n    /**\n     * @notice Required override of decimals() which is implemented by both\n     * ERC20Upgradeable and ERC20WrapperUpgradeable parent contracts.\n     * @dev The ERC20WrapperUpgradeable version is preferred because it mirrors the\n     * decimals amount of the underlying stablecoin token.\n     * @inheritdoc ERC20WrapperUpgradeable\n     */\n    function decimals()\n        public\n        view\n        override(ERC20Upgradeable, ERC20WrapperUpgradeable)\n        returns (uint8)\n    {\n        return ERC20WrapperUpgradeable.decimals();\n    }\n\n    /**\n     * @notice Required override of paused() which is implemented by both\n     * GlobalPausableUpgradeable and ERC20BaseUpgradeable parent contracts.\n     * @dev Both version are the same as ERC20BaseUpgradeable.paused() mirrors\n     * GlobalPausableUpgradeable.paused(), so a random one is chosen.\n     * @inheritdoc GlobalPausableUpgradeable\n     */\n    function paused()\n        public\n        view\n        virtual\n        override(GlobalPausableUpgradeable, ERC20BaseUpgradeable)\n        returns (bool)\n    {\n        return GlobalPausableUpgradeable.paused();\n    }\n\n    /**\n     * @notice Updates the current withdrawal fee rate.\n     * @param feesRateUD7x3_ The new withdrawal fee rate in UD7x3 format.\n     */\n    function setFeesRate(uint32 feesRateUD7x3_) public onlyOwner {\n        require(feesRateUD7x3_ <= MAX_FEES_RATE_UD7x3, \"L88\");\n        feesRateUD7x3 = feesRateUD7x3_;\n    }\n\n    /**\n     * @notice Updates the current withdrawalFeeInETH.\n     * @param withdrawalFeeInEth_ The new withdrawalFee in ETH.\n     */\n    function setWithdrawalFeeInEth(uint256 withdrawalFeeInEth_) public onlyOwner {\n        withdrawalFeeInEth = withdrawalFeeInEth_;\n    }\n\n    /**\n     * @notice Updates the current underlying token retention rate.\n     * @dev The retention rate is capped at 10%, which ensures that no more than 10% of\n     * deposited assets will ever be exposed in this contract (reduces attack surface).\n     * @param retentionRateUD7x3_ The new retention rate in UD7x3 format.\n     */\n    function setRetentionRate(uint32 retentionRateUD7x3_) public onlyOwner {\n        require(retentionRateUD7x3_ <= MAX_RETENTION_RATE_UD7x3, \"L41\");\n        retentionRateUD7x3 = retentionRateUD7x3_;\n    }\n\n    /**\n     * @notice Updates the address of LDYStaking contract.\n     * @param ldyStakingAddress The address of the new LDYStaking contract.\n     */\n    function setLDYStaking(address ldyStakingAddress) public onlyOwner {\n        ldyStaking = LDYStaking(ldyStakingAddress);\n    }\n\n    /**\n     * @notice Updates the address of the withdrawer wallet.\n     * @param withdrawer_ The address of the new withdrawer wallet.\n     */\n    function setWithdrawer(address payable withdrawer_) public onlyOwner {\n        // Ensure address is not the zero address (pre-processing fees would be lost else)\n        require(withdrawer_ != address(0), \"L63\");\n\n        // Set new withdrawer wallet's address\n        withdrawer = withdrawer_;\n    }\n\n    /**\n     * @notice Updates the address of the fund wallet.\n     * @param fund_ The address of the new fund wallet.\n     */\n    function setFund(address payable fund_) public onlyOwner {\n        // Ensure address is not the zero address (deposited tokens would be lost else)\n        require(fund_ != address(0), \"L64\");\n\n        // Set new fund wallet's address\n        fund = fund_;\n    }\n\n    /**\n     * @notice Adds a new contract to the L-Token transfers list.\n     * @dev Each time a transfer occurs, the onLTokenTransfer() function of the\n     * specified contract will be called.\n     * @dev IMPORTANT SECURITY NOTE: This method is not intended to be used with\n     * contracts that are not owned by the Ledgity team.\n     * @param listenerContract The address of the new transfers listener contract.\n     */\n    function listenToTransfers(address listenerContract) public onlyOwner {\n        transfersListeners.push(ITransfersListener(listenerContract));\n    }\n\n    /**\n     * @notice Removes a contract from the L-Token transfers list.\n     * @dev The onLTokenTransfer() function of the specified contract will not be called\n     * anymore each time a L-Token transfer occurs.\n     * @param listenerContract The address of the listener contract.\n     */\n    function unlistenToTransfers(address listenerContract) public onlyOwner {\n        // Find index of listener contract in transferListeners array\n        int256 index = -1;\n        uint256 transfersListenersLength = transfersListeners.length;\n        for (uint256 i = 0; i < transfersListenersLength; i++) {\n            if (address(transfersListeners[i]) == listenerContract) {\n                index = int256(i);\n                break;\n            }\n        }\n\n        // Revert if given contract wasn't listening to transfers\n        require(index > -1, \"L42\");\n\n        // Else, remove transfers listener contract from listeners array\n        transfersListeners[uint256(index)] = transfersListeners[transfersListenersLength - 1];\n        transfersListeners.pop();\n    }\n\n    /**\n     * @notice Retrieves the amount of given account's not yet minted rewards.\n     * @dev This is a public implementation of InvestUpgradeable_rewardsOf(). In the\n     * context of LToken, this function returns the amount of rewards that have not been\n     * distributed/minted yet to the specified account.\n     * @dev This is particularly useful for off-chain services to display charts and\n     * statistics, as seen in the Ledgity Yield's frontend.\n     * @param account The account to check the unminted rewards of.\n     * @return The amount of account's unminted rewards.\n     */\n    function unmintedRewardsOf(address account) public view returns (uint256) {\n        return _rewardsOf(account, true);\n    }\n\n    /**\n     * @notice Retrieves the \"real\" balance of an account, i.e., excluding its not yet\n     * minted/distributed rewards.\n     * @param account The account to check the real balance of.\n     * @return The real balance of the account.\n     */\n    function realBalanceOf(address account) public view returns (uint256) {\n        return super.balanceOf(account);\n    }\n\n    /**\n     * @notice Retrieves the total balance of L-Tokens that belong to the account.\n     * @dev This is an oOverride of ERC20Upgradeable.balanceOf() that rewards that have\n     * not been yet minted to the specified account.\n     * @param account The account to check the total balance of.\n     * @return The total balance of the account.\n     */\n    function balanceOf(address account) public view override returns (uint256) {\n        return realBalanceOf(account) + unmintedRewardsOf(account);\n    }\n\n    /**\n     * @notice Returns the \"real\" amount of existing L-Tokens, i.e., excluding not yet\n     * minted withdrawal fees and L-Tokens currently in the withdrawal queue.\n     * @return The real total supply of L-Tokens.\n     */\n    function realTotalSupply() public view returns (uint256) {\n        return super.totalSupply();\n    }\n\n    /**\n     * @notice Retrives the total supply of L-Tokens, including not yet minted withdrawal\n     * fees and L-Tokens currently in the withdrawal queue.\n     * @return The total supply of L-Tokens.\n     */\n    function totalSupply() public view override returns (uint256) {\n        return realTotalSupply() + totalQueued + unclaimedFees;\n    }\n\n    /**\n     * @notice Recovers a specified amount of a given token address.\n     * @dev This override of RecoverableUpgradeable.recoverERC20() prevents the recovered\n     * token from being the underlying token.\n     * @inheritdoc RecoverableUpgradeable\n     */\n    function recoverERC20(address tokenAddress, uint256 amount) public override onlyOwner {\n        // Ensure the token is not the underlying token\n        require(tokenAddress != address(underlying()), \"L43\");\n\n        // Proceed to recovery\n        super.recoverERC20(tokenAddress, amount);\n    }\n\n    /**\n     * @notice Recovers underlying tokens accidentally sent to the contract.\n     * @dev To prevent owner from being able to drain the contract, this function only\n     * allows recovering \"unusable\" underlying tokens, i.e., tokens that have not been\n     * sent through fund() or deposit() functions.\n     */\n    function recoverUnderlying() external onlyOwner {\n        // Compute the recoverable amount by taking the difference between the contract's\n        // balance and the amount of usable underlying tokens\n        uint256 recoverableAmount = underlying().balanceOf(address(this)) - usableUnderlyings;\n\n        // Revert if there is nothing to recover\n        require(recoverableAmount > 0, \"L44\");\n\n        // Else, proceed to underlying tokens recovery\n        super.recoverERC20(address(underlying()), recoverableAmount);\n    }\n\n    /**\n     * @notice Retrieves the amount of underlying tokens invested by the given account.\n     * @dev Implementing this function is required by the InvestUpgradeable contract. In\n     * LToken contract, the investment of an account is equal to its real balance.\n     * @inheritdoc InvestUpgradeable\n     */\n    function _investmentOf(address account) internal view override returns (uint256) {\n        return realBalanceOf(account);\n    }\n\n    /**\n     * @notice Distributes a specified amount of rewards (in L-Tokens) to a given account.\n     * @dev Implementing this function is required by the InvestUpgradeable contract so\n     * it can distribute rewards to accounts before each period reset.\n     * @dev InvestUpgradeable contract already ensure that amount > 0.\n     * @inheritdoc InvestUpgradeable\n     */\n    function _distributeRewards(address account, uint256 amount) internal override returns (bool) {\n        // Inform listeners of the rewards minting\n        emit MintedRewardsEvent(account, realBalanceOf(account), amount);\n\n        // Mint L-Tokens rewards to account\n        _mint(account, amount);\n\n        // Return true indicating to InvestUpgradeable that the rewards have been distributed\n        return true;\n    }\n\n    /**\n     * @notice Override of ERC20._beforeTokenTransfer() to integrate with InvestUpgradeable.\n     * @dev This overriden version ensure that _beforeInvestmentChange() hook is properly\n     * called each time an account's balance is going to change.\n     * @dev Note: whenNotPaused and notBlacklisted modifiers are not set as they are\n     * already included in ERC20BaseUpgradeable._beforeTokenTransfer().\n     * @inheritdoc ERC20BaseUpgradeable\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal override(ERC20Upgradeable, ERC20BaseUpgradeable) {\n        ERC20BaseUpgradeable._beforeTokenTransfer(from, to, amount);\n\n        // Invoke _beforeInvestmentChange() hook for non-zero accounts\n        if (from != address(0)) _beforeInvestmentChange(from, true);\n        if (to != address(0)) _beforeInvestmentChange(to, true);\n    }\n\n    /**\n     * @notice Override of ERC20._afterTokenTransfer() to notify all transfers listeners.\n     * @dev This overriden version will trigger onLTokenTransfer() functions of all\n     * transfers listeners.\n     * @dev Note: whenNotPaused and notBlacklisted modifiers are not set as they are\n     * already checked in _beforeTokenTransfer().\n     * @inheritdoc ERC20Upgradeable\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal override {\n        super._afterTokenTransfer(from, to, amount);\n\n        // If some L-Token have been burned/minted, inform listeners of a TVL change\n        if (from == address(0) || to == address(0)) emit TVLChangeEvent(totalSupply());\n\n        // Trigger onLTokenTransfer() functions of all the transfers listeners\n        for (uint256 i = 0; i < transfersListeners.length; i++) {\n            transfersListeners[i].onLTokenTransfer(from, to, amount);\n        }\n    }\n\n    /**\n     * @notice Computes the maximum amount of underlying tokens that should be retained\n     * by the contract (based on retention rate).\n     * @return amount The expected amount of retained underlying tokens.\n     */\n    function getExpectedRetained() public view returns (uint256 amount) {\n        // Cache invested token's decimals number\n        uint256 d = SUD.decimalsOf(address(invested()));\n\n        // Convert totalSupply and retentionRate to SUD\n        uint256 totalSupplySUD = SUD.fromAmount(totalSupply(), d);\n        uint256 retentionRateSUD = SUD.fromRate(retentionRateUD7x3, d);\n\n        // Compute and return expected retained amount\n        uint256 expectedRetainedSUD = (totalSupplySUD * retentionRateSUD) / SUD.fromInt(100, d);\n        return SUD.toAmount(expectedRetainedSUD, d);\n    }\n\n    /// @notice Transfers underlying tokens exceeding the retention rate to the fund wallet.\n    function _transferExceedingToFund() internal {\n        // Retrieve the expected amount retained\n        uint256 expectedRetained = getExpectedRetained();\n\n        // If usable underlyings are less than or equal to expected retained, return\n        if (usableUnderlyings <= expectedRetained) return;\n\n        // Else, exceeding amount is equal to difference between those values\n        uint256 exceedingAmount = usableUnderlyings - expectedRetained;\n\n        // Decrease usable underlyings amount accordingly\n        usableUnderlyings -= exceedingAmount;\n\n        // Transfer the exceeding amount to the fund wallet\n        underlying().safeTransfer(fund, exceedingAmount);\n    }\n\n    /**\n     * @notice Override of ERC20WrapperUpgradeable.withdrawTo() that reverts.\n     * Use instantWithdrawal() or requestWithdrawal() functions instead.\n     * @inheritdoc ERC20WrapperUpgradeable\n     */\n    function withdrawTo(address account, uint256 amount) public pure override returns (bool) {\n        account; // Silence unused variable compiler warning\n        amount;\n        revert(\"L45\");\n    }\n\n    /**\n     * @notice Override of ERC20WrapperUpgradeable.depositFor() that reverts.\n     * Use deposit() function instead.\n     * @inheritdoc ERC20WrapperUpgradeable\n     */\n    function depositFor(address account, uint256 amount) public pure override returns (bool) {\n        account; // Silence unused variable compiler warning\n        amount;\n        revert(\"L46\");\n    }\n\n    /**\n     * @notice Allows exchanging some underlying tokens for the same amount of L-Tokens.\n     * @param amount The amount of underlying tokens to deposit.\n     * @param refCode The Referral code\n     */\n    function deposit(\n        uint256 amount,\n        string memory refCode\n    ) public whenNotPaused notBlacklisted(_msgSender()) {\n        // Ensure the account has enough underlying tokens to deposit\n        require(underlying().balanceOf(_msgSender()) >= amount, \"L47\");\n\n        // Update usable underlyings balance accordingly\n        usableUnderlyings += amount;\n\n        // Inform listeners of the deposit activity event\n        emit ActivityEvent(\n            NO_ID,\n            _msgSender(),\n            Action.Deposit,\n            amount,\n            amount,\n            Status.Success,\n            NO_ID,\n            refCode\n        );\n\n        // Receive underlying tokens and mint L-Tokens to the account in a 1:1 ratio\n        super.depositFor(_msgSender(), amount);\n\n        // Transfer exceeding underlying tokens to the fund wallet\n        _transferExceedingToFund();\n    }\n\n    /**\n     * @notice Computes fees and net withdrawn amount for a given account withdrawing a\n     * given amount.\n     * @param account The account initiating the withdrawal.\n     * @param amount The amount of the withdrawal.\n     */\n    function getWithdrawnAmountAndFees(\n        address account,\n        uint256 amount\n    ) public view returns (uint256 withdrawnAmount, uint256 fees) {\n        // If the account is eligible to staking tier 2, no fees are applied\n        if (ldyStaking.tierOf(account) >= 2) return (amount, 0);\n\n        // Cache invested token's decimals number\n        uint256 d = SUD.decimalsOf(address(invested()));\n\n        // Convert amount and fees rate to SUD\n        uint256 amountSUD = SUD.fromAmount(amount, d);\n        uint256 feesRateSUD = SUD.fromRate(feesRateUD7x3, d);\n\n        // Compute fees and withdrawn amount (initial amount minus fees)\n        uint256 feesSUD = (amountSUD * feesRateSUD) / SUD.fromInt(100, d);\n        fees = SUD.toAmount(feesSUD, d);\n        withdrawnAmount = amount - fees;\n    }\n\n    /**\n     * @notice Allows instaneously exchanging a given amount of L-Tokens for the same\n     * amount of underlying tokens. It will fail if the contract currently doesn't hold\n     * enough underlying tokens to cover the withdrawal.\n     * @dev In order to save some gas and time to users, frontends should propose this\n     * function to users only when it has been verified that it will not revert. They\n     * should propose the requestWithdrawal() function otherwise.\n     * @param amount The amount L-Tokens to withdraw.\n     */\n    function instantWithdrawal(uint256 amount) external whenNotPaused notBlacklisted(_msgSender()) {\n        // Ensure the account has enough L-Tokens to withdraw\n        require(amount <= balanceOf(_msgSender()), \"L48\");\n\n        // Can the contract cover this withdrawal plus all already queued requests?\n        bool cond1 = totalQueued + amount <= usableUnderlyings;\n\n        // Is caller eligible to staking tier 2 and the contract can cover this withdrawal?\n        bool cond2 = ldyStaking.tierOf(_msgSender()) >= 2 && amount <= usableUnderlyings;\n\n        // Revert if conditions are not met for the withdrawal to be processed instantaneously\n        if (!(cond1 || cond2)) revert(\"L49\");\n\n        // Else, retrieve withdrawal fees and net withdrawn amount\n        (uint256 withdrawnAmount, uint256 fees) = getWithdrawnAmountAndFees(_msgSender(), amount);\n\n        // Increase unclaimed fees amount accordingly\n        unclaimedFees += fees;\n\n        // Decrease usable underlyings balance accordingly\n        usableUnderlyings -= withdrawnAmount;\n\n        // Inform listeners of this instant withdrawal activity event\n        emit ActivityEvent(\n            NO_ID,\n            _msgSender(),\n            Action.Withdraw,\n            amount,\n            withdrawnAmount,\n            Status.Success,\n            NO_ID,\n            \"\"\n        );\n\n        // Burn withdrawal fees from the account\n        _burn(_msgSender(), fees);\n\n        // Burn account's withdrawn L-Tokens and transfer to it underlying tokens in a 1:1 ratio\n        super.withdrawTo(_msgSender(), withdrawnAmount);\n    }\n\n    /**\n     * @notice Allows requesting the exchange of a given amount of L-Tokens for the same\n     * amount of underlying tokens. The request will be automatically processed later.\n     * @dev The sender must attach withdrawalFeeInETH to pre-pay the future processing gas fees\n     * paid by the withdrawer wallet.\n     * @param amount The amount L-Tokens to withdraw.\n     */\n    function requestWithdrawal(\n        uint256 amount\n    ) public payable whenNotPaused notBlacklisted(_msgSender()) {\n        // Ensure the account has enough L-Tokens to withdraw\n        require(amount <= balanceOf(_msgSender()), \"L53\");\n\n        // Ensure the requested amount doesn't overflow uint96\n        require(amount <= type(uint96).max, \"L54\");\n\n        // Ensure the sender attached the pre-paid processing gas fees\n        require(msg.value == withdrawalFeeInEth, \"L55\");\n\n        // Create withdrawal request data\n        WithdrawalRequest memory request = WithdrawalRequest({\n            account: _msgSender(),\n            amount: uint96(amount)\n        });\n\n        // Will hold the request ID\n        uint256 requestId;\n\n        // Append request to the withdrawal queue:\n        // - At the beginning, if account is eligible to staking tier 2 and cursor is not 0\n        if (ldyStaking.tierOf(_msgSender()) >= 2 && withdrawalQueueCursor > 0) {\n            withdrawalQueueCursor--;\n            requestId = withdrawalQueueCursor;\n            withdrawalQueue[requestId] = request;\n        }\n        // - At the end else\n        else {\n            withdrawalQueue.push(request);\n            requestId = withdrawalQueue.length - 1;\n        }\n\n        // Increase total amount queued accordingly\n        totalQueued += amount;\n\n        // Inform listeners of this new queued withdrawal activity event\n        emit ActivityEvent(\n            int256(requestId),\n            _msgSender(),\n            Action.Withdraw,\n            amount,\n            amount,\n            Status.Queued,\n            NO_ID,\n            \"\"\n        );\n\n        // Burn withdrawal L-Tokens amount from account's balance\n        _burn(_msgSender(), amount);\n\n        // Forward pre-paid processing gas fees to the withdrawer wallet\n        (bool sent, ) = withdrawer.call{value: msg.value}(\"\");\n        require(sent, \"L56\");\n    }\n\n    /**\n     * @notice Processes queued withdrawal requests until there is else no more requests,\n     * else not enough underlying tokens to continue.\n     * @dev For further details, see \"LToken  > Withdrawals\" section of whitepaper.\n     */\n    function processQueuedRequests() external onlyWithdrawer whenNotPaused {\n        // Accumulators variables, will be written on-chain after the loop\n        uint256 cumulatedFees = 0;\n        uint256 cumulatedWithdrawnAmount = 0;\n        uint256 nextRequestId = withdrawalQueueCursor;\n\n        // Cache queue length to avoid multiple SLOADs and avoid infinite loop as big\n        // requests are increasing the queue length when moved at the end of the queue.\n        uint256 queueLength = withdrawalQueue.length;\n\n        // Iterate over requests to be processed\n        while (nextRequestId < queueLength) {\n            // Stop processing requests if there is not enough gas left to continue the\n            // loop and properly end the function call. This prevents an attacker from\n            // blocking the withdrawal processing by creating a ton of tiny requests so\n            // this function call cannot fit anymore in block gas limit.\n            if (gasleft() < 45000) break;\n\n            // Retrieve request data\n            WithdrawalRequest memory request = withdrawalQueue[nextRequestId];\n\n            // Skip empty request (processed big requests or cancelled requests)\n            if (request.account == address(0)) {}\n            //\n            // If account has been blacklisted since request emission\n            else if (isBlacklisted(request.account)) {\n                // Remove request from queue\n                delete withdrawalQueue[nextRequestId];\n\n                // Append request in the frozen requests list\n                frozenRequests.push(request);\n            }\n            //\n            // Or if request is a big request, move it at the end of the queue for now.\n            // This request will be processed manually later using processBigQueuedRequest()\n            else if (request.amount > getExpectedRetained() / 2) {\n                // Inform listeners of this queued request being moved at the end of the queue\n                emit ActivityEvent(\n                    int256(nextRequestId),\n                    _msgSender(),\n                    Action.Withdraw,\n                    request.amount,\n                    request.amount,\n                    Status.Moved,\n                    int256(withdrawalQueue.length),\n                    \"\"\n                );\n\n                // Remove request from queue\n                delete withdrawalQueue[nextRequestId];\n\n                // Append request at the end of the queue\n                withdrawalQueue.push(request);\n            }\n            //\n            // Else, continue request processing\n            else {\n                // Retrieve withdrawal fees and net withdrawn amount\n                (uint256 withdrawnAmount, uint256 fees) = getWithdrawnAmountAndFees(\n                    request.account,\n                    request.amount\n                );\n\n                // Break if the contract doesn't hold enough funds to cover the request\n                if (withdrawnAmount > usableUnderlyings - cumulatedWithdrawnAmount) break;\n\n                // Accumulate fees and withdrawn amount\n                cumulatedFees += fees;\n                cumulatedWithdrawnAmount += withdrawnAmount;\n\n                // Inform listeners of this queued withdrawal processing activity event\n                emit ActivityEvent(\n                    int256(nextRequestId),\n                    request.account,\n                    Action.Withdraw,\n                    request.amount,\n                    withdrawnAmount,\n                    Status.Success,\n                    NO_ID,\n                    \"\"\n                );\n\n                // Remove request from queue\n                delete withdrawalQueue[nextRequestId];\n\n                // Transfer underlying tokens to account. Burning L-Tokens is not required\n                // as equestWithdrawal() already did it.\n                // Security note: Re-entrancy warning are disabled as the request has\n                // just been deleted from the queue, it will so be skipped if trying to\n                // process it again.\n                // slither-disable-next-line reentrancy-no-eth\n                underlying().safeTransfer(request.account, withdrawnAmount);\n            }\n\n            // Increment next request ID\n            nextRequestId++;\n        }\n\n        // Increase unclaimed fees by the amount of cumulated fees\n        unclaimedFees += cumulatedFees;\n\n        // Decrease usable underlyings by the cumulated amount of withdrawn underlyings\n        usableUnderlyings -= cumulatedWithdrawnAmount;\n\n        // Decrease total amount queued by the cumulated amount requested\n        totalQueued -= cumulatedWithdrawnAmount + cumulatedFees;\n\n        // Update new queue cursor\n        withdrawalQueueCursor = nextRequestId;\n\n        // Retention rate cannot exceeds as the withdrawal decreases both usable\n        // underlyings and expected retained amounts by the same number and as the\n        // expected retained amount is a subset of usable underlyings amount.\n    }\n\n    /**\n     * @notice Processes a given queued big withdrawal request (one that exceeds half of\n     * the retention rate).\n     * @dev In contrast to non-big requests processing, this function will uses to fund\n     * wallet's balance to fill the request. This allows processing requests that are\n     * greater than retention rate without having to exceed this rate on the contract.\n     * @param requestId The ID of the big request to process.\n     */\n    function processBigQueuedRequest(uint256 requestId) external onlyFund whenNotPaused {\n        // Retrieve request data\n        WithdrawalRequest memory request = withdrawalQueue[requestId];\n\n        // Ensure the request is active\n        require(request.account != address(0), \"L66\");\n\n        // Ensure the request emitter has not been blacklisted since request emission\n        require(!isBlacklisted(request.account), \"L50\");\n\n        // Ensure this is indeed a big request\n        require(request.amount > getExpectedRetained() / 2, \"L51\");\n\n        // Retrieve withdrawal fees and net withdrawn amount\n        (uint256 withdrawnAmount, uint256 fees) = getWithdrawnAmountAndFees(\n            request.account,\n            request.amount\n        );\n\n        // Ensure withdrawn amount can be covered by contract + fund wallet balances\n        uint256 fundBalance = underlying().balanceOf(fund);\n        require(withdrawnAmount <= usableUnderlyings + fundBalance, \"L52\");\n\n        // Increase amount of unclaimed fees accordingly\n        unclaimedFees += fees;\n\n        // Decrease total queued amount by request amount\n        totalQueued -= request.amount;\n\n        // Increment queue cursor if request was the next request to be processed\n        if (requestId == withdrawalQueueCursor) withdrawalQueueCursor++;\n\n        // Inform listeners of this queued withdrawal processing activity event\n        emit ActivityEvent(\n            int256(requestId),\n            request.account,\n            Action.Withdraw,\n            request.amount,\n            withdrawnAmount,\n            Status.Success,\n            NO_ID,\n            \"\"\n        );\n\n        // Remove request from queue\n        delete withdrawalQueue[requestId];\n\n        // If fund wallet's balance can cover request, rely on it only\n        if (withdrawnAmount <= fundBalance) {\n            underlying().safeTransferFrom(_msgSender(), request.account, withdrawnAmount);\n        }\n        // Else, cover request from both fund wallet and contract balances\n        else {\n            // Compute amount missing from fund wallet to cover request\n            uint256 missingAmount = withdrawnAmount - fundBalance;\n\n            // Decrease usable amount of underlying tokens accordingly\n            usableUnderlyings -= missingAmount;\n\n            // Transfer entire fund balance to request's emitter\n            underlying().safeTransferFrom(_msgSender(), request.account, fundBalance);\n\n            // Transfer missing amount from contract balance to request emitter\n            underlying().safeTransfer(request.account, missingAmount);\n        }\n\n        // Transfer exceeding underlying tokens to the fund wallet\n        _transferExceedingToFund();\n    }\n\n    /**\n     * @notice Cancels a given withdrawal request. The request emitter receive back its\n     * L-Tokens and no fees will be charged.\n     * @param requestId The ID of the withdrawal request to cancel.\n     */\n    function cancelWithdrawalRequest(\n        uint256 requestId\n    ) public whenNotPaused notBlacklisted(_msgSender()) {\n        // Retrieve request data\n        WithdrawalRequest memory request = withdrawalQueue[requestId];\n\n        // Ensure request belongs to caller\n        require(_msgSender() == request.account, \"L57\");\n\n        // Decrease total amount queued accordingly\n        totalQueued -= request.amount;\n\n        // Delete the withdrawal request from queue\n        delete withdrawalQueue[requestId];\n\n        // Inform listeners of this cancelled withdrawal request activity event\n        emit ActivityEvent(\n            int256(requestId),\n            request.account,\n            Action.Withdraw,\n            request.amount,\n            request.amount,\n            Status.Cancelled,\n            NO_ID,\n            \"\"\n        );\n\n        // Mint back L-Tokens to account\n        _mint(request.account, uint256(request.amount));\n    }\n\n    /**\n     * @notice Used by the fund wallet to repatriate underlying tokens on the contract\n     * whenever those are required to fulfill some withdrawal requests.\n     * @dev The function will revert if repatriated amount makes the contract exceeding\n     * the retention rate.\n     * @param amount The amount of underlying tokens to repatriate.\n     */\n    function repatriate(uint256 amount) external onlyFund whenNotPaused {\n        // Ensure the fund wallet has enough funds to repatriate\n        require(amount <= underlying().balanceOf(fund), \"L58\");\n\n        // Calculate new contract usable balance\n        uint256 newBalance = usableUnderlyings + amount;\n\n        // Ensure the new balance doesn't exceed the retention rate\n        require(newBalance <= getExpectedRetained(), \"L59\");\n\n        // Increase usable underlyings amount by repatriated amount\n        usableUnderlyings += amount;\n\n        // Transfer amount from fund wallet to contract\n        underlying().safeTransferFrom(_msgSender(), address(this), amount);\n    }\n\n    /// @notice Used by owner to claim fees generated from successful withdrawals.\n    function claimFees() external onlyOwner {\n        // Ensure there are some fees to claim\n        require(unclaimedFees > 0, \"L60\");\n\n        // Ensure the contract holds enough underlying tokens to cover fees\n        require(usableUnderlyings >= unclaimedFees, \"L61\");\n\n        // Decrease usable underlyings amount accordingly\n        usableUnderlyings -= unclaimedFees;\n\n        // Store fees amount in memory and reset unclaimed fees amount\n        uint256 fees = unclaimedFees;\n        unclaimedFees = 0;\n\n        // Transfer unclaimed fees to owner\n        underlying().safeTransfer(owner(), fees);\n    }\n}\n"
>>>>>>>> main:contracts/hardhat/deployments/arbitrumSepolia/solcInputs/1d9f98e9f73009a42653e1abaf15e178.json
    },
    "contracts/src/LTokenSignaler.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.18;\n\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport {GlobalOwnableUpgradeable} from \"./abstracts/GlobalOwnableUpgradeable.sol\";\n\n/**\n * @title LTokenSignaler\n * @author Lila Rest (https://lila.rest)\n * @custom:security-contact security@ledgity.com\n *\n * @notice Used to inform subgraph from the existence of a new L-Token contract. Once\n * signaled, a L-Token will start being indexed.\n *\n * @dev Signal are ignored by the subgraph if the L-Token is already known by it.\n *\n * @custom:security-contact security@ledgity.com\n */\ncontract LTokenSignaler is Initializable, UUPSUpgradeable, GlobalOwnableUpgradeable {\n    /**\n     * @notice Emitted to inform subgraph of the existence of a new L-Token contract.\n     * @param lTokenAddress The address of the L-Token contract to signal.\n     */\n    event LTokenSignalEvent(address indexed lTokenAddress);\n\n    /**\n     * @notice Prevents implementation contract from being initialized as recommended by\n     * OpenZeppelin.\n     * @dev See: https://docs.openzeppelin.com/contracts/4.x/api/proxy#Initializable-_disableInitializers--\n     * @custom:oz-upgrades-unsafe-allow constructor\n     */\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @notice Initializer function of the contract. It replaces the constructor()\n     * function in the context of upgradeable contracts.\n     * @dev See: https://docs.openzeppelin.com/contracts/4.x/upgradeable\n     */\n    function initialize(address globalOwner_) public initializer {\n        __GlobalOwnable_init(globalOwner_);\n        __UUPSUpgradeable_init();\n    }\n\n    /**\n     * @notice Override of UUPSUpgradeable._authorizeUpgrade() function restricted to\n     * global owner. It is called by the proxy contract during an upgrade.\n     * @param newImplementation The address of the new implementation contract.\n     */\n    function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}\n\n    /**\n     * @notice Signals a LToken contract to the TheGraph subgraph of the current chain.\n     * @param lTokenAddress The address of the LToken contract to signal.\n     */\n    function signalLToken(address lTokenAddress) external onlyOwner {\n        // Signal the LToken contract\n        emit LTokenSignalEvent(lTokenAddress);\n    }\n}\n"
    },
    "contracts/src/PreMining.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.18;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {LToken} from \"./LToken.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Ownable2Step} from \"@openzeppelin/contracts/access/Ownable2Step.sol\";\nimport {Pausable} from \"@openzeppelin/contracts/security/Pausable.sol\";\n\n/**\n * @title PreMining\n * @author Lila Rest (https://lila.rest)\n * @custom:security-contact security@ledgity.com\n\n * @notice PreMining pool contract, allowing accounts to lock underlying tokens in a \n * pre-defined L-Token contract, over a given duration (in months), in exchange of \n * vested LDY rewards.\n * \n * @dev Intuition\n * \n * Lifecycle of a lockdrop pool is composed by 3 main phases:\n * 1) Deposit: During this phase, users can lock their underlying tokens.\n * 2) Claim: During this phase, users can claim their LDY rewards.\n * 3) Recovery: During this phase, owner can recover remaining ERC20 on the contract.\n * \n * Transitioning between two phases is manually triggered by contract's owner.\n * To ensure fair usage of this power and prevent potential misuse:\n * - the Recovery phase cannot start before 3 months after the end of rewards vesting,\n * - the Recovery phase cannot start before 3 months after the maximum lock end.\n * \n * Finally, note that this contract proxies main L-Token contract's functions:\n * - lock() --> deposit()\n * - instantUnlock() --> instantWithdrawal()\n * - requestUnlock() --> requestWithdrawal()\n * This design enables users to interact with the PreMining contract in a similar fashion\n * to the L-Token contract.\n * \n * @dev Definitions:\n * - Locker: An account that has locked underlying tokens in the pool.\n * \n * @custom:security-contact security@ledgity.com\n */\ncontract PreMining is Ownable2Step, Pausable {\n    using SafeERC20 for IERC20;\n\n    /**\n     * @notice Represents the lock information of an account.\n     * @param amount Amount of underlying tokens locked.\n     * @param duration Duration of the lock (in months).\n     * @param hasUnlocked Whether the account has unlocked its locked tokens.\n     * @param claimedRewards Amount of LDY rewards already claimed.\n     * @param lockEndTimestamp Timestamp at which the account's lock ends.\n     */\n    struct AccountLock {\n        uint240 amount;\n        uint8 duration;\n        bool hasUnlocked;\n        uint216 claimedRewards;\n        uint40 lockEndTimestamp;\n    }\n\n    /// @notice Holds the amount of LDY to be distributed to lockers.\n    uint256 public immutable maxDistributedLDY;\n\n    /// @notice Holds the maximum total amount of L-Tokens that can be locked.\n    uint256 public immutable lockedHardCap;\n\n    /// @notice Holds the minimum possible lock duration (in months).\n    uint8 public immutable minLockDuration;\n\n    /// @notice Holds the maximum possible lock duration (in months).\n    uint8 public immutable maxLockDuration;\n\n    /// @notice Holds the duration of LDY rewards vesting (in months).\n    uint8 public immutable vestingDuration;\n\n    /// @notice Holds a reference to the locked L-Token contract.\n    LToken public immutable lToken;\n\n    /// @notice Holds a reference to the L-Token underlying stablecoin.\n    IERC20 public immutable underlyingToken;\n\n    /// @notice Holds the max pool weight.\n    uint256 public immutable maxWeight;\n\n    /// @notice Holds a reference to the LDY token contract.\n    IERC20 public ldyToken;\n\n    /// @notice Holds lockers' participations informations.\n    mapping(address => AccountLock) public accountsLocks;\n\n    /// @notice Holds the total amount of locked underlying tokens.\n    uint256 public totalLocked;\n\n    /// @notice Holds whether the Deposit phase has ended.\n    bool public hasDepositPhaseEnded;\n\n    /// @notice Holds whether the Claim phase has started.\n    bool public hasClaimPhaseStarted;\n\n    /// @notice Holds whether the Recovery phase has started.\n    bool public hasRecoveryPhaseStarted;\n\n    /// @notice Holds the timestamp at which the Claim phase started.\n    uint256 public claimPhaseStartTimestamp;\n\n    /// @notice Holds an ordered queue of accounts that requested to unlock their tokens.\n    address[] public unlockRequests;\n\n    /// @notice Holds the index of the first request in the queue (a.k.a, next one to be processed).\n    uint256 public unlockRequestsCursor;\n\n    /// @notice Emitted to inform about a new lock/deposit.\n    event Lock(address indexed account, uint256 amount, uint8 duration);\n\n    /// @notice Top-level checks and code shared by both unlock functions.\n    modifier safeUnlock() {\n        // Ensure that the account's lock has ended\n        require(accountsLocks[msg.sender].lockEndTimestamp <= block.timestamp, \"L68\");\n\n        // Ensure the account hasn't already unlocked its tokens\n        require(!accountsLocks[msg.sender].hasUnlocked, \"L69\");\n\n        // Ensure the account has something to unlock\n        require(accountsLocks[msg.sender].amount > 0, \"L70\");\n\n        // Indicate that account has unlocked its tokens\n        accountsLocks[msg.sender].hasUnlocked = true;\n        _;\n    }\n\n    /**\n     * @notice This constructor function etches the lockdrop terms in immutable states.\n     * Ensuring that those terms cannot be modified after deployment.\n     * @param lTokenAddress_ Address of the L-Token contract to use.\n     * @param maxDistributedLDY_ Amount of LDY to be distributed to lockers.\n     * @param lockedHardCap_ Maximum total amount of L-Tokens that can be locked.\n     * @param minLockDuration_ Minimum possible lock duration (in months).\n     * @param maxLockDuration_ Maximum possible lock duration (in months).\n     * @param vestingDuration_ Duration of LDY rewards vesting (in months).\n     */\n    constructor(\n        address lTokenAddress_,\n        uint256 maxDistributedLDY_,\n        uint256 lockedHardCap_,\n        uint8 minLockDuration_,\n        uint8 maxLockDuration_,\n        uint8 vestingDuration_\n    ) {\n        // Ensure minLockDuration is at least 1 month\n        require(minLockDuration_ >= 1, \"L72\");\n\n        // Ensure minLockDuration is not greater than maxLockDuration\n        require(minLockDuration_ <= maxLockDuration_, \"L73\");\n\n        // Set immutable states\n        lToken = LToken(lTokenAddress_);\n        underlyingToken = IERC20(address(lToken.underlying()));\n        lockedHardCap = lockedHardCap_;\n        maxDistributedLDY = maxDistributedLDY_;\n        minLockDuration = minLockDuration_;\n        maxLockDuration = maxLockDuration_;\n        vestingDuration = vestingDuration_;\n        maxWeight = lockedHardCap * uint256(maxLockDuration);\n    }\n\n    /**\n     * @notice Public implementation of Pausable's pausing and unpausing functions, but\n     * restricted to contract's owner.\n     */\n    function pause() public onlyOwner {\n        _pause();\n    }\n\n    function unpause() public onlyOwner {\n        _unpause();\n    }\n\n    /**\n     * @notice Updates the LDY token contract address.\n     * @dev As the first Ledgity Yield lockdrop campaigns will start before the LDY TGE,\n     * this function allows the contract's owner to set the LDY token address once it\n     * becomes available.\n     * @param ldyTokenAddress Address of the LDY token contract.\n     */\n    function setLDYToken(address ldyTokenAddress) external onlyOwner {\n        // Prevent owner from changing the LDY address after Claim phase has started\n        require(!hasClaimPhaseStarted, \"L74\");\n\n        // Set LDY token address\n        ldyToken = IERC20(ldyTokenAddress);\n    }\n\n    /**\n     * @notice Closes the Deposit phase. After calling this function, account won't be\n     * able to lock additional underlying tokens anymore.\n     */\n    function endDepositPhase() external onlyOwner {\n        hasDepositPhaseEnded = true;\n    }\n\n    /**\n     * @notice Opens the Claim phase. After calling this function, lockers will be able\n     * to start claiming their LDY rewards.\n     */\n    function startClaimPhase() external onlyOwner {\n        // Ensure Claim phase has not already started\n        require(!hasClaimPhaseStarted, \"L76\");\n\n        // Ensure that LDY token address is available\n        require(address(ldyToken) != address(0), \"L77\");\n\n        // Set Claim phase as started and store the start timestamp\n        hasClaimPhaseStarted = true;\n        claimPhaseStartTimestamp = block.timestamp;\n    }\n\n    /**\n     * @notice Opens the Recovery phase. After calling this function, the contract owner\n     * will be able to recover remaining ERC20 tokens on the contract.\n     * Note that this won't close the Claim phase and lockers will still be able to claim\n     * their LDY rewards.\n     */\n    function startRecoveryPhase() external onlyOwner {\n        // Ensure Claim phase has started\n        require(hasClaimPhaseStarted, \"L79\");\n\n        // Compute some durations in seconds\n        uint256 threeMonthsInSecond = 3 * 30 days;\n        uint256 vestingInSecond = uint256(vestingDuration) * 30 days;\n        uint256 maxLockInSecond = uint256(maxLockDuration) * 30 days;\n\n        // Compute timestamp of vesting end + 3 months\n        uint256 afterVestingTimestamp = claimPhaseStartTimestamp +\n            vestingInSecond +\n            threeMonthsInSecond;\n\n        // Ensure we are at least 3 months after the end of reward vesting\n        // This prevents owner from recovering LDY before lockers can claim their rewards\n        require(block.timestamp >= afterVestingTimestamp, \"L80\");\n\n        // Compute end of maximum lock + 3 months\n        // Note that claimPhaseStartTimestamp is used for simplicity even if it can exist a time\n        // span between Deposit and Claim phases.\n        uint256 afterMaxLockTimestamp = claimPhaseStartTimestamp +\n            maxLockInSecond +\n            threeMonthsInSecond;\n\n        // Ensure we are at least 3 months after the maximum lock end\n        // This prevents owner from recovering underlying tokens before lockers can unlock those\n        require(block.timestamp >= afterMaxLockTimestamp, \"L81\");\n\n        // Set recovery phase as started\n        hasRecoveryPhaseStarted = true;\n    }\n\n    /**\n     * @notice Recovers a specified amount of a given token address. Will revert if\n     * recovery phase has not started yet or if the contract doesn't hold enough tokens.\n     * @param tokenAddress The address of the token to recover.\n     * @param amount The amount of token to recover.\n     */\n    function recoverERC20(address tokenAddress, uint256 amount) external onlyOwner {\n        // Ensure recovery phase has started\n        require(hasRecoveryPhaseStarted, \"L82\");\n\n        // Create a reference to token's contract\n        IERC20 tokenContract = IERC20(tokenAddress);\n\n        // Ensure there is enough tokens to recover\n        require(tokenContract.balanceOf(address(this)) >= amount, \"L83\");\n\n        // Transfer the recovered token amount to the sender (owner)\n        tokenContract.safeTransfer(msg.sender, amount);\n    }\n\n    /**\n     * @notice Compute the total amount of LDY rewards that a given account is eligible to.\n     * @dev Note: This function neither considers vesting nor already claimed rewards.\n     * @param account The account to compute the eligible rewards of.\n     * @return The total amount of LDY rewards that the account is eligible to.\n     */\n    function eligibleRewardsOf(address account) public view returns (uint256) {\n        // Compute account's lock weight\n        uint256 lockerWeight = accountsLocks[account].amount * accountsLocks[account].duration;\n\n        // Compute amount of LDY that this locker is eligible to\n        if (maxWeight == 0) return 0;\n        else return (maxDistributedLDY * lockerWeight) / maxWeight;\n    }\n\n    /**\n     * @notice Allows locking a specified amount of underlying tokens for a given duration.\n     * By locking, an account became eligible to a portion of the distributed LDY rewards.\n     * @dev This function proxies LToken.deposit()\n     * @dev Lockers can extend their lock duration by calling this function again with a\n     * greater duration and 0 as amount.\n     * @param amount Amount of underlying tokens to lock.\n     * @param duration Duration of the lock (in months).\n     */\n    function lock(uint256 amount, uint8 duration) external whenNotPaused {\n        // Ensure Deposit phase has not ended yet\n        require(!hasDepositPhaseEnded, \"L84\");\n\n        // Ensure account hasn't already unlocked a past lock\n        require(!accountsLocks[msg.sender].hasUnlocked, \"L71\");\n\n        // Ensure lock duration is in valid range\n        require(duration >= minLockDuration && duration <= maxLockDuration, \"L85\");\n\n        // Ensure it won't exceed the hardcap\n        require(totalLocked + amount <= uint256(lockedHardCap), \"L86\");\n\n        // Increase account's locked amount\n        accountsLocks[msg.sender].amount += uint240(amount);\n\n        // Increase total locked amount accordingly\n        totalLocked += amount;\n\n        // Use existing lock duration if greater than the new one\n        uint8 existingDuration = accountsLocks[msg.sender].duration;\n        uint8 appliedDuration = existingDuration > duration ? existingDuration : duration;\n\n        // Update account's lock duration\n        accountsLocks[msg.sender].duration = appliedDuration;\n\n        // Update account's lock end timestamp\n        accountsLocks[msg.sender].lockEndTimestamp = uint40(\n            block.timestamp + uint40(appliedDuration) * 30 days\n        );\n\n        // Emit a Lock event\n        emit Lock(msg.sender, amount, appliedDuration);\n\n        // If amount is 0, skip deposit\n        if (amount == 0) return;\n\n        // Transfer underlyingToken from account to contract\n        underlyingToken.safeTransferFrom(msg.sender, address(this), amount);\n\n        // Deposit USDC in the L-Token contract\n        underlyingToken.safeApprove(address(lToken), amount);\n        lToken.deposit(amount, \"\");\n    }\n\n    /**\n     * @notice Allows the caller to instaneously unlock its locked amount of underlying\n     * tokens.\n     * @dev In order to save some gas and time to users, frontends should propose this\n     * function to users only when it has been verified that it will not revert. They\n     * should propose the requestUnlock() function otherwise.\n     */\n    function instantUnlock() external whenNotPaused safeUnlock {\n        // Retrieve underlying tokens from the L-Token contract\n        uint256 unlockedAmount = accountsLocks[msg.sender].amount;\n        lToken.instantWithdrawal(unlockedAmount);\n\n        // Transfer underlying tokens back to caller\n        underlyingToken.safeTransfer(msg.sender, unlockedAmount);\n    }\n\n    /**\n     * @notice Allows the call to request for the unlocking of its locked amount of\n     * underlying tokens. The request will be automatically processed later.\n     * @dev The sender must attach 0.003 ETH to pre-pay the future processing gas fees\n     * paid by the withdrawer wallet.\n     */\n    function requestUnlock() external payable whenNotPaused safeUnlock {\n        // Put account in the unlock requests queue\n        unlockRequests.push(msg.sender);\n\n        // Request underlying tokens to the L-Token contract\n        uint256 unlockedAmount = accountsLocks[msg.sender].amount;\n        lToken.requestWithdrawal{value: msg.value}(unlockedAmount);\n    }\n\n    /**\n     * @notice Processes queued unlock requests until there is else no more requests,\n     * else not enough underlying tokens to continue.\n     */\n    function processUnlockRequests() external onlyOwner {\n        // Store the current request ID to process\n        uint256 processedId = unlockRequestsCursor;\n\n        // Loop over remaining requests\n        while (processedId < unlockRequests.length) {\n            // Prevent OOG by stopping request processing if there is not enough gas left\n            // to continue the loop and properly end the function call.\n            if (gasleft() < 45000) break;\n\n            // Retrieve the request account\n            address unlockAccount = unlockRequests[processedId];\n\n            // Retrieve the unlocked amount\n            uint256 unlockAmount = accountsLocks[unlockAccount].amount;\n\n            // If the request has already been processed, skip it\n            if (unlockAccount != address(0)) {\n                // If the contract doesn't hold enough underlying tokens to process the request, stop here\n                if (underlyingToken.balanceOf(address(this)) < unlockAmount) break;\n\n                // Delete the request\n                delete unlockRequests[processedId];\n\n                // Transfer underlying back to account\n                underlyingToken.safeTransfer(unlockAccount, unlockAmount);\n            }\n\n            // Increment processed request ID\n            processedId++;\n        }\n\n        // Write back the cursor in storage\n        unlockRequestsCursor = processedId;\n    }\n\n    /**\n     * @notice Computes the amount of LDY rewards available to claim for a given account.\n     * @dev This function considers vesting and already claimed rewards.\n     * @param account The account to compute the available rewards of.\n     * @return The amount of LDY rewards available to claim.\n     */\n    function availableToClaim(address account) public view returns (uint256) {\n        // Compute total amount of rewards allocated to this locker\n        uint256 totalEligibleRewards = eligibleRewardsOf(account);\n\n        // Compute vesting duration in seconds\n        uint256 vestingInSeconds = uint256(vestingDuration) * 30 days;\n\n        // Compute elapsed months since claim phase started, and cap it to vesting duration\n        uint256 elapsedTime = block.timestamp - claimPhaseStartTimestamp;\n        if (elapsedTime > vestingInSeconds) elapsedTime = vestingInSeconds;\n\n        // Compute total available to claim (proportionally to elapsed time)\n        uint256 totalAvailableToClaim = (totalEligibleRewards * elapsedTime) / vestingInSeconds;\n\n        // Else return net claimable (available minus already claimed)\n        return totalAvailableToClaim - accountsLocks[account].claimedRewards;\n    }\n\n    /// @notice Allows the caller to claim its available LDY rewards.\n    function claimRewards() external whenNotPaused {\n        // Ensure Claim phase has started\n        require(hasClaimPhaseStarted, \"L87\");\n\n        // Compute claimable LDY rewards\n        uint256 claimableLDY = availableToClaim(msg.sender);\n\n        // Increase account claimed amount accordingly\n        accountsLocks[msg.sender].claimedRewards += uint216(claimableLDY);\n\n        // Transfer rewards to account\n        ldyToken.safeTransfer(msg.sender, claimableLDY);\n    }\n}\n"
    }
  },
  "settings": {
    "evmVersion": "london",
    "optimizer": {
      "enabled": true,
      "runs": 100
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}