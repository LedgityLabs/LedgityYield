/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/json-duplicate-key-handle";
exports.ids = ["vendor-chunks/json-duplicate-key-handle"];
exports.modules = {

/***/ "(ssr)/../node_modules/json-duplicate-key-handle/index.js":
/*!**********************************************************!*\
  !*** ../node_modules/json-duplicate-key-handle/index.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var backslash = __webpack_require__(/*! backslash */ \"(ssr)/../node_modules/backslash/index.js\");\nmodule.exports = {\n  validate: validate,\n  parse: parse\n};\n\n/**\n * Validates a json string.\n * Errors are returned\n * @param jsonString\n * @param allowDuplicatedKeys\n * @returns {String} error. undefined if no error\n */\nfunction validate(jsonString, allowDuplicatedKeys) {\n  var error;\n  allowDuplicatedKeys = allowDuplicatedKeys || false;\n  if (typeof jsonString !== 'string') {\n    error = 'Input must be a string';\n  } else {\n    try {\n      // Try to find a value starting from index 0\n      _findValue(jsonString, 0, allowDuplicatedKeys, false);\n    } catch(e) {\n      error = e.message;\n    }\n  }\n  return error;\n}\n\n/**\n * Parses a json. Errors are thrown if any\n * @param jsonString\n * @param allowDuplicatedKeys\n * @returns {Object}\n */\nfunction parse(jsonString, allowDuplicatedKeys) {\n  if (typeof jsonString !== 'string') {\n    throw new Error('Input must be a string');\n  }\n\n  allowDuplicatedKeys = allowDuplicatedKeys || false;\n\n  // Try to find a value starting from index 0\n  var value = _findValue(jsonString, 0, allowDuplicatedKeys, true);\n  return value.value;\n}\n\n/**\n * Find the comma separator, ], } or end of file\n * @param {String} str - original json string\n * @param {Number} startInd - starting index\n * @returns {{start: Number, end: Number, value: String}} value: the separator found\n * @private\n */\nfunction _findSeparator(str, startInd) {\n  var len = str.length;\n  var sepStartInd = startInd;\n  var sepEndInd;\n  for (var i = startInd; i < len; i++) {\n    var ch = str[i];\n    if (ch === ',') {\n      sepEndInd = i;\n      break;\n    } else if ( ch === ']' || ch === '}') {\n      sepEndInd = i - 1;\n      break;\n    } else if (!_isWhiteSpace(ch)) {\n      throw _syntaxError(str, i, 'expecting end of expression or separator');\n    }\n  }\n\n  var value;\n  if (sepEndInd === undefined) {\n    sepEndInd = len;\n    value = str[sepEndInd];\n  } else {\n    value = str[sepEndInd];\n    sepEndInd++;\n  }\n  return {\n    start: sepStartInd,\n    end: sepEndInd,\n    value: value\n  };\n}\n\n/**\n * Find the semi-colon separator ':'\n * @param {String} str - original json string\n * @param {Number} startInd\n * @returns {{start: Number, end: Number}}\n * @private\n */\nfunction _findSemiColonSeparator(str, startInd) {\n  var len = str.length;\n  var semiColStartInd = startInd;\n  var semiColEndInd;\n  for (var i = startInd; i < len; i++) {\n    var ch = str[i];\n    if (ch === ':') {\n      semiColEndInd = i;\n      break;\n    } else if (!_isWhiteSpace(ch)) {\n      throw _syntaxError(str, i, 'expecting \\':\\'');\n    }\n  }\n  if (semiColEndInd === undefined) {\n    throw _syntaxError(str, i, 'expecting \\':\\'');\n  }\n  semiColEndInd++;\n  return {\n    start: semiColStartInd,\n    end: semiColEndInd\n  };\n}\n\n/**\n * Find a value it can be number, array, object, strings or boolean\n * @param {String} str - original json string\n * @param {Number} startInd\n * @param {Boolean} allowDuplicatedKeys - allow duplicated keys in objects or not\n * @returns {{value: *, start: Number, end: Number}}\n * @private\n */\nfunction _findValue(str, startInd, allowDuplicatedKeys, parse) {\n  var len = str.length;\n  var valueStartInd;\n  var valueEndInd;\n  var isArray = false;\n  var isObject = false;\n  var isString = false;\n  var isNumber = false;\n  var dotFound = false;\n  var whiteSpaceInNumber = false;\n  var value;\n\n  for (var i = startInd; i < len; i++) {\n\n    var ch = str[i];\n    if (valueStartInd === undefined) {\n      if (!_isWhiteSpace(ch)) {\n        if (ch === '[') {\n          isArray = true;\n        } else if (ch === '{') {\n          isObject = true;\n        } else if (ch === '\"') {\n          isString = true;\n        } else if (_isTrueFromIndex(str, i)) {\n          valueStartInd = i;\n          i = i + 3;\n          valueEndInd = i;\n          value = true;\n          break;\n        } else if (_isFalseFromIndex(str, i)) {\n          valueStartInd = i;\n          i = i + 4;\n          valueEndInd = i;\n          value = false;\n          break;\n        } else if (_isNullFromIndex(str, i)) {\n          valueStartInd = i;\n          i = i + 3;\n          valueEndInd = i;\n          value = null;\n          break;\n        } else if (_isNumber(ch)) {\n          isNumber = true;\n        } else if (ch === '-') {\n          isNumber = true;\n        } else {\n          throw _syntaxError(str, i, '');\n        }\n        valueStartInd = i;\n      }\n    } else {\n      if (isArray) {\n        var arr = _findArray(str, i, allowDuplicatedKeys, parse);\n        valueEndInd = arr.end;\n        value = arr.value;\n        break;\n      } else if (isObject) {\n        var obj = _findObject(str, i, allowDuplicatedKeys, parse);\n        valueEndInd = obj.end;\n        value = obj.value;\n        break;\n      } else if (isString && ch === '\"' && _hasEvenNumberOfBackSlash(str, i - 1)) {\n        valueEndInd = i;\n        value = backslash(str.substring(valueStartInd + 1, valueEndInd));\n        break;\n      } else if (isNumber) {\n        if(_isWhiteSpace(ch)) {\n          whiteSpaceInNumber = true;\n        } else if (ch === ',' || ch === ']' || ch === '}') {\n          value = parseFloat(str.substring(valueStartInd, valueEndInd), 10);\n          valueEndInd = i - 1;\n          break;\n        } else if (_isNumber(ch) && !whiteSpaceInNumber) {\n          continue;\n        } else if (ch === '.' && !dotFound && !whiteSpaceInNumber) {\n          dotFound = true;\n        } else {\n          throw _syntaxError(str, i, 'expecting number');\n        }\n      }\n    }\n  }\n\n  if (valueEndInd === undefined) {\n    if (isNumber) {\n      value = parseFloat(str.substring(valueStartInd, i), 10);\n      valueEndInd = i - 1;\n    } else {\n      throw _syntaxError(str, i, 'unclosed statement');\n    }\n  }\n  valueEndInd++;\n  return {\n    value: value,\n    start: valueStartInd,\n    end: valueEndInd\n  };\n}\n\n/**\n * Find a key in an object\n * @param {String} str - original json string\n * @param {Number} startInd\n * @returns {{start: Number, end: Number, value: String}}\n * @private\n */\nfunction _findKey(str, startInd) {\n  var len = str.length;\n  var keyStartInd;\n  var keyEndInd;\n  for (var i = startInd; i < len; i++) {\n    var ch = str[i];\n    if (keyStartInd === undefined) {\n      if (!_isWhiteSpace(ch)) {\n        if (ch !== '\"') {\n          throw _syntaxError(str, i, 'expecting String');\n        }\n        keyStartInd = i;\n      }\n    } else {\n      if (ch === '\"' && _hasEvenNumberOfBackSlash(str, i - 1)) {\n        keyEndInd = i;\n        break;\n      }\n    }\n  }\n\n  if (keyEndInd === undefined) {\n    throw _syntaxError(str, len, 'expecting String');\n  }\n\n  var value = backslash(str.substring(keyStartInd + 1, keyEndInd));\n  if (value === '') {\n    throw _syntaxError(str, keyStartInd, 'empty string');\n  }\n  keyEndInd++;\n  return {\n    start: keyStartInd,\n    end: keyEndInd,\n    value: value\n  };\n}\n\n/**\n * Find an object by identifying the key, ':' separator and value\n * @param {String} str - original json string\n * @param {Number} startInd\n * @param {Boolean} allowDuplicatedKeys\n * @returns {{start: Number, end: Number, value: Object}}\n * @private\n */\nfunction _findObject(str, startInd, allowDuplicatedKeys, parse) {\n  var i = startInd;\n  var sepValue = ',';\n  var obj = {};\n  var keys = [];\n  var values = [];\n\n  var j = startInd;\n  while (_isWhiteSpace(str[j])) {\n    j++;\n  }\n\n  if (str[j] === '}') {\n    return {\n      start: startInd,\n      end: j,\n      value: obj\n    };\n  }\n\n  while (sepValue === ',') {\n    var key = _findKey(str, i);\n    var semi = _findSemiColonSeparator(str, key.end);\n    var value = _findValue(str, semi.end, allowDuplicatedKeys, parse);\n    var sepIndex = _findSeparator(str, value.end);\n\n    if (!allowDuplicatedKeys) {\n      if(keys.indexOf(key.value) !== -1) {\n        key.value = key.value + '1';\n        // throw _syntaxError(str, key.end, 'duplicated keys \"' + key.value + '\"');\n      }\n    }\n    keys.push(key.value);\n    values.push(value.value);\n    i = sepIndex.end;\n    sepValue = sepIndex.value;\n  }\n\n  if (parse) {\n    var indx = 0;\n    for(indx = 0; indx < keys.length; indx++) {\n      obj[keys[indx]] = values[indx];\n    }\n  }\n\n  return {\n    start: startInd,\n    end: i,\n    value: obj\n  };\n}\n\n/**\n * Going backward from an index, determine if there are even number\n * of consecutive backslashes in the string\n * @param {String} str - original json string\n * @param {Number} endInd\n * @returns {Boolean}\n * @private\n */\nfunction _hasEvenNumberOfBackSlash(str, endInd) {\n  var i = endInd;\n  var count = 0;\n  while(i > -1 && str[i] === '\\\\') {\n    count++;\n    i--;\n  }\n  return (count % 2) === 0;\n}\n\n/**\n * Find an array by identifying values separated by ',' separator\n * @param {String} str - original json string\n * @param {Number} startInd\n * @returns {{start: Number, end: Number, value: Array}}\n * @private\n */\nfunction _findArray(str, startInd, allowDuplicatedKeys, parse) {\n  var i = startInd;\n  var sepValue = ',';\n  var arr = [];\n\n  var j = startInd;\n  while (_isWhiteSpace(str[j])) {\n    j++;\n  }\n\n  if (str[j] === ']') {\n    return {\n      start: startInd,\n      end: j,\n      value: arr\n    };\n  }\n\n  while (sepValue === ',') {\n    var value = _findValue(str, i, allowDuplicatedKeys, parse);\n    var sepIndex = _findSeparator(str, value.end);\n\n    if (parse) {\n      arr.push(value.value);\n    }\n    i = sepIndex.end;\n    sepValue = sepIndex.value;\n  }\n  return {\n    start: startInd,\n    end: i,\n    value: arr\n  };\n}\n\n/**\n * Determine if the string is 'true' from specified index\n * @param {String} str - original json string\n * @param {Number} ind\n * @returns {Boolean}\n * @private\n */\nfunction _isTrueFromIndex(str, ind) {\n  return (str.substr(ind, 4) === 'true');\n}\n\n/**\n * Determine if the string is 'false' from specified index\n * @param {String} str - original json string\n * @param {Number} ind\n * @returns {Boolean}\n * @private\n */\nfunction _isFalseFromIndex(str, ind) {\n  return (str.substr(ind, 5) === 'false');\n}\n\n/**\n * Determine if the string is 'null' from specified index\n * @param {String} str - original json string\n * @param {Number} ind\n * @returns {Boolean}\n * @private\n */\nfunction _isNullFromIndex(str, ind) {\n  return (str.substr(ind, 4) === 'null');\n}\n\nvar white = new RegExp(/^\\s$/);\n/**\n * Determine if this character is a white space\n * @param {String} ch - single character string\n * @returns {Boolean}\n * @private\n */\nfunction _isWhiteSpace(ch){\n  return white.test(ch);\n}\n\nvar numberReg = new RegExp(/^\\d$/);\n/**\n * Determine if this character is a numeric character\n * @param {String} ch - single character string\n * @returns {Boolean}\n * @private\n */\nfunction _isNumber(ch) {\n  return numberReg.test(ch);\n}\n\n/**\n * Generate syntax error\n * @param {String} str - original json string\n * @param {Number} index - index in which the error was detected\n * @param {String} reason\n * @returns {Error}\n * @private\n */\nfunction _syntaxError(str, index, reason) {\n  var regionLen = 10;\n\n  var regionStr;\n  if (str.length < index + regionLen) {\n    regionStr = str.substr(_normalizeNegativeNumber(str.length - regionLen), str.length);\n  } else if (index - (regionLen/2) < 0) {\n    regionStr = str.substr(0, regionLen);\n  } else {\n    regionStr = str.substr(_normalizeNegativeNumber(index - (regionLen/2)), regionLen);\n  }\n\n  var message;\n  if (reason) {\n    message = 'Syntax error: ' + reason + ' near ' + regionStr;\n  } else {\n    message = 'Syntax error near ' + regionStr;\n  }\n  return new Error(message);\n}\n\n/**\n * Return 0 if number is negative, the original number otherwise\n * @param {Number} num\n * @returns {Number}\n * @private\n */\nfunction _normalizeNegativeNumber(num) {\n  return (num < 0) ? 0 : num;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL2pzb24tZHVwbGljYXRlLWtleS1oYW5kbGUvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUEsZ0JBQWdCLG1CQUFPLENBQUMsMkRBQVc7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQztBQUNsQyxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGNBQWMsNENBQTRDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixTQUFTO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxpQ0FBaUM7QUFDdkM7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsU0FBUztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFD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OztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGVkZ2l0eS15aWVsZC1mcm9udGVuZC8uLi9ub2RlX21vZHVsZXMvanNvbi1kdXBsaWNhdGUta2V5LWhhbmRsZS9pbmRleC5qcz9iZDlmIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBiYWNrc2xhc2ggPSByZXF1aXJlKCdiYWNrc2xhc2gnKTtcbm1vZHVsZS5leHBvcnRzID0ge1xuICB2YWxpZGF0ZTogdmFsaWRhdGUsXG4gIHBhcnNlOiBwYXJzZVxufTtcblxuLyoqXG4gKiBWYWxpZGF0ZXMgYSBqc29uIHN0cmluZy5cbiAqIEVycm9ycyBhcmUgcmV0dXJuZWRcbiAqIEBwYXJhbSBqc29uU3RyaW5nXG4gKiBAcGFyYW0gYWxsb3dEdXBsaWNhdGVkS2V5c1xuICogQHJldHVybnMge1N0cmluZ30gZXJyb3IuIHVuZGVmaW5lZCBpZiBubyBlcnJvclxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZShqc29uU3RyaW5nLCBhbGxvd0R1cGxpY2F0ZWRLZXlzKSB7XG4gIHZhciBlcnJvcjtcbiAgYWxsb3dEdXBsaWNhdGVkS2V5cyA9IGFsbG93RHVwbGljYXRlZEtleXMgfHwgZmFsc2U7XG4gIGlmICh0eXBlb2YganNvblN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICBlcnJvciA9ICdJbnB1dCBtdXN0IGJlIGEgc3RyaW5nJztcbiAgfSBlbHNlIHtcbiAgICB0cnkge1xuICAgICAgLy8gVHJ5IHRvIGZpbmQgYSB2YWx1ZSBzdGFydGluZyBmcm9tIGluZGV4IDBcbiAgICAgIF9maW5kVmFsdWUoanNvblN0cmluZywgMCwgYWxsb3dEdXBsaWNhdGVkS2V5cywgZmFsc2UpO1xuICAgIH0gY2F0Y2goZSkge1xuICAgICAgZXJyb3IgPSBlLm1lc3NhZ2U7XG4gICAgfVxuICB9XG4gIHJldHVybiBlcnJvcjtcbn1cblxuLyoqXG4gKiBQYXJzZXMgYSBqc29uLiBFcnJvcnMgYXJlIHRocm93biBpZiBhbnlcbiAqIEBwYXJhbSBqc29uU3RyaW5nXG4gKiBAcGFyYW0gYWxsb3dEdXBsaWNhdGVkS2V5c1xuICogQHJldHVybnMge09iamVjdH1cbiAqL1xuZnVuY3Rpb24gcGFyc2UoanNvblN0cmluZywgYWxsb3dEdXBsaWNhdGVkS2V5cykge1xuICBpZiAodHlwZW9mIGpzb25TdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gIH1cblxuICBhbGxvd0R1cGxpY2F0ZWRLZXlzID0gYWxsb3dEdXBsaWNhdGVkS2V5cyB8fCBmYWxzZTtcblxuICAvLyBUcnkgdG8gZmluZCBhIHZhbHVlIHN0YXJ0aW5nIGZyb20gaW5kZXggMFxuICB2YXIgdmFsdWUgPSBfZmluZFZhbHVlKGpzb25TdHJpbmcsIDAsIGFsbG93RHVwbGljYXRlZEtleXMsIHRydWUpO1xuICByZXR1cm4gdmFsdWUudmFsdWU7XG59XG5cbi8qKlxuICogRmluZCB0aGUgY29tbWEgc2VwYXJhdG9yLCBdLCB9IG9yIGVuZCBvZiBmaWxlXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIC0gb3JpZ2luYWwganNvbiBzdHJpbmdcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydEluZCAtIHN0YXJ0aW5nIGluZGV4XG4gKiBAcmV0dXJucyB7e3N0YXJ0OiBOdW1iZXIsIGVuZDogTnVtYmVyLCB2YWx1ZTogU3RyaW5nfX0gdmFsdWU6IHRoZSBzZXBhcmF0b3IgZm91bmRcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9maW5kU2VwYXJhdG9yKHN0ciwgc3RhcnRJbmQpIHtcbiAgdmFyIGxlbiA9IHN0ci5sZW5ndGg7XG4gIHZhciBzZXBTdGFydEluZCA9IHN0YXJ0SW5kO1xuICB2YXIgc2VwRW5kSW5kO1xuICBmb3IgKHZhciBpID0gc3RhcnRJbmQ7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBjaCA9IHN0cltpXTtcbiAgICBpZiAoY2ggPT09ICcsJykge1xuICAgICAgc2VwRW5kSW5kID0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH0gZWxzZSBpZiAoIGNoID09PSAnXScgfHwgY2ggPT09ICd9Jykge1xuICAgICAgc2VwRW5kSW5kID0gaSAtIDE7XG4gICAgICBicmVhaztcbiAgICB9IGVsc2UgaWYgKCFfaXNXaGl0ZVNwYWNlKGNoKSkge1xuICAgICAgdGhyb3cgX3N5bnRheEVycm9yKHN0ciwgaSwgJ2V4cGVjdGluZyBlbmQgb2YgZXhwcmVzc2lvbiBvciBzZXBhcmF0b3InKTtcbiAgICB9XG4gIH1cblxuICB2YXIgdmFsdWU7XG4gIGlmIChzZXBFbmRJbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHNlcEVuZEluZCA9IGxlbjtcbiAgICB2YWx1ZSA9IHN0cltzZXBFbmRJbmRdO1xuICB9IGVsc2Uge1xuICAgIHZhbHVlID0gc3RyW3NlcEVuZEluZF07XG4gICAgc2VwRW5kSW5kKys7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzdGFydDogc2VwU3RhcnRJbmQsXG4gICAgZW5kOiBzZXBFbmRJbmQsXG4gICAgdmFsdWU6IHZhbHVlXG4gIH07XG59XG5cbi8qKlxuICogRmluZCB0aGUgc2VtaS1jb2xvbiBzZXBhcmF0b3IgJzonXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIC0gb3JpZ2luYWwganNvbiBzdHJpbmdcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydEluZFxuICogQHJldHVybnMge3tzdGFydDogTnVtYmVyLCBlbmQ6IE51bWJlcn19XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfZmluZFNlbWlDb2xvblNlcGFyYXRvcihzdHIsIHN0YXJ0SW5kKSB7XG4gIHZhciBsZW4gPSBzdHIubGVuZ3RoO1xuICB2YXIgc2VtaUNvbFN0YXJ0SW5kID0gc3RhcnRJbmQ7XG4gIHZhciBzZW1pQ29sRW5kSW5kO1xuICBmb3IgKHZhciBpID0gc3RhcnRJbmQ7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBjaCA9IHN0cltpXTtcbiAgICBpZiAoY2ggPT09ICc6Jykge1xuICAgICAgc2VtaUNvbEVuZEluZCA9IGk7XG4gICAgICBicmVhaztcbiAgICB9IGVsc2UgaWYgKCFfaXNXaGl0ZVNwYWNlKGNoKSkge1xuICAgICAgdGhyb3cgX3N5bnRheEVycm9yKHN0ciwgaSwgJ2V4cGVjdGluZyBcXCc6XFwnJyk7XG4gICAgfVxuICB9XG4gIGlmIChzZW1pQ29sRW5kSW5kID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBfc3ludGF4RXJyb3Ioc3RyLCBpLCAnZXhwZWN0aW5nIFxcJzpcXCcnKTtcbiAgfVxuICBzZW1pQ29sRW5kSW5kKys7XG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IHNlbWlDb2xTdGFydEluZCxcbiAgICBlbmQ6IHNlbWlDb2xFbmRJbmRcbiAgfTtcbn1cblxuLyoqXG4gKiBGaW5kIGEgdmFsdWUgaXQgY2FuIGJlIG51bWJlciwgYXJyYXksIG9iamVjdCwgc3RyaW5ncyBvciBib29sZWFuXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIC0gb3JpZ2luYWwganNvbiBzdHJpbmdcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydEluZFxuICogQHBhcmFtIHtCb29sZWFufSBhbGxvd0R1cGxpY2F0ZWRLZXlzIC0gYWxsb3cgZHVwbGljYXRlZCBrZXlzIGluIG9iamVjdHMgb3Igbm90XG4gKiBAcmV0dXJucyB7e3ZhbHVlOiAqLCBzdGFydDogTnVtYmVyLCBlbmQ6IE51bWJlcn19XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfZmluZFZhbHVlKHN0ciwgc3RhcnRJbmQsIGFsbG93RHVwbGljYXRlZEtleXMsIHBhcnNlKSB7XG4gIHZhciBsZW4gPSBzdHIubGVuZ3RoO1xuICB2YXIgdmFsdWVTdGFydEluZDtcbiAgdmFyIHZhbHVlRW5kSW5kO1xuICB2YXIgaXNBcnJheSA9IGZhbHNlO1xuICB2YXIgaXNPYmplY3QgPSBmYWxzZTtcbiAgdmFyIGlzU3RyaW5nID0gZmFsc2U7XG4gIHZhciBpc051bWJlciA9IGZhbHNlO1xuICB2YXIgZG90Rm91bmQgPSBmYWxzZTtcbiAgdmFyIHdoaXRlU3BhY2VJbk51bWJlciA9IGZhbHNlO1xuICB2YXIgdmFsdWU7XG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kOyBpIDwgbGVuOyBpKyspIHtcblxuICAgIHZhciBjaCA9IHN0cltpXTtcbiAgICBpZiAodmFsdWVTdGFydEluZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoIV9pc1doaXRlU3BhY2UoY2gpKSB7XG4gICAgICAgIGlmIChjaCA9PT0gJ1snKSB7XG4gICAgICAgICAgaXNBcnJheSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoY2ggPT09ICd7Jykge1xuICAgICAgICAgIGlzT2JqZWN0ID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gJ1wiJykge1xuICAgICAgICAgIGlzU3RyaW5nID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChfaXNUcnVlRnJvbUluZGV4KHN0ciwgaSkpIHtcbiAgICAgICAgICB2YWx1ZVN0YXJ0SW5kID0gaTtcbiAgICAgICAgICBpID0gaSArIDM7XG4gICAgICAgICAgdmFsdWVFbmRJbmQgPSBpO1xuICAgICAgICAgIHZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIGlmIChfaXNGYWxzZUZyb21JbmRleChzdHIsIGkpKSB7XG4gICAgICAgICAgdmFsdWVTdGFydEluZCA9IGk7XG4gICAgICAgICAgaSA9IGkgKyA0O1xuICAgICAgICAgIHZhbHVlRW5kSW5kID0gaTtcbiAgICAgICAgICB2YWx1ZSA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2UgaWYgKF9pc051bGxGcm9tSW5kZXgoc3RyLCBpKSkge1xuICAgICAgICAgIHZhbHVlU3RhcnRJbmQgPSBpO1xuICAgICAgICAgIGkgPSBpICsgMztcbiAgICAgICAgICB2YWx1ZUVuZEluZCA9IGk7XG4gICAgICAgICAgdmFsdWUgPSBudWxsO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2UgaWYgKF9pc051bWJlcihjaCkpIHtcbiAgICAgICAgICBpc051bWJlciA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoY2ggPT09ICctJykge1xuICAgICAgICAgIGlzTnVtYmVyID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBfc3ludGF4RXJyb3Ioc3RyLCBpLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWVTdGFydEluZCA9IGk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpc0FycmF5KSB7XG4gICAgICAgIHZhciBhcnIgPSBfZmluZEFycmF5KHN0ciwgaSwgYWxsb3dEdXBsaWNhdGVkS2V5cywgcGFyc2UpO1xuICAgICAgICB2YWx1ZUVuZEluZCA9IGFyci5lbmQ7XG4gICAgICAgIHZhbHVlID0gYXJyLnZhbHVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3QpIHtcbiAgICAgICAgdmFyIG9iaiA9IF9maW5kT2JqZWN0KHN0ciwgaSwgYWxsb3dEdXBsaWNhdGVkS2V5cywgcGFyc2UpO1xuICAgICAgICB2YWx1ZUVuZEluZCA9IG9iai5lbmQ7XG4gICAgICAgIHZhbHVlID0gb2JqLnZhbHVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSBpZiAoaXNTdHJpbmcgJiYgY2ggPT09ICdcIicgJiYgX2hhc0V2ZW5OdW1iZXJPZkJhY2tTbGFzaChzdHIsIGkgLSAxKSkge1xuICAgICAgICB2YWx1ZUVuZEluZCA9IGk7XG4gICAgICAgIHZhbHVlID0gYmFja3NsYXNoKHN0ci5zdWJzdHJpbmcodmFsdWVTdGFydEluZCArIDEsIHZhbHVlRW5kSW5kKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIGlmIChpc051bWJlcikge1xuICAgICAgICBpZihfaXNXaGl0ZVNwYWNlKGNoKSkge1xuICAgICAgICAgIHdoaXRlU3BhY2VJbk51bWJlciA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoY2ggPT09ICcsJyB8fCBjaCA9PT0gJ10nIHx8IGNoID09PSAnfScpIHtcbiAgICAgICAgICB2YWx1ZSA9IHBhcnNlRmxvYXQoc3RyLnN1YnN0cmluZyh2YWx1ZVN0YXJ0SW5kLCB2YWx1ZUVuZEluZCksIDEwKTtcbiAgICAgICAgICB2YWx1ZUVuZEluZCA9IGkgLSAxO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2UgaWYgKF9pc051bWJlcihjaCkgJiYgIXdoaXRlU3BhY2VJbk51bWJlcikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGNoID09PSAnLicgJiYgIWRvdEZvdW5kICYmICF3aGl0ZVNwYWNlSW5OdW1iZXIpIHtcbiAgICAgICAgICBkb3RGb3VuZCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgX3N5bnRheEVycm9yKHN0ciwgaSwgJ2V4cGVjdGluZyBudW1iZXInKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICh2YWx1ZUVuZEluZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKGlzTnVtYmVyKSB7XG4gICAgICB2YWx1ZSA9IHBhcnNlRmxvYXQoc3RyLnN1YnN0cmluZyh2YWx1ZVN0YXJ0SW5kLCBpKSwgMTApO1xuICAgICAgdmFsdWVFbmRJbmQgPSBpIC0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgX3N5bnRheEVycm9yKHN0ciwgaSwgJ3VuY2xvc2VkIHN0YXRlbWVudCcpO1xuICAgIH1cbiAgfVxuICB2YWx1ZUVuZEluZCsrO1xuICByZXR1cm4ge1xuICAgIHZhbHVlOiB2YWx1ZSxcbiAgICBzdGFydDogdmFsdWVTdGFydEluZCxcbiAgICBlbmQ6IHZhbHVlRW5kSW5kXG4gIH07XG59XG5cbi8qKlxuICogRmluZCBhIGtleSBpbiBhbiBvYmplY3RcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgLSBvcmlnaW5hbCBqc29uIHN0cmluZ1xuICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0SW5kXG4gKiBAcmV0dXJucyB7e3N0YXJ0OiBOdW1iZXIsIGVuZDogTnVtYmVyLCB2YWx1ZTogU3RyaW5nfX1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9maW5kS2V5KHN0ciwgc3RhcnRJbmQpIHtcbiAgdmFyIGxlbiA9IHN0ci5sZW5ndGg7XG4gIHZhciBrZXlTdGFydEluZDtcbiAgdmFyIGtleUVuZEluZDtcbiAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgY2ggPSBzdHJbaV07XG4gICAgaWYgKGtleVN0YXJ0SW5kID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICghX2lzV2hpdGVTcGFjZShjaCkpIHtcbiAgICAgICAgaWYgKGNoICE9PSAnXCInKSB7XG4gICAgICAgICAgdGhyb3cgX3N5bnRheEVycm9yKHN0ciwgaSwgJ2V4cGVjdGluZyBTdHJpbmcnKTtcbiAgICAgICAgfVxuICAgICAgICBrZXlTdGFydEluZCA9IGk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChjaCA9PT0gJ1wiJyAmJiBfaGFzRXZlbk51bWJlck9mQmFja1NsYXNoKHN0ciwgaSAtIDEpKSB7XG4gICAgICAgIGtleUVuZEluZCA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChrZXlFbmRJbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IF9zeW50YXhFcnJvcihzdHIsIGxlbiwgJ2V4cGVjdGluZyBTdHJpbmcnKTtcbiAgfVxuXG4gIHZhciB2YWx1ZSA9IGJhY2tzbGFzaChzdHIuc3Vic3RyaW5nKGtleVN0YXJ0SW5kICsgMSwga2V5RW5kSW5kKSk7XG4gIGlmICh2YWx1ZSA9PT0gJycpIHtcbiAgICB0aHJvdyBfc3ludGF4RXJyb3Ioc3RyLCBrZXlTdGFydEluZCwgJ2VtcHR5IHN0cmluZycpO1xuICB9XG4gIGtleUVuZEluZCsrO1xuICByZXR1cm4ge1xuICAgIHN0YXJ0OiBrZXlTdGFydEluZCxcbiAgICBlbmQ6IGtleUVuZEluZCxcbiAgICB2YWx1ZTogdmFsdWVcbiAgfTtcbn1cblxuLyoqXG4gKiBGaW5kIGFuIG9iamVjdCBieSBpZGVudGlmeWluZyB0aGUga2V5LCAnOicgc2VwYXJhdG9yIGFuZCB2YWx1ZVxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciAtIG9yaWdpbmFsIGpzb24gc3RyaW5nXG4gKiBAcGFyYW0ge051bWJlcn0gc3RhcnRJbmRcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gYWxsb3dEdXBsaWNhdGVkS2V5c1xuICogQHJldHVybnMge3tzdGFydDogTnVtYmVyLCBlbmQ6IE51bWJlciwgdmFsdWU6IE9iamVjdH19XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfZmluZE9iamVjdChzdHIsIHN0YXJ0SW5kLCBhbGxvd0R1cGxpY2F0ZWRLZXlzLCBwYXJzZSkge1xuICB2YXIgaSA9IHN0YXJ0SW5kO1xuICB2YXIgc2VwVmFsdWUgPSAnLCc7XG4gIHZhciBvYmogPSB7fTtcbiAgdmFyIGtleXMgPSBbXTtcbiAgdmFyIHZhbHVlcyA9IFtdO1xuXG4gIHZhciBqID0gc3RhcnRJbmQ7XG4gIHdoaWxlIChfaXNXaGl0ZVNwYWNlKHN0cltqXSkpIHtcbiAgICBqKys7XG4gIH1cblxuICBpZiAoc3RyW2pdID09PSAnfScpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhcnQ6IHN0YXJ0SW5kLFxuICAgICAgZW5kOiBqLFxuICAgICAgdmFsdWU6IG9ialxuICAgIH07XG4gIH1cblxuICB3aGlsZSAoc2VwVmFsdWUgPT09ICcsJykge1xuICAgIHZhciBrZXkgPSBfZmluZEtleShzdHIsIGkpO1xuICAgIHZhciBzZW1pID0gX2ZpbmRTZW1pQ29sb25TZXBhcmF0b3Ioc3RyLCBrZXkuZW5kKTtcbiAgICB2YXIgdmFsdWUgPSBfZmluZFZhbHVlKHN0ciwgc2VtaS5lbmQsIGFsbG93RHVwbGljYXRlZEtleXMsIHBhcnNlKTtcbiAgICB2YXIgc2VwSW5kZXggPSBfZmluZFNlcGFyYXRvcihzdHIsIHZhbHVlLmVuZCk7XG5cbiAgICBpZiAoIWFsbG93RHVwbGljYXRlZEtleXMpIHtcbiAgICAgIGlmKGtleXMuaW5kZXhPZihrZXkudmFsdWUpICE9PSAtMSkge1xuICAgICAgICBrZXkudmFsdWUgPSBrZXkudmFsdWUgKyAnMSc7XG4gICAgICAgIC8vIHRocm93IF9zeW50YXhFcnJvcihzdHIsIGtleS5lbmQsICdkdXBsaWNhdGVkIGtleXMgXCInICsga2V5LnZhbHVlICsgJ1wiJyk7XG4gICAgICB9XG4gICAgfVxuICAgIGtleXMucHVzaChrZXkudmFsdWUpO1xuICAgIHZhbHVlcy5wdXNoKHZhbHVlLnZhbHVlKTtcbiAgICBpID0gc2VwSW5kZXguZW5kO1xuICAgIHNlcFZhbHVlID0gc2VwSW5kZXgudmFsdWU7XG4gIH1cblxuICBpZiAocGFyc2UpIHtcbiAgICB2YXIgaW5keCA9IDA7XG4gICAgZm9yKGluZHggPSAwOyBpbmR4IDwga2V5cy5sZW5ndGg7IGluZHgrKykge1xuICAgICAgb2JqW2tleXNbaW5keF1dID0gdmFsdWVzW2luZHhdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IHN0YXJ0SW5kLFxuICAgIGVuZDogaSxcbiAgICB2YWx1ZTogb2JqXG4gIH07XG59XG5cbi8qKlxuICogR29pbmcgYmFja3dhcmQgZnJvbSBhbiBpbmRleCwgZGV0ZXJtaW5lIGlmIHRoZXJlIGFyZSBldmVuIG51bWJlclxuICogb2YgY29uc2VjdXRpdmUgYmFja3NsYXNoZXMgaW4gdGhlIHN0cmluZ1xuICogQHBhcmFtIHtTdHJpbmd9IHN0ciAtIG9yaWdpbmFsIGpzb24gc3RyaW5nXG4gKiBAcGFyYW0ge051bWJlcn0gZW5kSW5kXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9oYXNFdmVuTnVtYmVyT2ZCYWNrU2xhc2goc3RyLCBlbmRJbmQpIHtcbiAgdmFyIGkgPSBlbmRJbmQ7XG4gIHZhciBjb3VudCA9IDA7XG4gIHdoaWxlKGkgPiAtMSAmJiBzdHJbaV0gPT09ICdcXFxcJykge1xuICAgIGNvdW50Kys7XG4gICAgaS0tO1xuICB9XG4gIHJldHVybiAoY291bnQgJSAyKSA9PT0gMDtcbn1cblxuLyoqXG4gKiBGaW5kIGFuIGFycmF5IGJ5IGlkZW50aWZ5aW5nIHZhbHVlcyBzZXBhcmF0ZWQgYnkgJywnIHNlcGFyYXRvclxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciAtIG9yaWdpbmFsIGpzb24gc3RyaW5nXG4gKiBAcGFyYW0ge051bWJlcn0gc3RhcnRJbmRcbiAqIEByZXR1cm5zIHt7c3RhcnQ6IE51bWJlciwgZW5kOiBOdW1iZXIsIHZhbHVlOiBBcnJheX19XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfZmluZEFycmF5KHN0ciwgc3RhcnRJbmQsIGFsbG93RHVwbGljYXRlZEtleXMsIHBhcnNlKSB7XG4gIHZhciBpID0gc3RhcnRJbmQ7XG4gIHZhciBzZXBWYWx1ZSA9ICcsJztcbiAgdmFyIGFyciA9IFtdO1xuXG4gIHZhciBqID0gc3RhcnRJbmQ7XG4gIHdoaWxlIChfaXNXaGl0ZVNwYWNlKHN0cltqXSkpIHtcbiAgICBqKys7XG4gIH1cblxuICBpZiAoc3RyW2pdID09PSAnXScpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhcnQ6IHN0YXJ0SW5kLFxuICAgICAgZW5kOiBqLFxuICAgICAgdmFsdWU6IGFyclxuICAgIH07XG4gIH1cblxuICB3aGlsZSAoc2VwVmFsdWUgPT09ICcsJykge1xuICAgIHZhciB2YWx1ZSA9IF9maW5kVmFsdWUoc3RyLCBpLCBhbGxvd0R1cGxpY2F0ZWRLZXlzLCBwYXJzZSk7XG4gICAgdmFyIHNlcEluZGV4ID0gX2ZpbmRTZXBhcmF0b3Ioc3RyLCB2YWx1ZS5lbmQpO1xuXG4gICAgaWYgKHBhcnNlKSB7XG4gICAgICBhcnIucHVzaCh2YWx1ZS52YWx1ZSk7XG4gICAgfVxuICAgIGkgPSBzZXBJbmRleC5lbmQ7XG4gICAgc2VwVmFsdWUgPSBzZXBJbmRleC52YWx1ZTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHN0YXJ0OiBzdGFydEluZCxcbiAgICBlbmQ6IGksXG4gICAgdmFsdWU6IGFyclxuICB9O1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiB0aGUgc3RyaW5nIGlzICd0cnVlJyBmcm9tIHNwZWNpZmllZCBpbmRleFxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciAtIG9yaWdpbmFsIGpzb24gc3RyaW5nXG4gKiBAcGFyYW0ge051bWJlcn0gaW5kXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9pc1RydWVGcm9tSW5kZXgoc3RyLCBpbmQpIHtcbiAgcmV0dXJuIChzdHIuc3Vic3RyKGluZCwgNCkgPT09ICd0cnVlJyk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIHRoZSBzdHJpbmcgaXMgJ2ZhbHNlJyBmcm9tIHNwZWNpZmllZCBpbmRleFxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciAtIG9yaWdpbmFsIGpzb24gc3RyaW5nXG4gKiBAcGFyYW0ge051bWJlcn0gaW5kXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9pc0ZhbHNlRnJvbUluZGV4KHN0ciwgaW5kKSB7XG4gIHJldHVybiAoc3RyLnN1YnN0cihpbmQsIDUpID09PSAnZmFsc2UnKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgdGhlIHN0cmluZyBpcyAnbnVsbCcgZnJvbSBzcGVjaWZpZWQgaW5kZXhcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgLSBvcmlnaW5hbCBqc29uIHN0cmluZ1xuICogQHBhcmFtIHtOdW1iZXJ9IGluZFxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfaXNOdWxsRnJvbUluZGV4KHN0ciwgaW5kKSB7XG4gIHJldHVybiAoc3RyLnN1YnN0cihpbmQsIDQpID09PSAnbnVsbCcpO1xufVxuXG52YXIgd2hpdGUgPSBuZXcgUmVnRXhwKC9eXFxzJC8pO1xuLyoqXG4gKiBEZXRlcm1pbmUgaWYgdGhpcyBjaGFyYWN0ZXIgaXMgYSB3aGl0ZSBzcGFjZVxuICogQHBhcmFtIHtTdHJpbmd9IGNoIC0gc2luZ2xlIGNoYXJhY3RlciBzdHJpbmdcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gX2lzV2hpdGVTcGFjZShjaCl7XG4gIHJldHVybiB3aGl0ZS50ZXN0KGNoKTtcbn1cblxudmFyIG51bWJlclJlZyA9IG5ldyBSZWdFeHAoL15cXGQkLyk7XG4vKipcbiAqIERldGVybWluZSBpZiB0aGlzIGNoYXJhY3RlciBpcyBhIG51bWVyaWMgY2hhcmFjdGVyXG4gKiBAcGFyYW0ge1N0cmluZ30gY2ggLSBzaW5nbGUgY2hhcmFjdGVyIHN0cmluZ1xuICogQHJldHVybnMge0Jvb2xlYW59XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfaXNOdW1iZXIoY2gpIHtcbiAgcmV0dXJuIG51bWJlclJlZy50ZXN0KGNoKTtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSBzeW50YXggZXJyb3JcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgLSBvcmlnaW5hbCBqc29uIHN0cmluZ1xuICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IC0gaW5kZXggaW4gd2hpY2ggdGhlIGVycm9yIHdhcyBkZXRlY3RlZFxuICogQHBhcmFtIHtTdHJpbmd9IHJlYXNvblxuICogQHJldHVybnMge0Vycm9yfVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gX3N5bnRheEVycm9yKHN0ciwgaW5kZXgsIHJlYXNvbikge1xuICB2YXIgcmVnaW9uTGVuID0gMTA7XG5cbiAgdmFyIHJlZ2lvblN0cjtcbiAgaWYgKHN0ci5sZW5ndGggPCBpbmRleCArIHJlZ2lvbkxlbikge1xuICAgIHJlZ2lvblN0ciA9IHN0ci5zdWJzdHIoX25vcm1hbGl6ZU5lZ2F0aXZlTnVtYmVyKHN0ci5sZW5ndGggLSByZWdpb25MZW4pLCBzdHIubGVuZ3RoKTtcbiAgfSBlbHNlIGlmIChpbmRleCAtIChyZWdpb25MZW4vMikgPCAwKSB7XG4gICAgcmVnaW9uU3RyID0gc3RyLnN1YnN0cigwLCByZWdpb25MZW4pO1xuICB9IGVsc2Uge1xuICAgIHJlZ2lvblN0ciA9IHN0ci5zdWJzdHIoX25vcm1hbGl6ZU5lZ2F0aXZlTnVtYmVyKGluZGV4IC0gKHJlZ2lvbkxlbi8yKSksIHJlZ2lvbkxlbik7XG4gIH1cblxuICB2YXIgbWVzc2FnZTtcbiAgaWYgKHJlYXNvbikge1xuICAgIG1lc3NhZ2UgPSAnU3ludGF4IGVycm9yOiAnICsgcmVhc29uICsgJyBuZWFyICcgKyByZWdpb25TdHI7XG4gIH0gZWxzZSB7XG4gICAgbWVzc2FnZSA9ICdTeW50YXggZXJyb3IgbmVhciAnICsgcmVnaW9uU3RyO1xuICB9XG4gIHJldHVybiBuZXcgRXJyb3IobWVzc2FnZSk7XG59XG5cbi8qKlxuICogUmV0dXJuIDAgaWYgbnVtYmVyIGlzIG5lZ2F0aXZlLCB0aGUgb3JpZ2luYWwgbnVtYmVyIG90aGVyd2lzZVxuICogQHBhcmFtIHtOdW1iZXJ9IG51bVxuICogQHJldHVybnMge051bWJlcn1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9ub3JtYWxpemVOZWdhdGl2ZU51bWJlcihudW0pIHtcbiAgcmV0dXJuIChudW0gPCAwKSA/IDAgOiBudW07XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/json-duplicate-key-handle/index.js\n");

/***/ })

};
;