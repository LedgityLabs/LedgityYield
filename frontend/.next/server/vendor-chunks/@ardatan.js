/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@ardatan";
exports.ids = ["vendor-chunks/@ardatan"];
exports.modules = {

/***/ "(ssr)/../node_modules/@ardatan/sync-fetch/index.js":
/*!****************************************************!*\
  !*** ../node_modules/@ardatan/sync-fetch/index.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const exec = (__webpack_require__(/*! child_process */ \"child_process\").execFileSync)\nconst path = __webpack_require__(/*! path */ \"path\")\nconst { URL } = __webpack_require__(/*! url */ \"url\")\nconst _fetch = __webpack_require__(/*! node-fetch */ \"(ssr)/../node_modules/node-fetch/lib/index.mjs\")\nconst shared = __webpack_require__(/*! ./shared */ \"(ssr)/../node_modules/@ardatan/sync-fetch/shared.js\")\n\nfunction fetch (resource, init) {\n  const request = []\n\n  if (resource instanceof fetch.Request) {\n    request.push(...shared.serializeRequest(resource))\n  } else if (resource instanceof URL) {\n    request.push(resource.href, {})\n  } else {\n    request.push(resource, {})\n  }\n\n  Object.assign(request[1], init)\n\n  request[1].headers = new _fetch.Headers(request[1].headers)\n\n  if (request[1].body) {\n    const contentType = extractContentType(request)\n    if (contentType && !request[1].headers.get('content-type')) { request[1].headers.append('content-type', contentType) }\n    request[1].body = shared.parseBody(init.body).toString()\n  }\n\n  request[1].headers = shared.serializeHeaders(request[1].headers)\n\n  // TODO credentials\n\n  const response = JSON.parse(sendMessage(request))\n  if ('headers' in response[1]) {\n    return shared.deserializeResponse(fetch, ...response)\n  } else {\n    throw shared.deserializeError(fetch, ...response)\n  }\n}\n\nfunction sendMessage (message) {\n  return exec(process.execPath, [path.join(__dirname, 'worker.js')], {\n    windowsHide: true,\n    maxBuffer: Infinity,\n    input: JSON.stringify(message),\n    shell: false\n  }).toString()\n}\n\nfunction extractContentType (input) {\n  const request = new _fetch.Request(...input)\n  return request.headers.get('content-type') || undefined\n}\n\nconst _body = Symbol('bodyBuffer')\nconst _bodyError = Symbol('bodyError')\n\nclass SyncRequest extends _fetch.Request {\n  constructor (resource, init = {}) {\n    const buffer = shared.parseBody(init.body)\n\n    super(resource, init)\n    defineBuffer(this, buffer)\n  }\n\n  clone () {\n    checkBody(this)\n    return new SyncRequest(...shared.serializeRequest(this))\n  }\n}\n\nclass SyncResponse extends _fetch.Response {\n  constructor (body, init, options = {}) {\n    const {\n      buffer = shared.parseBody(body),\n      bodyError\n    } = options\n\n    super(body, init)\n    defineBuffer(this, buffer)\n    if (bodyError) defineBodyError(this, bodyError)\n  }\n\n  clone () {\n    checkBody(this)\n    const buffer = Buffer.from(this[_body])\n    return new SyncResponse(\n      shared.createStream(buffer),\n      shared.serializeResponse(this),\n      {\n        buffer,\n        bodyError: this[_bodyError]\n      }\n    )\n  }\n}\n\nclass Body {\n  static mixin (proto) {\n    for (const name of Object.getOwnPropertyNames(Body.prototype)) {\n      if (name === 'constructor') { continue }\n      const desc = Object.getOwnPropertyDescriptor(Body.prototype, name)\n      Object.defineProperty(proto, name, {\n        ...desc,\n        enumerable: true\n      })\n    }\n  }\n\n  arrayBuffer () {\n    checkBody(this)\n    const buf = consumeBody(this)\n    return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength)\n  }\n\n  text () {\n    checkBody(this)\n    return consumeBody(this).toString()\n  }\n\n  json () {\n    checkBody(this)\n    try {\n      return JSON.parse(consumeBody(this).toString())\n    } catch (err) {\n      throw new fetch.FetchError(`invalid json response body at ${this.url} reason: ${err.message}`, 'invalid-json')\n    }\n  }\n\n  buffer () {\n    checkBody(this)\n    return Buffer.from(consumeBody(this))\n  }\n\n  textConverted () {\n    throw new fetch.FetchError('textConverted not implemented')\n  }\n}\n\nfunction _super (self, method) {\n  return Object.getPrototypeOf(Object.getPrototypeOf(self))[method].bind(self)\n}\n\nfunction checkBody (body) {\n  if (body[_bodyError]) {\n    throw body[_bodyError]\n  }\n  if (body.bodyUsed) {\n    throw new TypeError(`body used already for: ${body.url}`)\n  }\n}\n\nfunction consumeBody (body) {\n  _super(body, 'buffer')().catch(error => console.error(error))\n  return body[_body] || Buffer.alloc(0)\n}\n\nfunction defineBuffer (body, buffer) {\n  Object.defineProperty(body, _body, {\n    value: buffer,\n    enumerable: false\n  })\n}\n\nfunction defineBodyError (body, error) {\n  Object.defineProperty(body, _bodyError, {\n    value: shared.deserializeError(fetch, ...error),\n    enumerable: false\n  })\n}\n\nBody.mixin(SyncRequest.prototype)\nBody.mixin(SyncResponse.prototype)\nObject.defineProperties(SyncRequest.prototype, { clone: { enumerable: true } })\nObject.defineProperties(SyncResponse.prototype, { clone: { enumerable: true } })\n\nfetch.Headers = _fetch.Headers\nfetch.FetchError = _fetch.FetchError\nfetch.Request = SyncRequest\nfetch.Response = SyncResponse\nmodule.exports = fetch\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BhcmRhdGFuL3N5bmMtZmV0Y2gvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUEsYUFBYSx3RUFBcUM7QUFDbEQsYUFBYSxtQkFBTyxDQUFDLGtCQUFNO0FBQzNCLFFBQVEsTUFBTSxFQUFFLG1CQUFPLENBQUMsZ0JBQUs7QUFDN0IsZUFBZSxtQkFBTyxDQUFDLGtFQUFZO0FBQ25DLGVBQWUsbUJBQU8sQ0FBQyxxRUFBVTs7QUFFakM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLGtDQUFrQztBQUNsQyxJQUFJO0FBQ0osNkJBQTZCO0FBQzdCOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxrRUFBa0U7QUFDbEU7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esa0NBQWtDO0FBQ2xDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixrRUFBa0UsVUFBVSxVQUFVLFlBQVk7QUFDbEc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxTQUFTO0FBQzNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLGlEQUFpRCxTQUFTLG9CQUFvQjtBQUM5RSxrREFBa0QsU0FBUyxvQkFBb0I7O0FBRS9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sZWRnaXR5LXlpZWxkLWZyb250ZW5kLy4uL25vZGVfbW9kdWxlcy9AYXJkYXRhbi9zeW5jLWZldGNoL2luZGV4LmpzPzk0MjEiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgZXhlYyA9IHJlcXVpcmUoJ2NoaWxkX3Byb2Nlc3MnKS5leGVjRmlsZVN5bmNcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcbmNvbnN0IHsgVVJMIH0gPSByZXF1aXJlKCd1cmwnKVxuY29uc3QgX2ZldGNoID0gcmVxdWlyZSgnbm9kZS1mZXRjaCcpXG5jb25zdCBzaGFyZWQgPSByZXF1aXJlKCcuL3NoYXJlZCcpXG5cbmZ1bmN0aW9uIGZldGNoIChyZXNvdXJjZSwgaW5pdCkge1xuICBjb25zdCByZXF1ZXN0ID0gW11cblxuICBpZiAocmVzb3VyY2UgaW5zdGFuY2VvZiBmZXRjaC5SZXF1ZXN0KSB7XG4gICAgcmVxdWVzdC5wdXNoKC4uLnNoYXJlZC5zZXJpYWxpemVSZXF1ZXN0KHJlc291cmNlKSlcbiAgfSBlbHNlIGlmIChyZXNvdXJjZSBpbnN0YW5jZW9mIFVSTCkge1xuICAgIHJlcXVlc3QucHVzaChyZXNvdXJjZS5ocmVmLCB7fSlcbiAgfSBlbHNlIHtcbiAgICByZXF1ZXN0LnB1c2gocmVzb3VyY2UsIHt9KVxuICB9XG5cbiAgT2JqZWN0LmFzc2lnbihyZXF1ZXN0WzFdLCBpbml0KVxuXG4gIHJlcXVlc3RbMV0uaGVhZGVycyA9IG5ldyBfZmV0Y2guSGVhZGVycyhyZXF1ZXN0WzFdLmhlYWRlcnMpXG5cbiAgaWYgKHJlcXVlc3RbMV0uYm9keSkge1xuICAgIGNvbnN0IGNvbnRlbnRUeXBlID0gZXh0cmFjdENvbnRlbnRUeXBlKHJlcXVlc3QpXG4gICAgaWYgKGNvbnRlbnRUeXBlICYmICFyZXF1ZXN0WzFdLmhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKSkgeyByZXF1ZXN0WzFdLmhlYWRlcnMuYXBwZW5kKCdjb250ZW50LXR5cGUnLCBjb250ZW50VHlwZSkgfVxuICAgIHJlcXVlc3RbMV0uYm9keSA9IHNoYXJlZC5wYXJzZUJvZHkoaW5pdC5ib2R5KS50b1N0cmluZygpXG4gIH1cblxuICByZXF1ZXN0WzFdLmhlYWRlcnMgPSBzaGFyZWQuc2VyaWFsaXplSGVhZGVycyhyZXF1ZXN0WzFdLmhlYWRlcnMpXG5cbiAgLy8gVE9ETyBjcmVkZW50aWFsc1xuXG4gIGNvbnN0IHJlc3BvbnNlID0gSlNPTi5wYXJzZShzZW5kTWVzc2FnZShyZXF1ZXN0KSlcbiAgaWYgKCdoZWFkZXJzJyBpbiByZXNwb25zZVsxXSkge1xuICAgIHJldHVybiBzaGFyZWQuZGVzZXJpYWxpemVSZXNwb25zZShmZXRjaCwgLi4ucmVzcG9uc2UpXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgc2hhcmVkLmRlc2VyaWFsaXplRXJyb3IoZmV0Y2gsIC4uLnJlc3BvbnNlKVxuICB9XG59XG5cbmZ1bmN0aW9uIHNlbmRNZXNzYWdlIChtZXNzYWdlKSB7XG4gIHJldHVybiBleGVjKHByb2Nlc3MuZXhlY1BhdGgsIFtwYXRoLmpvaW4oX19kaXJuYW1lLCAnd29ya2VyLmpzJyldLCB7XG4gICAgd2luZG93c0hpZGU6IHRydWUsXG4gICAgbWF4QnVmZmVyOiBJbmZpbml0eSxcbiAgICBpbnB1dDogSlNPTi5zdHJpbmdpZnkobWVzc2FnZSksXG4gICAgc2hlbGw6IGZhbHNlXG4gIH0pLnRvU3RyaW5nKClcbn1cblxuZnVuY3Rpb24gZXh0cmFjdENvbnRlbnRUeXBlIChpbnB1dCkge1xuICBjb25zdCByZXF1ZXN0ID0gbmV3IF9mZXRjaC5SZXF1ZXN0KC4uLmlucHV0KVxuICByZXR1cm4gcmVxdWVzdC5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJykgfHwgdW5kZWZpbmVkXG59XG5cbmNvbnN0IF9ib2R5ID0gU3ltYm9sKCdib2R5QnVmZmVyJylcbmNvbnN0IF9ib2R5RXJyb3IgPSBTeW1ib2woJ2JvZHlFcnJvcicpXG5cbmNsYXNzIFN5bmNSZXF1ZXN0IGV4dGVuZHMgX2ZldGNoLlJlcXVlc3Qge1xuICBjb25zdHJ1Y3RvciAocmVzb3VyY2UsIGluaXQgPSB7fSkge1xuICAgIGNvbnN0IGJ1ZmZlciA9IHNoYXJlZC5wYXJzZUJvZHkoaW5pdC5ib2R5KVxuXG4gICAgc3VwZXIocmVzb3VyY2UsIGluaXQpXG4gICAgZGVmaW5lQnVmZmVyKHRoaXMsIGJ1ZmZlcilcbiAgfVxuXG4gIGNsb25lICgpIHtcbiAgICBjaGVja0JvZHkodGhpcylcbiAgICByZXR1cm4gbmV3IFN5bmNSZXF1ZXN0KC4uLnNoYXJlZC5zZXJpYWxpemVSZXF1ZXN0KHRoaXMpKVxuICB9XG59XG5cbmNsYXNzIFN5bmNSZXNwb25zZSBleHRlbmRzIF9mZXRjaC5SZXNwb25zZSB7XG4gIGNvbnN0cnVjdG9yIChib2R5LCBpbml0LCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7XG4gICAgICBidWZmZXIgPSBzaGFyZWQucGFyc2VCb2R5KGJvZHkpLFxuICAgICAgYm9keUVycm9yXG4gICAgfSA9IG9wdGlvbnNcblxuICAgIHN1cGVyKGJvZHksIGluaXQpXG4gICAgZGVmaW5lQnVmZmVyKHRoaXMsIGJ1ZmZlcilcbiAgICBpZiAoYm9keUVycm9yKSBkZWZpbmVCb2R5RXJyb3IodGhpcywgYm9keUVycm9yKVxuICB9XG5cbiAgY2xvbmUgKCkge1xuICAgIGNoZWNrQm9keSh0aGlzKVxuICAgIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5mcm9tKHRoaXNbX2JvZHldKVxuICAgIHJldHVybiBuZXcgU3luY1Jlc3BvbnNlKFxuICAgICAgc2hhcmVkLmNyZWF0ZVN0cmVhbShidWZmZXIpLFxuICAgICAgc2hhcmVkLnNlcmlhbGl6ZVJlc3BvbnNlKHRoaXMpLFxuICAgICAge1xuICAgICAgICBidWZmZXIsXG4gICAgICAgIGJvZHlFcnJvcjogdGhpc1tfYm9keUVycm9yXVxuICAgICAgfVxuICAgIClcbiAgfVxufVxuXG5jbGFzcyBCb2R5IHtcbiAgc3RhdGljIG1peGluIChwcm90bykge1xuICAgIGZvciAoY29uc3QgbmFtZSBvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhCb2R5LnByb3RvdHlwZSkpIHtcbiAgICAgIGlmIChuYW1lID09PSAnY29uc3RydWN0b3InKSB7IGNvbnRpbnVlIH1cbiAgICAgIGNvbnN0IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKEJvZHkucHJvdG90eXBlLCBuYW1lKVxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvLCBuYW1lLCB7XG4gICAgICAgIC4uLmRlc2MsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgYXJyYXlCdWZmZXIgKCkge1xuICAgIGNoZWNrQm9keSh0aGlzKVxuICAgIGNvbnN0IGJ1ZiA9IGNvbnN1bWVCb2R5KHRoaXMpXG4gICAgcmV0dXJuIGJ1Zi5idWZmZXIuc2xpY2UoYnVmLmJ5dGVPZmZzZXQsIGJ1Zi5ieXRlT2Zmc2V0ICsgYnVmLmJ5dGVMZW5ndGgpXG4gIH1cblxuICB0ZXh0ICgpIHtcbiAgICBjaGVja0JvZHkodGhpcylcbiAgICByZXR1cm4gY29uc3VtZUJvZHkodGhpcykudG9TdHJpbmcoKVxuICB9XG5cbiAganNvbiAoKSB7XG4gICAgY2hlY2tCb2R5KHRoaXMpXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBKU09OLnBhcnNlKGNvbnN1bWVCb2R5KHRoaXMpLnRvU3RyaW5nKCkpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aHJvdyBuZXcgZmV0Y2guRmV0Y2hFcnJvcihgaW52YWxpZCBqc29uIHJlc3BvbnNlIGJvZHkgYXQgJHt0aGlzLnVybH0gcmVhc29uOiAke2Vyci5tZXNzYWdlfWAsICdpbnZhbGlkLWpzb24nKVxuICAgIH1cbiAgfVxuXG4gIGJ1ZmZlciAoKSB7XG4gICAgY2hlY2tCb2R5KHRoaXMpXG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGNvbnN1bWVCb2R5KHRoaXMpKVxuICB9XG5cbiAgdGV4dENvbnZlcnRlZCAoKSB7XG4gICAgdGhyb3cgbmV3IGZldGNoLkZldGNoRXJyb3IoJ3RleHRDb252ZXJ0ZWQgbm90IGltcGxlbWVudGVkJylcbiAgfVxufVxuXG5mdW5jdGlvbiBfc3VwZXIgKHNlbGYsIG1ldGhvZCkge1xuICByZXR1cm4gT2JqZWN0LmdldFByb3RvdHlwZU9mKE9iamVjdC5nZXRQcm90b3R5cGVPZihzZWxmKSlbbWV0aG9kXS5iaW5kKHNlbGYpXG59XG5cbmZ1bmN0aW9uIGNoZWNrQm9keSAoYm9keSkge1xuICBpZiAoYm9keVtfYm9keUVycm9yXSkge1xuICAgIHRocm93IGJvZHlbX2JvZHlFcnJvcl1cbiAgfVxuICBpZiAoYm9keS5ib2R5VXNlZCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGJvZHkgdXNlZCBhbHJlYWR5IGZvcjogJHtib2R5LnVybH1gKVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbnN1bWVCb2R5IChib2R5KSB7XG4gIF9zdXBlcihib2R5LCAnYnVmZmVyJykoKS5jYXRjaChlcnJvciA9PiBjb25zb2xlLmVycm9yKGVycm9yKSlcbiAgcmV0dXJuIGJvZHlbX2JvZHldIHx8IEJ1ZmZlci5hbGxvYygwKVxufVxuXG5mdW5jdGlvbiBkZWZpbmVCdWZmZXIgKGJvZHksIGJ1ZmZlcikge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYm9keSwgX2JvZHksIHtcbiAgICB2YWx1ZTogYnVmZmVyLFxuICAgIGVudW1lcmFibGU6IGZhbHNlXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGRlZmluZUJvZHlFcnJvciAoYm9keSwgZXJyb3IpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGJvZHksIF9ib2R5RXJyb3IsIHtcbiAgICB2YWx1ZTogc2hhcmVkLmRlc2VyaWFsaXplRXJyb3IoZmV0Y2gsIC4uLmVycm9yKSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICB9KVxufVxuXG5Cb2R5Lm1peGluKFN5bmNSZXF1ZXN0LnByb3RvdHlwZSlcbkJvZHkubWl4aW4oU3luY1Jlc3BvbnNlLnByb3RvdHlwZSlcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFN5bmNSZXF1ZXN0LnByb3RvdHlwZSwgeyBjbG9uZTogeyBlbnVtZXJhYmxlOiB0cnVlIH0gfSlcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFN5bmNSZXNwb25zZS5wcm90b3R5cGUsIHsgY2xvbmU6IHsgZW51bWVyYWJsZTogdHJ1ZSB9IH0pXG5cbmZldGNoLkhlYWRlcnMgPSBfZmV0Y2guSGVhZGVyc1xuZmV0Y2guRmV0Y2hFcnJvciA9IF9mZXRjaC5GZXRjaEVycm9yXG5mZXRjaC5SZXF1ZXN0ID0gU3luY1JlcXVlc3RcbmZldGNoLlJlc3BvbnNlID0gU3luY1Jlc3BvbnNlXG5tb2R1bGUuZXhwb3J0cyA9IGZldGNoXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ardatan/sync-fetch/index.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@ardatan/sync-fetch/shared.js":
/*!*****************************************************!*\
  !*** ../node_modules/@ardatan/sync-fetch/shared.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Stream = __webpack_require__(/*! stream */ \"stream\")\n\nfunction serializeHeaders (headers) {\n  return headers.raw()\n}\n\nfunction deserializeHeaders (fetch, old = {}) {\n  const headers = new fetch.Headers()\n  for (const name in old) {\n    for (const value of old[name]) {\n      headers.append(name, value)\n    }\n  }\n  return headers\n}\n\nfunction serializeRequest (request) {\n  return [\n    request.url,\n    {\n      method: request.method,\n      headers: request.headers,\n      body: request.body,\n      mode: request.mode,\n      credentials: request.credentials,\n      cache: request.cache,\n      redirect: request.redirect,\n      referrer: request.referrer,\n      referrerPolicy: request.referrerPolicy,\n      integrity: request.integrity,\n      keepalive: request.keepalive,\n      // signal: request.signal,\n\n      // node-fetch props\n      follow: request.follow,\n      timeout: request.timeout,\n      compress: request.compress,\n      size: request.size\n      // agent: request.agent\n    }\n  ]\n}\n\nfunction deserializeRequest (fetch, resource, init) {\n  return new fetch.Request(resource, {\n    ...init,\n    body: init.body ? Buffer.from(init.body) : undefined,\n    headers: deserializeHeaders(fetch, init.headers)\n  })\n}\n\nfunction serializeResponse (response) {\n  return {\n    url: response.url,\n    headers: response.headers.raw(),\n    status: response.status,\n    statusText: response.statusText,\n    counter: response.redirected ? 1 : 0 // could be more than one, but no way of telling\n  }\n}\n\nfunction deserializeResponse (fetch, body, init, bodyError) {\n  const buffer = Buffer.from(body, 'base64')\n\n  return new fetch.Response(\n    body ? createStream(buffer) : createStream(null),\n    {\n      ...init,\n      headers: deserializeHeaders(fetch, init.headers)\n    },\n    {\n      buffer,\n      bodyError\n    }\n  )\n}\n\nconst errors = {\n  TypeError\n}\n\nfunction serializeError ({ constructor, message, type, code }) {\n  return [\n    constructor.name,\n    [message, type, { code }]\n  ]\n}\n\nfunction deserializeError (fetch, name, init) {\n  if (name in errors) {\n    return new errors[name](...init)\n  } else {\n    return new fetch.FetchError(...init)\n  }\n}\n\nfunction parseBodyType (body) {\n  if (body == null) {\n    return 'Null'\n  } else if (body.constructor.name === 'URLSearchParams') {\n    return 'URLSearchParams'\n  } else if (Buffer.isBuffer(body)) {\n    return 'Buffer'\n  } else if (Object.prototype.toString.call(body) === '[object ArrayBuffer]') {\n    return 'ArrayBuffer'\n  } else if (ArrayBuffer.isView(body)) {\n    return 'ArrayBufferView'\n  } else if (body instanceof Stream) {\n    return 'Stream'\n  } else {\n    return 'String'\n  }\n}\n\nfunction parseBody (body, type = parseBodyType(body)) {\n  switch (type) {\n    case 'Null': return null\n    case 'URLSearchParams': return Buffer.from(body.toString())\n    case 'Buffer': return body\n    case 'ArrayBuffer': return Buffer.from(body)\n    case 'ArrayBufferView': return Buffer.from(body.buffer, body.byteOffset, body.byteLength)\n    case 'String': return Buffer.from(String(body))\n    default: throw new TypeError(`sync-fetch does not support bodies of type: ${type}`)\n  }\n}\n\nfunction createStream (buffer) {\n  return new Stream.Transform({\n    read () {\n      this.push(buffer)\n      this.push(null)\n    }\n  })\n}\n\nmodule.exports = {\n  serializeHeaders,\n  deserializeHeaders,\n  serializeRequest,\n  deserializeRequest,\n  serializeResponse,\n  deserializeResponse,\n  serializeError,\n  deserializeError,\n\n  parseBodyType,\n  parseBody,\n  createStream\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BhcmRhdGFuL3N5bmMtZmV0Y2gvc2hhcmVkLmpzIiwibWFwcGluZ3MiOiJBQUFBLGVBQWUsbUJBQU8sQ0FBQyxzQkFBUTs7QUFFL0I7QUFDQTtBQUNBOztBQUVBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkIsa0NBQWtDO0FBQzdEO0FBQ0E7QUFDQSxzQkFBc0IsTUFBTTtBQUM1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGLEtBQUs7QUFDckY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGVkZ2l0eS15aWVsZC1mcm9udGVuZC8uLi9ub2RlX21vZHVsZXMvQGFyZGF0YW4vc3luYy1mZXRjaC9zaGFyZWQuanM/YzA5ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKVxuXG5mdW5jdGlvbiBzZXJpYWxpemVIZWFkZXJzIChoZWFkZXJzKSB7XG4gIHJldHVybiBoZWFkZXJzLnJhdygpXG59XG5cbmZ1bmN0aW9uIGRlc2VyaWFsaXplSGVhZGVycyAoZmV0Y2gsIG9sZCA9IHt9KSB7XG4gIGNvbnN0IGhlYWRlcnMgPSBuZXcgZmV0Y2guSGVhZGVycygpXG4gIGZvciAoY29uc3QgbmFtZSBpbiBvbGQpIHtcbiAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIG9sZFtuYW1lXSkge1xuICAgICAgaGVhZGVycy5hcHBlbmQobmFtZSwgdmFsdWUpXG4gICAgfVxuICB9XG4gIHJldHVybiBoZWFkZXJzXG59XG5cbmZ1bmN0aW9uIHNlcmlhbGl6ZVJlcXVlc3QgKHJlcXVlc3QpIHtcbiAgcmV0dXJuIFtcbiAgICByZXF1ZXN0LnVybCxcbiAgICB7XG4gICAgICBtZXRob2Q6IHJlcXVlc3QubWV0aG9kLFxuICAgICAgaGVhZGVyczogcmVxdWVzdC5oZWFkZXJzLFxuICAgICAgYm9keTogcmVxdWVzdC5ib2R5LFxuICAgICAgbW9kZTogcmVxdWVzdC5tb2RlLFxuICAgICAgY3JlZGVudGlhbHM6IHJlcXVlc3QuY3JlZGVudGlhbHMsXG4gICAgICBjYWNoZTogcmVxdWVzdC5jYWNoZSxcbiAgICAgIHJlZGlyZWN0OiByZXF1ZXN0LnJlZGlyZWN0LFxuICAgICAgcmVmZXJyZXI6IHJlcXVlc3QucmVmZXJyZXIsXG4gICAgICByZWZlcnJlclBvbGljeTogcmVxdWVzdC5yZWZlcnJlclBvbGljeSxcbiAgICAgIGludGVncml0eTogcmVxdWVzdC5pbnRlZ3JpdHksXG4gICAgICBrZWVwYWxpdmU6IHJlcXVlc3Qua2VlcGFsaXZlLFxuICAgICAgLy8gc2lnbmFsOiByZXF1ZXN0LnNpZ25hbCxcblxuICAgICAgLy8gbm9kZS1mZXRjaCBwcm9wc1xuICAgICAgZm9sbG93OiByZXF1ZXN0LmZvbGxvdyxcbiAgICAgIHRpbWVvdXQ6IHJlcXVlc3QudGltZW91dCxcbiAgICAgIGNvbXByZXNzOiByZXF1ZXN0LmNvbXByZXNzLFxuICAgICAgc2l6ZTogcmVxdWVzdC5zaXplXG4gICAgICAvLyBhZ2VudDogcmVxdWVzdC5hZ2VudFxuICAgIH1cbiAgXVxufVxuXG5mdW5jdGlvbiBkZXNlcmlhbGl6ZVJlcXVlc3QgKGZldGNoLCByZXNvdXJjZSwgaW5pdCkge1xuICByZXR1cm4gbmV3IGZldGNoLlJlcXVlc3QocmVzb3VyY2UsIHtcbiAgICAuLi5pbml0LFxuICAgIGJvZHk6IGluaXQuYm9keSA/IEJ1ZmZlci5mcm9tKGluaXQuYm9keSkgOiB1bmRlZmluZWQsXG4gICAgaGVhZGVyczogZGVzZXJpYWxpemVIZWFkZXJzKGZldGNoLCBpbml0LmhlYWRlcnMpXG4gIH0pXG59XG5cbmZ1bmN0aW9uIHNlcmlhbGl6ZVJlc3BvbnNlIChyZXNwb25zZSkge1xuICByZXR1cm4ge1xuICAgIHVybDogcmVzcG9uc2UudXJsLFxuICAgIGhlYWRlcnM6IHJlc3BvbnNlLmhlYWRlcnMucmF3KCksXG4gICAgc3RhdHVzOiByZXNwb25zZS5zdGF0dXMsXG4gICAgc3RhdHVzVGV4dDogcmVzcG9uc2Uuc3RhdHVzVGV4dCxcbiAgICBjb3VudGVyOiByZXNwb25zZS5yZWRpcmVjdGVkID8gMSA6IDAgLy8gY291bGQgYmUgbW9yZSB0aGFuIG9uZSwgYnV0IG5vIHdheSBvZiB0ZWxsaW5nXG4gIH1cbn1cblxuZnVuY3Rpb24gZGVzZXJpYWxpemVSZXNwb25zZSAoZmV0Y2gsIGJvZHksIGluaXQsIGJvZHlFcnJvcikge1xuICBjb25zdCBidWZmZXIgPSBCdWZmZXIuZnJvbShib2R5LCAnYmFzZTY0JylcblxuICByZXR1cm4gbmV3IGZldGNoLlJlc3BvbnNlKFxuICAgIGJvZHkgPyBjcmVhdGVTdHJlYW0oYnVmZmVyKSA6IGNyZWF0ZVN0cmVhbShudWxsKSxcbiAgICB7XG4gICAgICAuLi5pbml0LFxuICAgICAgaGVhZGVyczogZGVzZXJpYWxpemVIZWFkZXJzKGZldGNoLCBpbml0LmhlYWRlcnMpXG4gICAgfSxcbiAgICB7XG4gICAgICBidWZmZXIsXG4gICAgICBib2R5RXJyb3JcbiAgICB9XG4gIClcbn1cblxuY29uc3QgZXJyb3JzID0ge1xuICBUeXBlRXJyb3Jcbn1cblxuZnVuY3Rpb24gc2VyaWFsaXplRXJyb3IgKHsgY29uc3RydWN0b3IsIG1lc3NhZ2UsIHR5cGUsIGNvZGUgfSkge1xuICByZXR1cm4gW1xuICAgIGNvbnN0cnVjdG9yLm5hbWUsXG4gICAgW21lc3NhZ2UsIHR5cGUsIHsgY29kZSB9XVxuICBdXG59XG5cbmZ1bmN0aW9uIGRlc2VyaWFsaXplRXJyb3IgKGZldGNoLCBuYW1lLCBpbml0KSB7XG4gIGlmIChuYW1lIGluIGVycm9ycykge1xuICAgIHJldHVybiBuZXcgZXJyb3JzW25hbWVdKC4uLmluaXQpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBmZXRjaC5GZXRjaEVycm9yKC4uLmluaXQpXG4gIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VCb2R5VHlwZSAoYm9keSkge1xuICBpZiAoYm9keSA9PSBudWxsKSB7XG4gICAgcmV0dXJuICdOdWxsJ1xuICB9IGVsc2UgaWYgKGJvZHkuY29uc3RydWN0b3IubmFtZSA9PT0gJ1VSTFNlYXJjaFBhcmFtcycpIHtcbiAgICByZXR1cm4gJ1VSTFNlYXJjaFBhcmFtcydcbiAgfSBlbHNlIGlmIChCdWZmZXIuaXNCdWZmZXIoYm9keSkpIHtcbiAgICByZXR1cm4gJ0J1ZmZlcidcbiAgfSBlbHNlIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYm9keSkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXScpIHtcbiAgICByZXR1cm4gJ0FycmF5QnVmZmVyJ1xuICB9IGVsc2UgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhib2R5KSkge1xuICAgIHJldHVybiAnQXJyYXlCdWZmZXJWaWV3J1xuICB9IGVsc2UgaWYgKGJvZHkgaW5zdGFuY2VvZiBTdHJlYW0pIHtcbiAgICByZXR1cm4gJ1N0cmVhbSdcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gJ1N0cmluZydcbiAgfVxufVxuXG5mdW5jdGlvbiBwYXJzZUJvZHkgKGJvZHksIHR5cGUgPSBwYXJzZUJvZHlUeXBlKGJvZHkpKSB7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ051bGwnOiByZXR1cm4gbnVsbFxuICAgIGNhc2UgJ1VSTFNlYXJjaFBhcmFtcyc6IHJldHVybiBCdWZmZXIuZnJvbShib2R5LnRvU3RyaW5nKCkpXG4gICAgY2FzZSAnQnVmZmVyJzogcmV0dXJuIGJvZHlcbiAgICBjYXNlICdBcnJheUJ1ZmZlcic6IHJldHVybiBCdWZmZXIuZnJvbShib2R5KVxuICAgIGNhc2UgJ0FycmF5QnVmZmVyVmlldyc6IHJldHVybiBCdWZmZXIuZnJvbShib2R5LmJ1ZmZlciwgYm9keS5ieXRlT2Zmc2V0LCBib2R5LmJ5dGVMZW5ndGgpXG4gICAgY2FzZSAnU3RyaW5nJzogcmV0dXJuIEJ1ZmZlci5mcm9tKFN0cmluZyhib2R5KSlcbiAgICBkZWZhdWx0OiB0aHJvdyBuZXcgVHlwZUVycm9yKGBzeW5jLWZldGNoIGRvZXMgbm90IHN1cHBvcnQgYm9kaWVzIG9mIHR5cGU6ICR7dHlwZX1gKVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0cmVhbSAoYnVmZmVyKSB7XG4gIHJldHVybiBuZXcgU3RyZWFtLlRyYW5zZm9ybSh7XG4gICAgcmVhZCAoKSB7XG4gICAgICB0aGlzLnB1c2goYnVmZmVyKVxuICAgICAgdGhpcy5wdXNoKG51bGwpXG4gICAgfVxuICB9KVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2VyaWFsaXplSGVhZGVycyxcbiAgZGVzZXJpYWxpemVIZWFkZXJzLFxuICBzZXJpYWxpemVSZXF1ZXN0LFxuICBkZXNlcmlhbGl6ZVJlcXVlc3QsXG4gIHNlcmlhbGl6ZVJlc3BvbnNlLFxuICBkZXNlcmlhbGl6ZVJlc3BvbnNlLFxuICBzZXJpYWxpemVFcnJvcixcbiAgZGVzZXJpYWxpemVFcnJvcixcblxuICBwYXJzZUJvZHlUeXBlLFxuICBwYXJzZUJvZHksXG4gIGNyZWF0ZVN0cmVhbVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ardatan/sync-fetch/shared.js\n");

/***/ })

};
;