"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/json-pointer";
exports.ids = ["vendor-chunks/json-pointer"];
exports.modules = {

/***/ "(ssr)/../node_modules/json-pointer/index.js":
/*!*********************************************!*\
  !*** ../node_modules/json-pointer/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nvar each = __webpack_require__(/*! foreach */ \"(ssr)/../node_modules/foreach/index.js\");\nmodule.exports = api;\n\n\n/**\n * Convenience wrapper around the api.\n * Calls `.get` when called with an `object` and a `pointer`.\n * Calls `.set` when also called with `value`.\n * If only supplied `object`, returns a partially applied function, mapped to the object.\n *\n * @param {Object} obj\n * @param {String|Array} pointer\n * @param value\n * @returns {*}\n */\n\nfunction api (obj, pointer, value) {\n    // .set()\n    if (arguments.length === 3) {\n        return api.set(obj, pointer, value);\n    }\n    // .get()\n    if (arguments.length === 2) {\n        return api.get(obj, pointer);\n    }\n    // Return a partially applied function on `obj`.\n    var wrapped = api.bind(api, obj);\n\n    // Support for oo style\n    for (var name in api) {\n        if (api.hasOwnProperty(name)) {\n            wrapped[name] = api[name].bind(wrapped, obj);\n        }\n    }\n    return wrapped;\n}\n\n\n/**\n * Lookup a json pointer in an object\n *\n * @param {Object} obj\n * @param {String|Array} pointer\n * @returns {*}\n */\napi.get = function get (obj, pointer) {\n    var refTokens = Array.isArray(pointer) ? pointer : api.parse(pointer);\n\n    for (var i = 0; i < refTokens.length; ++i) {\n        var tok = refTokens[i];\n        if (!(typeof obj == 'object' && tok in obj)) {\n            throw new Error('Invalid reference token: ' + tok);\n        }\n        obj = obj[tok];\n    }\n    return obj;\n};\n\n/**\n * Sets a value on an object\n *\n * @param {Object} obj\n * @param {String|Array} pointer\n * @param value\n */\napi.set = function set (obj, pointer, value) {\n    var refTokens = Array.isArray(pointer) ? pointer : api.parse(pointer),\n      nextTok = refTokens[0];\n\n    if (refTokens.length === 0) {\n      throw Error('Can not set the root object');\n    }\n\n    for (var i = 0; i < refTokens.length - 1; ++i) {\n        var tok = refTokens[i];\n        if (typeof tok !== 'string' && typeof tok !== 'number') {\n          tok = String(tok)\n        }\n        if (tok === \"__proto__\" || tok === \"constructor\" || tok === \"prototype\") {\n            continue\n        }\n        if (tok === '-' && Array.isArray(obj)) {\n          tok = obj.length;\n        }\n        nextTok = refTokens[i + 1];\n\n        if (!(tok in obj)) {\n            if (nextTok.match(/^(\\d+|-)$/)) {\n                obj[tok] = [];\n            } else {\n                obj[tok] = {};\n            }\n        }\n        obj = obj[tok];\n    }\n    if (nextTok === '-' && Array.isArray(obj)) {\n      nextTok = obj.length;\n    }\n    obj[nextTok] = value;\n    return this;\n};\n\n/**\n * Removes an attribute\n *\n * @param {Object} obj\n * @param {String|Array} pointer\n */\napi.remove = function (obj, pointer) {\n    var refTokens = Array.isArray(pointer) ? pointer : api.parse(pointer);\n    var finalToken = refTokens[refTokens.length -1];\n    if (finalToken === undefined) {\n        throw new Error('Invalid JSON pointer for remove: \"' + pointer + '\"');\n    }\n\n    var parent = api.get(obj, refTokens.slice(0, -1));\n    if (Array.isArray(parent)) {\n      var index = +finalToken;\n      if (finalToken === '' && isNaN(index)) {\n        throw new Error('Invalid array index: \"' + finalToken + '\"');\n      }\n\n      Array.prototype.splice.call(parent, index, 1);\n    } else {\n      delete parent[finalToken];\n    }\n};\n\n/**\n * Returns a (pointer -> value) dictionary for an object\n *\n * @param obj\n * @param {function} descend\n * @returns {}\n */\napi.dict = function dict (obj, descend) {\n    var results = {};\n    api.walk(obj, function (value, pointer) {\n        results[pointer] = value;\n    }, descend);\n    return results;\n};\n\n/**\n * Iterates over an object\n * Iterator: function (value, pointer) {}\n *\n * @param obj\n * @param {function} iterator\n * @param {function} descend\n */\napi.walk = function walk (obj, iterator, descend) {\n    var refTokens = [];\n\n    descend = descend || function (value) {\n        var type = Object.prototype.toString.call(value);\n        return type === '[object Object]' || type === '[object Array]';\n    };\n\n    (function next (cur) {\n        each(cur, function (value, key) {\n            refTokens.push(String(key));\n            if (descend(value)) {\n                next(value);\n            } else {\n                iterator(value, api.compile(refTokens));\n            }\n            refTokens.pop();\n        });\n    }(obj));\n};\n\n/**\n * Tests if an object has a value for a json pointer\n *\n * @param obj\n * @param pointer\n * @returns {boolean}\n */\napi.has = function has (obj, pointer) {\n    try {\n        api.get(obj, pointer);\n    } catch (e) {\n        return false;\n    }\n    return true;\n};\n\n/**\n * Escapes a reference token\n *\n * @param str\n * @returns {string}\n */\napi.escape = function escape (str) {\n    return str.toString().replace(/~/g, '~0').replace(/\\//g, '~1');\n};\n\n/**\n * Unescapes a reference token\n *\n * @param str\n * @returns {string}\n */\napi.unescape = function unescape (str) {\n    return str.replace(/~1/g, '/').replace(/~0/g, '~');\n};\n\n/**\n * Converts a json pointer into a array of reference tokens\n *\n * @param pointer\n * @returns {Array}\n */\napi.parse = function parse (pointer) {\n    if (pointer === '') { return []; }\n    if (pointer.charAt(0) !== '/') { throw new Error('Invalid JSON pointer: ' + pointer); }\n    return pointer.substring(1).split(/\\//).map(api.unescape);\n};\n\n/**\n * Builds a json pointer from a array of reference tokens\n *\n * @param refTokens\n * @returns {string}\n */\napi.compile = function compile (refTokens) {\n    if (refTokens.length === 0) { return ''; }\n    return '/' + refTokens.map(api.escape).join('/');\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL2pzb24tcG9pbnRlci9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixXQUFXLG1CQUFPLENBQUMsdURBQVM7QUFDNUI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLGNBQWM7QUFDekI7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxjQUFjO0FBQ3pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLGNBQWM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLDBCQUEwQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLGNBQWM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQixxQ0FBcUM7QUFDckM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sZWRnaXR5LXlpZWxkLWZyb250ZW5kLy4uL25vZGVfbW9kdWxlcy9qc29uLXBvaW50ZXIvaW5kZXguanM/NzI0OSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBlYWNoID0gcmVxdWlyZSgnZm9yZWFjaCcpO1xubW9kdWxlLmV4cG9ydHMgPSBhcGk7XG5cblxuLyoqXG4gKiBDb252ZW5pZW5jZSB3cmFwcGVyIGFyb3VuZCB0aGUgYXBpLlxuICogQ2FsbHMgYC5nZXRgIHdoZW4gY2FsbGVkIHdpdGggYW4gYG9iamVjdGAgYW5kIGEgYHBvaW50ZXJgLlxuICogQ2FsbHMgYC5zZXRgIHdoZW4gYWxzbyBjYWxsZWQgd2l0aCBgdmFsdWVgLlxuICogSWYgb25seSBzdXBwbGllZCBgb2JqZWN0YCwgcmV0dXJucyBhIHBhcnRpYWxseSBhcHBsaWVkIGZ1bmN0aW9uLCBtYXBwZWQgdG8gdGhlIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gcG9pbnRlclxuICogQHBhcmFtIHZhbHVlXG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuXG5mdW5jdGlvbiBhcGkgKG9iaiwgcG9pbnRlciwgdmFsdWUpIHtcbiAgICAvLyAuc2V0KClcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgICAgICByZXR1cm4gYXBpLnNldChvYmosIHBvaW50ZXIsIHZhbHVlKTtcbiAgICB9XG4gICAgLy8gLmdldCgpXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgcmV0dXJuIGFwaS5nZXQob2JqLCBwb2ludGVyKTtcbiAgICB9XG4gICAgLy8gUmV0dXJuIGEgcGFydGlhbGx5IGFwcGxpZWQgZnVuY3Rpb24gb24gYG9iamAuXG4gICAgdmFyIHdyYXBwZWQgPSBhcGkuYmluZChhcGksIG9iaik7XG5cbiAgICAvLyBTdXBwb3J0IGZvciBvbyBzdHlsZVxuICAgIGZvciAodmFyIG5hbWUgaW4gYXBpKSB7XG4gICAgICAgIGlmIChhcGkuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgIHdyYXBwZWRbbmFtZV0gPSBhcGlbbmFtZV0uYmluZCh3cmFwcGVkLCBvYmopO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB3cmFwcGVkO1xufVxuXG5cbi8qKlxuICogTG9va3VwIGEganNvbiBwb2ludGVyIGluIGFuIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBwb2ludGVyXG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuYXBpLmdldCA9IGZ1bmN0aW9uIGdldCAob2JqLCBwb2ludGVyKSB7XG4gICAgdmFyIHJlZlRva2VucyA9IEFycmF5LmlzQXJyYXkocG9pbnRlcikgPyBwb2ludGVyIDogYXBpLnBhcnNlKHBvaW50ZXIpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZWZUb2tlbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHRvayA9IHJlZlRva2Vuc1tpXTtcbiAgICAgICAgaWYgKCEodHlwZW9mIG9iaiA9PSAnb2JqZWN0JyAmJiB0b2sgaW4gb2JqKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHJlZmVyZW5jZSB0b2tlbjogJyArIHRvayk7XG4gICAgICAgIH1cbiAgICAgICAgb2JqID0gb2JqW3Rva107XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG59O1xuXG4vKipcbiAqIFNldHMgYSB2YWx1ZSBvbiBhbiBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gcG9pbnRlclxuICogQHBhcmFtIHZhbHVlXG4gKi9cbmFwaS5zZXQgPSBmdW5jdGlvbiBzZXQgKG9iaiwgcG9pbnRlciwgdmFsdWUpIHtcbiAgICB2YXIgcmVmVG9rZW5zID0gQXJyYXkuaXNBcnJheShwb2ludGVyKSA/IHBvaW50ZXIgOiBhcGkucGFyc2UocG9pbnRlciksXG4gICAgICBuZXh0VG9rID0gcmVmVG9rZW5zWzBdO1xuXG4gICAgaWYgKHJlZlRva2Vucy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IEVycm9yKCdDYW4gbm90IHNldCB0aGUgcm9vdCBvYmplY3QnKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlZlRva2Vucy5sZW5ndGggLSAxOyArK2kpIHtcbiAgICAgICAgdmFyIHRvayA9IHJlZlRva2Vuc1tpXTtcbiAgICAgICAgaWYgKHR5cGVvZiB0b2sgIT09ICdzdHJpbmcnICYmIHR5cGVvZiB0b2sgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgdG9rID0gU3RyaW5nKHRvaylcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9rID09PSBcIl9fcHJvdG9fX1wiIHx8IHRvayA9PT0gXCJjb25zdHJ1Y3RvclwiIHx8IHRvayA9PT0gXCJwcm90b3R5cGVcIikge1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9rID09PSAnLScgJiYgQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICAgICAgdG9rID0gb2JqLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBuZXh0VG9rID0gcmVmVG9rZW5zW2kgKyAxXTtcblxuICAgICAgICBpZiAoISh0b2sgaW4gb2JqKSkge1xuICAgICAgICAgICAgaWYgKG5leHRUb2subWF0Y2goL14oXFxkK3wtKSQvKSkge1xuICAgICAgICAgICAgICAgIG9ialt0b2tdID0gW107XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG9ialt0b2tdID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgb2JqID0gb2JqW3Rva107XG4gICAgfVxuICAgIGlmIChuZXh0VG9rID09PSAnLScgJiYgQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICBuZXh0VG9rID0gb2JqLmxlbmd0aDtcbiAgICB9XG4gICAgb2JqW25leHRUb2tdID0gdmFsdWU7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgYW4gYXR0cmlidXRlXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IHBvaW50ZXJcbiAqL1xuYXBpLnJlbW92ZSA9IGZ1bmN0aW9uIChvYmosIHBvaW50ZXIpIHtcbiAgICB2YXIgcmVmVG9rZW5zID0gQXJyYXkuaXNBcnJheShwb2ludGVyKSA/IHBvaW50ZXIgOiBhcGkucGFyc2UocG9pbnRlcik7XG4gICAgdmFyIGZpbmFsVG9rZW4gPSByZWZUb2tlbnNbcmVmVG9rZW5zLmxlbmd0aCAtMV07XG4gICAgaWYgKGZpbmFsVG9rZW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgSlNPTiBwb2ludGVyIGZvciByZW1vdmU6IFwiJyArIHBvaW50ZXIgKyAnXCInKTtcbiAgICB9XG5cbiAgICB2YXIgcGFyZW50ID0gYXBpLmdldChvYmosIHJlZlRva2Vucy5zbGljZSgwLCAtMSkpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHBhcmVudCkpIHtcbiAgICAgIHZhciBpbmRleCA9ICtmaW5hbFRva2VuO1xuICAgICAgaWYgKGZpbmFsVG9rZW4gPT09ICcnICYmIGlzTmFOKGluZGV4KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXJyYXkgaW5kZXg6IFwiJyArIGZpbmFsVG9rZW4gKyAnXCInKTtcbiAgICAgIH1cblxuICAgICAgQXJyYXkucHJvdG90eXBlLnNwbGljZS5jYWxsKHBhcmVudCwgaW5kZXgsIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgcGFyZW50W2ZpbmFsVG9rZW5dO1xuICAgIH1cbn07XG5cbi8qKlxuICogUmV0dXJucyBhIChwb2ludGVyIC0+IHZhbHVlKSBkaWN0aW9uYXJ5IGZvciBhbiBvYmplY3RcbiAqXG4gKiBAcGFyYW0gb2JqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBkZXNjZW5kXG4gKiBAcmV0dXJucyB7fVxuICovXG5hcGkuZGljdCA9IGZ1bmN0aW9uIGRpY3QgKG9iaiwgZGVzY2VuZCkge1xuICAgIHZhciByZXN1bHRzID0ge307XG4gICAgYXBpLndhbGsob2JqLCBmdW5jdGlvbiAodmFsdWUsIHBvaW50ZXIpIHtcbiAgICAgICAgcmVzdWx0c1twb2ludGVyXSA9IHZhbHVlO1xuICAgIH0sIGRlc2NlbmQpO1xuICAgIHJldHVybiByZXN1bHRzO1xufTtcblxuLyoqXG4gKiBJdGVyYXRlcyBvdmVyIGFuIG9iamVjdFxuICogSXRlcmF0b3I6IGZ1bmN0aW9uICh2YWx1ZSwgcG9pbnRlcikge31cbiAqXG4gKiBAcGFyYW0gb2JqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBpdGVyYXRvclxuICogQHBhcmFtIHtmdW5jdGlvbn0gZGVzY2VuZFxuICovXG5hcGkud2FsayA9IGZ1bmN0aW9uIHdhbGsgKG9iaiwgaXRlcmF0b3IsIGRlc2NlbmQpIHtcbiAgICB2YXIgcmVmVG9rZW5zID0gW107XG5cbiAgICBkZXNjZW5kID0gZGVzY2VuZCB8fCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICAgICAgICByZXR1cm4gdHlwZSA9PT0gJ1tvYmplY3QgT2JqZWN0XScgfHwgdHlwZSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgICB9O1xuXG4gICAgKGZ1bmN0aW9uIG5leHQgKGN1cikge1xuICAgICAgICBlYWNoKGN1ciwgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICAgIHJlZlRva2Vucy5wdXNoKFN0cmluZyhrZXkpKTtcbiAgICAgICAgICAgIGlmIChkZXNjZW5kKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIG5leHQodmFsdWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpdGVyYXRvcih2YWx1ZSwgYXBpLmNvbXBpbGUocmVmVG9rZW5zKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWZUb2tlbnMucG9wKCk7XG4gICAgICAgIH0pO1xuICAgIH0ob2JqKSk7XG59O1xuXG4vKipcbiAqIFRlc3RzIGlmIGFuIG9iamVjdCBoYXMgYSB2YWx1ZSBmb3IgYSBqc29uIHBvaW50ZXJcbiAqXG4gKiBAcGFyYW0gb2JqXG4gKiBAcGFyYW0gcG9pbnRlclxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmFwaS5oYXMgPSBmdW5jdGlvbiBoYXMgKG9iaiwgcG9pbnRlcikge1xuICAgIHRyeSB7XG4gICAgICAgIGFwaS5nZXQob2JqLCBwb2ludGVyKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIEVzY2FwZXMgYSByZWZlcmVuY2UgdG9rZW5cbiAqXG4gKiBAcGFyYW0gc3RyXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5hcGkuZXNjYXBlID0gZnVuY3Rpb24gZXNjYXBlIChzdHIpIHtcbiAgICByZXR1cm4gc3RyLnRvU3RyaW5nKCkucmVwbGFjZSgvfi9nLCAnfjAnKS5yZXBsYWNlKC9cXC8vZywgJ34xJyk7XG59O1xuXG4vKipcbiAqIFVuZXNjYXBlcyBhIHJlZmVyZW5jZSB0b2tlblxuICpcbiAqIEBwYXJhbSBzdHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmFwaS51bmVzY2FwZSA9IGZ1bmN0aW9uIHVuZXNjYXBlIChzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoL34xL2csICcvJykucmVwbGFjZSgvfjAvZywgJ34nKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBqc29uIHBvaW50ZXIgaW50byBhIGFycmF5IG9mIHJlZmVyZW5jZSB0b2tlbnNcbiAqXG4gKiBAcGFyYW0gcG9pbnRlclxuICogQHJldHVybnMge0FycmF5fVxuICovXG5hcGkucGFyc2UgPSBmdW5jdGlvbiBwYXJzZSAocG9pbnRlcikge1xuICAgIGlmIChwb2ludGVyID09PSAnJykgeyByZXR1cm4gW107IH1cbiAgICBpZiAocG9pbnRlci5jaGFyQXQoMCkgIT09ICcvJykgeyB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgSlNPTiBwb2ludGVyOiAnICsgcG9pbnRlcik7IH1cbiAgICByZXR1cm4gcG9pbnRlci5zdWJzdHJpbmcoMSkuc3BsaXQoL1xcLy8pLm1hcChhcGkudW5lc2NhcGUpO1xufTtcblxuLyoqXG4gKiBCdWlsZHMgYSBqc29uIHBvaW50ZXIgZnJvbSBhIGFycmF5IG9mIHJlZmVyZW5jZSB0b2tlbnNcbiAqXG4gKiBAcGFyYW0gcmVmVG9rZW5zXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5hcGkuY29tcGlsZSA9IGZ1bmN0aW9uIGNvbXBpbGUgKHJlZlRva2Vucykge1xuICAgIGlmIChyZWZUb2tlbnMubGVuZ3RoID09PSAwKSB7IHJldHVybiAnJzsgfVxuICAgIHJldHVybiAnLycgKyByZWZUb2tlbnMubWFwKGFwaS5lc2NhcGUpLmpvaW4oJy8nKTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/json-pointer/index.js\n");

/***/ })

};
;