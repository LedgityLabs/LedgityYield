"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@ethersproject";
exports.ids = ["vendor-chunks/@ethersproject"];
exports.modules = {

/***/ "(ssr)/../node_modules/@ethersproject/abi/lib.esm/_version.js":
/*!**************************************************************!*\
  !*** ../node_modules/@ethersproject/abi/lib.esm/_version.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\nconst version = \"abi/5.7.0\";\n//# sourceMappingURL=_version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2FiaS9saWIuZXNtL192ZXJzaW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBTztBQUNQIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGVkZ2l0eS15aWVsZC1mcm9udGVuZC8uLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvYWJpL2xpYi5lc20vX3ZlcnNpb24uanM/NTc5OSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgdmVyc2lvbiA9IFwiYWJpLzUuNy4wXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdmVyc2lvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ethersproject/abi/lib.esm/_version.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@ethersproject/abi/lib.esm/abi-coder.js":
/*!***************************************************************!*\
  !*** ../node_modules/@ethersproject/abi/lib.esm/abi-coder.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbiCoder: () => (/* binding */ AbiCoder),\n/* harmony export */   defaultAbiCoder: () => (/* binding */ defaultAbiCoder)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/../node_modules/@ethersproject/bytes/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/../node_modules/@ethersproject/properties/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/../node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(ssr)/../node_modules/@ethersproject/abi/lib.esm/_version.js\");\n/* harmony import */ var _coders_abstract_coder__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./coders/abstract-coder */ \"(ssr)/../node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js\");\n/* harmony import */ var _coders_address__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./coders/address */ \"(ssr)/../node_modules/@ethersproject/abi/lib.esm/coders/address.js\");\n/* harmony import */ var _coders_array__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./coders/array */ \"(ssr)/../node_modules/@ethersproject/abi/lib.esm/coders/array.js\");\n/* harmony import */ var _coders_boolean__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./coders/boolean */ \"(ssr)/../node_modules/@ethersproject/abi/lib.esm/coders/boolean.js\");\n/* harmony import */ var _coders_bytes__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./coders/bytes */ \"(ssr)/../node_modules/@ethersproject/abi/lib.esm/coders/bytes.js\");\n/* harmony import */ var _coders_fixed_bytes__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./coders/fixed-bytes */ \"(ssr)/../node_modules/@ethersproject/abi/lib.esm/coders/fixed-bytes.js\");\n/* harmony import */ var _coders_null__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./coders/null */ \"(ssr)/../node_modules/@ethersproject/abi/lib.esm/coders/null.js\");\n/* harmony import */ var _coders_number__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./coders/number */ \"(ssr)/../node_modules/@ethersproject/abi/lib.esm/coders/number.js\");\n/* harmony import */ var _coders_string__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./coders/string */ \"(ssr)/../node_modules/@ethersproject/abi/lib.esm/coders/string.js\");\n/* harmony import */ var _coders_tuple__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./coders/tuple */ \"(ssr)/../node_modules/@ethersproject/abi/lib.esm/coders/tuple.js\");\n/* harmony import */ var _fragments__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./fragments */ \"(ssr)/../node_modules/@ethersproject/abi/lib.esm/fragments.js\");\n\n// See: https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI\n\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\n\n\n\n\n\n\n\n\n\n\n\nconst paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);\nconst paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);\nclass AbiCoder {\n    constructor(coerceFunc) {\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.defineReadOnly)(this, \"coerceFunc\", coerceFunc || null);\n    }\n    _getCoder(param) {\n        switch (param.baseType) {\n            case \"address\":\n                return new _coders_address__WEBPACK_IMPORTED_MODULE_3__.AddressCoder(param.name);\n            case \"bool\":\n                return new _coders_boolean__WEBPACK_IMPORTED_MODULE_4__.BooleanCoder(param.name);\n            case \"string\":\n                return new _coders_string__WEBPACK_IMPORTED_MODULE_5__.StringCoder(param.name);\n            case \"bytes\":\n                return new _coders_bytes__WEBPACK_IMPORTED_MODULE_6__.BytesCoder(param.name);\n            case \"array\":\n                return new _coders_array__WEBPACK_IMPORTED_MODULE_7__.ArrayCoder(this._getCoder(param.arrayChildren), param.arrayLength, param.name);\n            case \"tuple\":\n                return new _coders_tuple__WEBPACK_IMPORTED_MODULE_8__.TupleCoder((param.components || []).map((component) => {\n                    return this._getCoder(component);\n                }), param.name);\n            case \"\":\n                return new _coders_null__WEBPACK_IMPORTED_MODULE_9__.NullCoder(param.name);\n        }\n        // u?int[0-9]*\n        let match = param.type.match(paramTypeNumber);\n        if (match) {\n            let size = parseInt(match[2] || \"256\");\n            if (size === 0 || size > 256 || (size % 8) !== 0) {\n                logger.throwArgumentError(\"invalid \" + match[1] + \" bit length\", \"param\", param);\n            }\n            return new _coders_number__WEBPACK_IMPORTED_MODULE_10__.NumberCoder(size / 8, (match[1] === \"int\"), param.name);\n        }\n        // bytes[0-9]+\n        match = param.type.match(paramTypeBytes);\n        if (match) {\n            let size = parseInt(match[1]);\n            if (size === 0 || size > 32) {\n                logger.throwArgumentError(\"invalid bytes length\", \"param\", param);\n            }\n            return new _coders_fixed_bytes__WEBPACK_IMPORTED_MODULE_11__.FixedBytesCoder(size, param.name);\n        }\n        return logger.throwArgumentError(\"invalid type\", \"type\", param.type);\n    }\n    _getWordSize() { return 32; }\n    _getReader(data, allowLoose) {\n        return new _coders_abstract_coder__WEBPACK_IMPORTED_MODULE_12__.Reader(data, this._getWordSize(), this.coerceFunc, allowLoose);\n    }\n    _getWriter() {\n        return new _coders_abstract_coder__WEBPACK_IMPORTED_MODULE_12__.Writer(this._getWordSize());\n    }\n    getDefaultValue(types) {\n        const coders = types.map((type) => this._getCoder(_fragments__WEBPACK_IMPORTED_MODULE_13__.ParamType.from(type)));\n        const coder = new _coders_tuple__WEBPACK_IMPORTED_MODULE_8__.TupleCoder(coders, \"_\");\n        return coder.defaultValue();\n    }\n    encode(types, values) {\n        if (types.length !== values.length) {\n            logger.throwError(\"types/values length mismatch\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.INVALID_ARGUMENT, {\n                count: { types: types.length, values: values.length },\n                value: { types: types, values: values }\n            });\n        }\n        const coders = types.map((type) => this._getCoder(_fragments__WEBPACK_IMPORTED_MODULE_13__.ParamType.from(type)));\n        const coder = (new _coders_tuple__WEBPACK_IMPORTED_MODULE_8__.TupleCoder(coders, \"_\"));\n        const writer = this._getWriter();\n        coder.encode(writer, values);\n        return writer.data;\n    }\n    decode(types, data, loose) {\n        const coders = types.map((type) => this._getCoder(_fragments__WEBPACK_IMPORTED_MODULE_13__.ParamType.from(type)));\n        const coder = new _coders_tuple__WEBPACK_IMPORTED_MODULE_8__.TupleCoder(coders, \"_\");\n        return coder.decode(this._getReader((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_14__.arrayify)(data), loose));\n    }\n}\nconst defaultAbiCoder = new AbiCoder();\n//# sourceMappingURL=abi-coder.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2FiaS9saWIuZXNtL2FiaS1jb2Rlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFhO0FBQ2I7QUFDZ0Q7QUFDVztBQUNaO0FBQ1Y7QUFDckMsbUJBQW1CLHlEQUFNLENBQUMsNkNBQU87QUFDd0I7QUFDVDtBQUNKO0FBQ0k7QUFDSjtBQUNXO0FBQ2I7QUFDSTtBQUNBO0FBQ0Y7QUFDSjtBQUN4QztBQUNBO0FBQ087QUFDUDtBQUNBLFFBQVEseUVBQWM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIseURBQVk7QUFDdkM7QUFDQSwyQkFBMkIseURBQVk7QUFDdkM7QUFDQSwyQkFBMkIsdURBQVc7QUFDdEM7QUFDQSwyQkFBMkIscURBQVU7QUFDckM7QUFDQSwyQkFBMkIscURBQVU7QUFDckM7QUFDQSwyQkFBMkIscURBQVU7QUFDckM7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSwyQkFBMkIsbURBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix3REFBVztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGlFQUFlO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLG1CQUFtQiwyREFBTTtBQUN6QjtBQUNBO0FBQ0EsbUJBQW1CLDJEQUFNO0FBQ3pCO0FBQ0E7QUFDQSwwREFBMEQsa0RBQVM7QUFDbkUsMEJBQTBCLHFEQUFVO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELHlEQUFNO0FBQ3BFLHlCQUF5Qiw0Q0FBNEM7QUFDckUseUJBQXlCO0FBQ3pCLGFBQWE7QUFDYjtBQUNBLDBEQUEwRCxrREFBUztBQUNuRSwyQkFBMkIscURBQVU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxrREFBUztBQUNuRSwwQkFBMEIscURBQVU7QUFDcEMsNENBQTRDLCtEQUFRO0FBQ3BEO0FBQ0E7QUFDTztBQUNQIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGVkZ2l0eS15aWVsZC1mcm9udGVuZC8uLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvYWJpL2xpYi5lc20vYWJpLWNvZGVyLmpzPzMyOTkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS93aWtpL3dpa2kvRXRoZXJldW0tQ29udHJhY3QtQUJJXG5pbXBvcnQgeyBhcnJheWlmeSB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9ieXRlc1wiO1xuaW1wb3J0IHsgZGVmaW5lUmVhZE9ubHkgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvcHJvcGVydGllc1wiO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2xvZ2dlclwiO1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gXCIuL192ZXJzaW9uXCI7XG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyKHZlcnNpb24pO1xuaW1wb3J0IHsgUmVhZGVyLCBXcml0ZXIgfSBmcm9tIFwiLi9jb2RlcnMvYWJzdHJhY3QtY29kZXJcIjtcbmltcG9ydCB7IEFkZHJlc3NDb2RlciB9IGZyb20gXCIuL2NvZGVycy9hZGRyZXNzXCI7XG5pbXBvcnQgeyBBcnJheUNvZGVyIH0gZnJvbSBcIi4vY29kZXJzL2FycmF5XCI7XG5pbXBvcnQgeyBCb29sZWFuQ29kZXIgfSBmcm9tIFwiLi9jb2RlcnMvYm9vbGVhblwiO1xuaW1wb3J0IHsgQnl0ZXNDb2RlciB9IGZyb20gXCIuL2NvZGVycy9ieXRlc1wiO1xuaW1wb3J0IHsgRml4ZWRCeXRlc0NvZGVyIH0gZnJvbSBcIi4vY29kZXJzL2ZpeGVkLWJ5dGVzXCI7XG5pbXBvcnQgeyBOdWxsQ29kZXIgfSBmcm9tIFwiLi9jb2RlcnMvbnVsbFwiO1xuaW1wb3J0IHsgTnVtYmVyQ29kZXIgfSBmcm9tIFwiLi9jb2RlcnMvbnVtYmVyXCI7XG5pbXBvcnQgeyBTdHJpbmdDb2RlciB9IGZyb20gXCIuL2NvZGVycy9zdHJpbmdcIjtcbmltcG9ydCB7IFR1cGxlQ29kZXIgfSBmcm9tIFwiLi9jb2RlcnMvdHVwbGVcIjtcbmltcG9ydCB7IFBhcmFtVHlwZSB9IGZyb20gXCIuL2ZyYWdtZW50c1wiO1xuY29uc3QgcGFyYW1UeXBlQnl0ZXMgPSBuZXcgUmVnRXhwKC9eYnl0ZXMoWzAtOV0qKSQvKTtcbmNvbnN0IHBhcmFtVHlwZU51bWJlciA9IG5ldyBSZWdFeHAoL14odT9pbnQpKFswLTldKikkLyk7XG5leHBvcnQgY2xhc3MgQWJpQ29kZXIge1xuICAgIGNvbnN0cnVjdG9yKGNvZXJjZUZ1bmMpIHtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJjb2VyY2VGdW5jXCIsIGNvZXJjZUZ1bmMgfHwgbnVsbCk7XG4gICAgfVxuICAgIF9nZXRDb2RlcihwYXJhbSkge1xuICAgICAgICBzd2l0Y2ggKHBhcmFtLmJhc2VUeXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwiYWRkcmVzc1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQWRkcmVzc0NvZGVyKHBhcmFtLm5hbWUpO1xuICAgICAgICAgICAgY2FzZSBcImJvb2xcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJvb2xlYW5Db2RlcihwYXJhbS5uYW1lKTtcbiAgICAgICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFN0cmluZ0NvZGVyKHBhcmFtLm5hbWUpO1xuICAgICAgICAgICAgY2FzZSBcImJ5dGVzXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCeXRlc0NvZGVyKHBhcmFtLm5hbWUpO1xuICAgICAgICAgICAgY2FzZSBcImFycmF5XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBcnJheUNvZGVyKHRoaXMuX2dldENvZGVyKHBhcmFtLmFycmF5Q2hpbGRyZW4pLCBwYXJhbS5hcnJheUxlbmd0aCwgcGFyYW0ubmFtZSk7XG4gICAgICAgICAgICBjYXNlIFwidHVwbGVcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFR1cGxlQ29kZXIoKHBhcmFtLmNvbXBvbmVudHMgfHwgW10pLm1hcCgoY29tcG9uZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRDb2Rlcihjb21wb25lbnQpO1xuICAgICAgICAgICAgICAgIH0pLCBwYXJhbS5uYW1lKTtcbiAgICAgICAgICAgIGNhc2UgXCJcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IE51bGxDb2RlcihwYXJhbS5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICAvLyB1P2ludFswLTldKlxuICAgICAgICBsZXQgbWF0Y2ggPSBwYXJhbS50eXBlLm1hdGNoKHBhcmFtVHlwZU51bWJlcik7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgbGV0IHNpemUgPSBwYXJzZUludChtYXRjaFsyXSB8fCBcIjI1NlwiKTtcbiAgICAgICAgICAgIGlmIChzaXplID09PSAwIHx8IHNpemUgPiAyNTYgfHwgKHNpemUgJSA4KSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIFwiICsgbWF0Y2hbMV0gKyBcIiBiaXQgbGVuZ3RoXCIsIFwicGFyYW1cIiwgcGFyYW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBOdW1iZXJDb2RlcihzaXplIC8gOCwgKG1hdGNoWzFdID09PSBcImludFwiKSwgcGFyYW0ubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYnl0ZXNbMC05XStcbiAgICAgICAgbWF0Y2ggPSBwYXJhbS50eXBlLm1hdGNoKHBhcmFtVHlwZUJ5dGVzKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBsZXQgc2l6ZSA9IHBhcnNlSW50KG1hdGNoWzFdKTtcbiAgICAgICAgICAgIGlmIChzaXplID09PSAwIHx8IHNpemUgPiAzMikge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGJ5dGVzIGxlbmd0aFwiLCBcInBhcmFtXCIsIHBhcmFtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgRml4ZWRCeXRlc0NvZGVyKHNpemUsIHBhcmFtLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCB0eXBlXCIsIFwidHlwZVwiLCBwYXJhbS50eXBlKTtcbiAgICB9XG4gICAgX2dldFdvcmRTaXplKCkgeyByZXR1cm4gMzI7IH1cbiAgICBfZ2V0UmVhZGVyKGRhdGEsIGFsbG93TG9vc2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWFkZXIoZGF0YSwgdGhpcy5fZ2V0V29yZFNpemUoKSwgdGhpcy5jb2VyY2VGdW5jLCBhbGxvd0xvb3NlKTtcbiAgICB9XG4gICAgX2dldFdyaXRlcigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBXcml0ZXIodGhpcy5fZ2V0V29yZFNpemUoKSk7XG4gICAgfVxuICAgIGdldERlZmF1bHRWYWx1ZSh0eXBlcykge1xuICAgICAgICBjb25zdCBjb2RlcnMgPSB0eXBlcy5tYXAoKHR5cGUpID0+IHRoaXMuX2dldENvZGVyKFBhcmFtVHlwZS5mcm9tKHR5cGUpKSk7XG4gICAgICAgIGNvbnN0IGNvZGVyID0gbmV3IFR1cGxlQ29kZXIoY29kZXJzLCBcIl9cIik7XG4gICAgICAgIHJldHVybiBjb2Rlci5kZWZhdWx0VmFsdWUoKTtcbiAgICB9XG4gICAgZW5jb2RlKHR5cGVzLCB2YWx1ZXMpIHtcbiAgICAgICAgaWYgKHR5cGVzLmxlbmd0aCAhPT0gdmFsdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJ0eXBlcy92YWx1ZXMgbGVuZ3RoIG1pc21hdGNoXCIsIExvZ2dlci5lcnJvcnMuSU5WQUxJRF9BUkdVTUVOVCwge1xuICAgICAgICAgICAgICAgIGNvdW50OiB7IHR5cGVzOiB0eXBlcy5sZW5ndGgsIHZhbHVlczogdmFsdWVzLmxlbmd0aCB9LFxuICAgICAgICAgICAgICAgIHZhbHVlOiB7IHR5cGVzOiB0eXBlcywgdmFsdWVzOiB2YWx1ZXMgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29kZXJzID0gdHlwZXMubWFwKCh0eXBlKSA9PiB0aGlzLl9nZXRDb2RlcihQYXJhbVR5cGUuZnJvbSh0eXBlKSkpO1xuICAgICAgICBjb25zdCBjb2RlciA9IChuZXcgVHVwbGVDb2Rlcihjb2RlcnMsIFwiX1wiKSk7XG4gICAgICAgIGNvbnN0IHdyaXRlciA9IHRoaXMuX2dldFdyaXRlcigpO1xuICAgICAgICBjb2Rlci5lbmNvZGUod3JpdGVyLCB2YWx1ZXMpO1xuICAgICAgICByZXR1cm4gd3JpdGVyLmRhdGE7XG4gICAgfVxuICAgIGRlY29kZSh0eXBlcywgZGF0YSwgbG9vc2UpIHtcbiAgICAgICAgY29uc3QgY29kZXJzID0gdHlwZXMubWFwKCh0eXBlKSA9PiB0aGlzLl9nZXRDb2RlcihQYXJhbVR5cGUuZnJvbSh0eXBlKSkpO1xuICAgICAgICBjb25zdCBjb2RlciA9IG5ldyBUdXBsZUNvZGVyKGNvZGVycywgXCJfXCIpO1xuICAgICAgICByZXR1cm4gY29kZXIuZGVjb2RlKHRoaXMuX2dldFJlYWRlcihhcnJheWlmeShkYXRhKSwgbG9vc2UpKTtcbiAgICB9XG59XG5leHBvcnQgY29uc3QgZGVmYXVsdEFiaUNvZGVyID0gbmV3IEFiaUNvZGVyKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hYmktY29kZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ethersproject/abi/lib.esm/abi-coder.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js":
/*!***************************************************************************!*\
  !*** ../node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Coder: () => (/* binding */ Coder),\n/* harmony export */   Reader: () => (/* binding */ Reader),\n/* harmony export */   Writer: () => (/* binding */ Writer),\n/* harmony export */   checkResultErrors: () => (/* binding */ checkResultErrors)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/../node_modules/@ethersproject/bytes/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethersproject/bignumber */ \"(ssr)/../node_modules/@ethersproject/bignumber/lib.esm/bignumber.js\");\n/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/../node_modules/@ethersproject/properties/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/../node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../_version */ \"(ssr)/../node_modules/@ethersproject/abi/lib.esm/_version.js\");\n\n\n\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\nfunction checkResultErrors(result) {\n    // Find the first error (if any)\n    const errors = [];\n    const checkErrors = function (path, object) {\n        if (!Array.isArray(object)) {\n            return;\n        }\n        for (let key in object) {\n            const childPath = path.slice();\n            childPath.push(key);\n            try {\n                checkErrors(childPath, object[key]);\n            }\n            catch (error) {\n                errors.push({ path: childPath, error: error });\n            }\n        }\n    };\n    checkErrors([], result);\n    return errors;\n}\nclass Coder {\n    constructor(name, type, localName, dynamic) {\n        // @TODO: defineReadOnly these\n        this.name = name;\n        this.type = type;\n        this.localName = localName;\n        this.dynamic = dynamic;\n    }\n    _throwError(message, value) {\n        logger.throwArgumentError(message, this.localName, value);\n    }\n}\nclass Writer {\n    constructor(wordSize) {\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.defineReadOnly)(this, \"wordSize\", wordSize || 32);\n        this._data = [];\n        this._dataLength = 0;\n        this._padding = new Uint8Array(wordSize);\n    }\n    get data() {\n        return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexConcat)(this._data);\n    }\n    get length() { return this._dataLength; }\n    _writeData(data) {\n        this._data.push(data);\n        this._dataLength += data.length;\n        return data.length;\n    }\n    appendWriter(writer) {\n        return this._writeData((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.concat)(writer._data));\n    }\n    // Arrayish items; padded on the right to wordSize\n    writeBytes(value) {\n        let bytes = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.arrayify)(value);\n        const paddingOffset = bytes.length % this.wordSize;\n        if (paddingOffset) {\n            bytes = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.concat)([bytes, this._padding.slice(paddingOffset)]);\n        }\n        return this._writeData(bytes);\n    }\n    _getValue(value) {\n        let bytes = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.arrayify)(_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(value));\n        if (bytes.length > this.wordSize) {\n            logger.throwError(\"value out-of-bounds\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.BUFFER_OVERRUN, {\n                length: this.wordSize,\n                offset: bytes.length\n            });\n        }\n        if (bytes.length % this.wordSize) {\n            bytes = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.concat)([this._padding.slice(bytes.length % this.wordSize), bytes]);\n        }\n        return bytes;\n    }\n    // BigNumberish items; padded on the left to wordSize\n    writeValue(value) {\n        return this._writeData(this._getValue(value));\n    }\n    writeUpdatableValue() {\n        const offset = this._data.length;\n        this._data.push(this._padding);\n        this._dataLength += this.wordSize;\n        return (value) => {\n            this._data[offset] = this._getValue(value);\n        };\n    }\n}\nclass Reader {\n    constructor(data, wordSize, coerceFunc, allowLoose) {\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.defineReadOnly)(this, \"_data\", (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.arrayify)(data));\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.defineReadOnly)(this, \"wordSize\", wordSize || 32);\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.defineReadOnly)(this, \"_coerceFunc\", coerceFunc);\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.defineReadOnly)(this, \"allowLoose\", allowLoose);\n        this._offset = 0;\n    }\n    get data() { return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexlify)(this._data); }\n    get consumed() { return this._offset; }\n    // The default Coerce function\n    static coerce(name, value) {\n        let match = name.match(\"^u?int([0-9]+)$\");\n        if (match && parseInt(match[1]) <= 48) {\n            value = value.toNumber();\n        }\n        return value;\n    }\n    coerce(name, value) {\n        if (this._coerceFunc) {\n            return this._coerceFunc(name, value);\n        }\n        return Reader.coerce(name, value);\n    }\n    _peekBytes(offset, length, loose) {\n        let alignedLength = Math.ceil(length / this.wordSize) * this.wordSize;\n        if (this._offset + alignedLength > this._data.length) {\n            if (this.allowLoose && loose && this._offset + length <= this._data.length) {\n                alignedLength = length;\n            }\n            else {\n                logger.throwError(\"data out-of-bounds\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.BUFFER_OVERRUN, {\n                    length: this._data.length,\n                    offset: this._offset + alignedLength\n                });\n            }\n        }\n        return this._data.slice(this._offset, this._offset + alignedLength);\n    }\n    subReader(offset) {\n        return new Reader(this._data.slice(this._offset + offset), this.wordSize, this._coerceFunc, this.allowLoose);\n    }\n    readBytes(length, loose) {\n        let bytes = this._peekBytes(0, length, !!loose);\n        this._offset += bytes.length;\n        // @TODO: Make sure the length..end bytes are all 0?\n        return bytes.slice(0, length);\n    }\n    readValue() {\n        return _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(this.readBytes(this.wordSize));\n    }\n}\n//# sourceMappingURL=abstract-coder.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2FiaS9saWIuZXNtL2NvZGVycy9hYnN0cmFjdC1jb2Rlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBYTtBQUMrRDtBQUN2QjtBQUNNO0FBQ1o7QUFDVDtBQUN0QyxtQkFBbUIseURBQU0sQ0FBQyw2Q0FBTztBQUMxQjtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLCtCQUErQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsUUFBUSx5RUFBYztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwrREFBUztBQUN4QjtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsNERBQU07QUFDckM7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSxvQkFBb0IsOERBQVE7QUFDNUI7QUFDQTtBQUNBLG9CQUFvQiw0REFBTTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw4REFBUSxDQUFDLCtEQUFTO0FBQ3RDO0FBQ0EscURBQXFELHlEQUFNO0FBQzNEO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLG9CQUFvQiw0REFBTTtBQUMxQjtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLFFBQVEseUVBQWMsZ0JBQWdCLDhEQUFRO0FBQzlDLFFBQVEseUVBQWM7QUFDdEIsUUFBUSx5RUFBYztBQUN0QixRQUFRLHlFQUFjO0FBQ3RCO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTyw2REFBTztBQUMvQixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELHlEQUFNO0FBQzlEO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsK0RBQVM7QUFDeEI7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGVkZ2l0eS15aWVsZC1mcm9udGVuZC8uLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvYWJpL2xpYi5lc20vY29kZXJzL2Fic3RyYWN0LWNvZGVyLmpzP2Q5ZmMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgeyBhcnJheWlmeSwgY29uY2F0LCBoZXhDb25jYXQsIGhleGxpZnkgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYnl0ZXNcIjtcbmltcG9ydCB7IEJpZ051bWJlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9iaWdudW1iZXJcIjtcbmltcG9ydCB7IGRlZmluZVJlYWRPbmx5IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3Byb3BlcnRpZXNcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi4vX3ZlcnNpb25cIjtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIodmVyc2lvbik7XG5leHBvcnQgZnVuY3Rpb24gY2hlY2tSZXN1bHRFcnJvcnMocmVzdWx0KSB7XG4gICAgLy8gRmluZCB0aGUgZmlyc3QgZXJyb3IgKGlmIGFueSlcbiAgICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgICBjb25zdCBjaGVja0Vycm9ycyA9IGZ1bmN0aW9uIChwYXRoLCBvYmplY3QpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZFBhdGggPSBwYXRoLnNsaWNlKCk7XG4gICAgICAgICAgICBjaGlsZFBhdGgucHVzaChrZXkpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjaGVja0Vycm9ycyhjaGlsZFBhdGgsIG9iamVjdFtrZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKHsgcGF0aDogY2hpbGRQYXRoLCBlcnJvcjogZXJyb3IgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNoZWNrRXJyb3JzKFtdLCByZXN1bHQpO1xuICAgIHJldHVybiBlcnJvcnM7XG59XG5leHBvcnQgY2xhc3MgQ29kZXIge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIHR5cGUsIGxvY2FsTmFtZSwgZHluYW1pYykge1xuICAgICAgICAvLyBAVE9ETzogZGVmaW5lUmVhZE9ubHkgdGhlc2VcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5sb2NhbE5hbWUgPSBsb2NhbE5hbWU7XG4gICAgICAgIHRoaXMuZHluYW1pYyA9IGR5bmFtaWM7XG4gICAgfVxuICAgIF90aHJvd0Vycm9yKG1lc3NhZ2UsIHZhbHVlKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IobWVzc2FnZSwgdGhpcy5sb2NhbE5hbWUsIHZhbHVlKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgV3JpdGVyIHtcbiAgICBjb25zdHJ1Y3Rvcih3b3JkU2l6ZSkge1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcIndvcmRTaXplXCIsIHdvcmRTaXplIHx8IDMyKTtcbiAgICAgICAgdGhpcy5fZGF0YSA9IFtdO1xuICAgICAgICB0aGlzLl9kYXRhTGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5fcGFkZGluZyA9IG5ldyBVaW50OEFycmF5KHdvcmRTaXplKTtcbiAgICB9XG4gICAgZ2V0IGRhdGEoKSB7XG4gICAgICAgIHJldHVybiBoZXhDb25jYXQodGhpcy5fZGF0YSk7XG4gICAgfVxuICAgIGdldCBsZW5ndGgoKSB7IHJldHVybiB0aGlzLl9kYXRhTGVuZ3RoOyB9XG4gICAgX3dyaXRlRGF0YShkYXRhKSB7XG4gICAgICAgIHRoaXMuX2RhdGEucHVzaChkYXRhKTtcbiAgICAgICAgdGhpcy5fZGF0YUxlbmd0aCArPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIGRhdGEubGVuZ3RoO1xuICAgIH1cbiAgICBhcHBlbmRXcml0ZXIod3JpdGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93cml0ZURhdGEoY29uY2F0KHdyaXRlci5fZGF0YSkpO1xuICAgIH1cbiAgICAvLyBBcnJheWlzaCBpdGVtczsgcGFkZGVkIG9uIHRoZSByaWdodCB0byB3b3JkU2l6ZVxuICAgIHdyaXRlQnl0ZXModmFsdWUpIHtcbiAgICAgICAgbGV0IGJ5dGVzID0gYXJyYXlpZnkodmFsdWUpO1xuICAgICAgICBjb25zdCBwYWRkaW5nT2Zmc2V0ID0gYnl0ZXMubGVuZ3RoICUgdGhpcy53b3JkU2l6ZTtcbiAgICAgICAgaWYgKHBhZGRpbmdPZmZzZXQpIHtcbiAgICAgICAgICAgIGJ5dGVzID0gY29uY2F0KFtieXRlcywgdGhpcy5fcGFkZGluZy5zbGljZShwYWRkaW5nT2Zmc2V0KV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl93cml0ZURhdGEoYnl0ZXMpO1xuICAgIH1cbiAgICBfZ2V0VmFsdWUodmFsdWUpIHtcbiAgICAgICAgbGV0IGJ5dGVzID0gYXJyYXlpZnkoQmlnTnVtYmVyLmZyb20odmFsdWUpKTtcbiAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCA+IHRoaXMud29yZFNpemUpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwidmFsdWUgb3V0LW9mLWJvdW5kc1wiLCBMb2dnZXIuZXJyb3JzLkJVRkZFUl9PVkVSUlVOLCB7XG4gICAgICAgICAgICAgICAgbGVuZ3RoOiB0aGlzLndvcmRTaXplLFxuICAgICAgICAgICAgICAgIG9mZnNldDogYnl0ZXMubGVuZ3RoXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnl0ZXMubGVuZ3RoICUgdGhpcy53b3JkU2l6ZSkge1xuICAgICAgICAgICAgYnl0ZXMgPSBjb25jYXQoW3RoaXMuX3BhZGRpbmcuc2xpY2UoYnl0ZXMubGVuZ3RoICUgdGhpcy53b3JkU2l6ZSksIGJ5dGVzXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIH1cbiAgICAvLyBCaWdOdW1iZXJpc2ggaXRlbXM7IHBhZGRlZCBvbiB0aGUgbGVmdCB0byB3b3JkU2l6ZVxuICAgIHdyaXRlVmFsdWUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dyaXRlRGF0YSh0aGlzLl9nZXRWYWx1ZSh2YWx1ZSkpO1xuICAgIH1cbiAgICB3cml0ZVVwZGF0YWJsZVZhbHVlKCkge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLl9kYXRhLmxlbmd0aDtcbiAgICAgICAgdGhpcy5fZGF0YS5wdXNoKHRoaXMuX3BhZGRpbmcpO1xuICAgICAgICB0aGlzLl9kYXRhTGVuZ3RoICs9IHRoaXMud29yZFNpemU7XG4gICAgICAgIHJldHVybiAodmFsdWUpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2RhdGFbb2Zmc2V0XSA9IHRoaXMuX2dldFZhbHVlKHZhbHVlKTtcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgUmVhZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhLCB3b3JkU2l6ZSwgY29lcmNlRnVuYywgYWxsb3dMb29zZSkge1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcIl9kYXRhXCIsIGFycmF5aWZ5KGRhdGEpKTtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJ3b3JkU2l6ZVwiLCB3b3JkU2l6ZSB8fCAzMik7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiX2NvZXJjZUZ1bmNcIiwgY29lcmNlRnVuYyk7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiYWxsb3dMb29zZVwiLCBhbGxvd0xvb3NlKTtcbiAgICAgICAgdGhpcy5fb2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgZ2V0IGRhdGEoKSB7IHJldHVybiBoZXhsaWZ5KHRoaXMuX2RhdGEpOyB9XG4gICAgZ2V0IGNvbnN1bWVkKCkgeyByZXR1cm4gdGhpcy5fb2Zmc2V0OyB9XG4gICAgLy8gVGhlIGRlZmF1bHQgQ29lcmNlIGZ1bmN0aW9uXG4gICAgc3RhdGljIGNvZXJjZShuYW1lLCB2YWx1ZSkge1xuICAgICAgICBsZXQgbWF0Y2ggPSBuYW1lLm1hdGNoKFwiXnU/aW50KFswLTldKykkXCIpO1xuICAgICAgICBpZiAobWF0Y2ggJiYgcGFyc2VJbnQobWF0Y2hbMV0pIDw9IDQ4KSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvTnVtYmVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBjb2VyY2UobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NvZXJjZUZ1bmMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb2VyY2VGdW5jKG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUmVhZGVyLmNvZXJjZShuYW1lLCB2YWx1ZSk7XG4gICAgfVxuICAgIF9wZWVrQnl0ZXMob2Zmc2V0LCBsZW5ndGgsIGxvb3NlKSB7XG4gICAgICAgIGxldCBhbGlnbmVkTGVuZ3RoID0gTWF0aC5jZWlsKGxlbmd0aCAvIHRoaXMud29yZFNpemUpICogdGhpcy53b3JkU2l6ZTtcbiAgICAgICAgaWYgKHRoaXMuX29mZnNldCArIGFsaWduZWRMZW5ndGggPiB0aGlzLl9kYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuYWxsb3dMb29zZSAmJiBsb29zZSAmJiB0aGlzLl9vZmZzZXQgKyBsZW5ndGggPD0gdGhpcy5fZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBhbGlnbmVkTGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJkYXRhIG91dC1vZi1ib3VuZHNcIiwgTG9nZ2VyLmVycm9ycy5CVUZGRVJfT1ZFUlJVTiwge1xuICAgICAgICAgICAgICAgICAgICBsZW5ndGg6IHRoaXMuX2RhdGEubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IHRoaXMuX29mZnNldCArIGFsaWduZWRMZW5ndGhcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5zbGljZSh0aGlzLl9vZmZzZXQsIHRoaXMuX29mZnNldCArIGFsaWduZWRMZW5ndGgpO1xuICAgIH1cbiAgICBzdWJSZWFkZXIob2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVhZGVyKHRoaXMuX2RhdGEuc2xpY2UodGhpcy5fb2Zmc2V0ICsgb2Zmc2V0KSwgdGhpcy53b3JkU2l6ZSwgdGhpcy5fY29lcmNlRnVuYywgdGhpcy5hbGxvd0xvb3NlKTtcbiAgICB9XG4gICAgcmVhZEJ5dGVzKGxlbmd0aCwgbG9vc2UpIHtcbiAgICAgICAgbGV0IGJ5dGVzID0gdGhpcy5fcGVla0J5dGVzKDAsIGxlbmd0aCwgISFsb29zZSk7XG4gICAgICAgIHRoaXMuX29mZnNldCArPSBieXRlcy5sZW5ndGg7XG4gICAgICAgIC8vIEBUT0RPOiBNYWtlIHN1cmUgdGhlIGxlbmd0aC4uZW5kIGJ5dGVzIGFyZSBhbGwgMD9cbiAgICAgICAgcmV0dXJuIGJ5dGVzLnNsaWNlKDAsIGxlbmd0aCk7XG4gICAgfVxuICAgIHJlYWRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIEJpZ051bWJlci5mcm9tKHRoaXMucmVhZEJ5dGVzKHRoaXMud29yZFNpemUpKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hYnN0cmFjdC1jb2Rlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@ethersproject/abi/lib.esm/coders/address.js":
/*!********************************************************************!*\
  !*** ../node_modules/@ethersproject/abi/lib.esm/coders/address.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AddressCoder: () => (/* binding */ AddressCoder)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_address__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/address */ \"(ssr)/../node_modules/@ethersproject/address/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/../node_modules/@ethersproject/bytes/lib.esm/index.js\");\n/* harmony import */ var _abstract_coder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder */ \"(ssr)/../node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js\");\n\n\n\n\nclass AddressCoder extends _abstract_coder__WEBPACK_IMPORTED_MODULE_0__.Coder {\n    constructor(localName) {\n        super(\"address\", \"address\", localName, false);\n    }\n    defaultValue() {\n        return \"0x0000000000000000000000000000000000000000\";\n    }\n    encode(writer, value) {\n        try {\n            value = (0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_1__.getAddress)(value);\n        }\n        catch (error) {\n            this._throwError(error.message, value);\n        }\n        return writer.writeValue(value);\n    }\n    decode(reader) {\n        return (0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_1__.getAddress)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.hexZeroPad)(reader.readValue().toHexString(), 20));\n    }\n}\n//# sourceMappingURL=address.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2FiaS9saWIuZXNtL2NvZGVycy9hZGRyZXNzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBYTtBQUN1QztBQUNGO0FBQ1Q7QUFDbEMsMkJBQTJCLGtEQUFLO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0VBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGtFQUFVLENBQUMsZ0VBQVU7QUFDcEM7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGVkZ2l0eS15aWVsZC1mcm9udGVuZC8uLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvYWJpL2xpYi5lc20vY29kZXJzL2FkZHJlc3MuanM/ZjJlMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmltcG9ydCB7IGdldEFkZHJlc3MgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYWRkcmVzc1wiO1xuaW1wb3J0IHsgaGV4WmVyb1BhZCB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9ieXRlc1wiO1xuaW1wb3J0IHsgQ29kZXIgfSBmcm9tIFwiLi9hYnN0cmFjdC1jb2RlclwiO1xuZXhwb3J0IGNsYXNzIEFkZHJlc3NDb2RlciBleHRlbmRzIENvZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihsb2NhbE5hbWUpIHtcbiAgICAgICAgc3VwZXIoXCJhZGRyZXNzXCIsIFwiYWRkcmVzc1wiLCBsb2NhbE5hbWUsIGZhbHNlKTtcbiAgICB9XG4gICAgZGVmYXVsdFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gXCIweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIjtcbiAgICB9XG4gICAgZW5jb2RlKHdyaXRlciwgdmFsdWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhbHVlID0gZ2V0QWRkcmVzcyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLl90aHJvd0Vycm9yKGVycm9yLm1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyLndyaXRlVmFsdWUodmFsdWUpO1xuICAgIH1cbiAgICBkZWNvZGUocmVhZGVyKSB7XG4gICAgICAgIHJldHVybiBnZXRBZGRyZXNzKGhleFplcm9QYWQocmVhZGVyLnJlYWRWYWx1ZSgpLnRvSGV4U3RyaW5nKCksIDIwKSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRkcmVzcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ethersproject/abi/lib.esm/coders/address.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@ethersproject/abi/lib.esm/coders/anonymous.js":
/*!**********************************************************************!*\
  !*** ../node_modules/@ethersproject/abi/lib.esm/coders/anonymous.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AnonymousCoder: () => (/* binding */ AnonymousCoder)\n/* harmony export */ });\n/* harmony import */ var _abstract_coder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder */ \"(ssr)/../node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js\");\n\n\n// Clones the functionality of an existing Coder, but without a localName\nclass AnonymousCoder extends _abstract_coder__WEBPACK_IMPORTED_MODULE_0__.Coder {\n    constructor(coder) {\n        super(coder.name, coder.type, undefined, coder.dynamic);\n        this.coder = coder;\n    }\n    defaultValue() {\n        return this.coder.defaultValue();\n    }\n    encode(writer, value) {\n        return this.coder.encode(writer, value);\n    }\n    decode(reader) {\n        return this.coder.decode(reader);\n    }\n}\n//# sourceMappingURL=anonymous.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2FiaS9saWIuZXNtL2NvZGVycy9hbm9ueW1vdXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBYTtBQUM0QjtBQUN6QztBQUNPLDZCQUE2QixrREFBSztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sZWRnaXR5LXlpZWxkLWZyb250ZW5kLy4uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9hYmkvbGliLmVzbS9jb2RlcnMvYW5vbnltb3VzLmpzP2JhNzgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgeyBDb2RlciB9IGZyb20gXCIuL2Fic3RyYWN0LWNvZGVyXCI7XG4vLyBDbG9uZXMgdGhlIGZ1bmN0aW9uYWxpdHkgb2YgYW4gZXhpc3RpbmcgQ29kZXIsIGJ1dCB3aXRob3V0IGEgbG9jYWxOYW1lXG5leHBvcnQgY2xhc3MgQW5vbnltb3VzQ29kZXIgZXh0ZW5kcyBDb2RlciB7XG4gICAgY29uc3RydWN0b3IoY29kZXIpIHtcbiAgICAgICAgc3VwZXIoY29kZXIubmFtZSwgY29kZXIudHlwZSwgdW5kZWZpbmVkLCBjb2Rlci5keW5hbWljKTtcbiAgICAgICAgdGhpcy5jb2RlciA9IGNvZGVyO1xuICAgIH1cbiAgICBkZWZhdWx0VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvZGVyLmRlZmF1bHRWYWx1ZSgpO1xuICAgIH1cbiAgICBlbmNvZGUod3JpdGVyLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2Rlci5lbmNvZGUod3JpdGVyLCB2YWx1ZSk7XG4gICAgfVxuICAgIGRlY29kZShyZWFkZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29kZXIuZGVjb2RlKHJlYWRlcik7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YW5vbnltb3VzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ethersproject/abi/lib.esm/coders/anonymous.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@ethersproject/abi/lib.esm/coders/array.js":
/*!******************************************************************!*\
  !*** ../node_modules/@ethersproject/abi/lib.esm/coders/array.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ArrayCoder: () => (/* binding */ ArrayCoder),\n/* harmony export */   pack: () => (/* binding */ pack),\n/* harmony export */   unpack: () => (/* binding */ unpack)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/../node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../_version */ \"(ssr)/../node_modules/@ethersproject/abi/lib.esm/_version.js\");\n/* harmony import */ var _abstract_coder__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./abstract-coder */ \"(ssr)/../node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js\");\n/* harmony import */ var _anonymous__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./anonymous */ \"(ssr)/../node_modules/@ethersproject/abi/lib.esm/coders/anonymous.js\");\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\n\n\nfunction pack(writer, coders, values) {\n    let arrayValues = null;\n    if (Array.isArray(values)) {\n        arrayValues = values;\n    }\n    else if (values && typeof (values) === \"object\") {\n        let unique = {};\n        arrayValues = coders.map((coder) => {\n            const name = coder.localName;\n            if (!name) {\n                logger.throwError(\"cannot encode object for signature with missing names\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.INVALID_ARGUMENT, {\n                    argument: \"values\",\n                    coder: coder,\n                    value: values\n                });\n            }\n            if (unique[name]) {\n                logger.throwError(\"cannot encode object for signature with duplicate names\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.INVALID_ARGUMENT, {\n                    argument: \"values\",\n                    coder: coder,\n                    value: values\n                });\n            }\n            unique[name] = true;\n            return values[name];\n        });\n    }\n    else {\n        logger.throwArgumentError(\"invalid tuple value\", \"tuple\", values);\n    }\n    if (coders.length !== arrayValues.length) {\n        logger.throwArgumentError(\"types/value length mismatch\", \"tuple\", values);\n    }\n    let staticWriter = new _abstract_coder__WEBPACK_IMPORTED_MODULE_2__.Writer(writer.wordSize);\n    let dynamicWriter = new _abstract_coder__WEBPACK_IMPORTED_MODULE_2__.Writer(writer.wordSize);\n    let updateFuncs = [];\n    coders.forEach((coder, index) => {\n        let value = arrayValues[index];\n        if (coder.dynamic) {\n            // Get current dynamic offset (for the future pointer)\n            let dynamicOffset = dynamicWriter.length;\n            // Encode the dynamic value into the dynamicWriter\n            coder.encode(dynamicWriter, value);\n            // Prepare to populate the correct offset once we are done\n            let updateFunc = staticWriter.writeUpdatableValue();\n            updateFuncs.push((baseOffset) => {\n                updateFunc(baseOffset + dynamicOffset);\n            });\n        }\n        else {\n            coder.encode(staticWriter, value);\n        }\n    });\n    // Backfill all the dynamic offsets, now that we know the static length\n    updateFuncs.forEach((func) => { func(staticWriter.length); });\n    let length = writer.appendWriter(staticWriter);\n    length += writer.appendWriter(dynamicWriter);\n    return length;\n}\nfunction unpack(reader, coders) {\n    let values = [];\n    // A reader anchored to this base\n    let baseReader = reader.subReader(0);\n    coders.forEach((coder) => {\n        let value = null;\n        if (coder.dynamic) {\n            let offset = reader.readValue();\n            let offsetReader = baseReader.subReader(offset.toNumber());\n            try {\n                value = coder.decode(offsetReader);\n            }\n            catch (error) {\n                // Cannot recover from this\n                if (error.code === _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.BUFFER_OVERRUN) {\n                    throw error;\n                }\n                value = error;\n                value.baseType = coder.name;\n                value.name = coder.localName;\n                value.type = coder.type;\n            }\n        }\n        else {\n            try {\n                value = coder.decode(reader);\n            }\n            catch (error) {\n                // Cannot recover from this\n                if (error.code === _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.BUFFER_OVERRUN) {\n                    throw error;\n                }\n                value = error;\n                value.baseType = coder.name;\n                value.name = coder.localName;\n                value.type = coder.type;\n            }\n        }\n        if (value != undefined) {\n            values.push(value);\n        }\n    });\n    // We only output named properties for uniquely named coders\n    const uniqueNames = coders.reduce((accum, coder) => {\n        const name = coder.localName;\n        if (name) {\n            if (!accum[name]) {\n                accum[name] = 0;\n            }\n            accum[name]++;\n        }\n        return accum;\n    }, {});\n    // Add any named parameters (i.e. tuples)\n    coders.forEach((coder, index) => {\n        let name = coder.localName;\n        if (!name || uniqueNames[name] !== 1) {\n            return;\n        }\n        if (name === \"length\") {\n            name = \"_length\";\n        }\n        if (values[name] != null) {\n            return;\n        }\n        const value = values[index];\n        if (value instanceof Error) {\n            Object.defineProperty(values, name, {\n                enumerable: true,\n                get: () => { throw value; }\n            });\n        }\n        else {\n            values[name] = value;\n        }\n    });\n    for (let i = 0; i < values.length; i++) {\n        const value = values[i];\n        if (value instanceof Error) {\n            Object.defineProperty(values, i, {\n                enumerable: true,\n                get: () => { throw value; }\n            });\n        }\n    }\n    return Object.freeze(values);\n}\nclass ArrayCoder extends _abstract_coder__WEBPACK_IMPORTED_MODULE_2__.Coder {\n    constructor(coder, length, localName) {\n        const type = (coder.type + \"[\" + (length >= 0 ? length : \"\") + \"]\");\n        const dynamic = (length === -1 || coder.dynamic);\n        super(\"array\", type, localName, dynamic);\n        this.coder = coder;\n        this.length = length;\n    }\n    defaultValue() {\n        // Verifies the child coder is valid (even if the array is dynamic or 0-length)\n        const defaultChild = this.coder.defaultValue();\n        const result = [];\n        for (let i = 0; i < this.length; i++) {\n            result.push(defaultChild);\n        }\n        return result;\n    }\n    encode(writer, value) {\n        if (!Array.isArray(value)) {\n            this._throwError(\"expected array value\", value);\n        }\n        let count = this.length;\n        if (count === -1) {\n            count = value.length;\n            writer.writeValue(value.length);\n        }\n        logger.checkArgumentCount(value.length, count, \"coder array\" + (this.localName ? (\" \" + this.localName) : \"\"));\n        let coders = [];\n        for (let i = 0; i < value.length; i++) {\n            coders.push(this.coder);\n        }\n        return pack(writer, coders, value);\n    }\n    decode(reader) {\n        let count = this.length;\n        if (count === -1) {\n            count = reader.readValue().toNumber();\n            // Check that there is *roughly* enough data to ensure\n            // stray random data is not being read as a length. Each\n            // slot requires at least 32 bytes for their value (or 32\n            // bytes as a link to the data). This could use a much\n            // tighter bound, but we are erroring on the side of safety.\n            if (count * 32 > reader._data.length) {\n                logger.throwError(\"insufficient data length\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.BUFFER_OVERRUN, {\n                    length: reader._data.length,\n                    count: count\n                });\n            }\n        }\n        let coders = [];\n        for (let i = 0; i < count; i++) {\n            coders.push(new _anonymous__WEBPACK_IMPORTED_MODULE_3__.AnonymousCoder(this.coder));\n        }\n        return reader.coerce(this.name, unpack(reader, coders));\n    }\n}\n//# sourceMappingURL=array.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2FiaS9saWIuZXNtL2NvZGVycy9hcnJheS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQWE7QUFDa0M7QUFDVDtBQUN0QyxtQkFBbUIseURBQU0sQ0FBQyw2Q0FBTztBQUNnQjtBQUNKO0FBQ3RDO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkZBQTJGLHlEQUFNO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsNkZBQTZGLHlEQUFNO0FBQ25HO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsbURBQU07QUFDakMsNEJBQTRCLG1EQUFNO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLG9DQUFvQyw0QkFBNEI7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHlEQUFNO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMseURBQU07QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssSUFBSTtBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNPLHlCQUF5QixrREFBSztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQseURBQU07QUFDcEU7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsV0FBVztBQUNuQyw0QkFBNEIsc0RBQWM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xlZGdpdHkteWllbGQtZnJvbnRlbmQvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2FiaS9saWIuZXNtL2NvZGVycy9hcnJheS5qcz85ZmYxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2xvZ2dlclwiO1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gXCIuLi9fdmVyc2lvblwiO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcih2ZXJzaW9uKTtcbmltcG9ydCB7IENvZGVyLCBXcml0ZXIgfSBmcm9tIFwiLi9hYnN0cmFjdC1jb2RlclwiO1xuaW1wb3J0IHsgQW5vbnltb3VzQ29kZXIgfSBmcm9tIFwiLi9hbm9ueW1vdXNcIjtcbmV4cG9ydCBmdW5jdGlvbiBwYWNrKHdyaXRlciwgY29kZXJzLCB2YWx1ZXMpIHtcbiAgICBsZXQgYXJyYXlWYWx1ZXMgPSBudWxsO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlcykpIHtcbiAgICAgICAgYXJyYXlWYWx1ZXMgPSB2YWx1ZXM7XG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbHVlcyAmJiB0eXBlb2YgKHZhbHVlcykgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgbGV0IHVuaXF1ZSA9IHt9O1xuICAgICAgICBhcnJheVZhbHVlcyA9IGNvZGVycy5tYXAoKGNvZGVyKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gY29kZXIubG9jYWxOYW1lO1xuICAgICAgICAgICAgaWYgKCFuYW1lKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJjYW5ub3QgZW5jb2RlIG9iamVjdCBmb3Igc2lnbmF0dXJlIHdpdGggbWlzc2luZyBuYW1lc1wiLCBMb2dnZXIuZXJyb3JzLklOVkFMSURfQVJHVU1FTlQsIHtcbiAgICAgICAgICAgICAgICAgICAgYXJndW1lbnQ6IFwidmFsdWVzXCIsXG4gICAgICAgICAgICAgICAgICAgIGNvZGVyOiBjb2RlcixcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlc1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHVuaXF1ZVtuYW1lXSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiY2Fubm90IGVuY29kZSBvYmplY3QgZm9yIHNpZ25hdHVyZSB3aXRoIGR1cGxpY2F0ZSBuYW1lc1wiLCBMb2dnZXIuZXJyb3JzLklOVkFMSURfQVJHVU1FTlQsIHtcbiAgICAgICAgICAgICAgICAgICAgYXJndW1lbnQ6IFwidmFsdWVzXCIsXG4gICAgICAgICAgICAgICAgICAgIGNvZGVyOiBjb2RlcixcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlc1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdW5pcXVlW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZXNbbmFtZV07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgdHVwbGUgdmFsdWVcIiwgXCJ0dXBsZVwiLCB2YWx1ZXMpO1xuICAgIH1cbiAgICBpZiAoY29kZXJzLmxlbmd0aCAhPT0gYXJyYXlWYWx1ZXMubGVuZ3RoKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ0eXBlcy92YWx1ZSBsZW5ndGggbWlzbWF0Y2hcIiwgXCJ0dXBsZVwiLCB2YWx1ZXMpO1xuICAgIH1cbiAgICBsZXQgc3RhdGljV3JpdGVyID0gbmV3IFdyaXRlcih3cml0ZXIud29yZFNpemUpO1xuICAgIGxldCBkeW5hbWljV3JpdGVyID0gbmV3IFdyaXRlcih3cml0ZXIud29yZFNpemUpO1xuICAgIGxldCB1cGRhdGVGdW5jcyA9IFtdO1xuICAgIGNvZGVycy5mb3JFYWNoKChjb2RlciwgaW5kZXgpID0+IHtcbiAgICAgICAgbGV0IHZhbHVlID0gYXJyYXlWYWx1ZXNbaW5kZXhdO1xuICAgICAgICBpZiAoY29kZXIuZHluYW1pYykge1xuICAgICAgICAgICAgLy8gR2V0IGN1cnJlbnQgZHluYW1pYyBvZmZzZXQgKGZvciB0aGUgZnV0dXJlIHBvaW50ZXIpXG4gICAgICAgICAgICBsZXQgZHluYW1pY09mZnNldCA9IGR5bmFtaWNXcml0ZXIubGVuZ3RoO1xuICAgICAgICAgICAgLy8gRW5jb2RlIHRoZSBkeW5hbWljIHZhbHVlIGludG8gdGhlIGR5bmFtaWNXcml0ZXJcbiAgICAgICAgICAgIGNvZGVyLmVuY29kZShkeW5hbWljV3JpdGVyLCB2YWx1ZSk7XG4gICAgICAgICAgICAvLyBQcmVwYXJlIHRvIHBvcHVsYXRlIHRoZSBjb3JyZWN0IG9mZnNldCBvbmNlIHdlIGFyZSBkb25lXG4gICAgICAgICAgICBsZXQgdXBkYXRlRnVuYyA9IHN0YXRpY1dyaXRlci53cml0ZVVwZGF0YWJsZVZhbHVlKCk7XG4gICAgICAgICAgICB1cGRhdGVGdW5jcy5wdXNoKChiYXNlT2Zmc2V0KSA9PiB7XG4gICAgICAgICAgICAgICAgdXBkYXRlRnVuYyhiYXNlT2Zmc2V0ICsgZHluYW1pY09mZnNldCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvZGVyLmVuY29kZShzdGF0aWNXcml0ZXIsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIC8vIEJhY2tmaWxsIGFsbCB0aGUgZHluYW1pYyBvZmZzZXRzLCBub3cgdGhhdCB3ZSBrbm93IHRoZSBzdGF0aWMgbGVuZ3RoXG4gICAgdXBkYXRlRnVuY3MuZm9yRWFjaCgoZnVuYykgPT4geyBmdW5jKHN0YXRpY1dyaXRlci5sZW5ndGgpOyB9KTtcbiAgICBsZXQgbGVuZ3RoID0gd3JpdGVyLmFwcGVuZFdyaXRlcihzdGF0aWNXcml0ZXIpO1xuICAgIGxlbmd0aCArPSB3cml0ZXIuYXBwZW5kV3JpdGVyKGR5bmFtaWNXcml0ZXIpO1xuICAgIHJldHVybiBsZW5ndGg7XG59XG5leHBvcnQgZnVuY3Rpb24gdW5wYWNrKHJlYWRlciwgY29kZXJzKSB7XG4gICAgbGV0IHZhbHVlcyA9IFtdO1xuICAgIC8vIEEgcmVhZGVyIGFuY2hvcmVkIHRvIHRoaXMgYmFzZVxuICAgIGxldCBiYXNlUmVhZGVyID0gcmVhZGVyLnN1YlJlYWRlcigwKTtcbiAgICBjb2RlcnMuZm9yRWFjaCgoY29kZXIpID0+IHtcbiAgICAgICAgbGV0IHZhbHVlID0gbnVsbDtcbiAgICAgICAgaWYgKGNvZGVyLmR5bmFtaWMpIHtcbiAgICAgICAgICAgIGxldCBvZmZzZXQgPSByZWFkZXIucmVhZFZhbHVlKCk7XG4gICAgICAgICAgICBsZXQgb2Zmc2V0UmVhZGVyID0gYmFzZVJlYWRlci5zdWJSZWFkZXIob2Zmc2V0LnRvTnVtYmVyKCkpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGNvZGVyLmRlY29kZShvZmZzZXRSZWFkZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2Fubm90IHJlY292ZXIgZnJvbSB0aGlzXG4gICAgICAgICAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09IExvZ2dlci5lcnJvcnMuQlVGRkVSX09WRVJSVU4pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhbHVlID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgdmFsdWUuYmFzZVR5cGUgPSBjb2Rlci5uYW1lO1xuICAgICAgICAgICAgICAgIHZhbHVlLm5hbWUgPSBjb2Rlci5sb2NhbE5hbWU7XG4gICAgICAgICAgICAgICAgdmFsdWUudHlwZSA9IGNvZGVyLnR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gY29kZXIuZGVjb2RlKHJlYWRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBDYW5ub3QgcmVjb3ZlciBmcm9tIHRoaXNcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IuY29kZSA9PT0gTG9nZ2VyLmVycm9ycy5CVUZGRVJfT1ZFUlJVTikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICB2YWx1ZS5iYXNlVHlwZSA9IGNvZGVyLm5hbWU7XG4gICAgICAgICAgICAgICAgdmFsdWUubmFtZSA9IGNvZGVyLmxvY2FsTmFtZTtcbiAgICAgICAgICAgICAgICB2YWx1ZS50eXBlID0gY29kZXIudHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBXZSBvbmx5IG91dHB1dCBuYW1lZCBwcm9wZXJ0aWVzIGZvciB1bmlxdWVseSBuYW1lZCBjb2RlcnNcbiAgICBjb25zdCB1bmlxdWVOYW1lcyA9IGNvZGVycy5yZWR1Y2UoKGFjY3VtLCBjb2RlcikgPT4ge1xuICAgICAgICBjb25zdCBuYW1lID0gY29kZXIubG9jYWxOYW1lO1xuICAgICAgICBpZiAobmFtZSkge1xuICAgICAgICAgICAgaWYgKCFhY2N1bVtuYW1lXSkge1xuICAgICAgICAgICAgICAgIGFjY3VtW25hbWVdID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFjY3VtW25hbWVdKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFjY3VtO1xuICAgIH0sIHt9KTtcbiAgICAvLyBBZGQgYW55IG5hbWVkIHBhcmFtZXRlcnMgKGkuZS4gdHVwbGVzKVxuICAgIGNvZGVycy5mb3JFYWNoKChjb2RlciwgaW5kZXgpID0+IHtcbiAgICAgICAgbGV0IG5hbWUgPSBjb2Rlci5sb2NhbE5hbWU7XG4gICAgICAgIGlmICghbmFtZSB8fCB1bmlxdWVOYW1lc1tuYW1lXSAhPT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuYW1lID09PSBcImxlbmd0aFwiKSB7XG4gICAgICAgICAgICBuYW1lID0gXCJfbGVuZ3RoXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsdWUgPSB2YWx1ZXNbaW5kZXhdO1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHZhbHVlcywgbmFtZSwge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiAoKSA9PiB7IHRocm93IHZhbHVlOyB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlc1tuYW1lXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB2YWx1ZXNbaV07XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodmFsdWVzLCBpLCB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6ICgpID0+IHsgdGhyb3cgdmFsdWU7IH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHZhbHVlcyk7XG59XG5leHBvcnQgY2xhc3MgQXJyYXlDb2RlciBleHRlbmRzIENvZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb2RlciwgbGVuZ3RoLCBsb2NhbE5hbWUpIHtcbiAgICAgICAgY29uc3QgdHlwZSA9IChjb2Rlci50eXBlICsgXCJbXCIgKyAobGVuZ3RoID49IDAgPyBsZW5ndGggOiBcIlwiKSArIFwiXVwiKTtcbiAgICAgICAgY29uc3QgZHluYW1pYyA9IChsZW5ndGggPT09IC0xIHx8IGNvZGVyLmR5bmFtaWMpO1xuICAgICAgICBzdXBlcihcImFycmF5XCIsIHR5cGUsIGxvY2FsTmFtZSwgZHluYW1pYyk7XG4gICAgICAgIHRoaXMuY29kZXIgPSBjb2RlcjtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgfVxuICAgIGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgICAgLy8gVmVyaWZpZXMgdGhlIGNoaWxkIGNvZGVyIGlzIHZhbGlkIChldmVuIGlmIHRoZSBhcnJheSBpcyBkeW5hbWljIG9yIDAtbGVuZ3RoKVxuICAgICAgICBjb25zdCBkZWZhdWx0Q2hpbGQgPSB0aGlzLmNvZGVyLmRlZmF1bHRWYWx1ZSgpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChkZWZhdWx0Q2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGVuY29kZSh3cml0ZXIsIHZhbHVlKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX3Rocm93RXJyb3IoXCJleHBlY3RlZCBhcnJheSB2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvdW50ID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIGlmIChjb3VudCA9PT0gLTEpIHtcbiAgICAgICAgICAgIGNvdW50ID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgd3JpdGVyLndyaXRlVmFsdWUodmFsdWUubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXIuY2hlY2tBcmd1bWVudENvdW50KHZhbHVlLmxlbmd0aCwgY291bnQsIFwiY29kZXIgYXJyYXlcIiArICh0aGlzLmxvY2FsTmFtZSA/IChcIiBcIiArIHRoaXMubG9jYWxOYW1lKSA6IFwiXCIpKTtcbiAgICAgICAgbGV0IGNvZGVycyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb2RlcnMucHVzaCh0aGlzLmNvZGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFjayh3cml0ZXIsIGNvZGVycywgdmFsdWUpO1xuICAgIH1cbiAgICBkZWNvZGUocmVhZGVyKSB7XG4gICAgICAgIGxldCBjb3VudCA9IHRoaXMubGVuZ3RoO1xuICAgICAgICBpZiAoY291bnQgPT09IC0xKSB7XG4gICAgICAgICAgICBjb3VudCA9IHJlYWRlci5yZWFkVmFsdWUoKS50b051bWJlcigpO1xuICAgICAgICAgICAgLy8gQ2hlY2sgdGhhdCB0aGVyZSBpcyAqcm91Z2hseSogZW5vdWdoIGRhdGEgdG8gZW5zdXJlXG4gICAgICAgICAgICAvLyBzdHJheSByYW5kb20gZGF0YSBpcyBub3QgYmVpbmcgcmVhZCBhcyBhIGxlbmd0aC4gRWFjaFxuICAgICAgICAgICAgLy8gc2xvdCByZXF1aXJlcyBhdCBsZWFzdCAzMiBieXRlcyBmb3IgdGhlaXIgdmFsdWUgKG9yIDMyXG4gICAgICAgICAgICAvLyBieXRlcyBhcyBhIGxpbmsgdG8gdGhlIGRhdGEpLiBUaGlzIGNvdWxkIHVzZSBhIG11Y2hcbiAgICAgICAgICAgIC8vIHRpZ2h0ZXIgYm91bmQsIGJ1dCB3ZSBhcmUgZXJyb3Jpbmcgb24gdGhlIHNpZGUgb2Ygc2FmZXR5LlxuICAgICAgICAgICAgaWYgKGNvdW50ICogMzIgPiByZWFkZXIuX2RhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJpbnN1ZmZpY2llbnQgZGF0YSBsZW5ndGhcIiwgTG9nZ2VyLmVycm9ycy5CVUZGRVJfT1ZFUlJVTiwge1xuICAgICAgICAgICAgICAgICAgICBsZW5ndGg6IHJlYWRlci5fZGF0YS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgIGNvdW50OiBjb3VudFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBjb2RlcnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBjb2RlcnMucHVzaChuZXcgQW5vbnltb3VzQ29kZXIodGhpcy5jb2RlcikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWFkZXIuY29lcmNlKHRoaXMubmFtZSwgdW5wYWNrKHJlYWRlciwgY29kZXJzKSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXJyYXkuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ethersproject/abi/lib.esm/coders/array.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@ethersproject/abi/lib.esm/coders/boolean.js":
/*!********************************************************************!*\
  !*** ../node_modules/@ethersproject/abi/lib.esm/coders/boolean.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BooleanCoder: () => (/* binding */ BooleanCoder)\n/* harmony export */ });\n/* harmony import */ var _abstract_coder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder */ \"(ssr)/../node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js\");\n\n\nclass BooleanCoder extends _abstract_coder__WEBPACK_IMPORTED_MODULE_0__.Coder {\n    constructor(localName) {\n        super(\"bool\", \"bool\", localName, false);\n    }\n    defaultValue() {\n        return false;\n    }\n    encode(writer, value) {\n        return writer.writeValue(value ? 1 : 0);\n    }\n    decode(reader) {\n        return reader.coerce(this.type, !reader.readValue().isZero());\n    }\n}\n//# sourceMappingURL=boolean.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2FiaS9saWIuZXNtL2NvZGVycy9ib29sZWFuLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQWE7QUFDNEI7QUFDbEMsMkJBQTJCLGtEQUFLO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sZWRnaXR5LXlpZWxkLWZyb250ZW5kLy4uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9hYmkvbGliLmVzbS9jb2RlcnMvYm9vbGVhbi5qcz9kNTgwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuaW1wb3J0IHsgQ29kZXIgfSBmcm9tIFwiLi9hYnN0cmFjdC1jb2RlclwiO1xuZXhwb3J0IGNsYXNzIEJvb2xlYW5Db2RlciBleHRlbmRzIENvZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihsb2NhbE5hbWUpIHtcbiAgICAgICAgc3VwZXIoXCJib29sXCIsIFwiYm9vbFwiLCBsb2NhbE5hbWUsIGZhbHNlKTtcbiAgICB9XG4gICAgZGVmYXVsdFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGVuY29kZSh3cml0ZXIsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB3cml0ZXIud3JpdGVWYWx1ZSh2YWx1ZSA/IDEgOiAwKTtcbiAgICB9XG4gICAgZGVjb2RlKHJlYWRlcikge1xuICAgICAgICByZXR1cm4gcmVhZGVyLmNvZXJjZSh0aGlzLnR5cGUsICFyZWFkZXIucmVhZFZhbHVlKCkuaXNaZXJvKCkpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJvb2xlYW4uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ethersproject/abi/lib.esm/coders/boolean.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@ethersproject/abi/lib.esm/coders/bytes.js":
/*!******************************************************************!*\
  !*** ../node_modules/@ethersproject/abi/lib.esm/coders/bytes.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BytesCoder: () => (/* binding */ BytesCoder),\n/* harmony export */   DynamicBytesCoder: () => (/* binding */ DynamicBytesCoder)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/../node_modules/@ethersproject/bytes/lib.esm/index.js\");\n/* harmony import */ var _abstract_coder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder */ \"(ssr)/../node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js\");\n\n\n\nclass DynamicBytesCoder extends _abstract_coder__WEBPACK_IMPORTED_MODULE_0__.Coder {\n    constructor(type, localName) {\n        super(type, type, localName, true);\n    }\n    defaultValue() {\n        return \"0x\";\n    }\n    encode(writer, value) {\n        value = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__.arrayify)(value);\n        let length = writer.writeValue(value.length);\n        length += writer.writeBytes(value);\n        return length;\n    }\n    decode(reader) {\n        return reader.readBytes(reader.readValue().toNumber(), true);\n    }\n}\nclass BytesCoder extends DynamicBytesCoder {\n    constructor(localName) {\n        super(\"bytes\", localName);\n    }\n    decode(reader) {\n        return reader.coerce(this.name, (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__.hexlify)(super.decode(reader)));\n    }\n}\n//# sourceMappingURL=bytes.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2FiaS9saWIuZXNtL2NvZGVycy9ieXRlcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQWE7QUFDNEM7QUFDaEI7QUFDbEMsZ0NBQWdDLGtEQUFLO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDhEQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLDZEQUFPO0FBQy9DO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xlZGdpdHkteWllbGQtZnJvbnRlbmQvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2FiaS9saWIuZXNtL2NvZGVycy9ieXRlcy5qcz9kOTFlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuaW1wb3J0IHsgYXJyYXlpZnksIGhleGxpZnkgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYnl0ZXNcIjtcbmltcG9ydCB7IENvZGVyIH0gZnJvbSBcIi4vYWJzdHJhY3QtY29kZXJcIjtcbmV4cG9ydCBjbGFzcyBEeW5hbWljQnl0ZXNDb2RlciBleHRlbmRzIENvZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcih0eXBlLCBsb2NhbE5hbWUpIHtcbiAgICAgICAgc3VwZXIodHlwZSwgdHlwZSwgbG9jYWxOYW1lLCB0cnVlKTtcbiAgICB9XG4gICAgZGVmYXVsdFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gXCIweFwiO1xuICAgIH1cbiAgICBlbmNvZGUod3JpdGVyLCB2YWx1ZSkge1xuICAgICAgICB2YWx1ZSA9IGFycmF5aWZ5KHZhbHVlKTtcbiAgICAgICAgbGV0IGxlbmd0aCA9IHdyaXRlci53cml0ZVZhbHVlKHZhbHVlLmxlbmd0aCk7XG4gICAgICAgIGxlbmd0aCArPSB3cml0ZXIud3JpdGVCeXRlcyh2YWx1ZSk7XG4gICAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgfVxuICAgIGRlY29kZShyZWFkZXIpIHtcbiAgICAgICAgcmV0dXJuIHJlYWRlci5yZWFkQnl0ZXMocmVhZGVyLnJlYWRWYWx1ZSgpLnRvTnVtYmVyKCksIHRydWUpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBCeXRlc0NvZGVyIGV4dGVuZHMgRHluYW1pY0J5dGVzQ29kZXIge1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsTmFtZSkge1xuICAgICAgICBzdXBlcihcImJ5dGVzXCIsIGxvY2FsTmFtZSk7XG4gICAgfVxuICAgIGRlY29kZShyZWFkZXIpIHtcbiAgICAgICAgcmV0dXJuIHJlYWRlci5jb2VyY2UodGhpcy5uYW1lLCBoZXhsaWZ5KHN1cGVyLmRlY29kZShyZWFkZXIpKSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Ynl0ZXMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ethersproject/abi/lib.esm/coders/bytes.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@ethersproject/abi/lib.esm/coders/fixed-bytes.js":
/*!************************************************************************!*\
  !*** ../node_modules/@ethersproject/abi/lib.esm/coders/fixed-bytes.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FixedBytesCoder: () => (/* binding */ FixedBytesCoder)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/../node_modules/@ethersproject/bytes/lib.esm/index.js\");\n/* harmony import */ var _abstract_coder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder */ \"(ssr)/../node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js\");\n\n\n\n// @TODO: Merge this with bytes\nclass FixedBytesCoder extends _abstract_coder__WEBPACK_IMPORTED_MODULE_0__.Coder {\n    constructor(size, localName) {\n        let name = \"bytes\" + String(size);\n        super(name, name, localName, false);\n        this.size = size;\n    }\n    defaultValue() {\n        return (\"0x0000000000000000000000000000000000000000000000000000000000000000\").substring(0, 2 + this.size * 2);\n    }\n    encode(writer, value) {\n        let data = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__.arrayify)(value);\n        if (data.length !== this.size) {\n            this._throwError(\"incorrect data length\", value);\n        }\n        return writer.writeBytes(data);\n    }\n    decode(reader) {\n        return reader.coerce(this.name, (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__.hexlify)(reader.readBytes(this.size)));\n    }\n}\n//# sourceMappingURL=fixed-bytes.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2FiaS9saWIuZXNtL2NvZGVycy9maXhlZC1ieXRlcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBYTtBQUM0QztBQUNoQjtBQUN6QztBQUNPLDhCQUE4QixrREFBSztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsOERBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLDZEQUFPO0FBQy9DO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xlZGdpdHkteWllbGQtZnJvbnRlbmQvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2FiaS9saWIuZXNtL2NvZGVycy9maXhlZC1ieXRlcy5qcz80YjhlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuaW1wb3J0IHsgYXJyYXlpZnksIGhleGxpZnkgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYnl0ZXNcIjtcbmltcG9ydCB7IENvZGVyIH0gZnJvbSBcIi4vYWJzdHJhY3QtY29kZXJcIjtcbi8vIEBUT0RPOiBNZXJnZSB0aGlzIHdpdGggYnl0ZXNcbmV4cG9ydCBjbGFzcyBGaXhlZEJ5dGVzQ29kZXIgZXh0ZW5kcyBDb2RlciB7XG4gICAgY29uc3RydWN0b3Ioc2l6ZSwgbG9jYWxOYW1lKSB7XG4gICAgICAgIGxldCBuYW1lID0gXCJieXRlc1wiICsgU3RyaW5nKHNpemUpO1xuICAgICAgICBzdXBlcihuYW1lLCBuYW1lLCBsb2NhbE5hbWUsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5zaXplID0gc2l6ZTtcbiAgICB9XG4gICAgZGVmYXVsdFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gKFwiMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCIpLnN1YnN0cmluZygwLCAyICsgdGhpcy5zaXplICogMik7XG4gICAgfVxuICAgIGVuY29kZSh3cml0ZXIsIHZhbHVlKSB7XG4gICAgICAgIGxldCBkYXRhID0gYXJyYXlpZnkodmFsdWUpO1xuICAgICAgICBpZiAoZGF0YS5sZW5ndGggIT09IHRoaXMuc2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5fdGhyb3dFcnJvcihcImluY29ycmVjdCBkYXRhIGxlbmd0aFwiLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlci53cml0ZUJ5dGVzKGRhdGEpO1xuICAgIH1cbiAgICBkZWNvZGUocmVhZGVyKSB7XG4gICAgICAgIHJldHVybiByZWFkZXIuY29lcmNlKHRoaXMubmFtZSwgaGV4bGlmeShyZWFkZXIucmVhZEJ5dGVzKHRoaXMuc2l6ZSkpKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1maXhlZC1ieXRlcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ethersproject/abi/lib.esm/coders/fixed-bytes.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@ethersproject/abi/lib.esm/coders/null.js":
/*!*****************************************************************!*\
  !*** ../node_modules/@ethersproject/abi/lib.esm/coders/null.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NullCoder: () => (/* binding */ NullCoder)\n/* harmony export */ });\n/* harmony import */ var _abstract_coder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder */ \"(ssr)/../node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js\");\n\n\nclass NullCoder extends _abstract_coder__WEBPACK_IMPORTED_MODULE_0__.Coder {\n    constructor(localName) {\n        super(\"null\", \"\", localName, false);\n    }\n    defaultValue() {\n        return null;\n    }\n    encode(writer, value) {\n        if (value != null) {\n            this._throwError(\"not null\", value);\n        }\n        return writer.writeBytes([]);\n    }\n    decode(reader) {\n        reader.readBytes(0);\n        return reader.coerce(this.name, null);\n    }\n}\n//# sourceMappingURL=null.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2FiaS9saWIuZXNtL2NvZGVycy9udWxsLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQWE7QUFDNEI7QUFDbEMsd0JBQXdCLGtEQUFLO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xlZGdpdHkteWllbGQtZnJvbnRlbmQvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2FiaS9saWIuZXNtL2NvZGVycy9udWxsLmpzPzEzMmYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgeyBDb2RlciB9IGZyb20gXCIuL2Fic3RyYWN0LWNvZGVyXCI7XG5leHBvcnQgY2xhc3MgTnVsbENvZGVyIGV4dGVuZHMgQ29kZXIge1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsTmFtZSkge1xuICAgICAgICBzdXBlcihcIm51bGxcIiwgXCJcIiwgbG9jYWxOYW1lLCBmYWxzZSk7XG4gICAgfVxuICAgIGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGVuY29kZSh3cml0ZXIsIHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl90aHJvd0Vycm9yKFwibm90IG51bGxcIiwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXIud3JpdGVCeXRlcyhbXSk7XG4gICAgfVxuICAgIGRlY29kZShyZWFkZXIpIHtcbiAgICAgICAgcmVhZGVyLnJlYWRCeXRlcygwKTtcbiAgICAgICAgcmV0dXJuIHJlYWRlci5jb2VyY2UodGhpcy5uYW1lLCBudWxsKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1udWxsLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ethersproject/abi/lib.esm/coders/null.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@ethersproject/abi/lib.esm/coders/number.js":
/*!*******************************************************************!*\
  !*** ../node_modules/@ethersproject/abi/lib.esm/coders/number.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NumberCoder: () => (/* binding */ NumberCoder)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/bignumber */ \"(ssr)/../node_modules/@ethersproject/bignumber/lib.esm/bignumber.js\");\n/* harmony import */ var _ethersproject_constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/constants */ \"(ssr)/../node_modules/@ethersproject/constants/lib.esm/bignumbers.js\");\n/* harmony import */ var _abstract_coder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder */ \"(ssr)/../node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js\");\n\n\n\n\nclass NumberCoder extends _abstract_coder__WEBPACK_IMPORTED_MODULE_0__.Coder {\n    constructor(size, signed, localName) {\n        const name = ((signed ? \"int\" : \"uint\") + (size * 8));\n        super(name, name, localName, false);\n        this.size = size;\n        this.signed = signed;\n    }\n    defaultValue() {\n        return 0;\n    }\n    encode(writer, value) {\n        let v = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_1__.BigNumber.from(value);\n        // Check bounds are safe for encoding\n        let maxUintValue = _ethersproject_constants__WEBPACK_IMPORTED_MODULE_2__.MaxUint256.mask(writer.wordSize * 8);\n        if (this.signed) {\n            let bounds = maxUintValue.mask(this.size * 8 - 1);\n            if (v.gt(bounds) || v.lt(bounds.add(_ethersproject_constants__WEBPACK_IMPORTED_MODULE_2__.One).mul(_ethersproject_constants__WEBPACK_IMPORTED_MODULE_2__.NegativeOne))) {\n                this._throwError(\"value out-of-bounds\", value);\n            }\n        }\n        else if (v.lt(_ethersproject_constants__WEBPACK_IMPORTED_MODULE_2__.Zero) || v.gt(maxUintValue.mask(this.size * 8))) {\n            this._throwError(\"value out-of-bounds\", value);\n        }\n        v = v.toTwos(this.size * 8).mask(this.size * 8);\n        if (this.signed) {\n            v = v.fromTwos(this.size * 8).toTwos(8 * writer.wordSize);\n        }\n        return writer.writeValue(v);\n    }\n    decode(reader) {\n        let value = reader.readValue().mask(this.size * 8);\n        if (this.signed) {\n            value = value.fromTwos(this.size * 8);\n        }\n        return reader.coerce(this.name, value);\n    }\n}\n//# sourceMappingURL=number.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2FiaS9saWIuZXNtL2NvZGVycy9udW1iZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFhO0FBQ3dDO0FBQ3lCO0FBQ3JDO0FBQ2xDLDBCQUEwQixrREFBSztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwrREFBUztBQUN6QjtBQUNBLDJCQUEyQixnRUFBVTtBQUNyQztBQUNBO0FBQ0EsZ0RBQWdELHlEQUFHLE1BQU0saUVBQVc7QUFDcEU7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDBEQUFJO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sZWRnaXR5LXlpZWxkLWZyb250ZW5kLy4uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9hYmkvbGliLmVzbS9jb2RlcnMvbnVtYmVyLmpzP2EzNTAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgeyBCaWdOdW1iZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYmlnbnVtYmVyXCI7XG5pbXBvcnQgeyBNYXhVaW50MjU2LCBOZWdhdGl2ZU9uZSwgT25lLCBaZXJvIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2NvbnN0YW50c1wiO1xuaW1wb3J0IHsgQ29kZXIgfSBmcm9tIFwiLi9hYnN0cmFjdC1jb2RlclwiO1xuZXhwb3J0IGNsYXNzIE51bWJlckNvZGVyIGV4dGVuZHMgQ29kZXIge1xuICAgIGNvbnN0cnVjdG9yKHNpemUsIHNpZ25lZCwgbG9jYWxOYW1lKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSAoKHNpZ25lZCA/IFwiaW50XCIgOiBcInVpbnRcIikgKyAoc2l6ZSAqIDgpKTtcbiAgICAgICAgc3VwZXIobmFtZSwgbmFtZSwgbG9jYWxOYW1lLCBmYWxzZSk7XG4gICAgICAgIHRoaXMuc2l6ZSA9IHNpemU7XG4gICAgICAgIHRoaXMuc2lnbmVkID0gc2lnbmVkO1xuICAgIH1cbiAgICBkZWZhdWx0VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBlbmNvZGUod3JpdGVyLCB2YWx1ZSkge1xuICAgICAgICBsZXQgdiA9IEJpZ051bWJlci5mcm9tKHZhbHVlKTtcbiAgICAgICAgLy8gQ2hlY2sgYm91bmRzIGFyZSBzYWZlIGZvciBlbmNvZGluZ1xuICAgICAgICBsZXQgbWF4VWludFZhbHVlID0gTWF4VWludDI1Ni5tYXNrKHdyaXRlci53b3JkU2l6ZSAqIDgpO1xuICAgICAgICBpZiAodGhpcy5zaWduZWQpIHtcbiAgICAgICAgICAgIGxldCBib3VuZHMgPSBtYXhVaW50VmFsdWUubWFzayh0aGlzLnNpemUgKiA4IC0gMSk7XG4gICAgICAgICAgICBpZiAodi5ndChib3VuZHMpIHx8IHYubHQoYm91bmRzLmFkZChPbmUpLm11bChOZWdhdGl2ZU9uZSkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGhyb3dFcnJvcihcInZhbHVlIG91dC1vZi1ib3VuZHNcIiwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHYubHQoWmVybykgfHwgdi5ndChtYXhVaW50VmFsdWUubWFzayh0aGlzLnNpemUgKiA4KSkpIHtcbiAgICAgICAgICAgIHRoaXMuX3Rocm93RXJyb3IoXCJ2YWx1ZSBvdXQtb2YtYm91bmRzXCIsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICB2ID0gdi50b1R3b3ModGhpcy5zaXplICogOCkubWFzayh0aGlzLnNpemUgKiA4KTtcbiAgICAgICAgaWYgKHRoaXMuc2lnbmVkKSB7XG4gICAgICAgICAgICB2ID0gdi5mcm9tVHdvcyh0aGlzLnNpemUgKiA4KS50b1R3b3MoOCAqIHdyaXRlci53b3JkU2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlci53cml0ZVZhbHVlKHYpO1xuICAgIH1cbiAgICBkZWNvZGUocmVhZGVyKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IHJlYWRlci5yZWFkVmFsdWUoKS5tYXNrKHRoaXMuc2l6ZSAqIDgpO1xuICAgICAgICBpZiAodGhpcy5zaWduZWQpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuZnJvbVR3b3ModGhpcy5zaXplICogOCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlYWRlci5jb2VyY2UodGhpcy5uYW1lLCB2YWx1ZSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bnVtYmVyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ethersproject/abi/lib.esm/coders/number.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@ethersproject/abi/lib.esm/coders/string.js":
/*!*******************************************************************!*\
  !*** ../node_modules/@ethersproject/abi/lib.esm/coders/string.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StringCoder: () => (/* binding */ StringCoder)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_strings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/strings */ \"(ssr)/../node_modules/@ethersproject/strings/lib.esm/utf8.js\");\n/* harmony import */ var _bytes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bytes */ \"(ssr)/../node_modules/@ethersproject/abi/lib.esm/coders/bytes.js\");\n\n\n\nclass StringCoder extends _bytes__WEBPACK_IMPORTED_MODULE_0__.DynamicBytesCoder {\n    constructor(localName) {\n        super(\"string\", localName);\n    }\n    defaultValue() {\n        return \"\";\n    }\n    encode(writer, value) {\n        return super.encode(writer, (0,_ethersproject_strings__WEBPACK_IMPORTED_MODULE_1__.toUtf8Bytes)(value));\n    }\n    decode(reader) {\n        return (0,_ethersproject_strings__WEBPACK_IMPORTED_MODULE_1__.toUtf8String)(super.decode(reader));\n    }\n}\n//# sourceMappingURL=string.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2FiaS9saWIuZXNtL2NvZGVycy9zdHJpbmcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQWE7QUFDc0Q7QUFDdkI7QUFDckMsMEJBQTBCLHFEQUFpQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxtRUFBVztBQUMvQztBQUNBO0FBQ0EsZUFBZSxvRUFBWTtBQUMzQjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sZWRnaXR5LXlpZWxkLWZyb250ZW5kLy4uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9hYmkvbGliLmVzbS9jb2RlcnMvc3RyaW5nLmpzP2FlY2YiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgeyB0b1V0ZjhCeXRlcywgdG9VdGY4U3RyaW5nIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3N0cmluZ3NcIjtcbmltcG9ydCB7IER5bmFtaWNCeXRlc0NvZGVyIH0gZnJvbSBcIi4vYnl0ZXNcIjtcbmV4cG9ydCBjbGFzcyBTdHJpbmdDb2RlciBleHRlbmRzIER5bmFtaWNCeXRlc0NvZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihsb2NhbE5hbWUpIHtcbiAgICAgICAgc3VwZXIoXCJzdHJpbmdcIiwgbG9jYWxOYW1lKTtcbiAgICB9XG4gICAgZGVmYXVsdFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgZW5jb2RlKHdyaXRlciwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmVuY29kZSh3cml0ZXIsIHRvVXRmOEJ5dGVzKHZhbHVlKSk7XG4gICAgfVxuICAgIGRlY29kZShyZWFkZXIpIHtcbiAgICAgICAgcmV0dXJuIHRvVXRmOFN0cmluZyhzdXBlci5kZWNvZGUocmVhZGVyKSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RyaW5nLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ethersproject/abi/lib.esm/coders/string.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@ethersproject/abi/lib.esm/coders/tuple.js":
/*!******************************************************************!*\
  !*** ../node_modules/@ethersproject/abi/lib.esm/coders/tuple.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TupleCoder: () => (/* binding */ TupleCoder)\n/* harmony export */ });\n/* harmony import */ var _abstract_coder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder */ \"(ssr)/../node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js\");\n/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./array */ \"(ssr)/../node_modules/@ethersproject/abi/lib.esm/coders/array.js\");\n\n\n\nclass TupleCoder extends _abstract_coder__WEBPACK_IMPORTED_MODULE_0__.Coder {\n    constructor(coders, localName) {\n        let dynamic = false;\n        const types = [];\n        coders.forEach((coder) => {\n            if (coder.dynamic) {\n                dynamic = true;\n            }\n            types.push(coder.type);\n        });\n        const type = (\"tuple(\" + types.join(\",\") + \")\");\n        super(\"tuple\", type, localName, dynamic);\n        this.coders = coders;\n    }\n    defaultValue() {\n        const values = [];\n        this.coders.forEach((coder) => {\n            values.push(coder.defaultValue());\n        });\n        // We only output named properties for uniquely named coders\n        const uniqueNames = this.coders.reduce((accum, coder) => {\n            const name = coder.localName;\n            if (name) {\n                if (!accum[name]) {\n                    accum[name] = 0;\n                }\n                accum[name]++;\n            }\n            return accum;\n        }, {});\n        // Add named values\n        this.coders.forEach((coder, index) => {\n            let name = coder.localName;\n            if (!name || uniqueNames[name] !== 1) {\n                return;\n            }\n            if (name === \"length\") {\n                name = \"_length\";\n            }\n            if (values[name] != null) {\n                return;\n            }\n            values[name] = values[index];\n        });\n        return Object.freeze(values);\n    }\n    encode(writer, value) {\n        return (0,_array__WEBPACK_IMPORTED_MODULE_1__.pack)(writer, this.coders, value);\n    }\n    decode(reader) {\n        return reader.coerce(this.name, (0,_array__WEBPACK_IMPORTED_MODULE_1__.unpack)(reader, this.coders));\n    }\n}\n//# sourceMappingURL=tuple.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2FiaS9saWIuZXNtL2NvZGVycy90dXBsZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBYTtBQUM0QjtBQUNGO0FBQ2hDLHlCQUF5QixrREFBSztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLElBQUk7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxlQUFlLDRDQUFJO0FBQ25CO0FBQ0E7QUFDQSx3Q0FBd0MsOENBQU07QUFDOUM7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGVkZ2l0eS15aWVsZC1mcm9udGVuZC8uLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvYWJpL2xpYi5lc20vY29kZXJzL3R1cGxlLmpzPzgxYzAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgeyBDb2RlciB9IGZyb20gXCIuL2Fic3RyYWN0LWNvZGVyXCI7XG5pbXBvcnQgeyBwYWNrLCB1bnBhY2sgfSBmcm9tIFwiLi9hcnJheVwiO1xuZXhwb3J0IGNsYXNzIFR1cGxlQ29kZXIgZXh0ZW5kcyBDb2RlciB7XG4gICAgY29uc3RydWN0b3IoY29kZXJzLCBsb2NhbE5hbWUpIHtcbiAgICAgICAgbGV0IGR5bmFtaWMgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgdHlwZXMgPSBbXTtcbiAgICAgICAgY29kZXJzLmZvckVhY2goKGNvZGVyKSA9PiB7XG4gICAgICAgICAgICBpZiAoY29kZXIuZHluYW1pYykge1xuICAgICAgICAgICAgICAgIGR5bmFtaWMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHlwZXMucHVzaChjb2Rlci50eXBlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHR5cGUgPSAoXCJ0dXBsZShcIiArIHR5cGVzLmpvaW4oXCIsXCIpICsgXCIpXCIpO1xuICAgICAgICBzdXBlcihcInR1cGxlXCIsIHR5cGUsIGxvY2FsTmFtZSwgZHluYW1pYyk7XG4gICAgICAgIHRoaXMuY29kZXJzID0gY29kZXJzO1xuICAgIH1cbiAgICBkZWZhdWx0VmFsdWUoKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IFtdO1xuICAgICAgICB0aGlzLmNvZGVycy5mb3JFYWNoKChjb2RlcikgPT4ge1xuICAgICAgICAgICAgdmFsdWVzLnB1c2goY29kZXIuZGVmYXVsdFZhbHVlKCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gV2Ugb25seSBvdXRwdXQgbmFtZWQgcHJvcGVydGllcyBmb3IgdW5pcXVlbHkgbmFtZWQgY29kZXJzXG4gICAgICAgIGNvbnN0IHVuaXF1ZU5hbWVzID0gdGhpcy5jb2RlcnMucmVkdWNlKChhY2N1bSwgY29kZXIpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBjb2Rlci5sb2NhbE5hbWU7XG4gICAgICAgICAgICBpZiAobmFtZSkge1xuICAgICAgICAgICAgICAgIGlmICghYWNjdW1bbmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgYWNjdW1bbmFtZV0gPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhY2N1bVtuYW1lXSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFjY3VtO1xuICAgICAgICB9LCB7fSk7XG4gICAgICAgIC8vIEFkZCBuYW1lZCB2YWx1ZXNcbiAgICAgICAgdGhpcy5jb2RlcnMuZm9yRWFjaCgoY29kZXIsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBsZXQgbmFtZSA9IGNvZGVyLmxvY2FsTmFtZTtcbiAgICAgICAgICAgIGlmICghbmFtZSB8fCB1bmlxdWVOYW1lc1tuYW1lXSAhPT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuYW1lID09PSBcImxlbmd0aFwiKSB7XG4gICAgICAgICAgICAgICAgbmFtZSA9IFwiX2xlbmd0aFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsdWVzW25hbWVdID0gdmFsdWVzW2luZGV4XTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBPYmplY3QuZnJlZXplKHZhbHVlcyk7XG4gICAgfVxuICAgIGVuY29kZSh3cml0ZXIsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBwYWNrKHdyaXRlciwgdGhpcy5jb2RlcnMsIHZhbHVlKTtcbiAgICB9XG4gICAgZGVjb2RlKHJlYWRlcikge1xuICAgICAgICByZXR1cm4gcmVhZGVyLmNvZXJjZSh0aGlzLm5hbWUsIHVucGFjayhyZWFkZXIsIHRoaXMuY29kZXJzKSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHVwbGUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ethersproject/abi/lib.esm/coders/tuple.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@ethersproject/abi/lib.esm/fragments.js":
/*!***************************************************************!*\
  !*** ../node_modules/@ethersproject/abi/lib.esm/fragments.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ConstructorFragment: () => (/* binding */ ConstructorFragment),\n/* harmony export */   ErrorFragment: () => (/* binding */ ErrorFragment),\n/* harmony export */   EventFragment: () => (/* binding */ EventFragment),\n/* harmony export */   FormatTypes: () => (/* binding */ FormatTypes),\n/* harmony export */   Fragment: () => (/* binding */ Fragment),\n/* harmony export */   FunctionFragment: () => (/* binding */ FunctionFragment),\n/* harmony export */   ParamType: () => (/* binding */ ParamType)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/bignumber */ \"(ssr)/../node_modules/@ethersproject/bignumber/lib.esm/bignumber.js\");\n/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/../node_modules/@ethersproject/properties/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/../node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(ssr)/../node_modules/@ethersproject/abi/lib.esm/_version.js\");\n\n\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\n;\nconst _constructorGuard = {};\nlet ModifiersBytes = { calldata: true, memory: true, storage: true };\nlet ModifiersNest = { calldata: true, memory: true };\nfunction checkModifier(type, name) {\n    if (type === \"bytes\" || type === \"string\") {\n        if (ModifiersBytes[name]) {\n            return true;\n        }\n    }\n    else if (type === \"address\") {\n        if (name === \"payable\") {\n            return true;\n        }\n    }\n    else if (type.indexOf(\"[\") >= 0 || type === \"tuple\") {\n        if (ModifiersNest[name]) {\n            return true;\n        }\n    }\n    if (ModifiersBytes[name] || name === \"payable\") {\n        logger.throwArgumentError(\"invalid modifier\", \"name\", name);\n    }\n    return false;\n}\n// @TODO: Make sure that children of an indexed tuple are marked with a null indexed\nfunction parseParamType(param, allowIndexed) {\n    let originalParam = param;\n    function throwError(i) {\n        logger.throwArgumentError(`unexpected character at position ${i}`, \"param\", param);\n    }\n    param = param.replace(/\\s/g, \" \");\n    function newNode(parent) {\n        let node = { type: \"\", name: \"\", parent: parent, state: { allowType: true } };\n        if (allowIndexed) {\n            node.indexed = false;\n        }\n        return node;\n    }\n    let parent = { type: \"\", name: \"\", state: { allowType: true } };\n    let node = parent;\n    for (let i = 0; i < param.length; i++) {\n        let c = param[i];\n        switch (c) {\n            case \"(\":\n                if (node.state.allowType && node.type === \"\") {\n                    node.type = \"tuple\";\n                }\n                else if (!node.state.allowParams) {\n                    throwError(i);\n                }\n                node.state.allowType = false;\n                node.type = verifyType(node.type);\n                node.components = [newNode(node)];\n                node = node.components[0];\n                break;\n            case \")\":\n                delete node.state;\n                if (node.name === \"indexed\") {\n                    if (!allowIndexed) {\n                        throwError(i);\n                    }\n                    node.indexed = true;\n                    node.name = \"\";\n                }\n                if (checkModifier(node.type, node.name)) {\n                    node.name = \"\";\n                }\n                node.type = verifyType(node.type);\n                let child = node;\n                node = node.parent;\n                if (!node) {\n                    throwError(i);\n                }\n                delete child.parent;\n                node.state.allowParams = false;\n                node.state.allowName = true;\n                node.state.allowArray = true;\n                break;\n            case \",\":\n                delete node.state;\n                if (node.name === \"indexed\") {\n                    if (!allowIndexed) {\n                        throwError(i);\n                    }\n                    node.indexed = true;\n                    node.name = \"\";\n                }\n                if (checkModifier(node.type, node.name)) {\n                    node.name = \"\";\n                }\n                node.type = verifyType(node.type);\n                let sibling = newNode(node.parent);\n                //{ type: \"\", name: \"\", parent: node.parent, state: { allowType: true } };\n                node.parent.components.push(sibling);\n                delete node.parent;\n                node = sibling;\n                break;\n            // Hit a space...\n            case \" \":\n                // If reading type, the type is done and may read a param or name\n                if (node.state.allowType) {\n                    if (node.type !== \"\") {\n                        node.type = verifyType(node.type);\n                        delete node.state.allowType;\n                        node.state.allowName = true;\n                        node.state.allowParams = true;\n                    }\n                }\n                // If reading name, the name is done\n                if (node.state.allowName) {\n                    if (node.name !== \"\") {\n                        if (node.name === \"indexed\") {\n                            if (!allowIndexed) {\n                                throwError(i);\n                            }\n                            if (node.indexed) {\n                                throwError(i);\n                            }\n                            node.indexed = true;\n                            node.name = \"\";\n                        }\n                        else if (checkModifier(node.type, node.name)) {\n                            node.name = \"\";\n                        }\n                        else {\n                            node.state.allowName = false;\n                        }\n                    }\n                }\n                break;\n            case \"[\":\n                if (!node.state.allowArray) {\n                    throwError(i);\n                }\n                node.type += c;\n                node.state.allowArray = false;\n                node.state.allowName = false;\n                node.state.readArray = true;\n                break;\n            case \"]\":\n                if (!node.state.readArray) {\n                    throwError(i);\n                }\n                node.type += c;\n                node.state.readArray = false;\n                node.state.allowArray = true;\n                node.state.allowName = true;\n                break;\n            default:\n                if (node.state.allowType) {\n                    node.type += c;\n                    node.state.allowParams = true;\n                    node.state.allowArray = true;\n                }\n                else if (node.state.allowName) {\n                    node.name += c;\n                    delete node.state.allowArray;\n                }\n                else if (node.state.readArray) {\n                    node.type += c;\n                }\n                else {\n                    throwError(i);\n                }\n        }\n    }\n    if (node.parent) {\n        logger.throwArgumentError(\"unexpected eof\", \"param\", param);\n    }\n    delete parent.state;\n    if (node.name === \"indexed\") {\n        if (!allowIndexed) {\n            throwError(originalParam.length - 7);\n        }\n        if (node.indexed) {\n            throwError(originalParam.length - 7);\n        }\n        node.indexed = true;\n        node.name = \"\";\n    }\n    else if (checkModifier(node.type, node.name)) {\n        node.name = \"\";\n    }\n    parent.type = verifyType(parent.type);\n    return parent;\n}\nfunction populate(object, params) {\n    for (let key in params) {\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.defineReadOnly)(object, key, params[key]);\n    }\n}\nconst FormatTypes = Object.freeze({\n    // Bare formatting, as is needed for computing a sighash of an event or function\n    sighash: \"sighash\",\n    // Human-Readable with Minimal spacing and without names (compact human-readable)\n    minimal: \"minimal\",\n    // Human-Readable with nice spacing, including all names\n    full: \"full\",\n    // JSON-format a la Solidity\n    json: \"json\"\n});\nconst paramTypeArray = new RegExp(/^(.*)\\[([0-9]*)\\]$/);\nclass ParamType {\n    constructor(constructorGuard, params) {\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"use fromString\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new ParamType()\"\n            });\n        }\n        populate(this, params);\n        let match = this.type.match(paramTypeArray);\n        if (match) {\n            populate(this, {\n                arrayLength: parseInt(match[2] || \"-1\"),\n                arrayChildren: ParamType.fromObject({\n                    type: match[1],\n                    components: this.components\n                }),\n                baseType: \"array\"\n            });\n        }\n        else {\n            populate(this, {\n                arrayLength: null,\n                arrayChildren: null,\n                baseType: ((this.components != null) ? \"tuple\" : this.type)\n            });\n        }\n        this._isParamType = true;\n        Object.freeze(this);\n    }\n    // Format the parameter fragment\n    //   - sighash: \"(uint256,address)\"\n    //   - minimal: \"tuple(uint256,address) indexed\"\n    //   - full:    \"tuple(uint256 foo, address bar) indexed baz\"\n    format(format) {\n        if (!format) {\n            format = FormatTypes.sighash;\n        }\n        if (!FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n        if (format === FormatTypes.json) {\n            let result = {\n                type: ((this.baseType === \"tuple\") ? \"tuple\" : this.type),\n                name: (this.name || undefined)\n            };\n            if (typeof (this.indexed) === \"boolean\") {\n                result.indexed = this.indexed;\n            }\n            if (this.components) {\n                result.components = this.components.map((comp) => JSON.parse(comp.format(format)));\n            }\n            return JSON.stringify(result);\n        }\n        let result = \"\";\n        // Array\n        if (this.baseType === \"array\") {\n            result += this.arrayChildren.format(format);\n            result += \"[\" + (this.arrayLength < 0 ? \"\" : String(this.arrayLength)) + \"]\";\n        }\n        else {\n            if (this.baseType === \"tuple\") {\n                if (format !== FormatTypes.sighash) {\n                    result += this.type;\n                }\n                result += \"(\" + this.components.map((comp) => comp.format(format)).join((format === FormatTypes.full) ? \", \" : \",\") + \")\";\n            }\n            else {\n                result += this.type;\n            }\n        }\n        if (format !== FormatTypes.sighash) {\n            if (this.indexed === true) {\n                result += \" indexed\";\n            }\n            if (format === FormatTypes.full && this.name) {\n                result += \" \" + this.name;\n            }\n        }\n        return result;\n    }\n    static from(value, allowIndexed) {\n        if (typeof (value) === \"string\") {\n            return ParamType.fromString(value, allowIndexed);\n        }\n        return ParamType.fromObject(value);\n    }\n    static fromObject(value) {\n        if (ParamType.isParamType(value)) {\n            return value;\n        }\n        return new ParamType(_constructorGuard, {\n            name: (value.name || null),\n            type: verifyType(value.type),\n            indexed: ((value.indexed == null) ? null : !!value.indexed),\n            components: (value.components ? value.components.map(ParamType.fromObject) : null)\n        });\n    }\n    static fromString(value, allowIndexed) {\n        function ParamTypify(node) {\n            return ParamType.fromObject({\n                name: node.name,\n                type: node.type,\n                indexed: node.indexed,\n                components: node.components\n            });\n        }\n        return ParamTypify(parseParamType(value, !!allowIndexed));\n    }\n    static isParamType(value) {\n        return !!(value != null && value._isParamType);\n    }\n}\n;\nfunction parseParams(value, allowIndex) {\n    return splitNesting(value).map((param) => ParamType.fromString(param, allowIndex));\n}\nclass Fragment {\n    constructor(constructorGuard, params) {\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"use a static from method\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new Fragment()\"\n            });\n        }\n        populate(this, params);\n        this._isFragment = true;\n        Object.freeze(this);\n    }\n    static from(value) {\n        if (Fragment.isFragment(value)) {\n            return value;\n        }\n        if (typeof (value) === \"string\") {\n            return Fragment.fromString(value);\n        }\n        return Fragment.fromObject(value);\n    }\n    static fromObject(value) {\n        if (Fragment.isFragment(value)) {\n            return value;\n        }\n        switch (value.type) {\n            case \"function\":\n                return FunctionFragment.fromObject(value);\n            case \"event\":\n                return EventFragment.fromObject(value);\n            case \"constructor\":\n                return ConstructorFragment.fromObject(value);\n            case \"error\":\n                return ErrorFragment.fromObject(value);\n            case \"fallback\":\n            case \"receive\":\n                // @TODO: Something? Maybe return a FunctionFragment? A custom DefaultFunctionFragment?\n                return null;\n        }\n        return logger.throwArgumentError(\"invalid fragment object\", \"value\", value);\n    }\n    static fromString(value) {\n        // Make sure the \"returns\" is surrounded by a space and all whitespace is exactly one space\n        value = value.replace(/\\s/g, \" \");\n        value = value.replace(/\\(/g, \" (\").replace(/\\)/g, \") \").replace(/\\s+/g, \" \");\n        value = value.trim();\n        if (value.split(\" \")[0] === \"event\") {\n            return EventFragment.fromString(value.substring(5).trim());\n        }\n        else if (value.split(\" \")[0] === \"function\") {\n            return FunctionFragment.fromString(value.substring(8).trim());\n        }\n        else if (value.split(\"(\")[0].trim() === \"constructor\") {\n            return ConstructorFragment.fromString(value.trim());\n        }\n        else if (value.split(\" \")[0] === \"error\") {\n            return ErrorFragment.fromString(value.substring(5).trim());\n        }\n        return logger.throwArgumentError(\"unsupported fragment\", \"value\", value);\n    }\n    static isFragment(value) {\n        return !!(value && value._isFragment);\n    }\n}\nclass EventFragment extends Fragment {\n    format(format) {\n        if (!format) {\n            format = FormatTypes.sighash;\n        }\n        if (!FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n        if (format === FormatTypes.json) {\n            return JSON.stringify({\n                type: \"event\",\n                anonymous: this.anonymous,\n                name: this.name,\n                inputs: this.inputs.map((input) => JSON.parse(input.format(format)))\n            });\n        }\n        let result = \"\";\n        if (format !== FormatTypes.sighash) {\n            result += \"event \";\n        }\n        result += this.name + \"(\" + this.inputs.map((input) => input.format(format)).join((format === FormatTypes.full) ? \", \" : \",\") + \") \";\n        if (format !== FormatTypes.sighash) {\n            if (this.anonymous) {\n                result += \"anonymous \";\n            }\n        }\n        return result.trim();\n    }\n    static from(value) {\n        if (typeof (value) === \"string\") {\n            return EventFragment.fromString(value);\n        }\n        return EventFragment.fromObject(value);\n    }\n    static fromObject(value) {\n        if (EventFragment.isEventFragment(value)) {\n            return value;\n        }\n        if (value.type !== \"event\") {\n            logger.throwArgumentError(\"invalid event object\", \"value\", value);\n        }\n        const params = {\n            name: verifyIdentifier(value.name),\n            anonymous: value.anonymous,\n            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : []),\n            type: \"event\"\n        };\n        return new EventFragment(_constructorGuard, params);\n    }\n    static fromString(value) {\n        let match = value.match(regexParen);\n        if (!match) {\n            logger.throwArgumentError(\"invalid event string\", \"value\", value);\n        }\n        let anonymous = false;\n        match[3].split(\" \").forEach((modifier) => {\n            switch (modifier.trim()) {\n                case \"anonymous\":\n                    anonymous = true;\n                    break;\n                case \"\":\n                    break;\n                default:\n                    logger.warn(\"unknown modifier: \" + modifier);\n            }\n        });\n        return EventFragment.fromObject({\n            name: match[1].trim(),\n            anonymous: anonymous,\n            inputs: parseParams(match[2], true),\n            type: \"event\"\n        });\n    }\n    static isEventFragment(value) {\n        return (value && value._isFragment && value.type === \"event\");\n    }\n}\nfunction parseGas(value, params) {\n    params.gas = null;\n    let comps = value.split(\"@\");\n    if (comps.length !== 1) {\n        if (comps.length > 2) {\n            logger.throwArgumentError(\"invalid human-readable ABI signature\", \"value\", value);\n        }\n        if (!comps[1].match(/^[0-9]+$/)) {\n            logger.throwArgumentError(\"invalid human-readable ABI signature gas\", \"value\", value);\n        }\n        params.gas = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_3__.BigNumber.from(comps[1]);\n        return comps[0];\n    }\n    return value;\n}\nfunction parseModifiers(value, params) {\n    params.constant = false;\n    params.payable = false;\n    params.stateMutability = \"nonpayable\";\n    value.split(\" \").forEach((modifier) => {\n        switch (modifier.trim()) {\n            case \"constant\":\n                params.constant = true;\n                break;\n            case \"payable\":\n                params.payable = true;\n                params.stateMutability = \"payable\";\n                break;\n            case \"nonpayable\":\n                params.payable = false;\n                params.stateMutability = \"nonpayable\";\n                break;\n            case \"pure\":\n                params.constant = true;\n                params.stateMutability = \"pure\";\n                break;\n            case \"view\":\n                params.constant = true;\n                params.stateMutability = \"view\";\n                break;\n            case \"external\":\n            case \"public\":\n            case \"\":\n                break;\n            default:\n                console.log(\"unknown modifier: \" + modifier);\n        }\n    });\n}\nfunction verifyState(value) {\n    let result = {\n        constant: false,\n        payable: true,\n        stateMutability: \"payable\"\n    };\n    if (value.stateMutability != null) {\n        result.stateMutability = value.stateMutability;\n        // Set (and check things are consistent) the constant property\n        result.constant = (result.stateMutability === \"view\" || result.stateMutability === \"pure\");\n        if (value.constant != null) {\n            if ((!!value.constant) !== result.constant) {\n                logger.throwArgumentError(\"cannot have constant function with mutability \" + result.stateMutability, \"value\", value);\n            }\n        }\n        // Set (and check things are consistent) the payable property\n        result.payable = (result.stateMutability === \"payable\");\n        if (value.payable != null) {\n            if ((!!value.payable) !== result.payable) {\n                logger.throwArgumentError(\"cannot have payable function with mutability \" + result.stateMutability, \"value\", value);\n            }\n        }\n    }\n    else if (value.payable != null) {\n        result.payable = !!value.payable;\n        // If payable we can assume non-constant; otherwise we can't assume\n        if (value.constant == null && !result.payable && value.type !== \"constructor\") {\n            logger.throwArgumentError(\"unable to determine stateMutability\", \"value\", value);\n        }\n        result.constant = !!value.constant;\n        if (result.constant) {\n            result.stateMutability = \"view\";\n        }\n        else {\n            result.stateMutability = (result.payable ? \"payable\" : \"nonpayable\");\n        }\n        if (result.payable && result.constant) {\n            logger.throwArgumentError(\"cannot have constant payable function\", \"value\", value);\n        }\n    }\n    else if (value.constant != null) {\n        result.constant = !!value.constant;\n        result.payable = !result.constant;\n        result.stateMutability = (result.constant ? \"view\" : \"payable\");\n    }\n    else if (value.type !== \"constructor\") {\n        logger.throwArgumentError(\"unable to determine stateMutability\", \"value\", value);\n    }\n    return result;\n}\nclass ConstructorFragment extends Fragment {\n    format(format) {\n        if (!format) {\n            format = FormatTypes.sighash;\n        }\n        if (!FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n        if (format === FormatTypes.json) {\n            return JSON.stringify({\n                type: \"constructor\",\n                stateMutability: ((this.stateMutability !== \"nonpayable\") ? this.stateMutability : undefined),\n                payable: this.payable,\n                gas: (this.gas ? this.gas.toNumber() : undefined),\n                inputs: this.inputs.map((input) => JSON.parse(input.format(format)))\n            });\n        }\n        if (format === FormatTypes.sighash) {\n            logger.throwError(\"cannot format a constructor for sighash\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"format(sighash)\"\n            });\n        }\n        let result = \"constructor(\" + this.inputs.map((input) => input.format(format)).join((format === FormatTypes.full) ? \", \" : \",\") + \") \";\n        if (this.stateMutability && this.stateMutability !== \"nonpayable\") {\n            result += this.stateMutability + \" \";\n        }\n        return result.trim();\n    }\n    static from(value) {\n        if (typeof (value) === \"string\") {\n            return ConstructorFragment.fromString(value);\n        }\n        return ConstructorFragment.fromObject(value);\n    }\n    static fromObject(value) {\n        if (ConstructorFragment.isConstructorFragment(value)) {\n            return value;\n        }\n        if (value.type !== \"constructor\") {\n            logger.throwArgumentError(\"invalid constructor object\", \"value\", value);\n        }\n        let state = verifyState(value);\n        if (state.constant) {\n            logger.throwArgumentError(\"constructor cannot be constant\", \"value\", value);\n        }\n        const params = {\n            name: null,\n            type: value.type,\n            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : []),\n            payable: state.payable,\n            stateMutability: state.stateMutability,\n            gas: (value.gas ? _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_3__.BigNumber.from(value.gas) : null)\n        };\n        return new ConstructorFragment(_constructorGuard, params);\n    }\n    static fromString(value) {\n        let params = { type: \"constructor\" };\n        value = parseGas(value, params);\n        let parens = value.match(regexParen);\n        if (!parens || parens[1].trim() !== \"constructor\") {\n            logger.throwArgumentError(\"invalid constructor string\", \"value\", value);\n        }\n        params.inputs = parseParams(parens[2].trim(), false);\n        parseModifiers(parens[3].trim(), params);\n        return ConstructorFragment.fromObject(params);\n    }\n    static isConstructorFragment(value) {\n        return (value && value._isFragment && value.type === \"constructor\");\n    }\n}\nclass FunctionFragment extends ConstructorFragment {\n    format(format) {\n        if (!format) {\n            format = FormatTypes.sighash;\n        }\n        if (!FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n        if (format === FormatTypes.json) {\n            return JSON.stringify({\n                type: \"function\",\n                name: this.name,\n                constant: this.constant,\n                stateMutability: ((this.stateMutability !== \"nonpayable\") ? this.stateMutability : undefined),\n                payable: this.payable,\n                gas: (this.gas ? this.gas.toNumber() : undefined),\n                inputs: this.inputs.map((input) => JSON.parse(input.format(format))),\n                outputs: this.outputs.map((output) => JSON.parse(output.format(format))),\n            });\n        }\n        let result = \"\";\n        if (format !== FormatTypes.sighash) {\n            result += \"function \";\n        }\n        result += this.name + \"(\" + this.inputs.map((input) => input.format(format)).join((format === FormatTypes.full) ? \", \" : \",\") + \") \";\n        if (format !== FormatTypes.sighash) {\n            if (this.stateMutability) {\n                if (this.stateMutability !== \"nonpayable\") {\n                    result += (this.stateMutability + \" \");\n                }\n            }\n            else if (this.constant) {\n                result += \"view \";\n            }\n            if (this.outputs && this.outputs.length) {\n                result += \"returns (\" + this.outputs.map((output) => output.format(format)).join(\", \") + \") \";\n            }\n            if (this.gas != null) {\n                result += \"@\" + this.gas.toString() + \" \";\n            }\n        }\n        return result.trim();\n    }\n    static from(value) {\n        if (typeof (value) === \"string\") {\n            return FunctionFragment.fromString(value);\n        }\n        return FunctionFragment.fromObject(value);\n    }\n    static fromObject(value) {\n        if (FunctionFragment.isFunctionFragment(value)) {\n            return value;\n        }\n        if (value.type !== \"function\") {\n            logger.throwArgumentError(\"invalid function object\", \"value\", value);\n        }\n        let state = verifyState(value);\n        const params = {\n            type: value.type,\n            name: verifyIdentifier(value.name),\n            constant: state.constant,\n            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : []),\n            outputs: (value.outputs ? value.outputs.map(ParamType.fromObject) : []),\n            payable: state.payable,\n            stateMutability: state.stateMutability,\n            gas: (value.gas ? _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_3__.BigNumber.from(value.gas) : null)\n        };\n        return new FunctionFragment(_constructorGuard, params);\n    }\n    static fromString(value) {\n        let params = { type: \"function\" };\n        value = parseGas(value, params);\n        let comps = value.split(\" returns \");\n        if (comps.length > 2) {\n            logger.throwArgumentError(\"invalid function string\", \"value\", value);\n        }\n        let parens = comps[0].match(regexParen);\n        if (!parens) {\n            logger.throwArgumentError(\"invalid function signature\", \"value\", value);\n        }\n        params.name = parens[1].trim();\n        if (params.name) {\n            verifyIdentifier(params.name);\n        }\n        params.inputs = parseParams(parens[2], false);\n        parseModifiers(parens[3].trim(), params);\n        // We have outputs\n        if (comps.length > 1) {\n            let returns = comps[1].match(regexParen);\n            if (returns[1].trim() != \"\" || returns[3].trim() != \"\") {\n                logger.throwArgumentError(\"unexpected tokens\", \"value\", value);\n            }\n            params.outputs = parseParams(returns[2], false);\n        }\n        else {\n            params.outputs = [];\n        }\n        return FunctionFragment.fromObject(params);\n    }\n    static isFunctionFragment(value) {\n        return (value && value._isFragment && value.type === \"function\");\n    }\n}\n//export class StructFragment extends Fragment {\n//}\nfunction checkForbidden(fragment) {\n    const sig = fragment.format();\n    if (sig === \"Error(string)\" || sig === \"Panic(uint256)\") {\n        logger.throwArgumentError(`cannot specify user defined ${sig} error`, \"fragment\", fragment);\n    }\n    return fragment;\n}\nclass ErrorFragment extends Fragment {\n    format(format) {\n        if (!format) {\n            format = FormatTypes.sighash;\n        }\n        if (!FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n        if (format === FormatTypes.json) {\n            return JSON.stringify({\n                type: \"error\",\n                name: this.name,\n                inputs: this.inputs.map((input) => JSON.parse(input.format(format))),\n            });\n        }\n        let result = \"\";\n        if (format !== FormatTypes.sighash) {\n            result += \"error \";\n        }\n        result += this.name + \"(\" + this.inputs.map((input) => input.format(format)).join((format === FormatTypes.full) ? \", \" : \",\") + \") \";\n        return result.trim();\n    }\n    static from(value) {\n        if (typeof (value) === \"string\") {\n            return ErrorFragment.fromString(value);\n        }\n        return ErrorFragment.fromObject(value);\n    }\n    static fromObject(value) {\n        if (ErrorFragment.isErrorFragment(value)) {\n            return value;\n        }\n        if (value.type !== \"error\") {\n            logger.throwArgumentError(\"invalid error object\", \"value\", value);\n        }\n        const params = {\n            type: value.type,\n            name: verifyIdentifier(value.name),\n            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : [])\n        };\n        return checkForbidden(new ErrorFragment(_constructorGuard, params));\n    }\n    static fromString(value) {\n        let params = { type: \"error\" };\n        let parens = value.match(regexParen);\n        if (!parens) {\n            logger.throwArgumentError(\"invalid error signature\", \"value\", value);\n        }\n        params.name = parens[1].trim();\n        if (params.name) {\n            verifyIdentifier(params.name);\n        }\n        params.inputs = parseParams(parens[2], false);\n        return checkForbidden(ErrorFragment.fromObject(params));\n    }\n    static isErrorFragment(value) {\n        return (value && value._isFragment && value.type === \"error\");\n    }\n}\nfunction verifyType(type) {\n    // These need to be transformed to their full description\n    if (type.match(/^uint($|[^1-9])/)) {\n        type = \"uint256\" + type.substring(4);\n    }\n    else if (type.match(/^int($|[^1-9])/)) {\n        type = \"int256\" + type.substring(3);\n    }\n    // @TODO: more verification\n    return type;\n}\n// See: https://github.com/ethereum/solidity/blob/1f8f1a3db93a548d0555e3e14cfc55a10e25b60e/docs/grammar/SolidityLexer.g4#L234\nconst regexIdentifier = new RegExp(\"^[a-zA-Z$_][a-zA-Z0-9$_]*$\");\nfunction verifyIdentifier(value) {\n    if (!value || !value.match(regexIdentifier)) {\n        logger.throwArgumentError(`invalid identifier \"${value}\"`, \"value\", value);\n    }\n    return value;\n}\nconst regexParen = new RegExp(\"^([^)(]*)\\\\((.*)\\\\)([^)(]*)$\");\nfunction splitNesting(value) {\n    value = value.trim();\n    let result = [];\n    let accum = \"\";\n    let depth = 0;\n    for (let offset = 0; offset < value.length; offset++) {\n        let c = value[offset];\n        if (c === \",\" && depth === 0) {\n            result.push(accum);\n            accum = \"\";\n        }\n        else {\n            accum += c;\n            if (c === \"(\") {\n                depth++;\n            }\n            else if (c === \")\") {\n                depth--;\n                if (depth === -1) {\n                    logger.throwArgumentError(\"unbalanced parenthesis\", \"value\", value);\n                }\n            }\n        }\n    }\n    if (accum) {\n        result.push(accum);\n    }\n    return result;\n}\n//# sourceMappingURL=fragments.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2FiaS9saWIuZXNtL2ZyYWdtZW50cy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFhO0FBQ3dDO0FBQ007QUFDWjtBQUNWO0FBQ3JDLG1CQUFtQix5REFBTSxDQUFDLDZDQUFPO0FBQ2pDO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLEVBQUU7QUFDeEU7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDZDQUE2QztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDZCQUE2QjtBQUNoRDtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtEQUFrRDtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx5RUFBYztBQUN0QjtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ087QUFDUDtBQUNBO0FBQ0EsZ0RBQWdELHlEQUFNO0FBQ3REO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsMERBQTBELHlEQUFNO0FBQ2hFO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxNQUFNO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix1QkFBdUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGVkZ2l0eS15aWVsZC1mcm9udGVuZC8uLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvYWJpL2xpYi5lc20vZnJhZ21lbnRzLmpzP2IzOWIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgeyBCaWdOdW1iZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYmlnbnVtYmVyXCI7XG5pbXBvcnQgeyBkZWZpbmVSZWFkT25seSB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9wcm9wZXJ0aWVzXCI7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvbG9nZ2VyXCI7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4vX3ZlcnNpb25cIjtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIodmVyc2lvbik7XG47XG5jb25zdCBfY29uc3RydWN0b3JHdWFyZCA9IHt9O1xubGV0IE1vZGlmaWVyc0J5dGVzID0geyBjYWxsZGF0YTogdHJ1ZSwgbWVtb3J5OiB0cnVlLCBzdG9yYWdlOiB0cnVlIH07XG5sZXQgTW9kaWZpZXJzTmVzdCA9IHsgY2FsbGRhdGE6IHRydWUsIG1lbW9yeTogdHJ1ZSB9O1xuZnVuY3Rpb24gY2hlY2tNb2RpZmllcih0eXBlLCBuYW1lKSB7XG4gICAgaWYgKHR5cGUgPT09IFwiYnl0ZXNcIiB8fCB0eXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmIChNb2RpZmllcnNCeXRlc1tuYW1lXSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSA9PT0gXCJhZGRyZXNzXCIpIHtcbiAgICAgICAgaWYgKG5hbWUgPT09IFwicGF5YWJsZVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlLmluZGV4T2YoXCJbXCIpID49IDAgfHwgdHlwZSA9PT0gXCJ0dXBsZVwiKSB7XG4gICAgICAgIGlmIChNb2RpZmllcnNOZXN0W25hbWVdKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoTW9kaWZpZXJzQnl0ZXNbbmFtZV0gfHwgbmFtZSA9PT0gXCJwYXlhYmxlXCIpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgbW9kaWZpZXJcIiwgXCJuYW1lXCIsIG5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG4vLyBAVE9ETzogTWFrZSBzdXJlIHRoYXQgY2hpbGRyZW4gb2YgYW4gaW5kZXhlZCB0dXBsZSBhcmUgbWFya2VkIHdpdGggYSBudWxsIGluZGV4ZWRcbmZ1bmN0aW9uIHBhcnNlUGFyYW1UeXBlKHBhcmFtLCBhbGxvd0luZGV4ZWQpIHtcbiAgICBsZXQgb3JpZ2luYWxQYXJhbSA9IHBhcmFtO1xuICAgIGZ1bmN0aW9uIHRocm93RXJyb3IoaSkge1xuICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKGB1bmV4cGVjdGVkIGNoYXJhY3RlciBhdCBwb3NpdGlvbiAke2l9YCwgXCJwYXJhbVwiLCBwYXJhbSk7XG4gICAgfVxuICAgIHBhcmFtID0gcGFyYW0ucmVwbGFjZSgvXFxzL2csIFwiIFwiKTtcbiAgICBmdW5jdGlvbiBuZXdOb2RlKHBhcmVudCkge1xuICAgICAgICBsZXQgbm9kZSA9IHsgdHlwZTogXCJcIiwgbmFtZTogXCJcIiwgcGFyZW50OiBwYXJlbnQsIHN0YXRlOiB7IGFsbG93VHlwZTogdHJ1ZSB9IH07XG4gICAgICAgIGlmIChhbGxvd0luZGV4ZWQpIHtcbiAgICAgICAgICAgIG5vZGUuaW5kZXhlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICBsZXQgcGFyZW50ID0geyB0eXBlOiBcIlwiLCBuYW1lOiBcIlwiLCBzdGF0ZTogeyBhbGxvd1R5cGU6IHRydWUgfSB9O1xuICAgIGxldCBub2RlID0gcGFyZW50O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyYW0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGMgPSBwYXJhbVtpXTtcbiAgICAgICAgc3dpdGNoIChjKSB7XG4gICAgICAgICAgICBjYXNlIFwiKFwiOlxuICAgICAgICAgICAgICAgIGlmIChub2RlLnN0YXRlLmFsbG93VHlwZSAmJiBub2RlLnR5cGUgPT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS50eXBlID0gXCJ0dXBsZVwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghbm9kZS5zdGF0ZS5hbGxvd1BhcmFtcykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBub2RlLnN0YXRlLmFsbG93VHlwZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIG5vZGUudHlwZSA9IHZlcmlmeVR5cGUobm9kZS50eXBlKTtcbiAgICAgICAgICAgICAgICBub2RlLmNvbXBvbmVudHMgPSBbbmV3Tm9kZShub2RlKV07XG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUuY29tcG9uZW50c1swXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCIpXCI6XG4gICAgICAgICAgICAgICAgZGVsZXRlIG5vZGUuc3RhdGU7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUubmFtZSA9PT0gXCJpbmRleGVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhbGxvd0luZGV4ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3IoaSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbm9kZS5pbmRleGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5uYW1lID0gXCJcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNoZWNrTW9kaWZpZXIobm9kZS50eXBlLCBub2RlLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUubmFtZSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5vZGUudHlwZSA9IHZlcmlmeVR5cGUobm9kZS50eXBlKTtcbiAgICAgICAgICAgICAgICBsZXQgY2hpbGQgPSBub2RlO1xuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudDtcbiAgICAgICAgICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVsZXRlIGNoaWxkLnBhcmVudDtcbiAgICAgICAgICAgICAgICBub2RlLnN0YXRlLmFsbG93UGFyYW1zID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgbm9kZS5zdGF0ZS5hbGxvd05hbWUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIG5vZGUuc3RhdGUuYWxsb3dBcnJheSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiLFwiOlxuICAgICAgICAgICAgICAgIGRlbGV0ZSBub2RlLnN0YXRlO1xuICAgICAgICAgICAgICAgIGlmIChub2RlLm5hbWUgPT09IFwiaW5kZXhlZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghYWxsb3dJbmRleGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuaW5kZXhlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUubmFtZSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjaGVja01vZGlmaWVyKG5vZGUudHlwZSwgbm9kZS5uYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBub2RlLm5hbWUgPSBcIlwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBub2RlLnR5cGUgPSB2ZXJpZnlUeXBlKG5vZGUudHlwZSk7XG4gICAgICAgICAgICAgICAgbGV0IHNpYmxpbmcgPSBuZXdOb2RlKG5vZGUucGFyZW50KTtcbiAgICAgICAgICAgICAgICAvL3sgdHlwZTogXCJcIiwgbmFtZTogXCJcIiwgcGFyZW50OiBub2RlLnBhcmVudCwgc3RhdGU6IHsgYWxsb3dUeXBlOiB0cnVlIH0gfTtcbiAgICAgICAgICAgICAgICBub2RlLnBhcmVudC5jb21wb25lbnRzLnB1c2goc2libGluZyk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIG5vZGUucGFyZW50O1xuICAgICAgICAgICAgICAgIG5vZGUgPSBzaWJsaW5nO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLy8gSGl0IGEgc3BhY2UuLi5cbiAgICAgICAgICAgIGNhc2UgXCIgXCI6XG4gICAgICAgICAgICAgICAgLy8gSWYgcmVhZGluZyB0eXBlLCB0aGUgdHlwZSBpcyBkb25lIGFuZCBtYXkgcmVhZCBhIHBhcmFtIG9yIG5hbWVcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5zdGF0ZS5hbGxvd1R5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUudHlwZSAhPT0gXCJcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS50eXBlID0gdmVyaWZ5VHlwZShub2RlLnR5cGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG5vZGUuc3RhdGUuYWxsb3dUeXBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5zdGF0ZS5hbGxvd05hbWUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5zdGF0ZS5hbGxvd1BhcmFtcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSWYgcmVhZGluZyBuYW1lLCB0aGUgbmFtZSBpcyBkb25lXG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuc3RhdGUuYWxsb3dOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLm5hbWUgIT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlLm5hbWUgPT09IFwiaW5kZXhlZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhbGxvd0luZGV4ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuaW5kZXhlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLmluZGV4ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUubmFtZSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjaGVja01vZGlmaWVyKG5vZGUudHlwZSwgbm9kZS5uYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUubmFtZSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLnN0YXRlLmFsbG93TmFtZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIltcIjpcbiAgICAgICAgICAgICAgICBpZiAoIW5vZGUuc3RhdGUuYWxsb3dBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBub2RlLnR5cGUgKz0gYztcbiAgICAgICAgICAgICAgICBub2RlLnN0YXRlLmFsbG93QXJyYXkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBub2RlLnN0YXRlLmFsbG93TmFtZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIG5vZGUuc3RhdGUucmVhZEFycmF5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJdXCI6XG4gICAgICAgICAgICAgICAgaWYgKCFub2RlLnN0YXRlLnJlYWRBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBub2RlLnR5cGUgKz0gYztcbiAgICAgICAgICAgICAgICBub2RlLnN0YXRlLnJlYWRBcnJheSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIG5vZGUuc3RhdGUuYWxsb3dBcnJheSA9IHRydWU7XG4gICAgICAgICAgICAgICAgbm9kZS5zdGF0ZS5hbGxvd05hbWUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5zdGF0ZS5hbGxvd1R5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS50eXBlICs9IGM7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuc3RhdGUuYWxsb3dQYXJhbXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBub2RlLnN0YXRlLmFsbG93QXJyYXkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChub2RlLnN0YXRlLmFsbG93TmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBub2RlLm5hbWUgKz0gYztcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG5vZGUuc3RhdGUuYWxsb3dBcnJheTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobm9kZS5zdGF0ZS5yZWFkQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS50eXBlICs9IGM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAobm9kZS5wYXJlbnQpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInVuZXhwZWN0ZWQgZW9mXCIsIFwicGFyYW1cIiwgcGFyYW0pO1xuICAgIH1cbiAgICBkZWxldGUgcGFyZW50LnN0YXRlO1xuICAgIGlmIChub2RlLm5hbWUgPT09IFwiaW5kZXhlZFwiKSB7XG4gICAgICAgIGlmICghYWxsb3dJbmRleGVkKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKG9yaWdpbmFsUGFyYW0ubGVuZ3RoIC0gNyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUuaW5kZXhlZCkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihvcmlnaW5hbFBhcmFtLmxlbmd0aCAtIDcpO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUuaW5kZXhlZCA9IHRydWU7XG4gICAgICAgIG5vZGUubmFtZSA9IFwiXCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNoZWNrTW9kaWZpZXIobm9kZS50eXBlLCBub2RlLm5hbWUpKSB7XG4gICAgICAgIG5vZGUubmFtZSA9IFwiXCI7XG4gICAgfVxuICAgIHBhcmVudC50eXBlID0gdmVyaWZ5VHlwZShwYXJlbnQudHlwZSk7XG4gICAgcmV0dXJuIHBhcmVudDtcbn1cbmZ1bmN0aW9uIHBvcHVsYXRlKG9iamVjdCwgcGFyYW1zKSB7XG4gICAgZm9yIChsZXQga2V5IGluIHBhcmFtcykge1xuICAgICAgICBkZWZpbmVSZWFkT25seShvYmplY3QsIGtleSwgcGFyYW1zW2tleV0pO1xuICAgIH1cbn1cbmV4cG9ydCBjb25zdCBGb3JtYXRUeXBlcyA9IE9iamVjdC5mcmVlemUoe1xuICAgIC8vIEJhcmUgZm9ybWF0dGluZywgYXMgaXMgbmVlZGVkIGZvciBjb21wdXRpbmcgYSBzaWdoYXNoIG9mIGFuIGV2ZW50IG9yIGZ1bmN0aW9uXG4gICAgc2lnaGFzaDogXCJzaWdoYXNoXCIsXG4gICAgLy8gSHVtYW4tUmVhZGFibGUgd2l0aCBNaW5pbWFsIHNwYWNpbmcgYW5kIHdpdGhvdXQgbmFtZXMgKGNvbXBhY3QgaHVtYW4tcmVhZGFibGUpXG4gICAgbWluaW1hbDogXCJtaW5pbWFsXCIsXG4gICAgLy8gSHVtYW4tUmVhZGFibGUgd2l0aCBuaWNlIHNwYWNpbmcsIGluY2x1ZGluZyBhbGwgbmFtZXNcbiAgICBmdWxsOiBcImZ1bGxcIixcbiAgICAvLyBKU09OLWZvcm1hdCBhIGxhIFNvbGlkaXR5XG4gICAganNvbjogXCJqc29uXCJcbn0pO1xuY29uc3QgcGFyYW1UeXBlQXJyYXkgPSBuZXcgUmVnRXhwKC9eKC4qKVxcWyhbMC05XSopXFxdJC8pO1xuZXhwb3J0IGNsYXNzIFBhcmFtVHlwZSB7XG4gICAgY29uc3RydWN0b3IoY29uc3RydWN0b3JHdWFyZCwgcGFyYW1zKSB7XG4gICAgICAgIGlmIChjb25zdHJ1Y3Rvckd1YXJkICE9PSBfY29uc3RydWN0b3JHdWFyZCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJ1c2UgZnJvbVN0cmluZ1wiLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJuZXcgUGFyYW1UeXBlKClcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcG9wdWxhdGUodGhpcywgcGFyYW1zKTtcbiAgICAgICAgbGV0IG1hdGNoID0gdGhpcy50eXBlLm1hdGNoKHBhcmFtVHlwZUFycmF5KTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBwb3B1bGF0ZSh0aGlzLCB7XG4gICAgICAgICAgICAgICAgYXJyYXlMZW5ndGg6IHBhcnNlSW50KG1hdGNoWzJdIHx8IFwiLTFcIiksXG4gICAgICAgICAgICAgICAgYXJyYXlDaGlsZHJlbjogUGFyYW1UeXBlLmZyb21PYmplY3Qoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBtYXRjaFsxXSxcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50czogdGhpcy5jb21wb25lbnRzXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgYmFzZVR5cGU6IFwiYXJyYXlcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwb3B1bGF0ZSh0aGlzLCB7XG4gICAgICAgICAgICAgICAgYXJyYXlMZW5ndGg6IG51bGwsXG4gICAgICAgICAgICAgICAgYXJyYXlDaGlsZHJlbjogbnVsbCxcbiAgICAgICAgICAgICAgICBiYXNlVHlwZTogKCh0aGlzLmNvbXBvbmVudHMgIT0gbnVsbCkgPyBcInR1cGxlXCIgOiB0aGlzLnR5cGUpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pc1BhcmFtVHlwZSA9IHRydWU7XG4gICAgICAgIE9iamVjdC5mcmVlemUodGhpcyk7XG4gICAgfVxuICAgIC8vIEZvcm1hdCB0aGUgcGFyYW1ldGVyIGZyYWdtZW50XG4gICAgLy8gICAtIHNpZ2hhc2g6IFwiKHVpbnQyNTYsYWRkcmVzcylcIlxuICAgIC8vICAgLSBtaW5pbWFsOiBcInR1cGxlKHVpbnQyNTYsYWRkcmVzcykgaW5kZXhlZFwiXG4gICAgLy8gICAtIGZ1bGw6ICAgIFwidHVwbGUodWludDI1NiBmb28sIGFkZHJlc3MgYmFyKSBpbmRleGVkIGJhelwiXG4gICAgZm9ybWF0KGZvcm1hdCkge1xuICAgICAgICBpZiAoIWZvcm1hdCkge1xuICAgICAgICAgICAgZm9ybWF0ID0gRm9ybWF0VHlwZXMuc2lnaGFzaDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIUZvcm1hdFR5cGVzW2Zvcm1hdF0pIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGZvcm1hdCB0eXBlXCIsIFwiZm9ybWF0XCIsIGZvcm1hdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gRm9ybWF0VHlwZXMuanNvbikge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAoKHRoaXMuYmFzZVR5cGUgPT09IFwidHVwbGVcIikgPyBcInR1cGxlXCIgOiB0aGlzLnR5cGUpLFxuICAgICAgICAgICAgICAgIG5hbWU6ICh0aGlzLm5hbWUgfHwgdW5kZWZpbmVkKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgKHRoaXMuaW5kZXhlZCkgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmluZGV4ZWQgPSB0aGlzLmluZGV4ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb21wb25lbnRzKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmNvbXBvbmVudHMgPSB0aGlzLmNvbXBvbmVudHMubWFwKChjb21wKSA9PiBKU09OLnBhcnNlKGNvbXAuZm9ybWF0KGZvcm1hdCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXN1bHQgPSBcIlwiO1xuICAgICAgICAvLyBBcnJheVxuICAgICAgICBpZiAodGhpcy5iYXNlVHlwZSA9PT0gXCJhcnJheVwiKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gdGhpcy5hcnJheUNoaWxkcmVuLmZvcm1hdChmb3JtYXQpO1xuICAgICAgICAgICAgcmVzdWx0ICs9IFwiW1wiICsgKHRoaXMuYXJyYXlMZW5ndGggPCAwID8gXCJcIiA6IFN0cmluZyh0aGlzLmFycmF5TGVuZ3RoKSkgKyBcIl1cIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmJhc2VUeXBlID09PSBcInR1cGxlXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZm9ybWF0ICE9PSBGb3JtYXRUeXBlcy5zaWdoYXNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSB0aGlzLnR5cGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcIihcIiArIHRoaXMuY29tcG9uZW50cy5tYXAoKGNvbXApID0+IGNvbXAuZm9ybWF0KGZvcm1hdCkpLmpvaW4oKGZvcm1hdCA9PT0gRm9ybWF0VHlwZXMuZnVsbCkgPyBcIiwgXCIgOiBcIixcIikgKyBcIilcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSB0aGlzLnR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvcm1hdCAhPT0gRm9ybWF0VHlwZXMuc2lnaGFzaCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaW5kZXhlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcIiBpbmRleGVkXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZm9ybWF0ID09PSBGb3JtYXRUeXBlcy5mdWxsICYmIHRoaXMubmFtZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcIiBcIiArIHRoaXMubmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbSh2YWx1ZSwgYWxsb3dJbmRleGVkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIFBhcmFtVHlwZS5mcm9tU3RyaW5nKHZhbHVlLCBhbGxvd0luZGV4ZWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQYXJhbVR5cGUuZnJvbU9iamVjdCh2YWx1ZSk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tT2JqZWN0KHZhbHVlKSB7XG4gICAgICAgIGlmIChQYXJhbVR5cGUuaXNQYXJhbVR5cGUodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQYXJhbVR5cGUoX2NvbnN0cnVjdG9yR3VhcmQsIHtcbiAgICAgICAgICAgIG5hbWU6ICh2YWx1ZS5uYW1lIHx8IG51bGwpLFxuICAgICAgICAgICAgdHlwZTogdmVyaWZ5VHlwZSh2YWx1ZS50eXBlKSxcbiAgICAgICAgICAgIGluZGV4ZWQ6ICgodmFsdWUuaW5kZXhlZCA9PSBudWxsKSA/IG51bGwgOiAhIXZhbHVlLmluZGV4ZWQpLFxuICAgICAgICAgICAgY29tcG9uZW50czogKHZhbHVlLmNvbXBvbmVudHMgPyB2YWx1ZS5jb21wb25lbnRzLm1hcChQYXJhbVR5cGUuZnJvbU9iamVjdCkgOiBudWxsKVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21TdHJpbmcodmFsdWUsIGFsbG93SW5kZXhlZCkge1xuICAgICAgICBmdW5jdGlvbiBQYXJhbVR5cGlmeShub2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gUGFyYW1UeXBlLmZyb21PYmplY3Qoe1xuICAgICAgICAgICAgICAgIG5hbWU6IG5vZGUubmFtZSxcbiAgICAgICAgICAgICAgICB0eXBlOiBub2RlLnR5cGUsXG4gICAgICAgICAgICAgICAgaW5kZXhlZDogbm9kZS5pbmRleGVkLFxuICAgICAgICAgICAgICAgIGNvbXBvbmVudHM6IG5vZGUuY29tcG9uZW50c1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFBhcmFtVHlwaWZ5KHBhcnNlUGFyYW1UeXBlKHZhbHVlLCAhIWFsbG93SW5kZXhlZCkpO1xuICAgIH1cbiAgICBzdGF0aWMgaXNQYXJhbVR5cGUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICEhKHZhbHVlICE9IG51bGwgJiYgdmFsdWUuX2lzUGFyYW1UeXBlKTtcbiAgICB9XG59XG47XG5mdW5jdGlvbiBwYXJzZVBhcmFtcyh2YWx1ZSwgYWxsb3dJbmRleCkge1xuICAgIHJldHVybiBzcGxpdE5lc3RpbmcodmFsdWUpLm1hcCgocGFyYW0pID0+IFBhcmFtVHlwZS5mcm9tU3RyaW5nKHBhcmFtLCBhbGxvd0luZGV4KSk7XG59XG5leHBvcnQgY2xhc3MgRnJhZ21lbnQge1xuICAgIGNvbnN0cnVjdG9yKGNvbnN0cnVjdG9yR3VhcmQsIHBhcmFtcykge1xuICAgICAgICBpZiAoY29uc3RydWN0b3JHdWFyZCAhPT0gX2NvbnN0cnVjdG9yR3VhcmQpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwidXNlIGEgc3RhdGljIGZyb20gbWV0aG9kXCIsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcIm5ldyBGcmFnbWVudCgpXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHBvcHVsYXRlKHRoaXMsIHBhcmFtcyk7XG4gICAgICAgIHRoaXMuX2lzRnJhZ21lbnQgPSB0cnVlO1xuICAgICAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbSh2YWx1ZSkge1xuICAgICAgICBpZiAoRnJhZ21lbnQuaXNGcmFnbWVudCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBGcmFnbWVudC5mcm9tU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRnJhZ21lbnQuZnJvbU9iamVjdCh2YWx1ZSk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tT2JqZWN0KHZhbHVlKSB7XG4gICAgICAgIGlmIChGcmFnbWVudC5pc0ZyYWdtZW50KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAodmFsdWUudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIEZ1bmN0aW9uRnJhZ21lbnQuZnJvbU9iamVjdCh2YWx1ZSk7XG4gICAgICAgICAgICBjYXNlIFwiZXZlbnRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gRXZlbnRGcmFnbWVudC5mcm9tT2JqZWN0KHZhbHVlKTtcbiAgICAgICAgICAgIGNhc2UgXCJjb25zdHJ1Y3RvclwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBDb25zdHJ1Y3RvckZyYWdtZW50LmZyb21PYmplY3QodmFsdWUpO1xuICAgICAgICAgICAgY2FzZSBcImVycm9yXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIEVycm9yRnJhZ21lbnQuZnJvbU9iamVjdCh2YWx1ZSk7XG4gICAgICAgICAgICBjYXNlIFwiZmFsbGJhY2tcIjpcbiAgICAgICAgICAgIGNhc2UgXCJyZWNlaXZlXCI6XG4gICAgICAgICAgICAgICAgLy8gQFRPRE86IFNvbWV0aGluZz8gTWF5YmUgcmV0dXJuIGEgRnVuY3Rpb25GcmFnbWVudD8gQSBjdXN0b20gRGVmYXVsdEZ1bmN0aW9uRnJhZ21lbnQ/XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGZyYWdtZW50IG9iamVjdFwiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21TdHJpbmcodmFsdWUpIHtcbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBcInJldHVybnNcIiBpcyBzdXJyb3VuZGVkIGJ5IGEgc3BhY2UgYW5kIGFsbCB3aGl0ZXNwYWNlIGlzIGV4YWN0bHkgb25lIHNwYWNlXG4gICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFxzL2csIFwiIFwiKTtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXCgvZywgXCIgKFwiKS5yZXBsYWNlKC9cXCkvZywgXCIpIFwiKS5yZXBsYWNlKC9cXHMrL2csIFwiIFwiKTtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS50cmltKCk7XG4gICAgICAgIGlmICh2YWx1ZS5zcGxpdChcIiBcIilbMF0gPT09IFwiZXZlbnRcIikge1xuICAgICAgICAgICAgcmV0dXJuIEV2ZW50RnJhZ21lbnQuZnJvbVN0cmluZyh2YWx1ZS5zdWJzdHJpbmcoNSkudHJpbSgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWx1ZS5zcGxpdChcIiBcIilbMF0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIEZ1bmN0aW9uRnJhZ21lbnQuZnJvbVN0cmluZyh2YWx1ZS5zdWJzdHJpbmcoOCkudHJpbSgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWx1ZS5zcGxpdChcIihcIilbMF0udHJpbSgpID09PSBcImNvbnN0cnVjdG9yXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBDb25zdHJ1Y3RvckZyYWdtZW50LmZyb21TdHJpbmcodmFsdWUudHJpbSgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWx1ZS5zcGxpdChcIiBcIilbMF0gPT09IFwiZXJyb3JcIikge1xuICAgICAgICAgICAgcmV0dXJuIEVycm9yRnJhZ21lbnQuZnJvbVN0cmluZyh2YWx1ZS5zdWJzdHJpbmcoNSkudHJpbSgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInVuc3VwcG9ydGVkIGZyYWdtZW50XCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgIH1cbiAgICBzdGF0aWMgaXNGcmFnbWVudCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUuX2lzRnJhZ21lbnQpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBFdmVudEZyYWdtZW50IGV4dGVuZHMgRnJhZ21lbnQge1xuICAgIGZvcm1hdChmb3JtYXQpIHtcbiAgICAgICAgaWYgKCFmb3JtYXQpIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IEZvcm1hdFR5cGVzLnNpZ2hhc2g7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFGb3JtYXRUeXBlc1tmb3JtYXRdKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBmb3JtYXQgdHlwZVwiLCBcImZvcm1hdFwiLCBmb3JtYXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb3JtYXQgPT09IEZvcm1hdFR5cGVzLmpzb24pIHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJldmVudFwiLFxuICAgICAgICAgICAgICAgIGFub255bW91czogdGhpcy5hbm9ueW1vdXMsXG4gICAgICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgICAgIGlucHV0czogdGhpcy5pbnB1dHMubWFwKChpbnB1dCkgPT4gSlNPTi5wYXJzZShpbnB1dC5mb3JtYXQoZm9ybWF0KSkpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgICAgICAgaWYgKGZvcm1hdCAhPT0gRm9ybWF0VHlwZXMuc2lnaGFzaCkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IFwiZXZlbnQgXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ICs9IHRoaXMubmFtZSArIFwiKFwiICsgdGhpcy5pbnB1dHMubWFwKChpbnB1dCkgPT4gaW5wdXQuZm9ybWF0KGZvcm1hdCkpLmpvaW4oKGZvcm1hdCA9PT0gRm9ybWF0VHlwZXMuZnVsbCkgPyBcIiwgXCIgOiBcIixcIikgKyBcIikgXCI7XG4gICAgICAgIGlmIChmb3JtYXQgIT09IEZvcm1hdFR5cGVzLnNpZ2hhc2gpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmFub255bW91cykge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcImFub255bW91cyBcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0LnRyaW0oKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb20odmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gRXZlbnRGcmFnbWVudC5mcm9tU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRXZlbnRGcmFnbWVudC5mcm9tT2JqZWN0KHZhbHVlKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21PYmplY3QodmFsdWUpIHtcbiAgICAgICAgaWYgKEV2ZW50RnJhZ21lbnQuaXNFdmVudEZyYWdtZW50KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZS50eXBlICE9PSBcImV2ZW50XCIpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGV2ZW50IG9iamVjdFwiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICAgICAgICBuYW1lOiB2ZXJpZnlJZGVudGlmaWVyKHZhbHVlLm5hbWUpLFxuICAgICAgICAgICAgYW5vbnltb3VzOiB2YWx1ZS5hbm9ueW1vdXMsXG4gICAgICAgICAgICBpbnB1dHM6ICh2YWx1ZS5pbnB1dHMgPyB2YWx1ZS5pbnB1dHMubWFwKFBhcmFtVHlwZS5mcm9tT2JqZWN0KSA6IFtdKSxcbiAgICAgICAgICAgIHR5cGU6IFwiZXZlbnRcIlxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbmV3IEV2ZW50RnJhZ21lbnQoX2NvbnN0cnVjdG9yR3VhcmQsIHBhcmFtcyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tU3RyaW5nKHZhbHVlKSB7XG4gICAgICAgIGxldCBtYXRjaCA9IHZhbHVlLm1hdGNoKHJlZ2V4UGFyZW4pO1xuICAgICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBldmVudCBzdHJpbmdcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGFub255bW91cyA9IGZhbHNlO1xuICAgICAgICBtYXRjaFszXS5zcGxpdChcIiBcIikuZm9yRWFjaCgobW9kaWZpZXIpID0+IHtcbiAgICAgICAgICAgIHN3aXRjaCAobW9kaWZpZXIudHJpbSgpKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcImFub255bW91c1wiOlxuICAgICAgICAgICAgICAgICAgICBhbm9ueW1vdXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiXCI6XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKFwidW5rbm93biBtb2RpZmllcjogXCIgKyBtb2RpZmllcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gRXZlbnRGcmFnbWVudC5mcm9tT2JqZWN0KHtcbiAgICAgICAgICAgIG5hbWU6IG1hdGNoWzFdLnRyaW0oKSxcbiAgICAgICAgICAgIGFub255bW91czogYW5vbnltb3VzLFxuICAgICAgICAgICAgaW5wdXRzOiBwYXJzZVBhcmFtcyhtYXRjaFsyXSwgdHJ1ZSksXG4gICAgICAgICAgICB0eXBlOiBcImV2ZW50XCJcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXRpYyBpc0V2ZW50RnJhZ21lbnQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICh2YWx1ZSAmJiB2YWx1ZS5faXNGcmFnbWVudCAmJiB2YWx1ZS50eXBlID09PSBcImV2ZW50XCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHBhcnNlR2FzKHZhbHVlLCBwYXJhbXMpIHtcbiAgICBwYXJhbXMuZ2FzID0gbnVsbDtcbiAgICBsZXQgY29tcHMgPSB2YWx1ZS5zcGxpdChcIkBcIik7XG4gICAgaWYgKGNvbXBzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICBpZiAoY29tcHMubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgaHVtYW4tcmVhZGFibGUgQUJJIHNpZ25hdHVyZVwiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNvbXBzWzFdLm1hdGNoKC9eWzAtOV0rJC8pKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBodW1hbi1yZWFkYWJsZSBBQkkgc2lnbmF0dXJlIGdhc1wiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJhbXMuZ2FzID0gQmlnTnVtYmVyLmZyb20oY29tcHNbMV0pO1xuICAgICAgICByZXR1cm4gY29tcHNbMF07XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIHBhcnNlTW9kaWZpZXJzKHZhbHVlLCBwYXJhbXMpIHtcbiAgICBwYXJhbXMuY29uc3RhbnQgPSBmYWxzZTtcbiAgICBwYXJhbXMucGF5YWJsZSA9IGZhbHNlO1xuICAgIHBhcmFtcy5zdGF0ZU11dGFiaWxpdHkgPSBcIm5vbnBheWFibGVcIjtcbiAgICB2YWx1ZS5zcGxpdChcIiBcIikuZm9yRWFjaCgobW9kaWZpZXIpID0+IHtcbiAgICAgICAgc3dpdGNoIChtb2RpZmllci50cmltKCkpIHtcbiAgICAgICAgICAgIGNhc2UgXCJjb25zdGFudFwiOlxuICAgICAgICAgICAgICAgIHBhcmFtcy5jb25zdGFudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwicGF5YWJsZVwiOlxuICAgICAgICAgICAgICAgIHBhcmFtcy5wYXlhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBwYXJhbXMuc3RhdGVNdXRhYmlsaXR5ID0gXCJwYXlhYmxlXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwibm9ucGF5YWJsZVwiOlxuICAgICAgICAgICAgICAgIHBhcmFtcy5wYXlhYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcGFyYW1zLnN0YXRlTXV0YWJpbGl0eSA9IFwibm9ucGF5YWJsZVwiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInB1cmVcIjpcbiAgICAgICAgICAgICAgICBwYXJhbXMuY29uc3RhbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHBhcmFtcy5zdGF0ZU11dGFiaWxpdHkgPSBcInB1cmVcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJ2aWV3XCI6XG4gICAgICAgICAgICAgICAgcGFyYW1zLmNvbnN0YW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBwYXJhbXMuc3RhdGVNdXRhYmlsaXR5ID0gXCJ2aWV3XCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZXh0ZXJuYWxcIjpcbiAgICAgICAgICAgIGNhc2UgXCJwdWJsaWNcIjpcbiAgICAgICAgICAgIGNhc2UgXCJcIjpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJ1bmtub3duIG1vZGlmaWVyOiBcIiArIG1vZGlmaWVyKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gdmVyaWZ5U3RhdGUodmFsdWUpIHtcbiAgICBsZXQgcmVzdWx0ID0ge1xuICAgICAgICBjb25zdGFudDogZmFsc2UsXG4gICAgICAgIHBheWFibGU6IHRydWUsXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogXCJwYXlhYmxlXCJcbiAgICB9O1xuICAgIGlmICh2YWx1ZS5zdGF0ZU11dGFiaWxpdHkgIT0gbnVsbCkge1xuICAgICAgICByZXN1bHQuc3RhdGVNdXRhYmlsaXR5ID0gdmFsdWUuc3RhdGVNdXRhYmlsaXR5O1xuICAgICAgICAvLyBTZXQgKGFuZCBjaGVjayB0aGluZ3MgYXJlIGNvbnNpc3RlbnQpIHRoZSBjb25zdGFudCBwcm9wZXJ0eVxuICAgICAgICByZXN1bHQuY29uc3RhbnQgPSAocmVzdWx0LnN0YXRlTXV0YWJpbGl0eSA9PT0gXCJ2aWV3XCIgfHwgcmVzdWx0LnN0YXRlTXV0YWJpbGl0eSA9PT0gXCJwdXJlXCIpO1xuICAgICAgICBpZiAodmFsdWUuY29uc3RhbnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKCghIXZhbHVlLmNvbnN0YW50KSAhPT0gcmVzdWx0LmNvbnN0YW50KSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImNhbm5vdCBoYXZlIGNvbnN0YW50IGZ1bmN0aW9uIHdpdGggbXV0YWJpbGl0eSBcIiArIHJlc3VsdC5zdGF0ZU11dGFiaWxpdHksIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFNldCAoYW5kIGNoZWNrIHRoaW5ncyBhcmUgY29uc2lzdGVudCkgdGhlIHBheWFibGUgcHJvcGVydHlcbiAgICAgICAgcmVzdWx0LnBheWFibGUgPSAocmVzdWx0LnN0YXRlTXV0YWJpbGl0eSA9PT0gXCJwYXlhYmxlXCIpO1xuICAgICAgICBpZiAodmFsdWUucGF5YWJsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoKCEhdmFsdWUucGF5YWJsZSkgIT09IHJlc3VsdC5wYXlhYmxlKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImNhbm5vdCBoYXZlIHBheWFibGUgZnVuY3Rpb24gd2l0aCBtdXRhYmlsaXR5IFwiICsgcmVzdWx0LnN0YXRlTXV0YWJpbGl0eSwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAodmFsdWUucGF5YWJsZSAhPSBudWxsKSB7XG4gICAgICAgIHJlc3VsdC5wYXlhYmxlID0gISF2YWx1ZS5wYXlhYmxlO1xuICAgICAgICAvLyBJZiBwYXlhYmxlIHdlIGNhbiBhc3N1bWUgbm9uLWNvbnN0YW50OyBvdGhlcndpc2Ugd2UgY2FuJ3QgYXNzdW1lXG4gICAgICAgIGlmICh2YWx1ZS5jb25zdGFudCA9PSBudWxsICYmICFyZXN1bHQucGF5YWJsZSAmJiB2YWx1ZS50eXBlICE9PSBcImNvbnN0cnVjdG9yXCIpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ1bmFibGUgdG8gZGV0ZXJtaW5lIHN0YXRlTXV0YWJpbGl0eVwiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQuY29uc3RhbnQgPSAhIXZhbHVlLmNvbnN0YW50O1xuICAgICAgICBpZiAocmVzdWx0LmNvbnN0YW50KSB7XG4gICAgICAgICAgICByZXN1bHQuc3RhdGVNdXRhYmlsaXR5ID0gXCJ2aWV3XCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQuc3RhdGVNdXRhYmlsaXR5ID0gKHJlc3VsdC5wYXlhYmxlID8gXCJwYXlhYmxlXCIgOiBcIm5vbnBheWFibGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdC5wYXlhYmxlICYmIHJlc3VsdC5jb25zdGFudCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImNhbm5vdCBoYXZlIGNvbnN0YW50IHBheWFibGUgZnVuY3Rpb25cIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAodmFsdWUuY29uc3RhbnQgIT0gbnVsbCkge1xuICAgICAgICByZXN1bHQuY29uc3RhbnQgPSAhIXZhbHVlLmNvbnN0YW50O1xuICAgICAgICByZXN1bHQucGF5YWJsZSA9ICFyZXN1bHQuY29uc3RhbnQ7XG4gICAgICAgIHJlc3VsdC5zdGF0ZU11dGFiaWxpdHkgPSAocmVzdWx0LmNvbnN0YW50ID8gXCJ2aWV3XCIgOiBcInBheWFibGVcIik7XG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbHVlLnR5cGUgIT09IFwiY29uc3RydWN0b3JcIikge1xuICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwidW5hYmxlIHRvIGRldGVybWluZSBzdGF0ZU11dGFiaWxpdHlcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnQgY2xhc3MgQ29uc3RydWN0b3JGcmFnbWVudCBleHRlbmRzIEZyYWdtZW50IHtcbiAgICBmb3JtYXQoZm9ybWF0KSB7XG4gICAgICAgIGlmICghZm9ybWF0KSB7XG4gICAgICAgICAgICBmb3JtYXQgPSBGb3JtYXRUeXBlcy5zaWdoYXNoO1xuICAgICAgICB9XG4gICAgICAgIGlmICghRm9ybWF0VHlwZXNbZm9ybWF0XSkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgZm9ybWF0IHR5cGVcIiwgXCJmb3JtYXRcIiwgZm9ybWF0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9ybWF0ID09PSBGb3JtYXRUeXBlcy5qc29uKSB7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiY29uc3RydWN0b3JcIixcbiAgICAgICAgICAgICAgICBzdGF0ZU11dGFiaWxpdHk6ICgodGhpcy5zdGF0ZU11dGFiaWxpdHkgIT09IFwibm9ucGF5YWJsZVwiKSA/IHRoaXMuc3RhdGVNdXRhYmlsaXR5IDogdW5kZWZpbmVkKSxcbiAgICAgICAgICAgICAgICBwYXlhYmxlOiB0aGlzLnBheWFibGUsXG4gICAgICAgICAgICAgICAgZ2FzOiAodGhpcy5nYXMgPyB0aGlzLmdhcy50b051bWJlcigpIDogdW5kZWZpbmVkKSxcbiAgICAgICAgICAgICAgICBpbnB1dHM6IHRoaXMuaW5wdXRzLm1hcCgoaW5wdXQpID0+IEpTT04ucGFyc2UoaW5wdXQuZm9ybWF0KGZvcm1hdCkpKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gRm9ybWF0VHlwZXMuc2lnaGFzaCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJjYW5ub3QgZm9ybWF0IGEgY29uc3RydWN0b3IgZm9yIHNpZ2hhc2hcIiwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwiZm9ybWF0KHNpZ2hhc2gpXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXN1bHQgPSBcImNvbnN0cnVjdG9yKFwiICsgdGhpcy5pbnB1dHMubWFwKChpbnB1dCkgPT4gaW5wdXQuZm9ybWF0KGZvcm1hdCkpLmpvaW4oKGZvcm1hdCA9PT0gRm9ybWF0VHlwZXMuZnVsbCkgPyBcIiwgXCIgOiBcIixcIikgKyBcIikgXCI7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlTXV0YWJpbGl0eSAmJiB0aGlzLnN0YXRlTXV0YWJpbGl0eSAhPT0gXCJub25wYXlhYmxlXCIpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSB0aGlzLnN0YXRlTXV0YWJpbGl0eSArIFwiIFwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQudHJpbSgpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbSh2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBDb25zdHJ1Y3RvckZyYWdtZW50LmZyb21TdHJpbmcodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBDb25zdHJ1Y3RvckZyYWdtZW50LmZyb21PYmplY3QodmFsdWUpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbU9iamVjdCh2YWx1ZSkge1xuICAgICAgICBpZiAoQ29uc3RydWN0b3JGcmFnbWVudC5pc0NvbnN0cnVjdG9yRnJhZ21lbnQodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlLnR5cGUgIT09IFwiY29uc3RydWN0b3JcIikge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgY29uc3RydWN0b3Igb2JqZWN0XCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzdGF0ZSA9IHZlcmlmeVN0YXRlKHZhbHVlKTtcbiAgICAgICAgaWYgKHN0YXRlLmNvbnN0YW50KSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiY29uc3RydWN0b3IgY2Fubm90IGJlIGNvbnN0YW50XCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgICAgICAgIG5hbWU6IG51bGwsXG4gICAgICAgICAgICB0eXBlOiB2YWx1ZS50eXBlLFxuICAgICAgICAgICAgaW5wdXRzOiAodmFsdWUuaW5wdXRzID8gdmFsdWUuaW5wdXRzLm1hcChQYXJhbVR5cGUuZnJvbU9iamVjdCkgOiBbXSksXG4gICAgICAgICAgICBwYXlhYmxlOiBzdGF0ZS5wYXlhYmxlLFxuICAgICAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiBzdGF0ZS5zdGF0ZU11dGFiaWxpdHksXG4gICAgICAgICAgICBnYXM6ICh2YWx1ZS5nYXMgPyBCaWdOdW1iZXIuZnJvbSh2YWx1ZS5nYXMpIDogbnVsbClcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG5ldyBDb25zdHJ1Y3RvckZyYWdtZW50KF9jb25zdHJ1Y3Rvckd1YXJkLCBwYXJhbXMpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbVN0cmluZyh2YWx1ZSkge1xuICAgICAgICBsZXQgcGFyYW1zID0geyB0eXBlOiBcImNvbnN0cnVjdG9yXCIgfTtcbiAgICAgICAgdmFsdWUgPSBwYXJzZUdhcyh2YWx1ZSwgcGFyYW1zKTtcbiAgICAgICAgbGV0IHBhcmVucyA9IHZhbHVlLm1hdGNoKHJlZ2V4UGFyZW4pO1xuICAgICAgICBpZiAoIXBhcmVucyB8fCBwYXJlbnNbMV0udHJpbSgpICE9PSBcImNvbnN0cnVjdG9yXCIpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGNvbnN0cnVjdG9yIHN0cmluZ1wiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJhbXMuaW5wdXRzID0gcGFyc2VQYXJhbXMocGFyZW5zWzJdLnRyaW0oKSwgZmFsc2UpO1xuICAgICAgICBwYXJzZU1vZGlmaWVycyhwYXJlbnNbM10udHJpbSgpLCBwYXJhbXMpO1xuICAgICAgICByZXR1cm4gQ29uc3RydWN0b3JGcmFnbWVudC5mcm9tT2JqZWN0KHBhcmFtcyk7XG4gICAgfVxuICAgIHN0YXRpYyBpc0NvbnN0cnVjdG9yRnJhZ21lbnQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICh2YWx1ZSAmJiB2YWx1ZS5faXNGcmFnbWVudCAmJiB2YWx1ZS50eXBlID09PSBcImNvbnN0cnVjdG9yXCIpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBGdW5jdGlvbkZyYWdtZW50IGV4dGVuZHMgQ29uc3RydWN0b3JGcmFnbWVudCB7XG4gICAgZm9ybWF0KGZvcm1hdCkge1xuICAgICAgICBpZiAoIWZvcm1hdCkge1xuICAgICAgICAgICAgZm9ybWF0ID0gRm9ybWF0VHlwZXMuc2lnaGFzaDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIUZvcm1hdFR5cGVzW2Zvcm1hdF0pIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGZvcm1hdCB0eXBlXCIsIFwiZm9ybWF0XCIsIGZvcm1hdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gRm9ybWF0VHlwZXMuanNvbikge1xuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgICAgIGNvbnN0YW50OiB0aGlzLmNvbnN0YW50LFxuICAgICAgICAgICAgICAgIHN0YXRlTXV0YWJpbGl0eTogKCh0aGlzLnN0YXRlTXV0YWJpbGl0eSAhPT0gXCJub25wYXlhYmxlXCIpID8gdGhpcy5zdGF0ZU11dGFiaWxpdHkgOiB1bmRlZmluZWQpLFxuICAgICAgICAgICAgICAgIHBheWFibGU6IHRoaXMucGF5YWJsZSxcbiAgICAgICAgICAgICAgICBnYXM6ICh0aGlzLmdhcyA/IHRoaXMuZ2FzLnRvTnVtYmVyKCkgOiB1bmRlZmluZWQpLFxuICAgICAgICAgICAgICAgIGlucHV0czogdGhpcy5pbnB1dHMubWFwKChpbnB1dCkgPT4gSlNPTi5wYXJzZShpbnB1dC5mb3JtYXQoZm9ybWF0KSkpLFxuICAgICAgICAgICAgICAgIG91dHB1dHM6IHRoaXMub3V0cHV0cy5tYXAoKG91dHB1dCkgPT4gSlNPTi5wYXJzZShvdXRwdXQuZm9ybWF0KGZvcm1hdCkpKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXN1bHQgPSBcIlwiO1xuICAgICAgICBpZiAoZm9ybWF0ICE9PSBGb3JtYXRUeXBlcy5zaWdoYXNoKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gXCJmdW5jdGlvbiBcIjtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgKz0gdGhpcy5uYW1lICsgXCIoXCIgKyB0aGlzLmlucHV0cy5tYXAoKGlucHV0KSA9PiBpbnB1dC5mb3JtYXQoZm9ybWF0KSkuam9pbigoZm9ybWF0ID09PSBGb3JtYXRUeXBlcy5mdWxsKSA/IFwiLCBcIiA6IFwiLFwiKSArIFwiKSBcIjtcbiAgICAgICAgaWYgKGZvcm1hdCAhPT0gRm9ybWF0VHlwZXMuc2lnaGFzaCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGVNdXRhYmlsaXR5KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGVNdXRhYmlsaXR5ICE9PSBcIm5vbnBheWFibGVcIikge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gKHRoaXMuc3RhdGVNdXRhYmlsaXR5ICsgXCIgXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuY29uc3RhbnQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCJ2aWV3IFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMub3V0cHV0cyAmJiB0aGlzLm91dHB1dHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IFwicmV0dXJucyAoXCIgKyB0aGlzLm91dHB1dHMubWFwKChvdXRwdXQpID0+IG91dHB1dC5mb3JtYXQoZm9ybWF0KSkuam9pbihcIiwgXCIpICsgXCIpIFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuZ2FzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCJAXCIgKyB0aGlzLmdhcy50b1N0cmluZygpICsgXCIgXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdC50cmltKCk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tKHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIEZ1bmN0aW9uRnJhZ21lbnQuZnJvbVN0cmluZyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEZ1bmN0aW9uRnJhZ21lbnQuZnJvbU9iamVjdCh2YWx1ZSk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tT2JqZWN0KHZhbHVlKSB7XG4gICAgICAgIGlmIChGdW5jdGlvbkZyYWdtZW50LmlzRnVuY3Rpb25GcmFnbWVudCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUudHlwZSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBmdW5jdGlvbiBvYmplY3RcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN0YXRlID0gdmVyaWZ5U3RhdGUodmFsdWUpO1xuICAgICAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICAgICAgICB0eXBlOiB2YWx1ZS50eXBlLFxuICAgICAgICAgICAgbmFtZTogdmVyaWZ5SWRlbnRpZmllcih2YWx1ZS5uYW1lKSxcbiAgICAgICAgICAgIGNvbnN0YW50OiBzdGF0ZS5jb25zdGFudCxcbiAgICAgICAgICAgIGlucHV0czogKHZhbHVlLmlucHV0cyA/IHZhbHVlLmlucHV0cy5tYXAoUGFyYW1UeXBlLmZyb21PYmplY3QpIDogW10pLFxuICAgICAgICAgICAgb3V0cHV0czogKHZhbHVlLm91dHB1dHMgPyB2YWx1ZS5vdXRwdXRzLm1hcChQYXJhbVR5cGUuZnJvbU9iamVjdCkgOiBbXSksXG4gICAgICAgICAgICBwYXlhYmxlOiBzdGF0ZS5wYXlhYmxlLFxuICAgICAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiBzdGF0ZS5zdGF0ZU11dGFiaWxpdHksXG4gICAgICAgICAgICBnYXM6ICh2YWx1ZS5nYXMgPyBCaWdOdW1iZXIuZnJvbSh2YWx1ZS5nYXMpIDogbnVsbClcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbkZyYWdtZW50KF9jb25zdHJ1Y3Rvckd1YXJkLCBwYXJhbXMpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbVN0cmluZyh2YWx1ZSkge1xuICAgICAgICBsZXQgcGFyYW1zID0geyB0eXBlOiBcImZ1bmN0aW9uXCIgfTtcbiAgICAgICAgdmFsdWUgPSBwYXJzZUdhcyh2YWx1ZSwgcGFyYW1zKTtcbiAgICAgICAgbGV0IGNvbXBzID0gdmFsdWUuc3BsaXQoXCIgcmV0dXJucyBcIik7XG4gICAgICAgIGlmIChjb21wcy5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBmdW5jdGlvbiBzdHJpbmdcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBhcmVucyA9IGNvbXBzWzBdLm1hdGNoKHJlZ2V4UGFyZW4pO1xuICAgICAgICBpZiAoIXBhcmVucykge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgZnVuY3Rpb24gc2lnbmF0dXJlXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHBhcmFtcy5uYW1lID0gcGFyZW5zWzFdLnRyaW0oKTtcbiAgICAgICAgaWYgKHBhcmFtcy5uYW1lKSB7XG4gICAgICAgICAgICB2ZXJpZnlJZGVudGlmaWVyKHBhcmFtcy5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJhbXMuaW5wdXRzID0gcGFyc2VQYXJhbXMocGFyZW5zWzJdLCBmYWxzZSk7XG4gICAgICAgIHBhcnNlTW9kaWZpZXJzKHBhcmVuc1szXS50cmltKCksIHBhcmFtcyk7XG4gICAgICAgIC8vIFdlIGhhdmUgb3V0cHV0c1xuICAgICAgICBpZiAoY29tcHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgbGV0IHJldHVybnMgPSBjb21wc1sxXS5tYXRjaChyZWdleFBhcmVuKTtcbiAgICAgICAgICAgIGlmIChyZXR1cm5zWzFdLnRyaW0oKSAhPSBcIlwiIHx8IHJldHVybnNbM10udHJpbSgpICE9IFwiXCIpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwidW5leHBlY3RlZCB0b2tlbnNcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJhbXMub3V0cHV0cyA9IHBhcnNlUGFyYW1zKHJldHVybnNbMl0sIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcy5vdXRwdXRzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEZ1bmN0aW9uRnJhZ21lbnQuZnJvbU9iamVjdChwYXJhbXMpO1xuICAgIH1cbiAgICBzdGF0aWMgaXNGdW5jdGlvbkZyYWdtZW50KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAodmFsdWUgJiYgdmFsdWUuX2lzRnJhZ21lbnQgJiYgdmFsdWUudHlwZSA9PT0gXCJmdW5jdGlvblwiKTtcbiAgICB9XG59XG4vL2V4cG9ydCBjbGFzcyBTdHJ1Y3RGcmFnbWVudCBleHRlbmRzIEZyYWdtZW50IHtcbi8vfVxuZnVuY3Rpb24gY2hlY2tGb3JiaWRkZW4oZnJhZ21lbnQpIHtcbiAgICBjb25zdCBzaWcgPSBmcmFnbWVudC5mb3JtYXQoKTtcbiAgICBpZiAoc2lnID09PSBcIkVycm9yKHN0cmluZylcIiB8fCBzaWcgPT09IFwiUGFuaWModWludDI1NilcIikge1xuICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKGBjYW5ub3Qgc3BlY2lmeSB1c2VyIGRlZmluZWQgJHtzaWd9IGVycm9yYCwgXCJmcmFnbWVudFwiLCBmcmFnbWVudCk7XG4gICAgfVxuICAgIHJldHVybiBmcmFnbWVudDtcbn1cbmV4cG9ydCBjbGFzcyBFcnJvckZyYWdtZW50IGV4dGVuZHMgRnJhZ21lbnQge1xuICAgIGZvcm1hdChmb3JtYXQpIHtcbiAgICAgICAgaWYgKCFmb3JtYXQpIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IEZvcm1hdFR5cGVzLnNpZ2hhc2g7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFGb3JtYXRUeXBlc1tmb3JtYXRdKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBmb3JtYXQgdHlwZVwiLCBcImZvcm1hdFwiLCBmb3JtYXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb3JtYXQgPT09IEZvcm1hdFR5cGVzLmpzb24pIHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgICAgICAgICBpbnB1dHM6IHRoaXMuaW5wdXRzLm1hcCgoaW5wdXQpID0+IEpTT04ucGFyc2UoaW5wdXQuZm9ybWF0KGZvcm1hdCkpKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXN1bHQgPSBcIlwiO1xuICAgICAgICBpZiAoZm9ybWF0ICE9PSBGb3JtYXRUeXBlcy5zaWdoYXNoKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gXCJlcnJvciBcIjtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgKz0gdGhpcy5uYW1lICsgXCIoXCIgKyB0aGlzLmlucHV0cy5tYXAoKGlucHV0KSA9PiBpbnB1dC5mb3JtYXQoZm9ybWF0KSkuam9pbigoZm9ybWF0ID09PSBGb3JtYXRUeXBlcy5mdWxsKSA/IFwiLCBcIiA6IFwiLFwiKSArIFwiKSBcIjtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC50cmltKCk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tKHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIEVycm9yRnJhZ21lbnQuZnJvbVN0cmluZyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEVycm9yRnJhZ21lbnQuZnJvbU9iamVjdCh2YWx1ZSk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tT2JqZWN0KHZhbHVlKSB7XG4gICAgICAgIGlmIChFcnJvckZyYWdtZW50LmlzRXJyb3JGcmFnbWVudCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUudHlwZSAhPT0gXCJlcnJvclwiKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBlcnJvciBvYmplY3RcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgICAgICAgdHlwZTogdmFsdWUudHlwZSxcbiAgICAgICAgICAgIG5hbWU6IHZlcmlmeUlkZW50aWZpZXIodmFsdWUubmFtZSksXG4gICAgICAgICAgICBpbnB1dHM6ICh2YWx1ZS5pbnB1dHMgPyB2YWx1ZS5pbnB1dHMubWFwKFBhcmFtVHlwZS5mcm9tT2JqZWN0KSA6IFtdKVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gY2hlY2tGb3JiaWRkZW4obmV3IEVycm9yRnJhZ21lbnQoX2NvbnN0cnVjdG9yR3VhcmQsIHBhcmFtcykpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbVN0cmluZyh2YWx1ZSkge1xuICAgICAgICBsZXQgcGFyYW1zID0geyB0eXBlOiBcImVycm9yXCIgfTtcbiAgICAgICAgbGV0IHBhcmVucyA9IHZhbHVlLm1hdGNoKHJlZ2V4UGFyZW4pO1xuICAgICAgICBpZiAoIXBhcmVucykge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgZXJyb3Igc2lnbmF0dXJlXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHBhcmFtcy5uYW1lID0gcGFyZW5zWzFdLnRyaW0oKTtcbiAgICAgICAgaWYgKHBhcmFtcy5uYW1lKSB7XG4gICAgICAgICAgICB2ZXJpZnlJZGVudGlmaWVyKHBhcmFtcy5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJhbXMuaW5wdXRzID0gcGFyc2VQYXJhbXMocGFyZW5zWzJdLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiBjaGVja0ZvcmJpZGRlbihFcnJvckZyYWdtZW50LmZyb21PYmplY3QocGFyYW1zKSk7XG4gICAgfVxuICAgIHN0YXRpYyBpc0Vycm9yRnJhZ21lbnQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICh2YWx1ZSAmJiB2YWx1ZS5faXNGcmFnbWVudCAmJiB2YWx1ZS50eXBlID09PSBcImVycm9yXCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHZlcmlmeVR5cGUodHlwZSkge1xuICAgIC8vIFRoZXNlIG5lZWQgdG8gYmUgdHJhbnNmb3JtZWQgdG8gdGhlaXIgZnVsbCBkZXNjcmlwdGlvblxuICAgIGlmICh0eXBlLm1hdGNoKC9edWludCgkfFteMS05XSkvKSkge1xuICAgICAgICB0eXBlID0gXCJ1aW50MjU2XCIgKyB0eXBlLnN1YnN0cmluZyg0KTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZS5tYXRjaCgvXmludCgkfFteMS05XSkvKSkge1xuICAgICAgICB0eXBlID0gXCJpbnQyNTZcIiArIHR5cGUuc3Vic3RyaW5nKDMpO1xuICAgIH1cbiAgICAvLyBAVE9ETzogbW9yZSB2ZXJpZmljYXRpb25cbiAgICByZXR1cm4gdHlwZTtcbn1cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL3NvbGlkaXR5L2Jsb2IvMWY4ZjFhM2RiOTNhNTQ4ZDA1NTVlM2UxNGNmYzU1YTEwZTI1YjYwZS9kb2NzL2dyYW1tYXIvU29saWRpdHlMZXhlci5nNCNMMjM0XG5jb25zdCByZWdleElkZW50aWZpZXIgPSBuZXcgUmVnRXhwKFwiXlthLXpBLVokX11bYS16QS1aMC05JF9dKiRcIik7XG5mdW5jdGlvbiB2ZXJpZnlJZGVudGlmaWVyKHZhbHVlKSB7XG4gICAgaWYgKCF2YWx1ZSB8fCAhdmFsdWUubWF0Y2gocmVnZXhJZGVudGlmaWVyKSkge1xuICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKGBpbnZhbGlkIGlkZW50aWZpZXIgXCIke3ZhbHVlfVwiYCwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbmNvbnN0IHJlZ2V4UGFyZW4gPSBuZXcgUmVnRXhwKFwiXihbXikoXSopXFxcXCgoLiopXFxcXCkoW14pKF0qKSRcIik7XG5mdW5jdGlvbiBzcGxpdE5lc3RpbmcodmFsdWUpIHtcbiAgICB2YWx1ZSA9IHZhbHVlLnRyaW0oKTtcbiAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgbGV0IGFjY3VtID0gXCJcIjtcbiAgICBsZXQgZGVwdGggPSAwO1xuICAgIGZvciAobGV0IG9mZnNldCA9IDA7IG9mZnNldCA8IHZhbHVlLmxlbmd0aDsgb2Zmc2V0KyspIHtcbiAgICAgICAgbGV0IGMgPSB2YWx1ZVtvZmZzZXRdO1xuICAgICAgICBpZiAoYyA9PT0gXCIsXCIgJiYgZGVwdGggPT09IDApIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGFjY3VtKTtcbiAgICAgICAgICAgIGFjY3VtID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFjY3VtICs9IGM7XG4gICAgICAgICAgICBpZiAoYyA9PT0gXCIoXCIpIHtcbiAgICAgICAgICAgICAgICBkZXB0aCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYyA9PT0gXCIpXCIpIHtcbiAgICAgICAgICAgICAgICBkZXB0aC0tO1xuICAgICAgICAgICAgICAgIGlmIChkZXB0aCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInVuYmFsYW5jZWQgcGFyZW50aGVzaXNcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChhY2N1bSkge1xuICAgICAgICByZXN1bHQucHVzaChhY2N1bSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mcmFnbWVudHMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ethersproject/abi/lib.esm/fragments.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@ethersproject/abi/lib.esm/interface.js":
/*!***************************************************************!*\
  !*** ../node_modules/@ethersproject/abi/lib.esm/interface.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ErrorDescription: () => (/* binding */ ErrorDescription),\n/* harmony export */   Indexed: () => (/* binding */ Indexed),\n/* harmony export */   Interface: () => (/* binding */ Interface),\n/* harmony export */   LogDescription: () => (/* binding */ LogDescription),\n/* harmony export */   TransactionDescription: () => (/* binding */ TransactionDescription),\n/* harmony export */   checkResultErrors: () => (/* reexport safe */ _coders_abstract_coder__WEBPACK_IMPORTED_MODULE_2__.checkResultErrors)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_address__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @ethersproject/address */ \"(ssr)/../node_modules/@ethersproject/address/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @ethersproject/bignumber */ \"(ssr)/../node_modules/@ethersproject/bignumber/lib.esm/bignumber.js\");\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/../node_modules/@ethersproject/bytes/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_hash__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @ethersproject/hash */ \"(ssr)/../node_modules/@ethersproject/hash/lib.esm/id.js\");\n/* harmony import */ var _ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @ethersproject/keccak256 */ \"(ssr)/../node_modules/@ethersproject/keccak256/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/../node_modules/@ethersproject/properties/lib.esm/index.js\");\n/* harmony import */ var _abi_coder__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./abi-coder */ \"(ssr)/../node_modules/@ethersproject/abi/lib.esm/abi-coder.js\");\n/* harmony import */ var _coders_abstract_coder__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./coders/abstract-coder */ \"(ssr)/../node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js\");\n/* harmony import */ var _fragments__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./fragments */ \"(ssr)/../node_modules/@ethersproject/abi/lib.esm/fragments.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/../node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(ssr)/../node_modules/@ethersproject/abi/lib.esm/_version.js\");\n\n\n\n\n\n\n\n\n\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\n\nclass LogDescription extends _ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.Description {\n}\nclass TransactionDescription extends _ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.Description {\n}\nclass ErrorDescription extends _ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.Description {\n}\nclass Indexed extends _ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.Description {\n    static isIndexed(value) {\n        return !!(value && value._isIndexed);\n    }\n}\nconst BuiltinErrors = {\n    \"0x08c379a0\": { signature: \"Error(string)\", name: \"Error\", inputs: [\"string\"], reason: true },\n    \"0x4e487b71\": { signature: \"Panic(uint256)\", name: \"Panic\", inputs: [\"uint256\"] }\n};\nfunction wrapAccessError(property, error) {\n    const wrap = new Error(`deferred error during ABI decoding triggered accessing ${property}`);\n    wrap.error = error;\n    return wrap;\n}\n/*\nfunction checkNames(fragment: Fragment, type: \"input\" | \"output\", params: Array<ParamType>): void {\n    params.reduce((accum, param) => {\n        if (param.name) {\n            if (accum[param.name]) {\n                logger.throwArgumentError(`duplicate ${ type } parameter ${ JSON.stringify(param.name) } in ${ fragment.format(\"full\") }`, \"fragment\", fragment);\n            }\n            accum[param.name] = true;\n        }\n        return accum;\n    }, <{ [ name: string ]: boolean }>{ });\n}\n*/\nclass Interface {\n    constructor(fragments) {\n        let abi = [];\n        if (typeof (fragments) === \"string\") {\n            abi = JSON.parse(fragments);\n        }\n        else {\n            abi = fragments;\n        }\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"fragments\", abi.map((fragment) => {\n            return _fragments__WEBPACK_IMPORTED_MODULE_4__.Fragment.from(fragment);\n        }).filter((fragment) => (fragment != null)));\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"_abiCoder\", (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.getStatic)(new.target, \"getAbiCoder\")());\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"functions\", {});\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"errors\", {});\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"events\", {});\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"structs\", {});\n        // Add all fragments by their signature\n        this.fragments.forEach((fragment) => {\n            let bucket = null;\n            switch (fragment.type) {\n                case \"constructor\":\n                    if (this.deploy) {\n                        logger.warn(\"duplicate definition - constructor\");\n                        return;\n                    }\n                    //checkNames(fragment, \"input\", fragment.inputs);\n                    (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"deploy\", fragment);\n                    return;\n                case \"function\":\n                    //checkNames(fragment, \"input\", fragment.inputs);\n                    //checkNames(fragment, \"output\", (<FunctionFragment>fragment).outputs);\n                    bucket = this.functions;\n                    break;\n                case \"event\":\n                    //checkNames(fragment, \"input\", fragment.inputs);\n                    bucket = this.events;\n                    break;\n                case \"error\":\n                    bucket = this.errors;\n                    break;\n                default:\n                    return;\n            }\n            let signature = fragment.format();\n            if (bucket[signature]) {\n                logger.warn(\"duplicate definition - \" + signature);\n                return;\n            }\n            bucket[signature] = fragment;\n        });\n        // If we do not have a constructor add a default\n        if (!this.deploy) {\n            (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"deploy\", _fragments__WEBPACK_IMPORTED_MODULE_4__.ConstructorFragment.from({\n                payable: false,\n                type: \"constructor\"\n            }));\n        }\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"_isInterface\", true);\n    }\n    format(format) {\n        if (!format) {\n            format = _fragments__WEBPACK_IMPORTED_MODULE_4__.FormatTypes.full;\n        }\n        if (format === _fragments__WEBPACK_IMPORTED_MODULE_4__.FormatTypes.sighash) {\n            logger.throwArgumentError(\"interface does not support formatting sighash\", \"format\", format);\n        }\n        const abi = this.fragments.map((fragment) => fragment.format(format));\n        // We need to re-bundle the JSON fragments a bit\n        if (format === _fragments__WEBPACK_IMPORTED_MODULE_4__.FormatTypes.json) {\n            return JSON.stringify(abi.map((j) => JSON.parse(j)));\n        }\n        return abi;\n    }\n    // Sub-classes can override these to handle other blockchains\n    static getAbiCoder() {\n        return _abi_coder__WEBPACK_IMPORTED_MODULE_5__.defaultAbiCoder;\n    }\n    static getAddress(address) {\n        return (0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_6__.getAddress)(address);\n    }\n    static getSighash(fragment) {\n        return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.hexDataSlice)((0,_ethersproject_hash__WEBPACK_IMPORTED_MODULE_8__.id)(fragment.format()), 0, 4);\n    }\n    static getEventTopic(eventFragment) {\n        return (0,_ethersproject_hash__WEBPACK_IMPORTED_MODULE_8__.id)(eventFragment.format());\n    }\n    // Find a function definition by any means necessary (unless it is ambiguous)\n    getFunction(nameOrSignatureOrSighash) {\n        if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.isHexString)(nameOrSignatureOrSighash)) {\n            for (const name in this.functions) {\n                if (nameOrSignatureOrSighash === this.getSighash(name)) {\n                    return this.functions[name];\n                }\n            }\n            logger.throwArgumentError(\"no matching function\", \"sighash\", nameOrSignatureOrSighash);\n        }\n        // It is a bare name, look up the function (will return null if ambiguous)\n        if (nameOrSignatureOrSighash.indexOf(\"(\") === -1) {\n            const name = nameOrSignatureOrSighash.trim();\n            const matching = Object.keys(this.functions).filter((f) => (f.split(\"(\" /* fix:) */)[0] === name));\n            if (matching.length === 0) {\n                logger.throwArgumentError(\"no matching function\", \"name\", name);\n            }\n            else if (matching.length > 1) {\n                logger.throwArgumentError(\"multiple matching functions\", \"name\", name);\n            }\n            return this.functions[matching[0]];\n        }\n        // Normalize the signature and lookup the function\n        const result = this.functions[_fragments__WEBPACK_IMPORTED_MODULE_4__.FunctionFragment.fromString(nameOrSignatureOrSighash).format()];\n        if (!result) {\n            logger.throwArgumentError(\"no matching function\", \"signature\", nameOrSignatureOrSighash);\n        }\n        return result;\n    }\n    // Find an event definition by any means necessary (unless it is ambiguous)\n    getEvent(nameOrSignatureOrTopic) {\n        if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.isHexString)(nameOrSignatureOrTopic)) {\n            const topichash = nameOrSignatureOrTopic.toLowerCase();\n            for (const name in this.events) {\n                if (topichash === this.getEventTopic(name)) {\n                    return this.events[name];\n                }\n            }\n            logger.throwArgumentError(\"no matching event\", \"topichash\", topichash);\n        }\n        // It is a bare name, look up the function (will return null if ambiguous)\n        if (nameOrSignatureOrTopic.indexOf(\"(\") === -1) {\n            const name = nameOrSignatureOrTopic.trim();\n            const matching = Object.keys(this.events).filter((f) => (f.split(\"(\" /* fix:) */)[0] === name));\n            if (matching.length === 0) {\n                logger.throwArgumentError(\"no matching event\", \"name\", name);\n            }\n            else if (matching.length > 1) {\n                logger.throwArgumentError(\"multiple matching events\", \"name\", name);\n            }\n            return this.events[matching[0]];\n        }\n        // Normalize the signature and lookup the function\n        const result = this.events[_fragments__WEBPACK_IMPORTED_MODULE_4__.EventFragment.fromString(nameOrSignatureOrTopic).format()];\n        if (!result) {\n            logger.throwArgumentError(\"no matching event\", \"signature\", nameOrSignatureOrTopic);\n        }\n        return result;\n    }\n    // Find a function definition by any means necessary (unless it is ambiguous)\n    getError(nameOrSignatureOrSighash) {\n        if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.isHexString)(nameOrSignatureOrSighash)) {\n            const getSighash = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.getStatic)(this.constructor, \"getSighash\");\n            for (const name in this.errors) {\n                const error = this.errors[name];\n                if (nameOrSignatureOrSighash === getSighash(error)) {\n                    return this.errors[name];\n                }\n            }\n            logger.throwArgumentError(\"no matching error\", \"sighash\", nameOrSignatureOrSighash);\n        }\n        // It is a bare name, look up the function (will return null if ambiguous)\n        if (nameOrSignatureOrSighash.indexOf(\"(\") === -1) {\n            const name = nameOrSignatureOrSighash.trim();\n            const matching = Object.keys(this.errors).filter((f) => (f.split(\"(\" /* fix:) */)[0] === name));\n            if (matching.length === 0) {\n                logger.throwArgumentError(\"no matching error\", \"name\", name);\n            }\n            else if (matching.length > 1) {\n                logger.throwArgumentError(\"multiple matching errors\", \"name\", name);\n            }\n            return this.errors[matching[0]];\n        }\n        // Normalize the signature and lookup the function\n        const result = this.errors[_fragments__WEBPACK_IMPORTED_MODULE_4__.FunctionFragment.fromString(nameOrSignatureOrSighash).format()];\n        if (!result) {\n            logger.throwArgumentError(\"no matching error\", \"signature\", nameOrSignatureOrSighash);\n        }\n        return result;\n    }\n    // Get the sighash (the bytes4 selector) used by Solidity to identify a function\n    getSighash(fragment) {\n        if (typeof (fragment) === \"string\") {\n            try {\n                fragment = this.getFunction(fragment);\n            }\n            catch (error) {\n                try {\n                    fragment = this.getError(fragment);\n                }\n                catch (_) {\n                    throw error;\n                }\n            }\n        }\n        return (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.getStatic)(this.constructor, \"getSighash\")(fragment);\n    }\n    // Get the topic (the bytes32 hash) used by Solidity to identify an event\n    getEventTopic(eventFragment) {\n        if (typeof (eventFragment) === \"string\") {\n            eventFragment = this.getEvent(eventFragment);\n        }\n        return (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.getStatic)(this.constructor, \"getEventTopic\")(eventFragment);\n    }\n    _decodeParams(params, data) {\n        return this._abiCoder.decode(params, data);\n    }\n    _encodeParams(params, values) {\n        return this._abiCoder.encode(params, values);\n    }\n    encodeDeploy(values) {\n        return this._encodeParams(this.deploy.inputs, values || []);\n    }\n    decodeErrorResult(fragment, data) {\n        if (typeof (fragment) === \"string\") {\n            fragment = this.getError(fragment);\n        }\n        const bytes = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.arrayify)(data);\n        if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.hexlify)(bytes.slice(0, 4)) !== this.getSighash(fragment)) {\n            logger.throwArgumentError(`data signature does not match error ${fragment.name}.`, \"data\", (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.hexlify)(bytes));\n        }\n        return this._decodeParams(fragment.inputs, bytes.slice(4));\n    }\n    encodeErrorResult(fragment, values) {\n        if (typeof (fragment) === \"string\") {\n            fragment = this.getError(fragment);\n        }\n        return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.hexlify)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.concat)([\n            this.getSighash(fragment),\n            this._encodeParams(fragment.inputs, values || [])\n        ]));\n    }\n    // Decode the data for a function call (e.g. tx.data)\n    decodeFunctionData(functionFragment, data) {\n        if (typeof (functionFragment) === \"string\") {\n            functionFragment = this.getFunction(functionFragment);\n        }\n        const bytes = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.arrayify)(data);\n        if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.hexlify)(bytes.slice(0, 4)) !== this.getSighash(functionFragment)) {\n            logger.throwArgumentError(`data signature does not match function ${functionFragment.name}.`, \"data\", (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.hexlify)(bytes));\n        }\n        return this._decodeParams(functionFragment.inputs, bytes.slice(4));\n    }\n    // Encode the data for a function call (e.g. tx.data)\n    encodeFunctionData(functionFragment, values) {\n        if (typeof (functionFragment) === \"string\") {\n            functionFragment = this.getFunction(functionFragment);\n        }\n        return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.hexlify)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.concat)([\n            this.getSighash(functionFragment),\n            this._encodeParams(functionFragment.inputs, values || [])\n        ]));\n    }\n    // Decode the result from a function call (e.g. from eth_call)\n    decodeFunctionResult(functionFragment, data) {\n        if (typeof (functionFragment) === \"string\") {\n            functionFragment = this.getFunction(functionFragment);\n        }\n        let bytes = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.arrayify)(data);\n        let reason = null;\n        let message = \"\";\n        let errorArgs = null;\n        let errorName = null;\n        let errorSignature = null;\n        switch (bytes.length % this._abiCoder._getWordSize()) {\n            case 0:\n                try {\n                    return this._abiCoder.decode(functionFragment.outputs, bytes);\n                }\n                catch (error) { }\n                break;\n            case 4: {\n                const selector = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.hexlify)(bytes.slice(0, 4));\n                const builtin = BuiltinErrors[selector];\n                if (builtin) {\n                    errorArgs = this._abiCoder.decode(builtin.inputs, bytes.slice(4));\n                    errorName = builtin.name;\n                    errorSignature = builtin.signature;\n                    if (builtin.reason) {\n                        reason = errorArgs[0];\n                    }\n                    if (errorName === \"Error\") {\n                        message = `; VM Exception while processing transaction: reverted with reason string ${JSON.stringify(errorArgs[0])}`;\n                    }\n                    else if (errorName === \"Panic\") {\n                        message = `; VM Exception while processing transaction: reverted with panic code ${errorArgs[0]}`;\n                    }\n                }\n                else {\n                    try {\n                        const error = this.getError(selector);\n                        errorArgs = this._abiCoder.decode(error.inputs, bytes.slice(4));\n                        errorName = error.name;\n                        errorSignature = error.format();\n                    }\n                    catch (error) { }\n                }\n                break;\n            }\n        }\n        return logger.throwError(\"call revert exception\" + message, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.CALL_EXCEPTION, {\n            method: functionFragment.format(),\n            data: (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.hexlify)(data), errorArgs, errorName, errorSignature, reason\n        });\n    }\n    // Encode the result for a function call (e.g. for eth_call)\n    encodeFunctionResult(functionFragment, values) {\n        if (typeof (functionFragment) === \"string\") {\n            functionFragment = this.getFunction(functionFragment);\n        }\n        return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.hexlify)(this._abiCoder.encode(functionFragment.outputs, values || []));\n    }\n    // Create the filter for the event with search criteria (e.g. for eth_filterLog)\n    encodeFilterTopics(eventFragment, values) {\n        if (typeof (eventFragment) === \"string\") {\n            eventFragment = this.getEvent(eventFragment);\n        }\n        if (values.length > eventFragment.inputs.length) {\n            logger.throwError(\"too many arguments for \" + eventFragment.format(), _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNEXPECTED_ARGUMENT, {\n                argument: \"values\",\n                value: values\n            });\n        }\n        let topics = [];\n        if (!eventFragment.anonymous) {\n            topics.push(this.getEventTopic(eventFragment));\n        }\n        const encodeTopic = (param, value) => {\n            if (param.type === \"string\") {\n                return (0,_ethersproject_hash__WEBPACK_IMPORTED_MODULE_8__.id)(value);\n            }\n            else if (param.type === \"bytes\") {\n                return (0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_9__.keccak256)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.hexlify)(value));\n            }\n            if (param.type === \"bool\" && typeof (value) === \"boolean\") {\n                value = (value ? \"0x01\" : \"0x00\");\n            }\n            if (param.type.match(/^u?int/)) {\n                value = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_10__.BigNumber.from(value).toHexString();\n            }\n            // Check addresses are valid\n            if (param.type === \"address\") {\n                this._abiCoder.encode([\"address\"], [value]);\n            }\n            return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.hexZeroPad)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.hexlify)(value), 32);\n        };\n        values.forEach((value, index) => {\n            let param = eventFragment.inputs[index];\n            if (!param.indexed) {\n                if (value != null) {\n                    logger.throwArgumentError(\"cannot filter non-indexed parameters; must be null\", (\"contract.\" + param.name), value);\n                }\n                return;\n            }\n            if (value == null) {\n                topics.push(null);\n            }\n            else if (param.baseType === \"array\" || param.baseType === \"tuple\") {\n                logger.throwArgumentError(\"filtering with tuples or arrays not supported\", (\"contract.\" + param.name), value);\n            }\n            else if (Array.isArray(value)) {\n                topics.push(value.map((value) => encodeTopic(param, value)));\n            }\n            else {\n                topics.push(encodeTopic(param, value));\n            }\n        });\n        // Trim off trailing nulls\n        while (topics.length && topics[topics.length - 1] === null) {\n            topics.pop();\n        }\n        return topics;\n    }\n    encodeEventLog(eventFragment, values) {\n        if (typeof (eventFragment) === \"string\") {\n            eventFragment = this.getEvent(eventFragment);\n        }\n        const topics = [];\n        const dataTypes = [];\n        const dataValues = [];\n        if (!eventFragment.anonymous) {\n            topics.push(this.getEventTopic(eventFragment));\n        }\n        if (values.length !== eventFragment.inputs.length) {\n            logger.throwArgumentError(\"event arguments/values mismatch\", \"values\", values);\n        }\n        eventFragment.inputs.forEach((param, index) => {\n            const value = values[index];\n            if (param.indexed) {\n                if (param.type === \"string\") {\n                    topics.push((0,_ethersproject_hash__WEBPACK_IMPORTED_MODULE_8__.id)(value));\n                }\n                else if (param.type === \"bytes\") {\n                    topics.push((0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_9__.keccak256)(value));\n                }\n                else if (param.baseType === \"tuple\" || param.baseType === \"array\") {\n                    // @TODO\n                    throw new Error(\"not implemented\");\n                }\n                else {\n                    topics.push(this._abiCoder.encode([param.type], [value]));\n                }\n            }\n            else {\n                dataTypes.push(param);\n                dataValues.push(value);\n            }\n        });\n        return {\n            data: this._abiCoder.encode(dataTypes, dataValues),\n            topics: topics\n        };\n    }\n    // Decode a filter for the event and the search criteria\n    decodeEventLog(eventFragment, data, topics) {\n        if (typeof (eventFragment) === \"string\") {\n            eventFragment = this.getEvent(eventFragment);\n        }\n        if (topics != null && !eventFragment.anonymous) {\n            let topicHash = this.getEventTopic(eventFragment);\n            if (!(0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.isHexString)(topics[0], 32) || topics[0].toLowerCase() !== topicHash) {\n                logger.throwError(\"fragment/topic mismatch\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.INVALID_ARGUMENT, { argument: \"topics[0]\", expected: topicHash, value: topics[0] });\n            }\n            topics = topics.slice(1);\n        }\n        let indexed = [];\n        let nonIndexed = [];\n        let dynamic = [];\n        eventFragment.inputs.forEach((param, index) => {\n            if (param.indexed) {\n                if (param.type === \"string\" || param.type === \"bytes\" || param.baseType === \"tuple\" || param.baseType === \"array\") {\n                    indexed.push(_fragments__WEBPACK_IMPORTED_MODULE_4__.ParamType.fromObject({ type: \"bytes32\", name: param.name }));\n                    dynamic.push(true);\n                }\n                else {\n                    indexed.push(param);\n                    dynamic.push(false);\n                }\n            }\n            else {\n                nonIndexed.push(param);\n                dynamic.push(false);\n            }\n        });\n        let resultIndexed = (topics != null) ? this._abiCoder.decode(indexed, (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.concat)(topics)) : null;\n        let resultNonIndexed = this._abiCoder.decode(nonIndexed, data, true);\n        let result = [];\n        let nonIndexedIndex = 0, indexedIndex = 0;\n        eventFragment.inputs.forEach((param, index) => {\n            if (param.indexed) {\n                if (resultIndexed == null) {\n                    result[index] = new Indexed({ _isIndexed: true, hash: null });\n                }\n                else if (dynamic[index]) {\n                    result[index] = new Indexed({ _isIndexed: true, hash: resultIndexed[indexedIndex++] });\n                }\n                else {\n                    try {\n                        result[index] = resultIndexed[indexedIndex++];\n                    }\n                    catch (error) {\n                        result[index] = error;\n                    }\n                }\n            }\n            else {\n                try {\n                    result[index] = resultNonIndexed[nonIndexedIndex++];\n                }\n                catch (error) {\n                    result[index] = error;\n                }\n            }\n            // Add the keyword argument if named and safe\n            if (param.name && result[param.name] == null) {\n                const value = result[index];\n                // Make error named values throw on access\n                if (value instanceof Error) {\n                    Object.defineProperty(result, param.name, {\n                        enumerable: true,\n                        get: () => { throw wrapAccessError(`property ${JSON.stringify(param.name)}`, value); }\n                    });\n                }\n                else {\n                    result[param.name] = value;\n                }\n            }\n        });\n        // Make all error indexed values throw on access\n        for (let i = 0; i < result.length; i++) {\n            const value = result[i];\n            if (value instanceof Error) {\n                Object.defineProperty(result, i, {\n                    enumerable: true,\n                    get: () => { throw wrapAccessError(`index ${i}`, value); }\n                });\n            }\n        }\n        return Object.freeze(result);\n    }\n    // Given a transaction, find the matching function fragment (if any) and\n    // determine all its properties and call parameters\n    parseTransaction(tx) {\n        let fragment = this.getFunction(tx.data.substring(0, 10).toLowerCase());\n        if (!fragment) {\n            return null;\n        }\n        return new TransactionDescription({\n            args: this._abiCoder.decode(fragment.inputs, \"0x\" + tx.data.substring(10)),\n            functionFragment: fragment,\n            name: fragment.name,\n            signature: fragment.format(),\n            sighash: this.getSighash(fragment),\n            value: _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_10__.BigNumber.from(tx.value || \"0\"),\n        });\n    }\n    // @TODO\n    //parseCallResult(data: BytesLike): ??\n    // Given an event log, find the matching event fragment (if any) and\n    // determine all its properties and values\n    parseLog(log) {\n        let fragment = this.getEvent(log.topics[0]);\n        if (!fragment || fragment.anonymous) {\n            return null;\n        }\n        // @TODO: If anonymous, and the only method, and the input count matches, should we parse?\n        //        Probably not, because just because it is the only event in the ABI does\n        //        not mean we have the full ABI; maybe just a fragment?\n        return new LogDescription({\n            eventFragment: fragment,\n            name: fragment.name,\n            signature: fragment.format(),\n            topic: this.getEventTopic(fragment),\n            args: this.decodeEventLog(fragment, log.data, log.topics)\n        });\n    }\n    parseError(data) {\n        const hexData = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.hexlify)(data);\n        let fragment = this.getError(hexData.substring(0, 10).toLowerCase());\n        if (!fragment) {\n            return null;\n        }\n        return new ErrorDescription({\n            args: this._abiCoder.decode(fragment.inputs, \"0x\" + hexData.substring(10)),\n            errorFragment: fragment,\n            name: fragment.name,\n            signature: fragment.format(),\n            sighash: this.getSighash(fragment),\n        });\n    }\n    /*\n    static from(value: Array<Fragment | string | JsonAbi> | string | Interface) {\n        if (Interface.isInterface(value)) {\n            return value;\n        }\n        if (typeof(value) === \"string\") {\n            return new Interface(JSON.parse(value));\n        }\n        return new Interface(value);\n    }\n    */\n    static isInterface(value) {\n        return !!(value && value._isInterface);\n    }\n}\n//# sourceMappingURL=interface.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2FiaS9saWIuZXNtL2ludGVyZmFjZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFhO0FBQ3VDO0FBQ0M7QUFDbUQ7QUFDL0Q7QUFDWTtBQUM4QjtBQUNyQztBQUNjO0FBQ3lEO0FBQ3RFO0FBQ1Y7QUFDckMsbUJBQW1CLHlEQUFNLENBQUMsNkNBQU87QUFDSjtBQUN0Qiw2QkFBNkIsa0VBQVc7QUFDL0M7QUFDTyxxQ0FBcUMsa0VBQVc7QUFDdkQ7QUFDTywrQkFBK0Isa0VBQVc7QUFDakQ7QUFDTyxzQkFBc0Isa0VBQVc7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw2RUFBNkU7QUFDakcsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQSxxRkFBcUYsU0FBUztBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELE9BQU8sYUFBYSw2QkFBNkIsTUFBTSx5QkFBeUI7QUFDeEk7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEtBQUssMkJBQTJCLElBQUk7QUFDekM7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEseUVBQWM7QUFDdEIsbUJBQW1CLGdEQUFRO0FBQzNCLFNBQVM7QUFDVCxRQUFRLHlFQUFjLG9CQUFvQixvRUFBUztBQUNuRCxRQUFRLHlFQUFjLHNCQUFzQjtBQUM1QyxRQUFRLHlFQUFjLG1CQUFtQjtBQUN6QyxRQUFRLHlFQUFjLG1CQUFtQjtBQUN6QyxRQUFRLHlFQUFjLG9CQUFvQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix5RUFBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCw4RUFBOEUsNERBQU07QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELDhCQUE4QjtBQUNoRjtBQUNBO0FBQ0Esa0RBQWtELHVEQUF1RDtBQUN6RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxrQ0FBa0MsMkJBQTJCO0FBQ2xHLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQywrQkFBK0IsRUFBRTtBQUNsRSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixnRUFBUztBQUM1QixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esd0JBQXdCLDZEQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sZWRnaXR5LXlpZWxkLWZyb250ZW5kLy4uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9hYmkvbGliLmVzbS9pbnRlcmZhY2UuanM/YTU3YSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmltcG9ydCB7IGdldEFkZHJlc3MgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYWRkcmVzc1wiO1xuaW1wb3J0IHsgQmlnTnVtYmVyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2JpZ251bWJlclwiO1xuaW1wb3J0IHsgYXJyYXlpZnksIGNvbmNhdCwgaGV4RGF0YVNsaWNlLCBoZXhsaWZ5LCBoZXhaZXJvUGFkLCBpc0hleFN0cmluZyB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9ieXRlc1wiO1xuaW1wb3J0IHsgaWQgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvaGFzaFwiO1xuaW1wb3J0IHsga2VjY2FrMjU2IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2tlY2NhazI1NlwiO1xuaW1wb3J0IHsgZGVmaW5lUmVhZE9ubHksIERlc2NyaXB0aW9uLCBnZXRTdGF0aWMgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvcHJvcGVydGllc1wiO1xuaW1wb3J0IHsgZGVmYXVsdEFiaUNvZGVyIH0gZnJvbSBcIi4vYWJpLWNvZGVyXCI7XG5pbXBvcnQgeyBjaGVja1Jlc3VsdEVycm9ycyB9IGZyb20gXCIuL2NvZGVycy9hYnN0cmFjdC1jb2RlclwiO1xuaW1wb3J0IHsgQ29uc3RydWN0b3JGcmFnbWVudCwgRXZlbnRGcmFnbWVudCwgRm9ybWF0VHlwZXMsIEZyYWdtZW50LCBGdW5jdGlvbkZyYWdtZW50LCBQYXJhbVR5cGUgfSBmcm9tIFwiLi9mcmFnbWVudHNcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi9fdmVyc2lvblwiO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcih2ZXJzaW9uKTtcbmV4cG9ydCB7IGNoZWNrUmVzdWx0RXJyb3JzIH07XG5leHBvcnQgY2xhc3MgTG9nRGVzY3JpcHRpb24gZXh0ZW5kcyBEZXNjcmlwdGlvbiB7XG59XG5leHBvcnQgY2xhc3MgVHJhbnNhY3Rpb25EZXNjcmlwdGlvbiBleHRlbmRzIERlc2NyaXB0aW9uIHtcbn1cbmV4cG9ydCBjbGFzcyBFcnJvckRlc2NyaXB0aW9uIGV4dGVuZHMgRGVzY3JpcHRpb24ge1xufVxuZXhwb3J0IGNsYXNzIEluZGV4ZWQgZXh0ZW5kcyBEZXNjcmlwdGlvbiB7XG4gICAgc3RhdGljIGlzSW5kZXhlZCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUuX2lzSW5kZXhlZCk7XG4gICAgfVxufVxuY29uc3QgQnVpbHRpbkVycm9ycyA9IHtcbiAgICBcIjB4MDhjMzc5YTBcIjogeyBzaWduYXR1cmU6IFwiRXJyb3Ioc3RyaW5nKVwiLCBuYW1lOiBcIkVycm9yXCIsIGlucHV0czogW1wic3RyaW5nXCJdLCByZWFzb246IHRydWUgfSxcbiAgICBcIjB4NGU0ODdiNzFcIjogeyBzaWduYXR1cmU6IFwiUGFuaWModWludDI1NilcIiwgbmFtZTogXCJQYW5pY1wiLCBpbnB1dHM6IFtcInVpbnQyNTZcIl0gfVxufTtcbmZ1bmN0aW9uIHdyYXBBY2Nlc3NFcnJvcihwcm9wZXJ0eSwgZXJyb3IpIHtcbiAgICBjb25zdCB3cmFwID0gbmV3IEVycm9yKGBkZWZlcnJlZCBlcnJvciBkdXJpbmcgQUJJIGRlY29kaW5nIHRyaWdnZXJlZCBhY2Nlc3NpbmcgJHtwcm9wZXJ0eX1gKTtcbiAgICB3cmFwLmVycm9yID0gZXJyb3I7XG4gICAgcmV0dXJuIHdyYXA7XG59XG4vKlxuZnVuY3Rpb24gY2hlY2tOYW1lcyhmcmFnbWVudDogRnJhZ21lbnQsIHR5cGU6IFwiaW5wdXRcIiB8IFwib3V0cHV0XCIsIHBhcmFtczogQXJyYXk8UGFyYW1UeXBlPik6IHZvaWQge1xuICAgIHBhcmFtcy5yZWR1Y2UoKGFjY3VtLCBwYXJhbSkgPT4ge1xuICAgICAgICBpZiAocGFyYW0ubmFtZSkge1xuICAgICAgICAgICAgaWYgKGFjY3VtW3BhcmFtLm5hbWVdKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihgZHVwbGljYXRlICR7IHR5cGUgfSBwYXJhbWV0ZXIgJHsgSlNPTi5zdHJpbmdpZnkocGFyYW0ubmFtZSkgfSBpbiAkeyBmcmFnbWVudC5mb3JtYXQoXCJmdWxsXCIpIH1gLCBcImZyYWdtZW50XCIsIGZyYWdtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFjY3VtW3BhcmFtLm5hbWVdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWNjdW07XG4gICAgfSwgPHsgWyBuYW1lOiBzdHJpbmcgXTogYm9vbGVhbiB9PnsgfSk7XG59XG4qL1xuZXhwb3J0IGNsYXNzIEludGVyZmFjZSB7XG4gICAgY29uc3RydWN0b3IoZnJhZ21lbnRzKSB7XG4gICAgICAgIGxldCBhYmkgPSBbXTtcbiAgICAgICAgaWYgKHR5cGVvZiAoZnJhZ21lbnRzKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgYWJpID0gSlNPTi5wYXJzZShmcmFnbWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYWJpID0gZnJhZ21lbnRzO1xuICAgICAgICB9XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiZnJhZ21lbnRzXCIsIGFiaS5tYXAoKGZyYWdtZW50KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gRnJhZ21lbnQuZnJvbShmcmFnbWVudCk7XG4gICAgICAgIH0pLmZpbHRlcigoZnJhZ21lbnQpID0+IChmcmFnbWVudCAhPSBudWxsKSkpO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcIl9hYmlDb2RlclwiLCBnZXRTdGF0aWMobmV3LnRhcmdldCwgXCJnZXRBYmlDb2RlclwiKSgpKTtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJmdW5jdGlvbnNcIiwge30pO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcImVycm9yc1wiLCB7fSk7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiZXZlbnRzXCIsIHt9KTtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJzdHJ1Y3RzXCIsIHt9KTtcbiAgICAgICAgLy8gQWRkIGFsbCBmcmFnbWVudHMgYnkgdGhlaXIgc2lnbmF0dXJlXG4gICAgICAgIHRoaXMuZnJhZ21lbnRzLmZvckVhY2goKGZyYWdtZW50KSA9PiB7XG4gICAgICAgICAgICBsZXQgYnVja2V0ID0gbnVsbDtcbiAgICAgICAgICAgIHN3aXRjaCAoZnJhZ21lbnQudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJjb25zdHJ1Y3RvclwiOlxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5kZXBsb3kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKFwiZHVwbGljYXRlIGRlZmluaXRpb24gLSBjb25zdHJ1Y3RvclwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvL2NoZWNrTmFtZXMoZnJhZ21lbnQsIFwiaW5wdXRcIiwgZnJhZ21lbnQuaW5wdXRzKTtcbiAgICAgICAgICAgICAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJkZXBsb3lcIiwgZnJhZ21lbnQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6XG4gICAgICAgICAgICAgICAgICAgIC8vY2hlY2tOYW1lcyhmcmFnbWVudCwgXCJpbnB1dFwiLCBmcmFnbWVudC5pbnB1dHMpO1xuICAgICAgICAgICAgICAgICAgICAvL2NoZWNrTmFtZXMoZnJhZ21lbnQsIFwib3V0cHV0XCIsICg8RnVuY3Rpb25GcmFnbWVudD5mcmFnbWVudCkub3V0cHV0cyk7XG4gICAgICAgICAgICAgICAgICAgIGJ1Y2tldCA9IHRoaXMuZnVuY3Rpb25zO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiZXZlbnRcIjpcbiAgICAgICAgICAgICAgICAgICAgLy9jaGVja05hbWVzKGZyYWdtZW50LCBcImlucHV0XCIsIGZyYWdtZW50LmlucHV0cyk7XG4gICAgICAgICAgICAgICAgICAgIGJ1Y2tldCA9IHRoaXMuZXZlbnRzO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgICAgICAgICAgICAgICAgYnVja2V0ID0gdGhpcy5lcnJvcnM7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBzaWduYXR1cmUgPSBmcmFnbWVudC5mb3JtYXQoKTtcbiAgICAgICAgICAgIGlmIChidWNrZXRbc2lnbmF0dXJlXSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKFwiZHVwbGljYXRlIGRlZmluaXRpb24gLSBcIiArIHNpZ25hdHVyZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnVja2V0W3NpZ25hdHVyZV0gPSBmcmFnbWVudDtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIElmIHdlIGRvIG5vdCBoYXZlIGEgY29uc3RydWN0b3IgYWRkIGEgZGVmYXVsdFxuICAgICAgICBpZiAoIXRoaXMuZGVwbG95KSB7XG4gICAgICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcImRlcGxveVwiLCBDb25zdHJ1Y3RvckZyYWdtZW50LmZyb20oe1xuICAgICAgICAgICAgICAgIHBheWFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiY29uc3RydWN0b3JcIlxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiX2lzSW50ZXJmYWNlXCIsIHRydWUpO1xuICAgIH1cbiAgICBmb3JtYXQoZm9ybWF0KSB7XG4gICAgICAgIGlmICghZm9ybWF0KSB7XG4gICAgICAgICAgICBmb3JtYXQgPSBGb3JtYXRUeXBlcy5mdWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb3JtYXQgPT09IEZvcm1hdFR5cGVzLnNpZ2hhc2gpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnRlcmZhY2UgZG9lcyBub3Qgc3VwcG9ydCBmb3JtYXR0aW5nIHNpZ2hhc2hcIiwgXCJmb3JtYXRcIiwgZm9ybWF0KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhYmkgPSB0aGlzLmZyYWdtZW50cy5tYXAoKGZyYWdtZW50KSA9PiBmcmFnbWVudC5mb3JtYXQoZm9ybWF0KSk7XG4gICAgICAgIC8vIFdlIG5lZWQgdG8gcmUtYnVuZGxlIHRoZSBKU09OIGZyYWdtZW50cyBhIGJpdFxuICAgICAgICBpZiAoZm9ybWF0ID09PSBGb3JtYXRUeXBlcy5qc29uKSB7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYWJpLm1hcCgoaikgPT4gSlNPTi5wYXJzZShqKSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhYmk7XG4gICAgfVxuICAgIC8vIFN1Yi1jbGFzc2VzIGNhbiBvdmVycmlkZSB0aGVzZSB0byBoYW5kbGUgb3RoZXIgYmxvY2tjaGFpbnNcbiAgICBzdGF0aWMgZ2V0QWJpQ29kZXIoKSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0QWJpQ29kZXI7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRBZGRyZXNzKGFkZHJlc3MpIHtcbiAgICAgICAgcmV0dXJuIGdldEFkZHJlc3MoYWRkcmVzcyk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRTaWdoYXNoKGZyYWdtZW50KSB7XG4gICAgICAgIHJldHVybiBoZXhEYXRhU2xpY2UoaWQoZnJhZ21lbnQuZm9ybWF0KCkpLCAwLCA0KTtcbiAgICB9XG4gICAgc3RhdGljIGdldEV2ZW50VG9waWMoZXZlbnRGcmFnbWVudCkge1xuICAgICAgICByZXR1cm4gaWQoZXZlbnRGcmFnbWVudC5mb3JtYXQoKSk7XG4gICAgfVxuICAgIC8vIEZpbmQgYSBmdW5jdGlvbiBkZWZpbml0aW9uIGJ5IGFueSBtZWFucyBuZWNlc3NhcnkgKHVubGVzcyBpdCBpcyBhbWJpZ3VvdXMpXG4gICAgZ2V0RnVuY3Rpb24obmFtZU9yU2lnbmF0dXJlT3JTaWdoYXNoKSB7XG4gICAgICAgIGlmIChpc0hleFN0cmluZyhuYW1lT3JTaWduYXR1cmVPclNpZ2hhc2gpKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gdGhpcy5mdW5jdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBpZiAobmFtZU9yU2lnbmF0dXJlT3JTaWdoYXNoID09PSB0aGlzLmdldFNpZ2hhc2gobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZnVuY3Rpb25zW25hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJubyBtYXRjaGluZyBmdW5jdGlvblwiLCBcInNpZ2hhc2hcIiwgbmFtZU9yU2lnbmF0dXJlT3JTaWdoYXNoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJdCBpcyBhIGJhcmUgbmFtZSwgbG9vayB1cCB0aGUgZnVuY3Rpb24gKHdpbGwgcmV0dXJuIG51bGwgaWYgYW1iaWd1b3VzKVxuICAgICAgICBpZiAobmFtZU9yU2lnbmF0dXJlT3JTaWdoYXNoLmluZGV4T2YoXCIoXCIpID09PSAtMSkge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IG5hbWVPclNpZ25hdHVyZU9yU2lnaGFzaC50cmltKCk7XG4gICAgICAgICAgICBjb25zdCBtYXRjaGluZyA9IE9iamVjdC5rZXlzKHRoaXMuZnVuY3Rpb25zKS5maWx0ZXIoKGYpID0+IChmLnNwbGl0KFwiKFwiIC8qIGZpeDopICovKVswXSA9PT0gbmFtZSkpO1xuICAgICAgICAgICAgaWYgKG1hdGNoaW5nLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJubyBtYXRjaGluZyBmdW5jdGlvblwiLCBcIm5hbWVcIiwgbmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtYXRjaGluZy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcIm11bHRpcGxlIG1hdGNoaW5nIGZ1bmN0aW9uc1wiLCBcIm5hbWVcIiwgbmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mdW5jdGlvbnNbbWF0Y2hpbmdbMF1dO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vcm1hbGl6ZSB0aGUgc2lnbmF0dXJlIGFuZCBsb29rdXAgdGhlIGZ1bmN0aW9uXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuZnVuY3Rpb25zW0Z1bmN0aW9uRnJhZ21lbnQuZnJvbVN0cmluZyhuYW1lT3JTaWduYXR1cmVPclNpZ2hhc2gpLmZvcm1hdCgpXTtcbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJubyBtYXRjaGluZyBmdW5jdGlvblwiLCBcInNpZ25hdHVyZVwiLCBuYW1lT3JTaWduYXR1cmVPclNpZ2hhc2gpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8vIEZpbmQgYW4gZXZlbnQgZGVmaW5pdGlvbiBieSBhbnkgbWVhbnMgbmVjZXNzYXJ5ICh1bmxlc3MgaXQgaXMgYW1iaWd1b3VzKVxuICAgIGdldEV2ZW50KG5hbWVPclNpZ25hdHVyZU9yVG9waWMpIHtcbiAgICAgICAgaWYgKGlzSGV4U3RyaW5nKG5hbWVPclNpZ25hdHVyZU9yVG9waWMpKSB7XG4gICAgICAgICAgICBjb25zdCB0b3BpY2hhc2ggPSBuYW1lT3JTaWduYXR1cmVPclRvcGljLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gdGhpcy5ldmVudHMpIHtcbiAgICAgICAgICAgICAgICBpZiAodG9waWNoYXNoID09PSB0aGlzLmdldEV2ZW50VG9waWMobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXZlbnRzW25hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJubyBtYXRjaGluZyBldmVudFwiLCBcInRvcGljaGFzaFwiLCB0b3BpY2hhc2gpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEl0IGlzIGEgYmFyZSBuYW1lLCBsb29rIHVwIHRoZSBmdW5jdGlvbiAod2lsbCByZXR1cm4gbnVsbCBpZiBhbWJpZ3VvdXMpXG4gICAgICAgIGlmIChuYW1lT3JTaWduYXR1cmVPclRvcGljLmluZGV4T2YoXCIoXCIpID09PSAtMSkge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IG5hbWVPclNpZ25hdHVyZU9yVG9waWMudHJpbSgpO1xuICAgICAgICAgICAgY29uc3QgbWF0Y2hpbmcgPSBPYmplY3Qua2V5cyh0aGlzLmV2ZW50cykuZmlsdGVyKChmKSA9PiAoZi5zcGxpdChcIihcIiAvKiBmaXg6KSAqLylbMF0gPT09IG5hbWUpKTtcbiAgICAgICAgICAgIGlmIChtYXRjaGluZy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwibm8gbWF0Y2hpbmcgZXZlbnRcIiwgXCJuYW1lXCIsIG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobWF0Y2hpbmcubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJtdWx0aXBsZSBtYXRjaGluZyBldmVudHNcIiwgXCJuYW1lXCIsIG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXZlbnRzW21hdGNoaW5nWzBdXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3JtYWxpemUgdGhlIHNpZ25hdHVyZSBhbmQgbG9va3VwIHRoZSBmdW5jdGlvblxuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmV2ZW50c1tFdmVudEZyYWdtZW50LmZyb21TdHJpbmcobmFtZU9yU2lnbmF0dXJlT3JUb3BpYykuZm9ybWF0KCldO1xuICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcIm5vIG1hdGNoaW5nIGV2ZW50XCIsIFwic2lnbmF0dXJlXCIsIG5hbWVPclNpZ25hdHVyZU9yVG9waWMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8vIEZpbmQgYSBmdW5jdGlvbiBkZWZpbml0aW9uIGJ5IGFueSBtZWFucyBuZWNlc3NhcnkgKHVubGVzcyBpdCBpcyBhbWJpZ3VvdXMpXG4gICAgZ2V0RXJyb3IobmFtZU9yU2lnbmF0dXJlT3JTaWdoYXNoKSB7XG4gICAgICAgIGlmIChpc0hleFN0cmluZyhuYW1lT3JTaWduYXR1cmVPclNpZ2hhc2gpKSB7XG4gICAgICAgICAgICBjb25zdCBnZXRTaWdoYXNoID0gZ2V0U3RhdGljKHRoaXMuY29uc3RydWN0b3IsIFwiZ2V0U2lnaGFzaFwiKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiB0aGlzLmVycm9ycykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5lcnJvcnNbbmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKG5hbWVPclNpZ25hdHVyZU9yU2lnaGFzaCA9PT0gZ2V0U2lnaGFzaChlcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3JzW25hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJubyBtYXRjaGluZyBlcnJvclwiLCBcInNpZ2hhc2hcIiwgbmFtZU9yU2lnbmF0dXJlT3JTaWdoYXNoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJdCBpcyBhIGJhcmUgbmFtZSwgbG9vayB1cCB0aGUgZnVuY3Rpb24gKHdpbGwgcmV0dXJuIG51bGwgaWYgYW1iaWd1b3VzKVxuICAgICAgICBpZiAobmFtZU9yU2lnbmF0dXJlT3JTaWdoYXNoLmluZGV4T2YoXCIoXCIpID09PSAtMSkge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IG5hbWVPclNpZ25hdHVyZU9yU2lnaGFzaC50cmltKCk7XG4gICAgICAgICAgICBjb25zdCBtYXRjaGluZyA9IE9iamVjdC5rZXlzKHRoaXMuZXJyb3JzKS5maWx0ZXIoKGYpID0+IChmLnNwbGl0KFwiKFwiIC8qIGZpeDopICovKVswXSA9PT0gbmFtZSkpO1xuICAgICAgICAgICAgaWYgKG1hdGNoaW5nLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJubyBtYXRjaGluZyBlcnJvclwiLCBcIm5hbWVcIiwgbmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtYXRjaGluZy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcIm11bHRpcGxlIG1hdGNoaW5nIGVycm9yc1wiLCBcIm5hbWVcIiwgbmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lcnJvcnNbbWF0Y2hpbmdbMF1dO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vcm1hbGl6ZSB0aGUgc2lnbmF0dXJlIGFuZCBsb29rdXAgdGhlIGZ1bmN0aW9uXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuZXJyb3JzW0Z1bmN0aW9uRnJhZ21lbnQuZnJvbVN0cmluZyhuYW1lT3JTaWduYXR1cmVPclNpZ2hhc2gpLmZvcm1hdCgpXTtcbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJubyBtYXRjaGluZyBlcnJvclwiLCBcInNpZ25hdHVyZVwiLCBuYW1lT3JTaWduYXR1cmVPclNpZ2hhc2gpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8vIEdldCB0aGUgc2lnaGFzaCAodGhlIGJ5dGVzNCBzZWxlY3RvcikgdXNlZCBieSBTb2xpZGl0eSB0byBpZGVudGlmeSBhIGZ1bmN0aW9uXG4gICAgZ2V0U2lnaGFzaChmcmFnbWVudCkge1xuICAgICAgICBpZiAodHlwZW9mIChmcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZnJhZ21lbnQgPSB0aGlzLmdldEZ1bmN0aW9uKGZyYWdtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGZyYWdtZW50ID0gdGhpcy5nZXRFcnJvcihmcmFnbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChfKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2V0U3RhdGljKHRoaXMuY29uc3RydWN0b3IsIFwiZ2V0U2lnaGFzaFwiKShmcmFnbWVudCk7XG4gICAgfVxuICAgIC8vIEdldCB0aGUgdG9waWMgKHRoZSBieXRlczMyIGhhc2gpIHVzZWQgYnkgU29saWRpdHkgdG8gaWRlbnRpZnkgYW4gZXZlbnRcbiAgICBnZXRFdmVudFRvcGljKGV2ZW50RnJhZ21lbnQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAoZXZlbnRGcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGV2ZW50RnJhZ21lbnQgPSB0aGlzLmdldEV2ZW50KGV2ZW50RnJhZ21lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnZXRTdGF0aWModGhpcy5jb25zdHJ1Y3RvciwgXCJnZXRFdmVudFRvcGljXCIpKGV2ZW50RnJhZ21lbnQpO1xuICAgIH1cbiAgICBfZGVjb2RlUGFyYW1zKHBhcmFtcywgZGF0YSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWJpQ29kZXIuZGVjb2RlKHBhcmFtcywgZGF0YSk7XG4gICAgfVxuICAgIF9lbmNvZGVQYXJhbXMocGFyYW1zLCB2YWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FiaUNvZGVyLmVuY29kZShwYXJhbXMsIHZhbHVlcyk7XG4gICAgfVxuICAgIGVuY29kZURlcGxveSh2YWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VuY29kZVBhcmFtcyh0aGlzLmRlcGxveS5pbnB1dHMsIHZhbHVlcyB8fCBbXSk7XG4gICAgfVxuICAgIGRlY29kZUVycm9yUmVzdWx0KGZyYWdtZW50LCBkYXRhKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKGZyYWdtZW50KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgZnJhZ21lbnQgPSB0aGlzLmdldEVycm9yKGZyYWdtZW50KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBieXRlcyA9IGFycmF5aWZ5KGRhdGEpO1xuICAgICAgICBpZiAoaGV4bGlmeShieXRlcy5zbGljZSgwLCA0KSkgIT09IHRoaXMuZ2V0U2lnaGFzaChmcmFnbWVudCkpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoYGRhdGEgc2lnbmF0dXJlIGRvZXMgbm90IG1hdGNoIGVycm9yICR7ZnJhZ21lbnQubmFtZX0uYCwgXCJkYXRhXCIsIGhleGxpZnkoYnl0ZXMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZGVjb2RlUGFyYW1zKGZyYWdtZW50LmlucHV0cywgYnl0ZXMuc2xpY2UoNCkpO1xuICAgIH1cbiAgICBlbmNvZGVFcnJvclJlc3VsdChmcmFnbWVudCwgdmFsdWVzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKGZyYWdtZW50KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgZnJhZ21lbnQgPSB0aGlzLmdldEVycm9yKGZyYWdtZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGV4bGlmeShjb25jYXQoW1xuICAgICAgICAgICAgdGhpcy5nZXRTaWdoYXNoKGZyYWdtZW50KSxcbiAgICAgICAgICAgIHRoaXMuX2VuY29kZVBhcmFtcyhmcmFnbWVudC5pbnB1dHMsIHZhbHVlcyB8fCBbXSlcbiAgICAgICAgXSkpO1xuICAgIH1cbiAgICAvLyBEZWNvZGUgdGhlIGRhdGEgZm9yIGEgZnVuY3Rpb24gY2FsbCAoZS5nLiB0eC5kYXRhKVxuICAgIGRlY29kZUZ1bmN0aW9uRGF0YShmdW5jdGlvbkZyYWdtZW50LCBkYXRhKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKGZ1bmN0aW9uRnJhZ21lbnQpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBmdW5jdGlvbkZyYWdtZW50ID0gdGhpcy5nZXRGdW5jdGlvbihmdW5jdGlvbkZyYWdtZW50KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBieXRlcyA9IGFycmF5aWZ5KGRhdGEpO1xuICAgICAgICBpZiAoaGV4bGlmeShieXRlcy5zbGljZSgwLCA0KSkgIT09IHRoaXMuZ2V0U2lnaGFzaChmdW5jdGlvbkZyYWdtZW50KSkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihgZGF0YSBzaWduYXR1cmUgZG9lcyBub3QgbWF0Y2ggZnVuY3Rpb24gJHtmdW5jdGlvbkZyYWdtZW50Lm5hbWV9LmAsIFwiZGF0YVwiLCBoZXhsaWZ5KGJ5dGVzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlY29kZVBhcmFtcyhmdW5jdGlvbkZyYWdtZW50LmlucHV0cywgYnl0ZXMuc2xpY2UoNCkpO1xuICAgIH1cbiAgICAvLyBFbmNvZGUgdGhlIGRhdGEgZm9yIGEgZnVuY3Rpb24gY2FsbCAoZS5nLiB0eC5kYXRhKVxuICAgIGVuY29kZUZ1bmN0aW9uRGF0YShmdW5jdGlvbkZyYWdtZW50LCB2YWx1ZXMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAoZnVuY3Rpb25GcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uRnJhZ21lbnQgPSB0aGlzLmdldEZ1bmN0aW9uKGZ1bmN0aW9uRnJhZ21lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoZXhsaWZ5KGNvbmNhdChbXG4gICAgICAgICAgICB0aGlzLmdldFNpZ2hhc2goZnVuY3Rpb25GcmFnbWVudCksXG4gICAgICAgICAgICB0aGlzLl9lbmNvZGVQYXJhbXMoZnVuY3Rpb25GcmFnbWVudC5pbnB1dHMsIHZhbHVlcyB8fCBbXSlcbiAgICAgICAgXSkpO1xuICAgIH1cbiAgICAvLyBEZWNvZGUgdGhlIHJlc3VsdCBmcm9tIGEgZnVuY3Rpb24gY2FsbCAoZS5nLiBmcm9tIGV0aF9jYWxsKVxuICAgIGRlY29kZUZ1bmN0aW9uUmVzdWx0KGZ1bmN0aW9uRnJhZ21lbnQsIGRhdGEpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAoZnVuY3Rpb25GcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uRnJhZ21lbnQgPSB0aGlzLmdldEZ1bmN0aW9uKGZ1bmN0aW9uRnJhZ21lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBieXRlcyA9IGFycmF5aWZ5KGRhdGEpO1xuICAgICAgICBsZXQgcmVhc29uID0gbnVsbDtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSBcIlwiO1xuICAgICAgICBsZXQgZXJyb3JBcmdzID0gbnVsbDtcbiAgICAgICAgbGV0IGVycm9yTmFtZSA9IG51bGw7XG4gICAgICAgIGxldCBlcnJvclNpZ25hdHVyZSA9IG51bGw7XG4gICAgICAgIHN3aXRjaCAoYnl0ZXMubGVuZ3RoICUgdGhpcy5fYWJpQ29kZXIuX2dldFdvcmRTaXplKCkpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYWJpQ29kZXIuZGVjb2RlKGZ1bmN0aW9uRnJhZ21lbnQub3V0cHV0cywgYnl0ZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA0OiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSBoZXhsaWZ5KGJ5dGVzLnNsaWNlKDAsIDQpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBidWlsdGluID0gQnVpbHRpbkVycm9yc1tzZWxlY3Rvcl07XG4gICAgICAgICAgICAgICAgaWYgKGJ1aWx0aW4pIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JBcmdzID0gdGhpcy5fYWJpQ29kZXIuZGVjb2RlKGJ1aWx0aW4uaW5wdXRzLCBieXRlcy5zbGljZSg0KSk7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yTmFtZSA9IGJ1aWx0aW4ubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JTaWduYXR1cmUgPSBidWlsdGluLnNpZ25hdHVyZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJ1aWx0aW4ucmVhc29uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWFzb24gPSBlcnJvckFyZ3NbMF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yTmFtZSA9PT0gXCJFcnJvclwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gYDsgVk0gRXhjZXB0aW9uIHdoaWxlIHByb2Nlc3NpbmcgdHJhbnNhY3Rpb246IHJldmVydGVkIHdpdGggcmVhc29uIHN0cmluZyAke0pTT04uc3RyaW5naWZ5KGVycm9yQXJnc1swXSl9YDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChlcnJvck5hbWUgPT09IFwiUGFuaWNcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IGA7IFZNIEV4Y2VwdGlvbiB3aGlsZSBwcm9jZXNzaW5nIHRyYW5zYWN0aW9uOiByZXZlcnRlZCB3aXRoIHBhbmljIGNvZGUgJHtlcnJvckFyZ3NbMF19YDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5nZXRFcnJvcihzZWxlY3Rvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvckFyZ3MgPSB0aGlzLl9hYmlDb2Rlci5kZWNvZGUoZXJyb3IuaW5wdXRzLCBieXRlcy5zbGljZSg0KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvck5hbWUgPSBlcnJvci5uYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JTaWduYXR1cmUgPSBlcnJvci5mb3JtYXQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93RXJyb3IoXCJjYWxsIHJldmVydCBleGNlcHRpb25cIiArIG1lc3NhZ2UsIExvZ2dlci5lcnJvcnMuQ0FMTF9FWENFUFRJT04sIHtcbiAgICAgICAgICAgIG1ldGhvZDogZnVuY3Rpb25GcmFnbWVudC5mb3JtYXQoKSxcbiAgICAgICAgICAgIGRhdGE6IGhleGxpZnkoZGF0YSksIGVycm9yQXJncywgZXJyb3JOYW1lLCBlcnJvclNpZ25hdHVyZSwgcmVhc29uXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBFbmNvZGUgdGhlIHJlc3VsdCBmb3IgYSBmdW5jdGlvbiBjYWxsIChlLmcuIGZvciBldGhfY2FsbClcbiAgICBlbmNvZGVGdW5jdGlvblJlc3VsdChmdW5jdGlvbkZyYWdtZW50LCB2YWx1ZXMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAoZnVuY3Rpb25GcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uRnJhZ21lbnQgPSB0aGlzLmdldEZ1bmN0aW9uKGZ1bmN0aW9uRnJhZ21lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoZXhsaWZ5KHRoaXMuX2FiaUNvZGVyLmVuY29kZShmdW5jdGlvbkZyYWdtZW50Lm91dHB1dHMsIHZhbHVlcyB8fCBbXSkpO1xuICAgIH1cbiAgICAvLyBDcmVhdGUgdGhlIGZpbHRlciBmb3IgdGhlIGV2ZW50IHdpdGggc2VhcmNoIGNyaXRlcmlhIChlLmcuIGZvciBldGhfZmlsdGVyTG9nKVxuICAgIGVuY29kZUZpbHRlclRvcGljcyhldmVudEZyYWdtZW50LCB2YWx1ZXMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAoZXZlbnRGcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGV2ZW50RnJhZ21lbnQgPSB0aGlzLmdldEV2ZW50KGV2ZW50RnJhZ21lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZXMubGVuZ3RoID4gZXZlbnRGcmFnbWVudC5pbnB1dHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcInRvbyBtYW55IGFyZ3VtZW50cyBmb3IgXCIgKyBldmVudEZyYWdtZW50LmZvcm1hdCgpLCBMb2dnZXIuZXJyb3JzLlVORVhQRUNURURfQVJHVU1FTlQsIHtcbiAgICAgICAgICAgICAgICBhcmd1bWVudDogXCJ2YWx1ZXNcIixcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdG9waWNzID0gW107XG4gICAgICAgIGlmICghZXZlbnRGcmFnbWVudC5hbm9ueW1vdXMpIHtcbiAgICAgICAgICAgIHRvcGljcy5wdXNoKHRoaXMuZ2V0RXZlbnRUb3BpYyhldmVudEZyYWdtZW50KSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZW5jb2RlVG9waWMgPSAocGFyYW0sIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBpZiAocGFyYW0udHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBpZCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwYXJhbS50eXBlID09PSBcImJ5dGVzXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ga2VjY2FrMjU2KGhleGxpZnkodmFsdWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJhbS50eXBlID09PSBcImJvb2xcIiAmJiB0eXBlb2YgKHZhbHVlKSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9ICh2YWx1ZSA/IFwiMHgwMVwiIDogXCIweDAwXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcmFtLnR5cGUubWF0Y2goL151P2ludC8pKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBCaWdOdW1iZXIuZnJvbSh2YWx1ZSkudG9IZXhTdHJpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENoZWNrIGFkZHJlc3NlcyBhcmUgdmFsaWRcbiAgICAgICAgICAgIGlmIChwYXJhbS50eXBlID09PSBcImFkZHJlc3NcIikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FiaUNvZGVyLmVuY29kZShbXCJhZGRyZXNzXCJdLCBbdmFsdWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBoZXhaZXJvUGFkKGhleGxpZnkodmFsdWUpLCAzMik7XG4gICAgICAgIH07XG4gICAgICAgIHZhbHVlcy5mb3JFYWNoKCh2YWx1ZSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGxldCBwYXJhbSA9IGV2ZW50RnJhZ21lbnQuaW5wdXRzW2luZGV4XTtcbiAgICAgICAgICAgIGlmICghcGFyYW0uaW5kZXhlZCkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJjYW5ub3QgZmlsdGVyIG5vbi1pbmRleGVkIHBhcmFtZXRlcnM7IG11c3QgYmUgbnVsbFwiLCAoXCJjb250cmFjdC5cIiArIHBhcmFtLm5hbWUpLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdG9waWNzLnB1c2gobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwYXJhbS5iYXNlVHlwZSA9PT0gXCJhcnJheVwiIHx8IHBhcmFtLmJhc2VUeXBlID09PSBcInR1cGxlXCIpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiZmlsdGVyaW5nIHdpdGggdHVwbGVzIG9yIGFycmF5cyBub3Qgc3VwcG9ydGVkXCIsIChcImNvbnRyYWN0LlwiICsgcGFyYW0ubmFtZSksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdG9waWNzLnB1c2godmFsdWUubWFwKCh2YWx1ZSkgPT4gZW5jb2RlVG9waWMocGFyYW0sIHZhbHVlKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdG9waWNzLnB1c2goZW5jb2RlVG9waWMocGFyYW0sIHZhbHVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBUcmltIG9mZiB0cmFpbGluZyBudWxsc1xuICAgICAgICB3aGlsZSAodG9waWNzLmxlbmd0aCAmJiB0b3BpY3NbdG9waWNzLmxlbmd0aCAtIDFdID09PSBudWxsKSB7XG4gICAgICAgICAgICB0b3BpY3MucG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvcGljcztcbiAgICB9XG4gICAgZW5jb2RlRXZlbnRMb2coZXZlbnRGcmFnbWVudCwgdmFsdWVzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKGV2ZW50RnJhZ21lbnQpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBldmVudEZyYWdtZW50ID0gdGhpcy5nZXRFdmVudChldmVudEZyYWdtZW50KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0b3BpY3MgPSBbXTtcbiAgICAgICAgY29uc3QgZGF0YVR5cGVzID0gW107XG4gICAgICAgIGNvbnN0IGRhdGFWYWx1ZXMgPSBbXTtcbiAgICAgICAgaWYgKCFldmVudEZyYWdtZW50LmFub255bW91cykge1xuICAgICAgICAgICAgdG9waWNzLnB1c2godGhpcy5nZXRFdmVudFRvcGljKGV2ZW50RnJhZ21lbnQpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWVzLmxlbmd0aCAhPT0gZXZlbnRGcmFnbWVudC5pbnB1dHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiZXZlbnQgYXJndW1lbnRzL3ZhbHVlcyBtaXNtYXRjaFwiLCBcInZhbHVlc1wiLCB2YWx1ZXMpO1xuICAgICAgICB9XG4gICAgICAgIGV2ZW50RnJhZ21lbnQuaW5wdXRzLmZvckVhY2goKHBhcmFtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB2YWx1ZXNbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKHBhcmFtLmluZGV4ZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyYW0udHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICB0b3BpY3MucHVzaChpZCh2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwYXJhbS50eXBlID09PSBcImJ5dGVzXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9waWNzLnB1c2goa2VjY2FrMjU2KHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhcmFtLmJhc2VUeXBlID09PSBcInR1cGxlXCIgfHwgcGFyYW0uYmFzZVR5cGUgPT09IFwiYXJyYXlcIikge1xuICAgICAgICAgICAgICAgICAgICAvLyBAVE9ET1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub3QgaW1wbGVtZW50ZWRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0b3BpY3MucHVzaCh0aGlzLl9hYmlDb2Rlci5lbmNvZGUoW3BhcmFtLnR5cGVdLCBbdmFsdWVdKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGF0YVR5cGVzLnB1c2gocGFyYW0pO1xuICAgICAgICAgICAgICAgIGRhdGFWYWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YTogdGhpcy5fYWJpQ29kZXIuZW5jb2RlKGRhdGFUeXBlcywgZGF0YVZhbHVlcyksXG4gICAgICAgICAgICB0b3BpY3M6IHRvcGljc1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBEZWNvZGUgYSBmaWx0ZXIgZm9yIHRoZSBldmVudCBhbmQgdGhlIHNlYXJjaCBjcml0ZXJpYVxuICAgIGRlY29kZUV2ZW50TG9nKGV2ZW50RnJhZ21lbnQsIGRhdGEsIHRvcGljcykge1xuICAgICAgICBpZiAodHlwZW9mIChldmVudEZyYWdtZW50KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgZXZlbnRGcmFnbWVudCA9IHRoaXMuZ2V0RXZlbnQoZXZlbnRGcmFnbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRvcGljcyAhPSBudWxsICYmICFldmVudEZyYWdtZW50LmFub255bW91cykge1xuICAgICAgICAgICAgbGV0IHRvcGljSGFzaCA9IHRoaXMuZ2V0RXZlbnRUb3BpYyhldmVudEZyYWdtZW50KTtcbiAgICAgICAgICAgIGlmICghaXNIZXhTdHJpbmcodG9waWNzWzBdLCAzMikgfHwgdG9waWNzWzBdLnRvTG93ZXJDYXNlKCkgIT09IHRvcGljSGFzaCkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiZnJhZ21lbnQvdG9waWMgbWlzbWF0Y2hcIiwgTG9nZ2VyLmVycm9ycy5JTlZBTElEX0FSR1VNRU5ULCB7IGFyZ3VtZW50OiBcInRvcGljc1swXVwiLCBleHBlY3RlZDogdG9waWNIYXNoLCB2YWx1ZTogdG9waWNzWzBdIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG9waWNzID0gdG9waWNzLnNsaWNlKDEpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBpbmRleGVkID0gW107XG4gICAgICAgIGxldCBub25JbmRleGVkID0gW107XG4gICAgICAgIGxldCBkeW5hbWljID0gW107XG4gICAgICAgIGV2ZW50RnJhZ21lbnQuaW5wdXRzLmZvckVhY2goKHBhcmFtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgaWYgKHBhcmFtLmluZGV4ZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyYW0udHlwZSA9PT0gXCJzdHJpbmdcIiB8fCBwYXJhbS50eXBlID09PSBcImJ5dGVzXCIgfHwgcGFyYW0uYmFzZVR5cGUgPT09IFwidHVwbGVcIiB8fCBwYXJhbS5iYXNlVHlwZSA9PT0gXCJhcnJheVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ZWQucHVzaChQYXJhbVR5cGUuZnJvbU9iamVjdCh7IHR5cGU6IFwiYnl0ZXMzMlwiLCBuYW1lOiBwYXJhbS5uYW1lIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgZHluYW1pYy5wdXNoKHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXhlZC5wdXNoKHBhcmFtKTtcbiAgICAgICAgICAgICAgICAgICAgZHluYW1pYy5wdXNoKGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBub25JbmRleGVkLnB1c2gocGFyYW0pO1xuICAgICAgICAgICAgICAgIGR5bmFtaWMucHVzaChmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgcmVzdWx0SW5kZXhlZCA9ICh0b3BpY3MgIT0gbnVsbCkgPyB0aGlzLl9hYmlDb2Rlci5kZWNvZGUoaW5kZXhlZCwgY29uY2F0KHRvcGljcykpIDogbnVsbDtcbiAgICAgICAgbGV0IHJlc3VsdE5vbkluZGV4ZWQgPSB0aGlzLl9hYmlDb2Rlci5kZWNvZGUobm9uSW5kZXhlZCwgZGF0YSwgdHJ1ZSk7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgbGV0IG5vbkluZGV4ZWRJbmRleCA9IDAsIGluZGV4ZWRJbmRleCA9IDA7XG4gICAgICAgIGV2ZW50RnJhZ21lbnQuaW5wdXRzLmZvckVhY2goKHBhcmFtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgaWYgKHBhcmFtLmluZGV4ZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0SW5kZXhlZCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpbmRleF0gPSBuZXcgSW5kZXhlZCh7IF9pc0luZGV4ZWQ6IHRydWUsIGhhc2g6IG51bGwgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGR5bmFtaWNbaW5kZXhdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpbmRleF0gPSBuZXcgSW5kZXhlZCh7IF9pc0luZGV4ZWQ6IHRydWUsIGhhc2g6IHJlc3VsdEluZGV4ZWRbaW5kZXhlZEluZGV4KytdIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpbmRleF0gPSByZXN1bHRJbmRleGVkW2luZGV4ZWRJbmRleCsrXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpbmRleF0gPSBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpbmRleF0gPSByZXN1bHROb25JbmRleGVkW25vbkluZGV4ZWRJbmRleCsrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpbmRleF0gPSBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBZGQgdGhlIGtleXdvcmQgYXJndW1lbnQgaWYgbmFtZWQgYW5kIHNhZmVcbiAgICAgICAgICAgIGlmIChwYXJhbS5uYW1lICYmIHJlc3VsdFtwYXJhbS5uYW1lXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSByZXN1bHRbaW5kZXhdO1xuICAgICAgICAgICAgICAgIC8vIE1ha2UgZXJyb3IgbmFtZWQgdmFsdWVzIHRocm93IG9uIGFjY2Vzc1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXN1bHQsIHBhcmFtLm5hbWUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQ6ICgpID0+IHsgdGhyb3cgd3JhcEFjY2Vzc0Vycm9yKGBwcm9wZXJ0eSAke0pTT04uc3RyaW5naWZ5KHBhcmFtLm5hbWUpfWAsIHZhbHVlKTsgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtwYXJhbS5uYW1lXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIE1ha2UgYWxsIGVycm9yIGluZGV4ZWQgdmFsdWVzIHRocm93IG9uIGFjY2Vzc1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3VsdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSByZXN1bHRbaV07XG4gICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXN1bHQsIGksIHtcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiAoKSA9PiB7IHRocm93IHdyYXBBY2Nlc3NFcnJvcihgaW5kZXggJHtpfWAsIHZhbHVlKTsgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPYmplY3QuZnJlZXplKHJlc3VsdCk7XG4gICAgfVxuICAgIC8vIEdpdmVuIGEgdHJhbnNhY3Rpb24sIGZpbmQgdGhlIG1hdGNoaW5nIGZ1bmN0aW9uIGZyYWdtZW50IChpZiBhbnkpIGFuZFxuICAgIC8vIGRldGVybWluZSBhbGwgaXRzIHByb3BlcnRpZXMgYW5kIGNhbGwgcGFyYW1ldGVyc1xuICAgIHBhcnNlVHJhbnNhY3Rpb24odHgpIHtcbiAgICAgICAgbGV0IGZyYWdtZW50ID0gdGhpcy5nZXRGdW5jdGlvbih0eC5kYXRhLnN1YnN0cmluZygwLCAxMCkudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgIGlmICghZnJhZ21lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25EZXNjcmlwdGlvbih7XG4gICAgICAgICAgICBhcmdzOiB0aGlzLl9hYmlDb2Rlci5kZWNvZGUoZnJhZ21lbnQuaW5wdXRzLCBcIjB4XCIgKyB0eC5kYXRhLnN1YnN0cmluZygxMCkpLFxuICAgICAgICAgICAgZnVuY3Rpb25GcmFnbWVudDogZnJhZ21lbnQsXG4gICAgICAgICAgICBuYW1lOiBmcmFnbWVudC5uYW1lLFxuICAgICAgICAgICAgc2lnbmF0dXJlOiBmcmFnbWVudC5mb3JtYXQoKSxcbiAgICAgICAgICAgIHNpZ2hhc2g6IHRoaXMuZ2V0U2lnaGFzaChmcmFnbWVudCksXG4gICAgICAgICAgICB2YWx1ZTogQmlnTnVtYmVyLmZyb20odHgudmFsdWUgfHwgXCIwXCIpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gQFRPRE9cbiAgICAvL3BhcnNlQ2FsbFJlc3VsdChkYXRhOiBCeXRlc0xpa2UpOiA/P1xuICAgIC8vIEdpdmVuIGFuIGV2ZW50IGxvZywgZmluZCB0aGUgbWF0Y2hpbmcgZXZlbnQgZnJhZ21lbnQgKGlmIGFueSkgYW5kXG4gICAgLy8gZGV0ZXJtaW5lIGFsbCBpdHMgcHJvcGVydGllcyBhbmQgdmFsdWVzXG4gICAgcGFyc2VMb2cobG9nKSB7XG4gICAgICAgIGxldCBmcmFnbWVudCA9IHRoaXMuZ2V0RXZlbnQobG9nLnRvcGljc1swXSk7XG4gICAgICAgIGlmICghZnJhZ21lbnQgfHwgZnJhZ21lbnQuYW5vbnltb3VzKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBAVE9ETzogSWYgYW5vbnltb3VzLCBhbmQgdGhlIG9ubHkgbWV0aG9kLCBhbmQgdGhlIGlucHV0IGNvdW50IG1hdGNoZXMsIHNob3VsZCB3ZSBwYXJzZT9cbiAgICAgICAgLy8gICAgICAgIFByb2JhYmx5IG5vdCwgYmVjYXVzZSBqdXN0IGJlY2F1c2UgaXQgaXMgdGhlIG9ubHkgZXZlbnQgaW4gdGhlIEFCSSBkb2VzXG4gICAgICAgIC8vICAgICAgICBub3QgbWVhbiB3ZSBoYXZlIHRoZSBmdWxsIEFCSTsgbWF5YmUganVzdCBhIGZyYWdtZW50P1xuICAgICAgICByZXR1cm4gbmV3IExvZ0Rlc2NyaXB0aW9uKHtcbiAgICAgICAgICAgIGV2ZW50RnJhZ21lbnQ6IGZyYWdtZW50LFxuICAgICAgICAgICAgbmFtZTogZnJhZ21lbnQubmFtZSxcbiAgICAgICAgICAgIHNpZ25hdHVyZTogZnJhZ21lbnQuZm9ybWF0KCksXG4gICAgICAgICAgICB0b3BpYzogdGhpcy5nZXRFdmVudFRvcGljKGZyYWdtZW50KSxcbiAgICAgICAgICAgIGFyZ3M6IHRoaXMuZGVjb2RlRXZlbnRMb2coZnJhZ21lbnQsIGxvZy5kYXRhLCBsb2cudG9waWNzKVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcGFyc2VFcnJvcihkYXRhKSB7XG4gICAgICAgIGNvbnN0IGhleERhdGEgPSBoZXhsaWZ5KGRhdGEpO1xuICAgICAgICBsZXQgZnJhZ21lbnQgPSB0aGlzLmdldEVycm9yKGhleERhdGEuc3Vic3RyaW5nKDAsIDEwKS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgaWYgKCFmcmFnbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvckRlc2NyaXB0aW9uKHtcbiAgICAgICAgICAgIGFyZ3M6IHRoaXMuX2FiaUNvZGVyLmRlY29kZShmcmFnbWVudC5pbnB1dHMsIFwiMHhcIiArIGhleERhdGEuc3Vic3RyaW5nKDEwKSksXG4gICAgICAgICAgICBlcnJvckZyYWdtZW50OiBmcmFnbWVudCxcbiAgICAgICAgICAgIG5hbWU6IGZyYWdtZW50Lm5hbWUsXG4gICAgICAgICAgICBzaWduYXR1cmU6IGZyYWdtZW50LmZvcm1hdCgpLFxuICAgICAgICAgICAgc2lnaGFzaDogdGhpcy5nZXRTaWdoYXNoKGZyYWdtZW50KSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qXG4gICAgc3RhdGljIGZyb20odmFsdWU6IEFycmF5PEZyYWdtZW50IHwgc3RyaW5nIHwgSnNvbkFiaT4gfCBzdHJpbmcgfCBJbnRlcmZhY2UpIHtcbiAgICAgICAgaWYgKEludGVyZmFjZS5pc0ludGVyZmFjZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mKHZhbHVlKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnRlcmZhY2UoSlNPTi5wYXJzZSh2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgSW50ZXJmYWNlKHZhbHVlKTtcbiAgICB9XG4gICAgKi9cbiAgICBzdGF0aWMgaXNJbnRlcmZhY2UodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlLl9pc0ludGVyZmFjZSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW50ZXJmYWNlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ethersproject/abi/lib.esm/interface.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@ethersproject/abstract-provider/lib.esm/_version.js":
/*!****************************************************************************!*\
  !*** ../node_modules/@ethersproject/abstract-provider/lib.esm/_version.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\nconst version = \"abstract-provider/5.7.0\";\n//# sourceMappingURL=_version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2Fic3RyYWN0LXByb3ZpZGVyL2xpYi5lc20vX3ZlcnNpb24uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFPO0FBQ1AiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sZWRnaXR5LXlpZWxkLWZyb250ZW5kLy4uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9hYnN0cmFjdC1wcm92aWRlci9saWIuZXNtL192ZXJzaW9uLmpzPzgwMDQiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IHZlcnNpb24gPSBcImFic3RyYWN0LXByb3ZpZGVyLzUuNy4wXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdmVyc2lvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ethersproject/abstract-provider/lib.esm/_version.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@ethersproject/abstract-provider/lib.esm/index.js":
/*!*************************************************************************!*\
  !*** ../node_modules/@ethersproject/abstract-provider/lib.esm/index.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BlockForkEvent: () => (/* binding */ BlockForkEvent),\n/* harmony export */   ForkEvent: () => (/* binding */ ForkEvent),\n/* harmony export */   Provider: () => (/* binding */ Provider),\n/* harmony export */   TransactionForkEvent: () => (/* binding */ TransactionForkEvent),\n/* harmony export */   TransactionOrderForkEvent: () => (/* binding */ TransactionOrderForkEvent)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethersproject/bignumber */ \"(ssr)/../node_modules/@ethersproject/bignumber/lib.esm/bignumber.js\");\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/../node_modules/@ethersproject/bytes/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/../node_modules/@ethersproject/properties/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/../node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(ssr)/../node_modules/@ethersproject/abstract-provider/lib.esm/_version.js\");\n\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\n;\n;\n//export type CallTransactionable = {\n//    call(transaction: TransactionRequest): Promise<TransactionResponse>;\n//};\nclass ForkEvent extends _ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.Description {\n    static isForkEvent(value) {\n        return !!(value && value._isForkEvent);\n    }\n}\nclass BlockForkEvent extends ForkEvent {\n    constructor(blockHash, expiry) {\n        if (!(0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.isHexString)(blockHash, 32)) {\n            logger.throwArgumentError(\"invalid blockHash\", \"blockHash\", blockHash);\n        }\n        super({\n            _isForkEvent: true,\n            _isBlockForkEvent: true,\n            expiry: (expiry || 0),\n            blockHash: blockHash\n        });\n    }\n}\nclass TransactionForkEvent extends ForkEvent {\n    constructor(hash, expiry) {\n        if (!(0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.isHexString)(hash, 32)) {\n            logger.throwArgumentError(\"invalid transaction hash\", \"hash\", hash);\n        }\n        super({\n            _isForkEvent: true,\n            _isTransactionForkEvent: true,\n            expiry: (expiry || 0),\n            hash: hash\n        });\n    }\n}\nclass TransactionOrderForkEvent extends ForkEvent {\n    constructor(beforeHash, afterHash, expiry) {\n        if (!(0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.isHexString)(beforeHash, 32)) {\n            logger.throwArgumentError(\"invalid transaction hash\", \"beforeHash\", beforeHash);\n        }\n        if (!(0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.isHexString)(afterHash, 32)) {\n            logger.throwArgumentError(\"invalid transaction hash\", \"afterHash\", afterHash);\n        }\n        super({\n            _isForkEvent: true,\n            _isTransactionOrderForkEvent: true,\n            expiry: (expiry || 0),\n            beforeHash: beforeHash,\n            afterHash: afterHash\n        });\n    }\n}\n///////////////////////////////\n// Exported Abstracts\nclass Provider {\n    constructor() {\n        logger.checkAbstract(new.target, Provider);\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.defineReadOnly)(this, \"_isProvider\", true);\n    }\n    getFeeData() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { block, gasPrice } = yield (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.resolveProperties)({\n                block: this.getBlock(\"latest\"),\n                gasPrice: this.getGasPrice().catch((error) => {\n                    // @TODO: Why is this now failing on Calaveras?\n                    //console.log(error);\n                    return null;\n                })\n            });\n            let lastBaseFeePerGas = null, maxFeePerGas = null, maxPriorityFeePerGas = null;\n            if (block && block.baseFeePerGas) {\n                // We may want to compute this more accurately in the future,\n                // using the formula \"check if the base fee is correct\".\n                // See: https://eips.ethereum.org/EIPS/eip-1559\n                lastBaseFeePerGas = block.baseFeePerGas;\n                maxPriorityFeePerGas = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(\"1500000000\");\n                maxFeePerGas = block.baseFeePerGas.mul(2).add(maxPriorityFeePerGas);\n            }\n            return { lastBaseFeePerGas, maxFeePerGas, maxPriorityFeePerGas, gasPrice };\n        });\n    }\n    // Alias for \"on\"\n    addListener(eventName, listener) {\n        return this.on(eventName, listener);\n    }\n    // Alias for \"off\"\n    removeListener(eventName, listener) {\n        return this.off(eventName, listener);\n    }\n    static isProvider(value) {\n        return !!(value && value._isProvider);\n    }\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2Fic3RyYWN0LXByb3ZpZGVyL2xpYi5lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFhO0FBQ2IsaUJBQWlCLFNBQUksSUFBSSxTQUFJO0FBQzdCLDRCQUE0QiwrREFBK0QsaUJBQWlCO0FBQzVHO0FBQ0Esb0NBQW9DLE1BQU0sK0JBQStCLFlBQVk7QUFDckYsbUNBQW1DLE1BQU0sbUNBQW1DLFlBQVk7QUFDeEYsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMO0FBQ3FEO0FBQ0Y7QUFDd0M7QUFDNUM7QUFDVjtBQUNyQyxtQkFBbUIseURBQU0sQ0FBQyw2Q0FBTztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sd0JBQXdCLGtFQUFXO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLGFBQWEsaUVBQVc7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNPO0FBQ1A7QUFDQSxhQUFhLGlFQUFXO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDTztBQUNQO0FBQ0EsYUFBYSxpRUFBVztBQUN4QjtBQUNBO0FBQ0EsYUFBYSxpRUFBVztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsUUFBUSx5RUFBYztBQUN0QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCLFFBQVEsNEVBQWlCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QywrREFBUztBQUNoRDtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGVkZ2l0eS15aWVsZC1mcm9udGVuZC8uLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvYWJzdHJhY3QtcHJvdmlkZXIvbGliLmVzbS9pbmRleC5qcz9hNWYzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5pbXBvcnQgeyBCaWdOdW1iZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYmlnbnVtYmVyXCI7XG5pbXBvcnQgeyBpc0hleFN0cmluZyB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9ieXRlc1wiO1xuaW1wb3J0IHsgRGVzY3JpcHRpb24sIGRlZmluZVJlYWRPbmx5LCByZXNvbHZlUHJvcGVydGllcyB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9wcm9wZXJ0aWVzXCI7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvbG9nZ2VyXCI7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4vX3ZlcnNpb25cIjtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIodmVyc2lvbik7XG47XG47XG4vL2V4cG9ydCB0eXBlIENhbGxUcmFuc2FjdGlvbmFibGUgPSB7XG4vLyAgICBjYWxsKHRyYW5zYWN0aW9uOiBUcmFuc2FjdGlvblJlcXVlc3QpOiBQcm9taXNlPFRyYW5zYWN0aW9uUmVzcG9uc2U+O1xuLy99O1xuZXhwb3J0IGNsYXNzIEZvcmtFdmVudCBleHRlbmRzIERlc2NyaXB0aW9uIHtcbiAgICBzdGF0aWMgaXNGb3JrRXZlbnQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlLl9pc0ZvcmtFdmVudCk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEJsb2NrRm9ya0V2ZW50IGV4dGVuZHMgRm9ya0V2ZW50IHtcbiAgICBjb25zdHJ1Y3RvcihibG9ja0hhc2gsIGV4cGlyeSkge1xuICAgICAgICBpZiAoIWlzSGV4U3RyaW5nKGJsb2NrSGFzaCwgMzIpKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBibG9ja0hhc2hcIiwgXCJibG9ja0hhc2hcIiwgYmxvY2tIYXNoKTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICBfaXNGb3JrRXZlbnQ6IHRydWUsXG4gICAgICAgICAgICBfaXNCbG9ja0ZvcmtFdmVudDogdHJ1ZSxcbiAgICAgICAgICAgIGV4cGlyeTogKGV4cGlyeSB8fCAwKSxcbiAgICAgICAgICAgIGJsb2NrSGFzaDogYmxvY2tIYXNoXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBUcmFuc2FjdGlvbkZvcmtFdmVudCBleHRlbmRzIEZvcmtFdmVudCB7XG4gICAgY29uc3RydWN0b3IoaGFzaCwgZXhwaXJ5KSB7XG4gICAgICAgIGlmICghaXNIZXhTdHJpbmcoaGFzaCwgMzIpKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCB0cmFuc2FjdGlvbiBoYXNoXCIsIFwiaGFzaFwiLCBoYXNoKTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICBfaXNGb3JrRXZlbnQ6IHRydWUsXG4gICAgICAgICAgICBfaXNUcmFuc2FjdGlvbkZvcmtFdmVudDogdHJ1ZSxcbiAgICAgICAgICAgIGV4cGlyeTogKGV4cGlyeSB8fCAwKSxcbiAgICAgICAgICAgIGhhc2g6IGhhc2hcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFRyYW5zYWN0aW9uT3JkZXJGb3JrRXZlbnQgZXh0ZW5kcyBGb3JrRXZlbnQge1xuICAgIGNvbnN0cnVjdG9yKGJlZm9yZUhhc2gsIGFmdGVySGFzaCwgZXhwaXJ5KSB7XG4gICAgICAgIGlmICghaXNIZXhTdHJpbmcoYmVmb3JlSGFzaCwgMzIpKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCB0cmFuc2FjdGlvbiBoYXNoXCIsIFwiYmVmb3JlSGFzaFwiLCBiZWZvcmVIYXNoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzSGV4U3RyaW5nKGFmdGVySGFzaCwgMzIpKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCB0cmFuc2FjdGlvbiBoYXNoXCIsIFwiYWZ0ZXJIYXNoXCIsIGFmdGVySGFzaCk7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgX2lzRm9ya0V2ZW50OiB0cnVlLFxuICAgICAgICAgICAgX2lzVHJhbnNhY3Rpb25PcmRlckZvcmtFdmVudDogdHJ1ZSxcbiAgICAgICAgICAgIGV4cGlyeTogKGV4cGlyeSB8fCAwKSxcbiAgICAgICAgICAgIGJlZm9yZUhhc2g6IGJlZm9yZUhhc2gsXG4gICAgICAgICAgICBhZnRlckhhc2g6IGFmdGVySGFzaFxuICAgICAgICB9KTtcbiAgICB9XG59XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBFeHBvcnRlZCBBYnN0cmFjdHNcbmV4cG9ydCBjbGFzcyBQcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIGxvZ2dlci5jaGVja0Fic3RyYWN0KG5ldy50YXJnZXQsIFByb3ZpZGVyKTtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJfaXNQcm92aWRlclwiLCB0cnVlKTtcbiAgICB9XG4gICAgZ2V0RmVlRGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgYmxvY2ssIGdhc1ByaWNlIH0gPSB5aWVsZCByZXNvbHZlUHJvcGVydGllcyh7XG4gICAgICAgICAgICAgICAgYmxvY2s6IHRoaXMuZ2V0QmxvY2soXCJsYXRlc3RcIiksXG4gICAgICAgICAgICAgICAgZ2FzUHJpY2U6IHRoaXMuZ2V0R2FzUHJpY2UoKS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQFRPRE86IFdoeSBpcyB0aGlzIG5vdyBmYWlsaW5nIG9uIENhbGF2ZXJhcz9cbiAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxldCBsYXN0QmFzZUZlZVBlckdhcyA9IG51bGwsIG1heEZlZVBlckdhcyA9IG51bGwsIG1heFByaW9yaXR5RmVlUGVyR2FzID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChibG9jayAmJiBibG9jay5iYXNlRmVlUGVyR2FzKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgbWF5IHdhbnQgdG8gY29tcHV0ZSB0aGlzIG1vcmUgYWNjdXJhdGVseSBpbiB0aGUgZnV0dXJlLFxuICAgICAgICAgICAgICAgIC8vIHVzaW5nIHRoZSBmb3JtdWxhIFwiY2hlY2sgaWYgdGhlIGJhc2UgZmVlIGlzIGNvcnJlY3RcIi5cbiAgICAgICAgICAgICAgICAvLyBTZWU6IGh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtMTU1OVxuICAgICAgICAgICAgICAgIGxhc3RCYXNlRmVlUGVyR2FzID0gYmxvY2suYmFzZUZlZVBlckdhcztcbiAgICAgICAgICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhcyA9IEJpZ051bWJlci5mcm9tKFwiMTUwMDAwMDAwMFwiKTtcbiAgICAgICAgICAgICAgICBtYXhGZWVQZXJHYXMgPSBibG9jay5iYXNlRmVlUGVyR2FzLm11bCgyKS5hZGQobWF4UHJpb3JpdHlGZWVQZXJHYXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgbGFzdEJhc2VGZWVQZXJHYXMsIG1heEZlZVBlckdhcywgbWF4UHJpb3JpdHlGZWVQZXJHYXMsIGdhc1ByaWNlIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBBbGlhcyBmb3IgXCJvblwiXG4gICAgYWRkTGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gdGhpcy5vbihldmVudE5hbWUsIGxpc3RlbmVyKTtcbiAgICB9XG4gICAgLy8gQWxpYXMgZm9yIFwib2ZmXCJcbiAgICByZW1vdmVMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9mZihldmVudE5hbWUsIGxpc3RlbmVyKTtcbiAgICB9XG4gICAgc3RhdGljIGlzUHJvdmlkZXIodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlLl9pc1Byb3ZpZGVyKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ethersproject/abstract-provider/lib.esm/index.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@ethersproject/abstract-signer/lib.esm/_version.js":
/*!**************************************************************************!*\
  !*** ../node_modules/@ethersproject/abstract-signer/lib.esm/_version.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\nconst version = \"abstract-signer/5.7.0\";\n//# sourceMappingURL=_version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2Fic3RyYWN0LXNpZ25lci9saWIuZXNtL192ZXJzaW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBTztBQUNQIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGVkZ2l0eS15aWVsZC1mcm9udGVuZC8uLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvYWJzdHJhY3Qtc2lnbmVyL2xpYi5lc20vX3ZlcnNpb24uanM/ZWVhZCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgdmVyc2lvbiA9IFwiYWJzdHJhY3Qtc2lnbmVyLzUuNy4wXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdmVyc2lvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ethersproject/abstract-signer/lib.esm/_version.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@ethersproject/abstract-signer/lib.esm/index.js":
/*!***********************************************************************!*\
  !*** ../node_modules/@ethersproject/abstract-signer/lib.esm/index.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Signer: () => (/* binding */ Signer),\n/* harmony export */   VoidSigner: () => (/* binding */ VoidSigner)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/../node_modules/@ethersproject/properties/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/../node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(ssr)/../node_modules/@ethersproject/abstract-signer/lib.esm/_version.js\");\n\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\nconst allowedTransactionKeys = [\n    \"accessList\", \"ccipReadEnabled\", \"chainId\", \"customData\", \"data\", \"from\", \"gasLimit\", \"gasPrice\", \"maxFeePerGas\", \"maxPriorityFeePerGas\", \"nonce\", \"to\", \"type\", \"value\"\n];\nconst forwardErrors = [\n    _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.INSUFFICIENT_FUNDS,\n    _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.NONCE_EXPIRED,\n    _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.REPLACEMENT_UNDERPRICED,\n];\n;\n;\nclass Signer {\n    ///////////////////\n    // Sub-classes MUST call super\n    constructor() {\n        logger.checkAbstract(new.target, Signer);\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.defineReadOnly)(this, \"_isSigner\", true);\n    }\n    ///////////////////\n    // Sub-classes MAY override these\n    getBalance(blockTag) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this._checkProvider(\"getBalance\");\n            return yield this.provider.getBalance(this.getAddress(), blockTag);\n        });\n    }\n    getTransactionCount(blockTag) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this._checkProvider(\"getTransactionCount\");\n            return yield this.provider.getTransactionCount(this.getAddress(), blockTag);\n        });\n    }\n    // Populates \"from\" if unspecified, and estimates the gas for the transaction\n    estimateGas(transaction) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this._checkProvider(\"estimateGas\");\n            const tx = yield (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.resolveProperties)(this.checkTransaction(transaction));\n            return yield this.provider.estimateGas(tx);\n        });\n    }\n    // Populates \"from\" if unspecified, and calls with the transaction\n    call(transaction, blockTag) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this._checkProvider(\"call\");\n            const tx = yield (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.resolveProperties)(this.checkTransaction(transaction));\n            return yield this.provider.call(tx, blockTag);\n        });\n    }\n    // Populates all fields in a transaction, signs it and sends it to the network\n    sendTransaction(transaction) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this._checkProvider(\"sendTransaction\");\n            const tx = yield this.populateTransaction(transaction);\n            const signedTx = yield this.signTransaction(tx);\n            return yield this.provider.sendTransaction(signedTx);\n        });\n    }\n    getChainId() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this._checkProvider(\"getChainId\");\n            const network = yield this.provider.getNetwork();\n            return network.chainId;\n        });\n    }\n    getGasPrice() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this._checkProvider(\"getGasPrice\");\n            return yield this.provider.getGasPrice();\n        });\n    }\n    getFeeData() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this._checkProvider(\"getFeeData\");\n            return yield this.provider.getFeeData();\n        });\n    }\n    resolveName(name) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this._checkProvider(\"resolveName\");\n            return yield this.provider.resolveName(name);\n        });\n    }\n    // Checks a transaction does not contain invalid keys and if\n    // no \"from\" is provided, populates it.\n    // - does NOT require a provider\n    // - adds \"from\" is not present\n    // - returns a COPY (safe to mutate the result)\n    // By default called from: (overriding these prevents it)\n    //   - call\n    //   - estimateGas\n    //   - populateTransaction (and therefor sendTransaction)\n    checkTransaction(transaction) {\n        for (const key in transaction) {\n            if (allowedTransactionKeys.indexOf(key) === -1) {\n                logger.throwArgumentError(\"invalid transaction key: \" + key, \"transaction\", transaction);\n            }\n        }\n        const tx = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.shallowCopy)(transaction);\n        if (tx.from == null) {\n            tx.from = this.getAddress();\n        }\n        else {\n            // Make sure any provided address matches this signer\n            tx.from = Promise.all([\n                Promise.resolve(tx.from),\n                this.getAddress()\n            ]).then((result) => {\n                if (result[0].toLowerCase() !== result[1].toLowerCase()) {\n                    logger.throwArgumentError(\"from address mismatch\", \"transaction\", transaction);\n                }\n                return result[0];\n            });\n        }\n        return tx;\n    }\n    // Populates ALL keys for a transaction and checks that \"from\" matches\n    // this Signer. Should be used by sendTransaction but NOT by signTransaction.\n    // By default called from: (overriding these prevents it)\n    //   - sendTransaction\n    //\n    // Notes:\n    //  - We allow gasPrice for EIP-1559 as long as it matches maxFeePerGas\n    populateTransaction(transaction) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const tx = yield (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.resolveProperties)(this.checkTransaction(transaction));\n            if (tx.to != null) {\n                tx.to = Promise.resolve(tx.to).then((to) => __awaiter(this, void 0, void 0, function* () {\n                    if (to == null) {\n                        return null;\n                    }\n                    const address = yield this.resolveName(to);\n                    if (address == null) {\n                        logger.throwArgumentError(\"provided ENS name resolves to null\", \"tx.to\", to);\n                    }\n                    return address;\n                }));\n                // Prevent this error from causing an UnhandledPromiseException\n                tx.to.catch((error) => { });\n            }\n            // Do not allow mixing pre-eip-1559 and eip-1559 properties\n            const hasEip1559 = (tx.maxFeePerGas != null || tx.maxPriorityFeePerGas != null);\n            if (tx.gasPrice != null && (tx.type === 2 || hasEip1559)) {\n                logger.throwArgumentError(\"eip-1559 transaction do not support gasPrice\", \"transaction\", transaction);\n            }\n            else if ((tx.type === 0 || tx.type === 1) && hasEip1559) {\n                logger.throwArgumentError(\"pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas\", \"transaction\", transaction);\n            }\n            if ((tx.type === 2 || tx.type == null) && (tx.maxFeePerGas != null && tx.maxPriorityFeePerGas != null)) {\n                // Fully-formed EIP-1559 transaction (skip getFeeData)\n                tx.type = 2;\n            }\n            else if (tx.type === 0 || tx.type === 1) {\n                // Explicit Legacy or EIP-2930 transaction\n                // Populate missing gasPrice\n                if (tx.gasPrice == null) {\n                    tx.gasPrice = this.getGasPrice();\n                }\n            }\n            else {\n                // We need to get fee data to determine things\n                const feeData = yield this.getFeeData();\n                if (tx.type == null) {\n                    // We need to auto-detect the intended type of this transaction...\n                    if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {\n                        // The network supports EIP-1559!\n                        // Upgrade transaction from null to eip-1559\n                        tx.type = 2;\n                        if (tx.gasPrice != null) {\n                            // Using legacy gasPrice property on an eip-1559 network,\n                            // so use gasPrice as both fee properties\n                            const gasPrice = tx.gasPrice;\n                            delete tx.gasPrice;\n                            tx.maxFeePerGas = gasPrice;\n                            tx.maxPriorityFeePerGas = gasPrice;\n                        }\n                        else {\n                            // Populate missing fee data\n                            if (tx.maxFeePerGas == null) {\n                                tx.maxFeePerGas = feeData.maxFeePerGas;\n                            }\n                            if (tx.maxPriorityFeePerGas == null) {\n                                tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;\n                            }\n                        }\n                    }\n                    else if (feeData.gasPrice != null) {\n                        // Network doesn't support EIP-1559...\n                        // ...but they are trying to use EIP-1559 properties\n                        if (hasEip1559) {\n                            logger.throwError(\"network does not support EIP-1559\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n                                operation: \"populateTransaction\"\n                            });\n                        }\n                        // Populate missing fee data\n                        if (tx.gasPrice == null) {\n                            tx.gasPrice = feeData.gasPrice;\n                        }\n                        // Explicitly set untyped transaction to legacy\n                        tx.type = 0;\n                    }\n                    else {\n                        // getFeeData has failed us.\n                        logger.throwError(\"failed to get consistent fee data\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n                            operation: \"signer.getFeeData\"\n                        });\n                    }\n                }\n                else if (tx.type === 2) {\n                    // Explicitly using EIP-1559\n                    // Populate missing fee data\n                    if (tx.maxFeePerGas == null) {\n                        tx.maxFeePerGas = feeData.maxFeePerGas;\n                    }\n                    if (tx.maxPriorityFeePerGas == null) {\n                        tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;\n                    }\n                }\n            }\n            if (tx.nonce == null) {\n                tx.nonce = this.getTransactionCount(\"pending\");\n            }\n            if (tx.gasLimit == null) {\n                tx.gasLimit = this.estimateGas(tx).catch((error) => {\n                    if (forwardErrors.indexOf(error.code) >= 0) {\n                        throw error;\n                    }\n                    return logger.throwError(\"cannot estimate gas; transaction may fail or may require manual gas limit\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNPREDICTABLE_GAS_LIMIT, {\n                        error: error,\n                        tx: tx\n                    });\n                });\n            }\n            if (tx.chainId == null) {\n                tx.chainId = this.getChainId();\n            }\n            else {\n                tx.chainId = Promise.all([\n                    Promise.resolve(tx.chainId),\n                    this.getChainId()\n                ]).then((results) => {\n                    if (results[1] !== 0 && results[0] !== results[1]) {\n                        logger.throwArgumentError(\"chainId address mismatch\", \"transaction\", transaction);\n                    }\n                    return results[0];\n                });\n            }\n            return yield (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.resolveProperties)(tx);\n        });\n    }\n    ///////////////////\n    // Sub-classes SHOULD leave these alone\n    _checkProvider(operation) {\n        if (!this.provider) {\n            logger.throwError(\"missing provider\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: (operation || \"_checkProvider\")\n            });\n        }\n    }\n    static isSigner(value) {\n        return !!(value && value._isSigner);\n    }\n}\nclass VoidSigner extends Signer {\n    constructor(address, provider) {\n        super();\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.defineReadOnly)(this, \"address\", address);\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.defineReadOnly)(this, \"provider\", provider || null);\n    }\n    getAddress() {\n        return Promise.resolve(this.address);\n    }\n    _fail(message, operation) {\n        return Promise.resolve().then(() => {\n            logger.throwError(message, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, { operation: operation });\n        });\n    }\n    signMessage(message) {\n        return this._fail(\"VoidSigner cannot sign messages\", \"signMessage\");\n    }\n    signTransaction(transaction) {\n        return this._fail(\"VoidSigner cannot sign transactions\", \"signTransaction\");\n    }\n    _signTypedData(domain, types, value) {\n        return this._fail(\"VoidSigner cannot sign typed data\", \"signTypedData\");\n    }\n    connect(provider) {\n        return new VoidSigner(this.address, provider);\n    }\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2Fic3RyYWN0LXNpZ25lci9saWIuZXNtL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQWE7QUFDYixpQkFBaUIsU0FBSSxJQUFJLFNBQUk7QUFDN0IsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDMkY7QUFDNUM7QUFDVjtBQUNyQyxtQkFBbUIseURBQU0sQ0FBQyw2Q0FBTztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUkseURBQU07QUFDVixJQUFJLHlEQUFNO0FBQ1YsSUFBSSx5REFBTTtBQUNWO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHlFQUFjO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw0RUFBaUI7QUFDOUM7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw0RUFBaUI7QUFDOUM7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0VBQVc7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDRFQUFpQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRkFBbUYseURBQU07QUFDekY7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0UseURBQU07QUFDckY7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLHVEQUF1RCx5REFBTTtBQUNoSTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLHlCQUF5Qiw0RUFBaUI7QUFDMUMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QseURBQU07QUFDeEQ7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsUUFBUSx5RUFBYztBQUN0QixRQUFRLHlFQUFjO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyx5REFBTSxpQ0FBaUMsc0JBQXNCO0FBQ3BHLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sZWRnaXR5LXlpZWxkLWZyb250ZW5kLy4uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9hYnN0cmFjdC1zaWduZXIvbGliLmVzbS9pbmRleC5qcz84MGYxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5pbXBvcnQgeyBkZWZpbmVSZWFkT25seSwgcmVzb2x2ZVByb3BlcnRpZXMsIHNoYWxsb3dDb3B5IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3Byb3BlcnRpZXNcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi9fdmVyc2lvblwiO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcih2ZXJzaW9uKTtcbmNvbnN0IGFsbG93ZWRUcmFuc2FjdGlvbktleXMgPSBbXG4gICAgXCJhY2Nlc3NMaXN0XCIsIFwiY2NpcFJlYWRFbmFibGVkXCIsIFwiY2hhaW5JZFwiLCBcImN1c3RvbURhdGFcIiwgXCJkYXRhXCIsIFwiZnJvbVwiLCBcImdhc0xpbWl0XCIsIFwiZ2FzUHJpY2VcIiwgXCJtYXhGZWVQZXJHYXNcIiwgXCJtYXhQcmlvcml0eUZlZVBlckdhc1wiLCBcIm5vbmNlXCIsIFwidG9cIiwgXCJ0eXBlXCIsIFwidmFsdWVcIlxuXTtcbmNvbnN0IGZvcndhcmRFcnJvcnMgPSBbXG4gICAgTG9nZ2VyLmVycm9ycy5JTlNVRkZJQ0lFTlRfRlVORFMsXG4gICAgTG9nZ2VyLmVycm9ycy5OT05DRV9FWFBJUkVELFxuICAgIExvZ2dlci5lcnJvcnMuUkVQTEFDRU1FTlRfVU5ERVJQUklDRUQsXG5dO1xuO1xuO1xuZXhwb3J0IGNsYXNzIFNpZ25lciB7XG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vIFN1Yi1jbGFzc2VzIE1VU1QgY2FsbCBzdXBlclxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBsb2dnZXIuY2hlY2tBYnN0cmFjdChuZXcudGFyZ2V0LCBTaWduZXIpO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcIl9pc1NpZ25lclwiLCB0cnVlKTtcbiAgICB9XG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vIFN1Yi1jbGFzc2VzIE1BWSBvdmVycmlkZSB0aGVzZVxuICAgIGdldEJhbGFuY2UoYmxvY2tUYWcpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRoaXMuX2NoZWNrUHJvdmlkZXIoXCJnZXRCYWxhbmNlXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMucHJvdmlkZXIuZ2V0QmFsYW5jZSh0aGlzLmdldEFkZHJlc3MoKSwgYmxvY2tUYWcpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0VHJhbnNhY3Rpb25Db3VudChibG9ja1RhZykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdGhpcy5fY2hlY2tQcm92aWRlcihcImdldFRyYW5zYWN0aW9uQ291bnRcIik7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5wcm92aWRlci5nZXRUcmFuc2FjdGlvbkNvdW50KHRoaXMuZ2V0QWRkcmVzcygpLCBibG9ja1RhZyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBQb3B1bGF0ZXMgXCJmcm9tXCIgaWYgdW5zcGVjaWZpZWQsIGFuZCBlc3RpbWF0ZXMgdGhlIGdhcyBmb3IgdGhlIHRyYW5zYWN0aW9uXG4gICAgZXN0aW1hdGVHYXModHJhbnNhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRoaXMuX2NoZWNrUHJvdmlkZXIoXCJlc3RpbWF0ZUdhc1wiKTtcbiAgICAgICAgICAgIGNvbnN0IHR4ID0geWllbGQgcmVzb2x2ZVByb3BlcnRpZXModGhpcy5jaGVja1RyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5wcm92aWRlci5lc3RpbWF0ZUdhcyh0eCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBQb3B1bGF0ZXMgXCJmcm9tXCIgaWYgdW5zcGVjaWZpZWQsIGFuZCBjYWxscyB3aXRoIHRoZSB0cmFuc2FjdGlvblxuICAgIGNhbGwodHJhbnNhY3Rpb24sIGJsb2NrVGFnKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9jaGVja1Byb3ZpZGVyKFwiY2FsbFwiKTtcbiAgICAgICAgICAgIGNvbnN0IHR4ID0geWllbGQgcmVzb2x2ZVByb3BlcnRpZXModGhpcy5jaGVja1RyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5wcm92aWRlci5jYWxsKHR4LCBibG9ja1RhZyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBQb3B1bGF0ZXMgYWxsIGZpZWxkcyBpbiBhIHRyYW5zYWN0aW9uLCBzaWducyBpdCBhbmQgc2VuZHMgaXQgdG8gdGhlIG5ldHdvcmtcbiAgICBzZW5kVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRoaXMuX2NoZWNrUHJvdmlkZXIoXCJzZW5kVHJhbnNhY3Rpb25cIik7XG4gICAgICAgICAgICBjb25zdCB0eCA9IHlpZWxkIHRoaXMucG9wdWxhdGVUcmFuc2FjdGlvbih0cmFuc2FjdGlvbik7XG4gICAgICAgICAgICBjb25zdCBzaWduZWRUeCA9IHlpZWxkIHRoaXMuc2lnblRyYW5zYWN0aW9uKHR4KTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLnByb3ZpZGVyLnNlbmRUcmFuc2FjdGlvbihzaWduZWRUeCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRDaGFpbklkKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdGhpcy5fY2hlY2tQcm92aWRlcihcImdldENoYWluSWRcIik7XG4gICAgICAgICAgICBjb25zdCBuZXR3b3JrID0geWllbGQgdGhpcy5wcm92aWRlci5nZXROZXR3b3JrKCk7XG4gICAgICAgICAgICByZXR1cm4gbmV0d29yay5jaGFpbklkO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0R2FzUHJpY2UoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9jaGVja1Byb3ZpZGVyKFwiZ2V0R2FzUHJpY2VcIik7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5wcm92aWRlci5nZXRHYXNQcmljZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0RmVlRGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRoaXMuX2NoZWNrUHJvdmlkZXIoXCJnZXRGZWVEYXRhXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMucHJvdmlkZXIuZ2V0RmVlRGF0YSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVzb2x2ZU5hbWUobmFtZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdGhpcy5fY2hlY2tQcm92aWRlcihcInJlc29sdmVOYW1lXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMucHJvdmlkZXIucmVzb2x2ZU5hbWUobmFtZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBDaGVja3MgYSB0cmFuc2FjdGlvbiBkb2VzIG5vdCBjb250YWluIGludmFsaWQga2V5cyBhbmQgaWZcbiAgICAvLyBubyBcImZyb21cIiBpcyBwcm92aWRlZCwgcG9wdWxhdGVzIGl0LlxuICAgIC8vIC0gZG9lcyBOT1QgcmVxdWlyZSBhIHByb3ZpZGVyXG4gICAgLy8gLSBhZGRzIFwiZnJvbVwiIGlzIG5vdCBwcmVzZW50XG4gICAgLy8gLSByZXR1cm5zIGEgQ09QWSAoc2FmZSB0byBtdXRhdGUgdGhlIHJlc3VsdClcbiAgICAvLyBCeSBkZWZhdWx0IGNhbGxlZCBmcm9tOiAob3ZlcnJpZGluZyB0aGVzZSBwcmV2ZW50cyBpdClcbiAgICAvLyAgIC0gY2FsbFxuICAgIC8vICAgLSBlc3RpbWF0ZUdhc1xuICAgIC8vICAgLSBwb3B1bGF0ZVRyYW5zYWN0aW9uIChhbmQgdGhlcmVmb3Igc2VuZFRyYW5zYWN0aW9uKVxuICAgIGNoZWNrVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgIGlmIChhbGxvd2VkVHJhbnNhY3Rpb25LZXlzLmluZGV4T2Yoa2V5KSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCB0cmFuc2FjdGlvbiBrZXk6IFwiICsga2V5LCBcInRyYW5zYWN0aW9uXCIsIHRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0eCA9IHNoYWxsb3dDb3B5KHRyYW5zYWN0aW9uKTtcbiAgICAgICAgaWYgKHR4LmZyb20gPT0gbnVsbCkge1xuICAgICAgICAgICAgdHguZnJvbSA9IHRoaXMuZ2V0QWRkcmVzcygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIGFueSBwcm92aWRlZCBhZGRyZXNzIG1hdGNoZXMgdGhpcyBzaWduZXJcbiAgICAgICAgICAgIHR4LmZyb20gPSBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKHR4LmZyb20pLFxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0QWRkcmVzcygpXG4gICAgICAgICAgICBdKS50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0WzBdLnRvTG93ZXJDYXNlKCkgIT09IHJlc3VsdFsxXS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJmcm9tIGFkZHJlc3MgbWlzbWF0Y2hcIiwgXCJ0cmFuc2FjdGlvblwiLCB0cmFuc2FjdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRbMF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHg7XG4gICAgfVxuICAgIC8vIFBvcHVsYXRlcyBBTEwga2V5cyBmb3IgYSB0cmFuc2FjdGlvbiBhbmQgY2hlY2tzIHRoYXQgXCJmcm9tXCIgbWF0Y2hlc1xuICAgIC8vIHRoaXMgU2lnbmVyLiBTaG91bGQgYmUgdXNlZCBieSBzZW5kVHJhbnNhY3Rpb24gYnV0IE5PVCBieSBzaWduVHJhbnNhY3Rpb24uXG4gICAgLy8gQnkgZGVmYXVsdCBjYWxsZWQgZnJvbTogKG92ZXJyaWRpbmcgdGhlc2UgcHJldmVudHMgaXQpXG4gICAgLy8gICAtIHNlbmRUcmFuc2FjdGlvblxuICAgIC8vXG4gICAgLy8gTm90ZXM6XG4gICAgLy8gIC0gV2UgYWxsb3cgZ2FzUHJpY2UgZm9yIEVJUC0xNTU5IGFzIGxvbmcgYXMgaXQgbWF0Y2hlcyBtYXhGZWVQZXJHYXNcbiAgICBwb3B1bGF0ZVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB0eCA9IHlpZWxkIHJlc29sdmVQcm9wZXJ0aWVzKHRoaXMuY2hlY2tUcmFuc2FjdGlvbih0cmFuc2FjdGlvbikpO1xuICAgICAgICAgICAgaWYgKHR4LnRvICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0eC50byA9IFByb21pc2UucmVzb2x2ZSh0eC50bykudGhlbigodG8pID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRvID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFkZHJlc3MgPSB5aWVsZCB0aGlzLnJlc29sdmVOYW1lKHRvKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFkZHJlc3MgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInByb3ZpZGVkIEVOUyBuYW1lIHJlc29sdmVzIHRvIG51bGxcIiwgXCJ0eC50b1wiLCB0byk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFkZHJlc3M7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIC8vIFByZXZlbnQgdGhpcyBlcnJvciBmcm9tIGNhdXNpbmcgYW4gVW5oYW5kbGVkUHJvbWlzZUV4Y2VwdGlvblxuICAgICAgICAgICAgICAgIHR4LnRvLmNhdGNoKChlcnJvcikgPT4geyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIERvIG5vdCBhbGxvdyBtaXhpbmcgcHJlLWVpcC0xNTU5IGFuZCBlaXAtMTU1OSBwcm9wZXJ0aWVzXG4gICAgICAgICAgICBjb25zdCBoYXNFaXAxNTU5ID0gKHR4Lm1heEZlZVBlckdhcyAhPSBudWxsIHx8IHR4Lm1heFByaW9yaXR5RmVlUGVyR2FzICE9IG51bGwpO1xuICAgICAgICAgICAgaWYgKHR4Lmdhc1ByaWNlICE9IG51bGwgJiYgKHR4LnR5cGUgPT09IDIgfHwgaGFzRWlwMTU1OSkpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiZWlwLTE1NTkgdHJhbnNhY3Rpb24gZG8gbm90IHN1cHBvcnQgZ2FzUHJpY2VcIiwgXCJ0cmFuc2FjdGlvblwiLCB0cmFuc2FjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgodHgudHlwZSA9PT0gMCB8fCB0eC50eXBlID09PSAxKSAmJiBoYXNFaXAxNTU5KSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInByZS1laXAtMTU1OSB0cmFuc2FjdGlvbiBkbyBub3Qgc3VwcG9ydCBtYXhGZWVQZXJHYXMvbWF4UHJpb3JpdHlGZWVQZXJHYXNcIiwgXCJ0cmFuc2FjdGlvblwiLCB0cmFuc2FjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKHR4LnR5cGUgPT09IDIgfHwgdHgudHlwZSA9PSBudWxsKSAmJiAodHgubWF4RmVlUGVyR2FzICE9IG51bGwgJiYgdHgubWF4UHJpb3JpdHlGZWVQZXJHYXMgIT0gbnVsbCkpIHtcbiAgICAgICAgICAgICAgICAvLyBGdWxseS1mb3JtZWQgRUlQLTE1NTkgdHJhbnNhY3Rpb24gKHNraXAgZ2V0RmVlRGF0YSlcbiAgICAgICAgICAgICAgICB0eC50eXBlID0gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR4LnR5cGUgPT09IDAgfHwgdHgudHlwZSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIC8vIEV4cGxpY2l0IExlZ2FjeSBvciBFSVAtMjkzMCB0cmFuc2FjdGlvblxuICAgICAgICAgICAgICAgIC8vIFBvcHVsYXRlIG1pc3NpbmcgZ2FzUHJpY2VcbiAgICAgICAgICAgICAgICBpZiAodHguZ2FzUHJpY2UgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0eC5nYXNQcmljZSA9IHRoaXMuZ2V0R2FzUHJpY2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGdldCBmZWUgZGF0YSB0byBkZXRlcm1pbmUgdGhpbmdzXG4gICAgICAgICAgICAgICAgY29uc3QgZmVlRGF0YSA9IHlpZWxkIHRoaXMuZ2V0RmVlRGF0YSgpO1xuICAgICAgICAgICAgICAgIGlmICh0eC50eXBlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBhdXRvLWRldGVjdCB0aGUgaW50ZW5kZWQgdHlwZSBvZiB0aGlzIHRyYW5zYWN0aW9uLi4uXG4gICAgICAgICAgICAgICAgICAgIGlmIChmZWVEYXRhLm1heEZlZVBlckdhcyAhPSBudWxsICYmIGZlZURhdGEubWF4UHJpb3JpdHlGZWVQZXJHYXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIG5ldHdvcmsgc3VwcG9ydHMgRUlQLTE1NTkhXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBVcGdyYWRlIHRyYW5zYWN0aW9uIGZyb20gbnVsbCB0byBlaXAtMTU1OVxuICAgICAgICAgICAgICAgICAgICAgICAgdHgudHlwZSA9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHguZ2FzUHJpY2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzaW5nIGxlZ2FjeSBnYXNQcmljZSBwcm9wZXJ0eSBvbiBhbiBlaXAtMTU1OSBuZXR3b3JrLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNvIHVzZSBnYXNQcmljZSBhcyBib3RoIGZlZSBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZ2FzUHJpY2UgPSB0eC5nYXNQcmljZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgdHguZ2FzUHJpY2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHgubWF4RmVlUGVyR2FzID0gZ2FzUHJpY2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHgubWF4UHJpb3JpdHlGZWVQZXJHYXMgPSBnYXNQcmljZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBvcHVsYXRlIG1pc3NpbmcgZmVlIGRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHgubWF4RmVlUGVyR2FzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHgubWF4RmVlUGVyR2FzID0gZmVlRGF0YS5tYXhGZWVQZXJHYXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eC5tYXhQcmlvcml0eUZlZVBlckdhcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR4Lm1heFByaW9yaXR5RmVlUGVyR2FzID0gZmVlRGF0YS5tYXhQcmlvcml0eUZlZVBlckdhcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZmVlRGF0YS5nYXNQcmljZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOZXR3b3JrIGRvZXNuJ3Qgc3VwcG9ydCBFSVAtMTU1OS4uLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gLi4uYnV0IHRoZXkgYXJlIHRyeWluZyB0byB1c2UgRUlQLTE1NTkgcHJvcGVydGllc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhc0VpcDE1NTkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcIm5ldHdvcmsgZG9lcyBub3Qgc3VwcG9ydCBFSVAtMTU1OVwiLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwicG9wdWxhdGVUcmFuc2FjdGlvblwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQb3B1bGF0ZSBtaXNzaW5nIGZlZSBkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHguZ2FzUHJpY2UgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR4Lmdhc1ByaWNlID0gZmVlRGF0YS5nYXNQcmljZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEV4cGxpY2l0bHkgc2V0IHVudHlwZWQgdHJhbnNhY3Rpb24gdG8gbGVnYWN5XG4gICAgICAgICAgICAgICAgICAgICAgICB0eC50eXBlID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGdldEZlZURhdGEgaGFzIGZhaWxlZCB1cy5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiZmFpbGVkIHRvIGdldCBjb25zaXN0ZW50IGZlZSBkYXRhXCIsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcInNpZ25lci5nZXRGZWVEYXRhXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR4LnR5cGUgPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRXhwbGljaXRseSB1c2luZyBFSVAtMTU1OVxuICAgICAgICAgICAgICAgICAgICAvLyBQb3B1bGF0ZSBtaXNzaW5nIGZlZSBkYXRhXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eC5tYXhGZWVQZXJHYXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHgubWF4RmVlUGVyR2FzID0gZmVlRGF0YS5tYXhGZWVQZXJHYXM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHR4Lm1heFByaW9yaXR5RmVlUGVyR2FzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR4Lm1heFByaW9yaXR5RmVlUGVyR2FzID0gZmVlRGF0YS5tYXhQcmlvcml0eUZlZVBlckdhcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eC5ub25jZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdHgubm9uY2UgPSB0aGlzLmdldFRyYW5zYWN0aW9uQ291bnQoXCJwZW5kaW5nXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR4Lmdhc0xpbWl0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0eC5nYXNMaW1pdCA9IHRoaXMuZXN0aW1hdGVHYXModHgpLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZm9yd2FyZEVycm9ycy5pbmRleE9mKGVycm9yLmNvZGUpID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dFcnJvcihcImNhbm5vdCBlc3RpbWF0ZSBnYXM7IHRyYW5zYWN0aW9uIG1heSBmYWlsIG9yIG1heSByZXF1aXJlIG1hbnVhbCBnYXMgbGltaXRcIiwgTG9nZ2VyLmVycm9ycy5VTlBSRURJQ1RBQkxFX0dBU19MSU1JVCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHg6IHR4XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR4LmNoYWluSWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHR4LmNoYWluSWQgPSB0aGlzLmdldENoYWluSWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHR4LmNoYWluSWQgPSBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZSh0eC5jaGFpbklkKSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRDaGFpbklkKClcbiAgICAgICAgICAgICAgICBdKS50aGVuKChyZXN1bHRzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHRzWzFdICE9PSAwICYmIHJlc3VsdHNbMF0gIT09IHJlc3VsdHNbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJjaGFpbklkIGFkZHJlc3MgbWlzbWF0Y2hcIiwgXCJ0cmFuc2FjdGlvblwiLCB0cmFuc2FjdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHNbMF07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzb2x2ZVByb3BlcnRpZXModHgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vIFN1Yi1jbGFzc2VzIFNIT1VMRCBsZWF2ZSB0aGVzZSBhbG9uZVxuICAgIF9jaGVja1Byb3ZpZGVyKG9wZXJhdGlvbikge1xuICAgICAgICBpZiAoIXRoaXMucHJvdmlkZXIpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwibWlzc2luZyBwcm92aWRlclwiLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogKG9wZXJhdGlvbiB8fCBcIl9jaGVja1Byb3ZpZGVyXCIpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgaXNTaWduZXIodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlLl9pc1NpZ25lcik7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFZvaWRTaWduZXIgZXh0ZW5kcyBTaWduZXIge1xuICAgIGNvbnN0cnVjdG9yKGFkZHJlc3MsIHByb3ZpZGVyKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiYWRkcmVzc1wiLCBhZGRyZXNzKTtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJwcm92aWRlclwiLCBwcm92aWRlciB8fCBudWxsKTtcbiAgICB9XG4gICAgZ2V0QWRkcmVzcygpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLmFkZHJlc3MpO1xuICAgIH1cbiAgICBfZmFpbChtZXNzYWdlLCBvcGVyYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IobWVzc2FnZSwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHsgb3BlcmF0aW9uOiBvcGVyYXRpb24gfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzaWduTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mYWlsKFwiVm9pZFNpZ25lciBjYW5ub3Qgc2lnbiBtZXNzYWdlc1wiLCBcInNpZ25NZXNzYWdlXCIpO1xuICAgIH1cbiAgICBzaWduVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZhaWwoXCJWb2lkU2lnbmVyIGNhbm5vdCBzaWduIHRyYW5zYWN0aW9uc1wiLCBcInNpZ25UcmFuc2FjdGlvblwiKTtcbiAgICB9XG4gICAgX3NpZ25UeXBlZERhdGEoZG9tYWluLCB0eXBlcywgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZhaWwoXCJWb2lkU2lnbmVyIGNhbm5vdCBzaWduIHR5cGVkIGRhdGFcIiwgXCJzaWduVHlwZWREYXRhXCIpO1xuICAgIH1cbiAgICBjb25uZWN0KHByb3ZpZGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgVm9pZFNpZ25lcih0aGlzLmFkZHJlc3MsIHByb3ZpZGVyKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ethersproject/abstract-signer/lib.esm/index.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@ethersproject/address/lib.esm/_version.js":
/*!******************************************************************!*\
  !*** ../node_modules/@ethersproject/address/lib.esm/_version.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\nconst version = \"address/5.7.0\";\n//# sourceMappingURL=_version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2FkZHJlc3MvbGliLmVzbS9fdmVyc2lvbi5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU87QUFDUCIsInNvdXJjZXMiOlsid2VicGFjazovL2xlZGdpdHkteWllbGQtZnJvbnRlbmQvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2FkZHJlc3MvbGliLmVzbS9fdmVyc2lvbi5qcz8wZjYzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCB2ZXJzaW9uID0gXCJhZGRyZXNzLzUuNy4wXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdmVyc2lvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ethersproject/address/lib.esm/_version.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@ethersproject/address/lib.esm/index.js":
/*!***************************************************************!*\
  !*** ../node_modules/@ethersproject/address/lib.esm/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getAddress: () => (/* binding */ getAddress),\n/* harmony export */   getContractAddress: () => (/* binding */ getContractAddress),\n/* harmony export */   getCreate2Address: () => (/* binding */ getCreate2Address),\n/* harmony export */   getIcapAddress: () => (/* binding */ getIcapAddress),\n/* harmony export */   isAddress: () => (/* binding */ isAddress)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/../node_modules/@ethersproject/bytes/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethersproject/bignumber */ \"(ssr)/../node_modules/@ethersproject/bignumber/lib.esm/bignumber.js\");\n/* harmony import */ var _ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/keccak256 */ \"(ssr)/../node_modules/@ethersproject/keccak256/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_rlp__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ethersproject/rlp */ \"(ssr)/../node_modules/@ethersproject/rlp/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/../node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(ssr)/../node_modules/@ethersproject/address/lib.esm/_version.js\");\n\n\n\n\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\nfunction getChecksumAddress(address) {\n    if (!(0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.isHexString)(address, 20)) {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n    address = address.toLowerCase();\n    const chars = address.substring(2).split(\"\");\n    const expanded = new Uint8Array(40);\n    for (let i = 0; i < 40; i++) {\n        expanded[i] = chars[i].charCodeAt(0);\n    }\n    const hashed = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.arrayify)((0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_3__.keccak256)(expanded));\n    for (let i = 0; i < 40; i += 2) {\n        if ((hashed[i >> 1] >> 4) >= 8) {\n            chars[i] = chars[i].toUpperCase();\n        }\n        if ((hashed[i >> 1] & 0x0f) >= 8) {\n            chars[i + 1] = chars[i + 1].toUpperCase();\n        }\n    }\n    return \"0x\" + chars.join(\"\");\n}\n// Shims for environments that are missing some required constants and functions\nconst MAX_SAFE_INTEGER = 0x1fffffffffffff;\nfunction log10(x) {\n    if (Math.log10) {\n        return Math.log10(x);\n    }\n    return Math.log(x) / Math.LN10;\n}\n// See: https://en.wikipedia.org/wiki/International_Bank_Account_Number\n// Create lookup table\nconst ibanLookup = {};\nfor (let i = 0; i < 10; i++) {\n    ibanLookup[String(i)] = String(i);\n}\nfor (let i = 0; i < 26; i++) {\n    ibanLookup[String.fromCharCode(65 + i)] = String(10 + i);\n}\n// How many decimal digits can we process? (for 64-bit float, this is 15)\nconst safeDigits = Math.floor(log10(MAX_SAFE_INTEGER));\nfunction ibanChecksum(address) {\n    address = address.toUpperCase();\n    address = address.substring(4) + address.substring(0, 2) + \"00\";\n    let expanded = address.split(\"\").map((c) => { return ibanLookup[c]; }).join(\"\");\n    // Javascript can handle integers safely up to 15 (decimal) digits\n    while (expanded.length >= safeDigits) {\n        let block = expanded.substring(0, safeDigits);\n        expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);\n    }\n    let checksum = String(98 - (parseInt(expanded, 10) % 97));\n    while (checksum.length < 2) {\n        checksum = \"0\" + checksum;\n    }\n    return checksum;\n}\n;\nfunction getAddress(address) {\n    let result = null;\n    if (typeof (address) !== \"string\") {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n    if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {\n        // Missing the 0x prefix\n        if (address.substring(0, 2) !== \"0x\") {\n            address = \"0x\" + address;\n        }\n        result = getChecksumAddress(address);\n        // It is a checksummed address with a bad checksum\n        if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {\n            logger.throwArgumentError(\"bad address checksum\", \"address\", address);\n        }\n        // Maybe ICAP? (we only support direct mode)\n    }\n    else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {\n        // It is an ICAP address with a bad checksum\n        if (address.substring(2, 4) !== ibanChecksum(address)) {\n            logger.throwArgumentError(\"bad icap checksum\", \"address\", address);\n        }\n        result = (0,_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__._base36To16)(address.substring(4));\n        while (result.length < 40) {\n            result = \"0\" + result;\n        }\n        result = getChecksumAddress(\"0x\" + result);\n    }\n    else {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n    return result;\n}\nfunction isAddress(address) {\n    try {\n        getAddress(address);\n        return true;\n    }\n    catch (error) { }\n    return false;\n}\nfunction getIcapAddress(address) {\n    let base36 = (0,_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__._base16To36)(getAddress(address).substring(2)).toUpperCase();\n    while (base36.length < 30) {\n        base36 = \"0\" + base36;\n    }\n    return \"XE\" + ibanChecksum(\"XE00\" + base36) + base36;\n}\n// http://ethereum.stackexchange.com/questions/760/how-is-the-address-of-an-ethereum-contract-computed\nfunction getContractAddress(transaction) {\n    let from = null;\n    try {\n        from = getAddress(transaction.from);\n    }\n    catch (error) {\n        logger.throwArgumentError(\"missing from address\", \"transaction\", transaction);\n    }\n    const nonce = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.stripZeros)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.arrayify)(_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(transaction.nonce).toHexString()));\n    return getAddress((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.hexDataSlice)((0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_3__.keccak256)((0,_ethersproject_rlp__WEBPACK_IMPORTED_MODULE_5__.encode)([from, nonce])), 12));\n}\nfunction getCreate2Address(from, salt, initCodeHash) {\n    if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.hexDataLength)(salt) !== 32) {\n        logger.throwArgumentError(\"salt must be 32 bytes\", \"salt\", salt);\n    }\n    if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.hexDataLength)(initCodeHash) !== 32) {\n        logger.throwArgumentError(\"initCodeHash must be 32 bytes\", \"initCodeHash\", initCodeHash);\n    }\n    return getAddress((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.hexDataSlice)((0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_3__.keccak256)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.concat)([\"0xff\", getAddress(from), salt, initCodeHash])), 12));\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2FkZHJlc3MvbGliLmVzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFhO0FBQ2lHO0FBQy9CO0FBQzFCO0FBQ1Q7QUFDRztBQUNWO0FBQ3JDLG1CQUFtQix5REFBTSxDQUFDLDZDQUFPO0FBQ2pDO0FBQ0EsU0FBUyxpRUFBVztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBLG1CQUFtQiw4REFBUSxDQUFDLG1FQUFTO0FBQ3JDLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsdUJBQXVCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsR0FBRztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLEVBQUUsWUFBWSxNQUFNO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHFFQUFXO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsaUJBQWlCLHFFQUFXO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0VBQVUsQ0FBQyw4REFBUSxDQUFDLCtEQUFTO0FBQy9DLHNCQUFzQixrRUFBWSxDQUFDLG1FQUFTLENBQUMsMERBQU07QUFDbkQ7QUFDTztBQUNQLFFBQVEsbUVBQWE7QUFDckI7QUFDQTtBQUNBLFFBQVEsbUVBQWE7QUFDckI7QUFDQTtBQUNBLHNCQUFzQixrRUFBWSxDQUFDLG1FQUFTLENBQUMsNERBQU07QUFDbkQ7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xlZGdpdHkteWllbGQtZnJvbnRlbmQvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2FkZHJlc3MvbGliLmVzbS9pbmRleC5qcz9lMWY4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuaW1wb3J0IHsgYXJyYXlpZnksIGNvbmNhdCwgaGV4RGF0YUxlbmd0aCwgaGV4RGF0YVNsaWNlLCBpc0hleFN0cmluZywgc3RyaXBaZXJvcyB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9ieXRlc1wiO1xuaW1wb3J0IHsgQmlnTnVtYmVyLCBfYmFzZTE2VG8zNiwgX2Jhc2UzNlRvMTYgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYmlnbnVtYmVyXCI7XG5pbXBvcnQgeyBrZWNjYWsyNTYgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3Qva2VjY2FrMjU2XCI7XG5pbXBvcnQgeyBlbmNvZGUgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvcmxwXCI7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvbG9nZ2VyXCI7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4vX3ZlcnNpb25cIjtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIodmVyc2lvbik7XG5mdW5jdGlvbiBnZXRDaGVja3N1bUFkZHJlc3MoYWRkcmVzcykge1xuICAgIGlmICghaXNIZXhTdHJpbmcoYWRkcmVzcywgMjApKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGFkZHJlc3NcIiwgXCJhZGRyZXNzXCIsIGFkZHJlc3MpO1xuICAgIH1cbiAgICBhZGRyZXNzID0gYWRkcmVzcy50b0xvd2VyQ2FzZSgpO1xuICAgIGNvbnN0IGNoYXJzID0gYWRkcmVzcy5zdWJzdHJpbmcoMikuc3BsaXQoXCJcIik7XG4gICAgY29uc3QgZXhwYW5kZWQgPSBuZXcgVWludDhBcnJheSg0MCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0MDsgaSsrKSB7XG4gICAgICAgIGV4cGFuZGVkW2ldID0gY2hhcnNbaV0uY2hhckNvZGVBdCgwKTtcbiAgICB9XG4gICAgY29uc3QgaGFzaGVkID0gYXJyYXlpZnkoa2VjY2FrMjU2KGV4cGFuZGVkKSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0MDsgaSArPSAyKSB7XG4gICAgICAgIGlmICgoaGFzaGVkW2kgPj4gMV0gPj4gNCkgPj0gOCkge1xuICAgICAgICAgICAgY2hhcnNbaV0gPSBjaGFyc1tpXS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoaGFzaGVkW2kgPj4gMV0gJiAweDBmKSA+PSA4KSB7XG4gICAgICAgICAgICBjaGFyc1tpICsgMV0gPSBjaGFyc1tpICsgMV0udG9VcHBlckNhc2UoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gXCIweFwiICsgY2hhcnMuam9pbihcIlwiKTtcbn1cbi8vIFNoaW1zIGZvciBlbnZpcm9ubWVudHMgdGhhdCBhcmUgbWlzc2luZyBzb21lIHJlcXVpcmVkIGNvbnN0YW50cyBhbmQgZnVuY3Rpb25zXG5jb25zdCBNQVhfU0FGRV9JTlRFR0VSID0gMHgxZmZmZmZmZmZmZmZmZjtcbmZ1bmN0aW9uIGxvZzEwKHgpIHtcbiAgICBpZiAoTWF0aC5sb2cxMCkge1xuICAgICAgICByZXR1cm4gTWF0aC5sb2cxMCh4KTtcbiAgICB9XG4gICAgcmV0dXJuIE1hdGgubG9nKHgpIC8gTWF0aC5MTjEwO1xufVxuLy8gU2VlOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JbnRlcm5hdGlvbmFsX0JhbmtfQWNjb3VudF9OdW1iZXJcbi8vIENyZWF0ZSBsb29rdXAgdGFibGVcbmNvbnN0IGliYW5Mb29rdXAgPSB7fTtcbmZvciAobGV0IGkgPSAwOyBpIDwgMTA7IGkrKykge1xuICAgIGliYW5Mb29rdXBbU3RyaW5nKGkpXSA9IFN0cmluZyhpKTtcbn1cbmZvciAobGV0IGkgPSAwOyBpIDwgMjY7IGkrKykge1xuICAgIGliYW5Mb29rdXBbU3RyaW5nLmZyb21DaGFyQ29kZSg2NSArIGkpXSA9IFN0cmluZygxMCArIGkpO1xufVxuLy8gSG93IG1hbnkgZGVjaW1hbCBkaWdpdHMgY2FuIHdlIHByb2Nlc3M/IChmb3IgNjQtYml0IGZsb2F0LCB0aGlzIGlzIDE1KVxuY29uc3Qgc2FmZURpZ2l0cyA9IE1hdGguZmxvb3IobG9nMTAoTUFYX1NBRkVfSU5URUdFUikpO1xuZnVuY3Rpb24gaWJhbkNoZWNrc3VtKGFkZHJlc3MpIHtcbiAgICBhZGRyZXNzID0gYWRkcmVzcy50b1VwcGVyQ2FzZSgpO1xuICAgIGFkZHJlc3MgPSBhZGRyZXNzLnN1YnN0cmluZyg0KSArIGFkZHJlc3Muc3Vic3RyaW5nKDAsIDIpICsgXCIwMFwiO1xuICAgIGxldCBleHBhbmRlZCA9IGFkZHJlc3Muc3BsaXQoXCJcIikubWFwKChjKSA9PiB7IHJldHVybiBpYmFuTG9va3VwW2NdOyB9KS5qb2luKFwiXCIpO1xuICAgIC8vIEphdmFzY3JpcHQgY2FuIGhhbmRsZSBpbnRlZ2VycyBzYWZlbHkgdXAgdG8gMTUgKGRlY2ltYWwpIGRpZ2l0c1xuICAgIHdoaWxlIChleHBhbmRlZC5sZW5ndGggPj0gc2FmZURpZ2l0cykge1xuICAgICAgICBsZXQgYmxvY2sgPSBleHBhbmRlZC5zdWJzdHJpbmcoMCwgc2FmZURpZ2l0cyk7XG4gICAgICAgIGV4cGFuZGVkID0gcGFyc2VJbnQoYmxvY2ssIDEwKSAlIDk3ICsgZXhwYW5kZWQuc3Vic3RyaW5nKGJsb2NrLmxlbmd0aCk7XG4gICAgfVxuICAgIGxldCBjaGVja3N1bSA9IFN0cmluZyg5OCAtIChwYXJzZUludChleHBhbmRlZCwgMTApICUgOTcpKTtcbiAgICB3aGlsZSAoY2hlY2tzdW0ubGVuZ3RoIDwgMikge1xuICAgICAgICBjaGVja3N1bSA9IFwiMFwiICsgY2hlY2tzdW07XG4gICAgfVxuICAgIHJldHVybiBjaGVja3N1bTtcbn1cbjtcbmV4cG9ydCBmdW5jdGlvbiBnZXRBZGRyZXNzKGFkZHJlc3MpIHtcbiAgICBsZXQgcmVzdWx0ID0gbnVsbDtcbiAgICBpZiAodHlwZW9mIChhZGRyZXNzKSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBhZGRyZXNzXCIsIFwiYWRkcmVzc1wiLCBhZGRyZXNzKTtcbiAgICB9XG4gICAgaWYgKGFkZHJlc3MubWF0Y2goL14oMHgpP1swLTlhLWZBLUZdezQwfSQvKSkge1xuICAgICAgICAvLyBNaXNzaW5nIHRoZSAweCBwcmVmaXhcbiAgICAgICAgaWYgKGFkZHJlc3Muc3Vic3RyaW5nKDAsIDIpICE9PSBcIjB4XCIpIHtcbiAgICAgICAgICAgIGFkZHJlc3MgPSBcIjB4XCIgKyBhZGRyZXNzO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCA9IGdldENoZWNrc3VtQWRkcmVzcyhhZGRyZXNzKTtcbiAgICAgICAgLy8gSXQgaXMgYSBjaGVja3N1bW1lZCBhZGRyZXNzIHdpdGggYSBiYWQgY2hlY2tzdW1cbiAgICAgICAgaWYgKGFkZHJlc3MubWF0Y2goLyhbQS1GXS4qW2EtZl0pfChbYS1mXS4qW0EtRl0pLykgJiYgcmVzdWx0ICE9PSBhZGRyZXNzKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiYmFkIGFkZHJlc3MgY2hlY2tzdW1cIiwgXCJhZGRyZXNzXCIsIGFkZHJlc3MpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE1heWJlIElDQVA/ICh3ZSBvbmx5IHN1cHBvcnQgZGlyZWN0IG1vZGUpXG4gICAgfVxuICAgIGVsc2UgaWYgKGFkZHJlc3MubWF0Y2goL15YRVswLTldezJ9WzAtOUEtWmEtel17MzAsMzF9JC8pKSB7XG4gICAgICAgIC8vIEl0IGlzIGFuIElDQVAgYWRkcmVzcyB3aXRoIGEgYmFkIGNoZWNrc3VtXG4gICAgICAgIGlmIChhZGRyZXNzLnN1YnN0cmluZygyLCA0KSAhPT0gaWJhbkNoZWNrc3VtKGFkZHJlc3MpKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiYmFkIGljYXAgY2hlY2tzdW1cIiwgXCJhZGRyZXNzXCIsIGFkZHJlc3MpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCA9IF9iYXNlMzZUbzE2KGFkZHJlc3Muc3Vic3RyaW5nKDQpKTtcbiAgICAgICAgd2hpbGUgKHJlc3VsdC5sZW5ndGggPCA0MCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gXCIwXCIgKyByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gZ2V0Q2hlY2tzdW1BZGRyZXNzKFwiMHhcIiArIHJlc3VsdCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBhZGRyZXNzXCIsIFwiYWRkcmVzc1wiLCBhZGRyZXNzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0FkZHJlc3MoYWRkcmVzcykge1xuICAgIHRyeSB7XG4gICAgICAgIGdldEFkZHJlc3MoYWRkcmVzcyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRJY2FwQWRkcmVzcyhhZGRyZXNzKSB7XG4gICAgbGV0IGJhc2UzNiA9IF9iYXNlMTZUbzM2KGdldEFkZHJlc3MoYWRkcmVzcykuc3Vic3RyaW5nKDIpKS50b1VwcGVyQ2FzZSgpO1xuICAgIHdoaWxlIChiYXNlMzYubGVuZ3RoIDwgMzApIHtcbiAgICAgICAgYmFzZTM2ID0gXCIwXCIgKyBiYXNlMzY7XG4gICAgfVxuICAgIHJldHVybiBcIlhFXCIgKyBpYmFuQ2hlY2tzdW0oXCJYRTAwXCIgKyBiYXNlMzYpICsgYmFzZTM2O1xufVxuLy8gaHR0cDovL2V0aGVyZXVtLnN0YWNrZXhjaGFuZ2UuY29tL3F1ZXN0aW9ucy83NjAvaG93LWlzLXRoZS1hZGRyZXNzLW9mLWFuLWV0aGVyZXVtLWNvbnRyYWN0LWNvbXB1dGVkXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q29udHJhY3RBZGRyZXNzKHRyYW5zYWN0aW9uKSB7XG4gICAgbGV0IGZyb20gPSBudWxsO1xuICAgIHRyeSB7XG4gICAgICAgIGZyb20gPSBnZXRBZGRyZXNzKHRyYW5zYWN0aW9uLmZyb20pO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcIm1pc3NpbmcgZnJvbSBhZGRyZXNzXCIsIFwidHJhbnNhY3Rpb25cIiwgdHJhbnNhY3Rpb24pO1xuICAgIH1cbiAgICBjb25zdCBub25jZSA9IHN0cmlwWmVyb3MoYXJyYXlpZnkoQmlnTnVtYmVyLmZyb20odHJhbnNhY3Rpb24ubm9uY2UpLnRvSGV4U3RyaW5nKCkpKTtcbiAgICByZXR1cm4gZ2V0QWRkcmVzcyhoZXhEYXRhU2xpY2Uoa2VjY2FrMjU2KGVuY29kZShbZnJvbSwgbm9uY2VdKSksIDEyKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0Q3JlYXRlMkFkZHJlc3MoZnJvbSwgc2FsdCwgaW5pdENvZGVIYXNoKSB7XG4gICAgaWYgKGhleERhdGFMZW5ndGgoc2FsdCkgIT09IDMyKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJzYWx0IG11c3QgYmUgMzIgYnl0ZXNcIiwgXCJzYWx0XCIsIHNhbHQpO1xuICAgIH1cbiAgICBpZiAoaGV4RGF0YUxlbmd0aChpbml0Q29kZUhhc2gpICE9PSAzMikge1xuICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW5pdENvZGVIYXNoIG11c3QgYmUgMzIgYnl0ZXNcIiwgXCJpbml0Q29kZUhhc2hcIiwgaW5pdENvZGVIYXNoKTtcbiAgICB9XG4gICAgcmV0dXJuIGdldEFkZHJlc3MoaGV4RGF0YVNsaWNlKGtlY2NhazI1Nihjb25jYXQoW1wiMHhmZlwiLCBnZXRBZGRyZXNzKGZyb20pLCBzYWx0LCBpbml0Q29kZUhhc2hdKSksIDEyKSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ethersproject/address/lib.esm/index.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@ethersproject/base64/lib.esm/base64.js":
/*!***************************************************************!*\
  !*** ../node_modules/@ethersproject/base64/lib.esm/base64.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decode: () => (/* binding */ decode),\n/* harmony export */   encode: () => (/* binding */ encode)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/../node_modules/@ethersproject/bytes/lib.esm/index.js\");\n\n\nfunction decode(textData) {\n    textData = atob(textData);\n    const data = [];\n    for (let i = 0; i < textData.length; i++) {\n        data.push(textData.charCodeAt(i));\n    }\n    return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__.arrayify)(data);\n}\nfunction encode(data) {\n    data = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__.arrayify)(data);\n    let textData = \"\";\n    for (let i = 0; i < data.length; i++) {\n        textData += String.fromCharCode(data[i]);\n    }\n    return btoa(textData);\n}\n//# sourceMappingURL=base64.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2Jhc2U2NC9saWIuZXNtL2Jhc2U2NC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBYTtBQUNtQztBQUN6QztBQUNQO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQSxXQUFXLDhEQUFRO0FBQ25CO0FBQ087QUFDUCxXQUFXLDhEQUFRO0FBQ25CO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGVkZ2l0eS15aWVsZC1mcm9udGVuZC8uLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvYmFzZTY0L2xpYi5lc20vYmFzZTY0LmpzPzkyMzQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgeyBhcnJheWlmeSB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9ieXRlc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZSh0ZXh0RGF0YSkge1xuICAgIHRleHREYXRhID0gYXRvYih0ZXh0RGF0YSk7XG4gICAgY29uc3QgZGF0YSA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGV4dERhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZGF0YS5wdXNoKHRleHREYXRhLmNoYXJDb2RlQXQoaSkpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXlpZnkoZGF0YSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlKGRhdGEpIHtcbiAgICBkYXRhID0gYXJyYXlpZnkoZGF0YSk7XG4gICAgbGV0IHRleHREYXRhID0gXCJcIjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGV4dERhdGEgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShkYXRhW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ0b2EodGV4dERhdGEpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmFzZTY0LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ethersproject/base64/lib.esm/base64.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@ethersproject/basex/lib.esm/index.js":
/*!*************************************************************!*\
  !*** ../node_modules/@ethersproject/basex/lib.esm/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Base32: () => (/* binding */ Base32),\n/* harmony export */   Base58: () => (/* binding */ Base58),\n/* harmony export */   BaseX: () => (/* binding */ BaseX)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/../node_modules/@ethersproject/bytes/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/../node_modules/@ethersproject/properties/lib.esm/index.js\");\n/**\n * var basex = require(\"base-x\");\n *\n * This implementation is heavily based on base-x. The main reason to\n * deviate was to prevent the dependency of Buffer.\n *\n * Contributors:\n *\n * base-x encoding\n * Forked from https://github.com/cryptocoinjs/bs58\n * Originally written by Mike Hearn for BitcoinJ\n * Copyright (c) 2011 Google Inc\n * Ported to JavaScript by Stefan Thomas\n * Merged Buffer refactorings from base58-native by Stephen Pair\n * Copyright (c) 2013 BitPay Inc\n *\n * The MIT License (MIT)\n *\n * Copyright base-x contributors (c) 2016\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n *\n */\n\n\nclass BaseX {\n    constructor(alphabet) {\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_0__.defineReadOnly)(this, \"alphabet\", alphabet);\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_0__.defineReadOnly)(this, \"base\", alphabet.length);\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_0__.defineReadOnly)(this, \"_alphabetMap\", {});\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_0__.defineReadOnly)(this, \"_leader\", alphabet.charAt(0));\n        // pre-compute lookup table\n        for (let i = 0; i < alphabet.length; i++) {\n            this._alphabetMap[alphabet.charAt(i)] = i;\n        }\n    }\n    encode(value) {\n        let source = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__.arrayify)(value);\n        if (source.length === 0) {\n            return \"\";\n        }\n        let digits = [0];\n        for (let i = 0; i < source.length; ++i) {\n            let carry = source[i];\n            for (let j = 0; j < digits.length; ++j) {\n                carry += digits[j] << 8;\n                digits[j] = carry % this.base;\n                carry = (carry / this.base) | 0;\n            }\n            while (carry > 0) {\n                digits.push(carry % this.base);\n                carry = (carry / this.base) | 0;\n            }\n        }\n        let string = \"\";\n        // deal with leading zeros\n        for (let k = 0; source[k] === 0 && k < source.length - 1; ++k) {\n            string += this._leader;\n        }\n        // convert digits to a string\n        for (let q = digits.length - 1; q >= 0; --q) {\n            string += this.alphabet[digits[q]];\n        }\n        return string;\n    }\n    decode(value) {\n        if (typeof (value) !== \"string\") {\n            throw new TypeError(\"Expected String\");\n        }\n        let bytes = [];\n        if (value.length === 0) {\n            return new Uint8Array(bytes);\n        }\n        bytes.push(0);\n        for (let i = 0; i < value.length; i++) {\n            let byte = this._alphabetMap[value[i]];\n            if (byte === undefined) {\n                throw new Error(\"Non-base\" + this.base + \" character\");\n            }\n            let carry = byte;\n            for (let j = 0; j < bytes.length; ++j) {\n                carry += bytes[j] * this.base;\n                bytes[j] = carry & 0xff;\n                carry >>= 8;\n            }\n            while (carry > 0) {\n                bytes.push(carry & 0xff);\n                carry >>= 8;\n            }\n        }\n        // deal with leading zeros\n        for (let k = 0; value[k] === this._leader && k < value.length - 1; ++k) {\n            bytes.push(0);\n        }\n        return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__.arrayify)(new Uint8Array(bytes.reverse()));\n    }\n}\nconst Base32 = new BaseX(\"abcdefghijklmnopqrstuvwxyz234567\");\nconst Base58 = new BaseX(\"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\");\n\n//console.log(Base58.decode(\"Qmd2V777o5XvJbYMeMb8k2nU5f8d3ciUQ5YpYuWhzv8iDj\"))\n//console.log(Base58.encode(Base58.decode(\"Qmd2V777o5XvJbYMeMb8k2nU5f8d3ciUQ5YpYuWhzv8iDj\")))\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2Jhc2V4L2xpYi5lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNnRDtBQUNXO0FBQ3BEO0FBQ1A7QUFDQSxRQUFRLHlFQUFjO0FBQ3RCLFFBQVEseUVBQWM7QUFDdEIsUUFBUSx5RUFBYyx5QkFBeUI7QUFDL0MsUUFBUSx5RUFBYztBQUN0QjtBQUNBLHdCQUF3QixxQkFBcUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsOERBQVE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQW1CO0FBQzNDO0FBQ0EsNEJBQTRCLG1CQUFtQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDBDQUEwQztBQUNsRTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsUUFBUTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixrQkFBa0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbURBQW1EO0FBQzNFO0FBQ0E7QUFDQSxlQUFlLDhEQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQzBCO0FBQzFCO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xlZGdpdHkteWllbGQtZnJvbnRlbmQvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2Jhc2V4L2xpYi5lc20vaW5kZXguanM/NTkxNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIHZhciBiYXNleCA9IHJlcXVpcmUoXCJiYXNlLXhcIik7XG4gKlxuICogVGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBoZWF2aWx5IGJhc2VkIG9uIGJhc2UteC4gVGhlIG1haW4gcmVhc29uIHRvXG4gKiBkZXZpYXRlIHdhcyB0byBwcmV2ZW50IHRoZSBkZXBlbmRlbmN5IG9mIEJ1ZmZlci5cbiAqXG4gKiBDb250cmlidXRvcnM6XG4gKlxuICogYmFzZS14IGVuY29kaW5nXG4gKiBGb3JrZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vY3J5cHRvY29pbmpzL2JzNThcbiAqIE9yaWdpbmFsbHkgd3JpdHRlbiBieSBNaWtlIEhlYXJuIGZvciBCaXRjb2luSlxuICogQ29weXJpZ2h0IChjKSAyMDExIEdvb2dsZSBJbmNcbiAqIFBvcnRlZCB0byBKYXZhU2NyaXB0IGJ5IFN0ZWZhbiBUaG9tYXNcbiAqIE1lcmdlZCBCdWZmZXIgcmVmYWN0b3JpbmdzIGZyb20gYmFzZTU4LW5hdGl2ZSBieSBTdGVwaGVuIFBhaXJcbiAqIENvcHlyaWdodCAoYykgMjAxMyBCaXRQYXkgSW5jXG4gKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKlxuICogQ29weXJpZ2h0IGJhc2UteCBjb250cmlidXRvcnMgKGMpIDIwMTZcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuICogY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLFxuICogdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvblxuICogdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsXG4gKiBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGVcbiAqIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcbiAqIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1NcbiAqIElOIFRIRSBTT0ZUV0FSRS5cbiAqXG4gKi9cbmltcG9ydCB7IGFycmF5aWZ5IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2J5dGVzXCI7XG5pbXBvcnQgeyBkZWZpbmVSZWFkT25seSB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9wcm9wZXJ0aWVzXCI7XG5leHBvcnQgY2xhc3MgQmFzZVgge1xuICAgIGNvbnN0cnVjdG9yKGFscGhhYmV0KSB7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiYWxwaGFiZXRcIiwgYWxwaGFiZXQpO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcImJhc2VcIiwgYWxwaGFiZXQubGVuZ3RoKTtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJfYWxwaGFiZXRNYXBcIiwge30pO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcIl9sZWFkZXJcIiwgYWxwaGFiZXQuY2hhckF0KDApKTtcbiAgICAgICAgLy8gcHJlLWNvbXB1dGUgbG9va3VwIHRhYmxlXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWxwaGFiZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuX2FscGhhYmV0TWFwW2FscGhhYmV0LmNoYXJBdChpKV0gPSBpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVuY29kZSh2YWx1ZSkge1xuICAgICAgICBsZXQgc291cmNlID0gYXJyYXlpZnkodmFsdWUpO1xuICAgICAgICBpZiAoc291cmNlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRpZ2l0cyA9IFswXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzb3VyY2UubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGxldCBjYXJyeSA9IHNvdXJjZVtpXTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgZGlnaXRzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgY2FycnkgKz0gZGlnaXRzW2pdIDw8IDg7XG4gICAgICAgICAgICAgICAgZGlnaXRzW2pdID0gY2FycnkgJSB0aGlzLmJhc2U7XG4gICAgICAgICAgICAgICAgY2FycnkgPSAoY2FycnkgLyB0aGlzLmJhc2UpIHwgMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChjYXJyeSA+IDApIHtcbiAgICAgICAgICAgICAgICBkaWdpdHMucHVzaChjYXJyeSAlIHRoaXMuYmFzZSk7XG4gICAgICAgICAgICAgICAgY2FycnkgPSAoY2FycnkgLyB0aGlzLmJhc2UpIHwgMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RyaW5nID0gXCJcIjtcbiAgICAgICAgLy8gZGVhbCB3aXRoIGxlYWRpbmcgemVyb3NcbiAgICAgICAgZm9yIChsZXQgayA9IDA7IHNvdXJjZVtrXSA9PT0gMCAmJiBrIDwgc291cmNlLmxlbmd0aCAtIDE7ICsraykge1xuICAgICAgICAgICAgc3RyaW5nICs9IHRoaXMuX2xlYWRlcjtcbiAgICAgICAgfVxuICAgICAgICAvLyBjb252ZXJ0IGRpZ2l0cyB0byBhIHN0cmluZ1xuICAgICAgICBmb3IgKGxldCBxID0gZGlnaXRzLmxlbmd0aCAtIDE7IHEgPj0gMDsgLS1xKSB7XG4gICAgICAgICAgICBzdHJpbmcgKz0gdGhpcy5hbHBoYWJldFtkaWdpdHNbcV1dO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgfVxuICAgIGRlY29kZSh2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mICh2YWx1ZSkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBTdHJpbmdcIik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGJ5dGVzID0gW107XG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShieXRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgYnl0ZXMucHVzaCgwKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGJ5dGUgPSB0aGlzLl9hbHBoYWJldE1hcFt2YWx1ZVtpXV07XG4gICAgICAgICAgICBpZiAoYnl0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm9uLWJhc2VcIiArIHRoaXMuYmFzZSArIFwiIGNoYXJhY3RlclwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBjYXJyeSA9IGJ5dGU7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGJ5dGVzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgY2FycnkgKz0gYnl0ZXNbal0gKiB0aGlzLmJhc2U7XG4gICAgICAgICAgICAgICAgYnl0ZXNbal0gPSBjYXJyeSAmIDB4ZmY7XG4gICAgICAgICAgICAgICAgY2FycnkgPj49IDg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoY2FycnkgPiAwKSB7XG4gICAgICAgICAgICAgICAgYnl0ZXMucHVzaChjYXJyeSAmIDB4ZmYpO1xuICAgICAgICAgICAgICAgIGNhcnJ5ID4+PSA4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGRlYWwgd2l0aCBsZWFkaW5nIHplcm9zXG4gICAgICAgIGZvciAobGV0IGsgPSAwOyB2YWx1ZVtrXSA9PT0gdGhpcy5fbGVhZGVyICYmIGsgPCB2YWx1ZS5sZW5ndGggLSAxOyArK2spIHtcbiAgICAgICAgICAgIGJ5dGVzLnB1c2goMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycmF5aWZ5KG5ldyBVaW50OEFycmF5KGJ5dGVzLnJldmVyc2UoKSkpO1xuICAgIH1cbn1cbmNvbnN0IEJhc2UzMiA9IG5ldyBCYXNlWChcImFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MjM0NTY3XCIpO1xuY29uc3QgQmFzZTU4ID0gbmV3IEJhc2VYKFwiMTIzNDU2Nzg5QUJDREVGR0hKS0xNTlBRUlNUVVZXWFlaYWJjZGVmZ2hpamttbm9wcXJzdHV2d3h5elwiKTtcbmV4cG9ydCB7IEJhc2UzMiwgQmFzZTU4IH07XG4vL2NvbnNvbGUubG9nKEJhc2U1OC5kZWNvZGUoXCJRbWQyVjc3N281WHZKYllNZU1iOGsyblU1ZjhkM2NpVVE1WXBZdVdoenY4aURqXCIpKVxuLy9jb25zb2xlLmxvZyhCYXNlNTguZW5jb2RlKEJhc2U1OC5kZWNvZGUoXCJRbWQyVjc3N281WHZKYllNZU1iOGsyblU1ZjhkM2NpVVE1WXBZdVdoenY4aURqXCIpKSlcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ethersproject/basex/lib.esm/index.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@ethersproject/bignumber/lib.esm/_version.js":
/*!********************************************************************!*\
  !*** ../node_modules/@ethersproject/bignumber/lib.esm/_version.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\nconst version = \"bignumber/5.7.0\";\n//# sourceMappingURL=_version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2JpZ251bWJlci9saWIuZXNtL192ZXJzaW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBTztBQUNQIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGVkZ2l0eS15aWVsZC1mcm9udGVuZC8uLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvYmlnbnVtYmVyL2xpYi5lc20vX3ZlcnNpb24uanM/YmVhNCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgdmVyc2lvbiA9IFwiYmlnbnVtYmVyLzUuNy4wXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdmVyc2lvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ethersproject/bignumber/lib.esm/_version.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@ethersproject/bignumber/lib.esm/bignumber.js":
/*!*********************************************************************!*\
  !*** ../node_modules/@ethersproject/bignumber/lib.esm/bignumber.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BigNumber: () => (/* binding */ BigNumber),\n/* harmony export */   _base16To36: () => (/* binding */ _base16To36),\n/* harmony export */   _base36To16: () => (/* binding */ _base36To16),\n/* harmony export */   isBigNumberish: () => (/* binding */ isBigNumberish)\n/* harmony export */ });\n/* harmony import */ var bn_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! bn.js */ \"(ssr)/../node_modules/bn.js/lib/bn.js\");\n/* harmony import */ var bn_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(bn_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/../node_modules/@ethersproject/bytes/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/../node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_version */ \"(ssr)/../node_modules/@ethersproject/bignumber/lib.esm/_version.js\");\n\n/**\n *  BigNumber\n *\n *  A wrapper around the BN.js object. We use the BN.js library\n *  because it is used by elliptic, so it is required regardless.\n *\n */\n\nvar BN = (bn_js__WEBPACK_IMPORTED_MODULE_0___default().BN);\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger(_version__WEBPACK_IMPORTED_MODULE_2__.version);\nconst _constructorGuard = {};\nconst MAX_SAFE = 0x1fffffffffffff;\nfunction isBigNumberish(value) {\n    return (value != null) && (BigNumber.isBigNumber(value) ||\n        (typeof (value) === \"number\" && (value % 1) === 0) ||\n        (typeof (value) === \"string\" && !!value.match(/^-?[0-9]+$/)) ||\n        (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.isHexString)(value) ||\n        (typeof (value) === \"bigint\") ||\n        (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.isBytes)(value));\n}\n// Only warn about passing 10 into radix once\nlet _warnedToStringRadix = false;\nclass BigNumber {\n    constructor(constructorGuard, hex) {\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"cannot call constructor directly; use BigNumber.from\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new (BigNumber)\"\n            });\n        }\n        this._hex = hex;\n        this._isBigNumber = true;\n        Object.freeze(this);\n    }\n    fromTwos(value) {\n        return toBigNumber(toBN(this).fromTwos(value));\n    }\n    toTwos(value) {\n        return toBigNumber(toBN(this).toTwos(value));\n    }\n    abs() {\n        if (this._hex[0] === \"-\") {\n            return BigNumber.from(this._hex.substring(1));\n        }\n        return this;\n    }\n    add(other) {\n        return toBigNumber(toBN(this).add(toBN(other)));\n    }\n    sub(other) {\n        return toBigNumber(toBN(this).sub(toBN(other)));\n    }\n    div(other) {\n        const o = BigNumber.from(other);\n        if (o.isZero()) {\n            throwFault(\"division-by-zero\", \"div\");\n        }\n        return toBigNumber(toBN(this).div(toBN(other)));\n    }\n    mul(other) {\n        return toBigNumber(toBN(this).mul(toBN(other)));\n    }\n    mod(other) {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"division-by-zero\", \"mod\");\n        }\n        return toBigNumber(toBN(this).umod(value));\n    }\n    pow(other) {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"negative-power\", \"pow\");\n        }\n        return toBigNumber(toBN(this).pow(value));\n    }\n    and(other) {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"and\");\n        }\n        return toBigNumber(toBN(this).and(value));\n    }\n    or(other) {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"or\");\n        }\n        return toBigNumber(toBN(this).or(value));\n    }\n    xor(other) {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"xor\");\n        }\n        return toBigNumber(toBN(this).xor(value));\n    }\n    mask(value) {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"mask\");\n        }\n        return toBigNumber(toBN(this).maskn(value));\n    }\n    shl(value) {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shl\");\n        }\n        return toBigNumber(toBN(this).shln(value));\n    }\n    shr(value) {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shr\");\n        }\n        return toBigNumber(toBN(this).shrn(value));\n    }\n    eq(other) {\n        return toBN(this).eq(toBN(other));\n    }\n    lt(other) {\n        return toBN(this).lt(toBN(other));\n    }\n    lte(other) {\n        return toBN(this).lte(toBN(other));\n    }\n    gt(other) {\n        return toBN(this).gt(toBN(other));\n    }\n    gte(other) {\n        return toBN(this).gte(toBN(other));\n    }\n    isNegative() {\n        return (this._hex[0] === \"-\");\n    }\n    isZero() {\n        return toBN(this).isZero();\n    }\n    toNumber() {\n        try {\n            return toBN(this).toNumber();\n        }\n        catch (error) {\n            throwFault(\"overflow\", \"toNumber\", this.toString());\n        }\n        return null;\n    }\n    toBigInt() {\n        try {\n            return BigInt(this.toString());\n        }\n        catch (e) { }\n        return logger.throwError(\"this platform does not support BigInt\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.UNSUPPORTED_OPERATION, {\n            value: this.toString()\n        });\n    }\n    toString() {\n        // Lots of people expect this, which we do not support, so check (See: #889)\n        if (arguments.length > 0) {\n            if (arguments[0] === 10) {\n                if (!_warnedToStringRadix) {\n                    _warnedToStringRadix = true;\n                    logger.warn(\"BigNumber.toString does not accept any parameters; base-10 is assumed\");\n                }\n            }\n            else if (arguments[0] === 16) {\n                logger.throwError(\"BigNumber.toString does not accept any parameters; use bigNumber.toHexString()\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.UNEXPECTED_ARGUMENT, {});\n            }\n            else {\n                logger.throwError(\"BigNumber.toString does not accept parameters\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.UNEXPECTED_ARGUMENT, {});\n            }\n        }\n        return toBN(this).toString(10);\n    }\n    toHexString() {\n        return this._hex;\n    }\n    toJSON(key) {\n        return { type: \"BigNumber\", hex: this.toHexString() };\n    }\n    static from(value) {\n        if (value instanceof BigNumber) {\n            return value;\n        }\n        if (typeof (value) === \"string\") {\n            if (value.match(/^-?0x[0-9a-f]+$/i)) {\n                return new BigNumber(_constructorGuard, toHex(value));\n            }\n            if (value.match(/^-?[0-9]+$/)) {\n                return new BigNumber(_constructorGuard, toHex(new BN(value)));\n            }\n            return logger.throwArgumentError(\"invalid BigNumber string\", \"value\", value);\n        }\n        if (typeof (value) === \"number\") {\n            if (value % 1) {\n                throwFault(\"underflow\", \"BigNumber.from\", value);\n            }\n            if (value >= MAX_SAFE || value <= -MAX_SAFE) {\n                throwFault(\"overflow\", \"BigNumber.from\", value);\n            }\n            return BigNumber.from(String(value));\n        }\n        const anyValue = value;\n        if (typeof (anyValue) === \"bigint\") {\n            return BigNumber.from(anyValue.toString());\n        }\n        if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.isBytes)(anyValue)) {\n            return BigNumber.from((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexlify)(anyValue));\n        }\n        if (anyValue) {\n            // Hexable interface (takes priority)\n            if (anyValue.toHexString) {\n                const hex = anyValue.toHexString();\n                if (typeof (hex) === \"string\") {\n                    return BigNumber.from(hex);\n                }\n            }\n            else {\n                // For now, handle legacy JSON-ified values (goes away in v6)\n                let hex = anyValue._hex;\n                // New-form JSON\n                if (hex == null && anyValue.type === \"BigNumber\") {\n                    hex = anyValue.hex;\n                }\n                if (typeof (hex) === \"string\") {\n                    if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.isHexString)(hex) || (hex[0] === \"-\" && (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.isHexString)(hex.substring(1)))) {\n                        return BigNumber.from(hex);\n                    }\n                }\n            }\n        }\n        return logger.throwArgumentError(\"invalid BigNumber value\", \"value\", value);\n    }\n    static isBigNumber(value) {\n        return !!(value && value._isBigNumber);\n    }\n}\n// Normalize the hex string\nfunction toHex(value) {\n    // For BN, call on the hex string\n    if (typeof (value) !== \"string\") {\n        return toHex(value.toString(16));\n    }\n    // If negative, prepend the negative sign to the normalized positive value\n    if (value[0] === \"-\") {\n        // Strip off the negative sign\n        value = value.substring(1);\n        // Cannot have multiple negative signs (e.g. \"--0x04\")\n        if (value[0] === \"-\") {\n            logger.throwArgumentError(\"invalid hex\", \"value\", value);\n        }\n        // Call toHex on the positive component\n        value = toHex(value);\n        // Do not allow \"-0x00\"\n        if (value === \"0x00\") {\n            return value;\n        }\n        // Negate the value\n        return \"-\" + value;\n    }\n    // Add a \"0x\" prefix if missing\n    if (value.substring(0, 2) !== \"0x\") {\n        value = \"0x\" + value;\n    }\n    // Normalize zero\n    if (value === \"0x\") {\n        return \"0x00\";\n    }\n    // Make the string even length\n    if (value.length % 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n    // Trim to smallest even-length string\n    while (value.length > 4 && value.substring(0, 4) === \"0x00\") {\n        value = \"0x\" + value.substring(4);\n    }\n    return value;\n}\nfunction toBigNumber(value) {\n    return BigNumber.from(toHex(value));\n}\nfunction toBN(value) {\n    const hex = BigNumber.from(value).toHexString();\n    if (hex[0] === \"-\") {\n        return (new BN(\"-\" + hex.substring(3), 16));\n    }\n    return new BN(hex.substring(2), 16);\n}\nfunction throwFault(fault, operation, value) {\n    const params = { fault: fault, operation: operation };\n    if (value != null) {\n        params.value = value;\n    }\n    return logger.throwError(fault, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.NUMERIC_FAULT, params);\n}\n// value should have no prefix\nfunction _base36To16(value) {\n    return (new BN(value, 36)).toString(16);\n}\n// value should have no prefix\nfunction _base16To36(value) {\n    return (new BN(value, 16)).toString(36);\n}\n//# sourceMappingURL=bignumber.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2JpZ251bWJlci9saWIuZXNtL2JpZ251bWJlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ3dCO0FBQ3hCLFNBQVMsaURBQU07QUFDc0Q7QUFDdEI7QUFDVjtBQUNyQyxtQkFBbUIseURBQU0sQ0FBQyw2Q0FBTztBQUNqQztBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxRQUFRLGlFQUFXO0FBQ25CO0FBQ0EsUUFBUSw2REFBTztBQUNmO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLGlFQUFpRSxxQkFBcUIseURBQU07QUFDNUY7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUseURBQU07QUFDaEY7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRkFBb0Y7QUFDcEY7QUFDQTtBQUNBO0FBQ0Esc0ZBQXNGLDhCQUE4Qix5REFBTSwrQkFBK0I7QUFDeko7QUFDQTtBQUNBLG1GQUFtRix5REFBTSwrQkFBK0I7QUFDeEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDZEQUFPO0FBQ25CLGtDQUFrQyw2REFBTztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlFQUFXLDRCQUE0QixpRUFBVztBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHlEQUFNO0FBQzFDO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGVkZ2l0eS15aWVsZC1mcm9udGVuZC8uLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvYmlnbnVtYmVyL2xpYi5lc20vYmlnbnVtYmVyLmpzP2UxNDkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqICBCaWdOdW1iZXJcbiAqXG4gKiAgQSB3cmFwcGVyIGFyb3VuZCB0aGUgQk4uanMgb2JqZWN0LiBXZSB1c2UgdGhlIEJOLmpzIGxpYnJhcnlcbiAqICBiZWNhdXNlIGl0IGlzIHVzZWQgYnkgZWxsaXB0aWMsIHNvIGl0IGlzIHJlcXVpcmVkIHJlZ2FyZGxlc3MuXG4gKlxuICovXG5pbXBvcnQgX0JOIGZyb20gXCJibi5qc1wiO1xudmFyIEJOID0gX0JOLkJOO1xuaW1wb3J0IHsgaGV4bGlmeSwgaXNCeXRlcywgaXNIZXhTdHJpbmcgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYnl0ZXNcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi9fdmVyc2lvblwiO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcih2ZXJzaW9uKTtcbmNvbnN0IF9jb25zdHJ1Y3Rvckd1YXJkID0ge307XG5jb25zdCBNQVhfU0FGRSA9IDB4MWZmZmZmZmZmZmZmZmY7XG5leHBvcnQgZnVuY3Rpb24gaXNCaWdOdW1iZXJpc2godmFsdWUpIHtcbiAgICByZXR1cm4gKHZhbHVlICE9IG51bGwpICYmIChCaWdOdW1iZXIuaXNCaWdOdW1iZXIodmFsdWUpIHx8XG4gICAgICAgICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJudW1iZXJcIiAmJiAodmFsdWUgJSAxKSA9PT0gMCkgfHxcbiAgICAgICAgKHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiICYmICEhdmFsdWUubWF0Y2goL14tP1swLTldKyQvKSkgfHxcbiAgICAgICAgaXNIZXhTdHJpbmcodmFsdWUpIHx8XG4gICAgICAgICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJiaWdpbnRcIikgfHxcbiAgICAgICAgaXNCeXRlcyh2YWx1ZSkpO1xufVxuLy8gT25seSB3YXJuIGFib3V0IHBhc3NpbmcgMTAgaW50byByYWRpeCBvbmNlXG5sZXQgX3dhcm5lZFRvU3RyaW5nUmFkaXggPSBmYWxzZTtcbmV4cG9ydCBjbGFzcyBCaWdOdW1iZXIge1xuICAgIGNvbnN0cnVjdG9yKGNvbnN0cnVjdG9yR3VhcmQsIGhleCkge1xuICAgICAgICBpZiAoY29uc3RydWN0b3JHdWFyZCAhPT0gX2NvbnN0cnVjdG9yR3VhcmQpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiY2Fubm90IGNhbGwgY29uc3RydWN0b3IgZGlyZWN0bHk7IHVzZSBCaWdOdW1iZXIuZnJvbVwiLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJuZXcgKEJpZ051bWJlcilcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faGV4ID0gaGV4O1xuICAgICAgICB0aGlzLl9pc0JpZ051bWJlciA9IHRydWU7XG4gICAgICAgIE9iamVjdC5mcmVlemUodGhpcyk7XG4gICAgfVxuICAgIGZyb21Ud29zKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0b0JpZ051bWJlcih0b0JOKHRoaXMpLmZyb21Ud29zKHZhbHVlKSk7XG4gICAgfVxuICAgIHRvVHdvcyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdG9CaWdOdW1iZXIodG9CTih0aGlzKS50b1R3b3ModmFsdWUpKTtcbiAgICB9XG4gICAgYWJzKCkge1xuICAgICAgICBpZiAodGhpcy5faGV4WzBdID09PSBcIi1cIikge1xuICAgICAgICAgICAgcmV0dXJuIEJpZ051bWJlci5mcm9tKHRoaXMuX2hleC5zdWJzdHJpbmcoMSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBhZGQob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRvQmlnTnVtYmVyKHRvQk4odGhpcykuYWRkKHRvQk4ob3RoZXIpKSk7XG4gICAgfVxuICAgIHN1YihvdGhlcikge1xuICAgICAgICByZXR1cm4gdG9CaWdOdW1iZXIodG9CTih0aGlzKS5zdWIodG9CTihvdGhlcikpKTtcbiAgICB9XG4gICAgZGl2KG90aGVyKSB7XG4gICAgICAgIGNvbnN0IG8gPSBCaWdOdW1iZXIuZnJvbShvdGhlcik7XG4gICAgICAgIGlmIChvLmlzWmVybygpKSB7XG4gICAgICAgICAgICB0aHJvd0ZhdWx0KFwiZGl2aXNpb24tYnktemVyb1wiLCBcImRpdlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9CaWdOdW1iZXIodG9CTih0aGlzKS5kaXYodG9CTihvdGhlcikpKTtcbiAgICB9XG4gICAgbXVsKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0b0JpZ051bWJlcih0b0JOKHRoaXMpLm11bCh0b0JOKG90aGVyKSkpO1xuICAgIH1cbiAgICBtb2Qob3RoZXIpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0b0JOKG90aGVyKTtcbiAgICAgICAgaWYgKHZhbHVlLmlzTmVnKCkpIHtcbiAgICAgICAgICAgIHRocm93RmF1bHQoXCJkaXZpc2lvbi1ieS16ZXJvXCIsIFwibW9kXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b0JpZ051bWJlcih0b0JOKHRoaXMpLnVtb2QodmFsdWUpKTtcbiAgICB9XG4gICAgcG93KG90aGVyKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdG9CTihvdGhlcik7XG4gICAgICAgIGlmICh2YWx1ZS5pc05lZygpKSB7XG4gICAgICAgICAgICB0aHJvd0ZhdWx0KFwibmVnYXRpdmUtcG93ZXJcIiwgXCJwb3dcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvQmlnTnVtYmVyKHRvQk4odGhpcykucG93KHZhbHVlKSk7XG4gICAgfVxuICAgIGFuZChvdGhlcikge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRvQk4ob3RoZXIpO1xuICAgICAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkgfHwgdmFsdWUuaXNOZWcoKSkge1xuICAgICAgICAgICAgdGhyb3dGYXVsdChcInVuYm91bmQtYml0d2lzZS1yZXN1bHRcIiwgXCJhbmRcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvQmlnTnVtYmVyKHRvQk4odGhpcykuYW5kKHZhbHVlKSk7XG4gICAgfVxuICAgIG9yKG90aGVyKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdG9CTihvdGhlcik7XG4gICAgICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSB8fCB2YWx1ZS5pc05lZygpKSB7XG4gICAgICAgICAgICB0aHJvd0ZhdWx0KFwidW5ib3VuZC1iaXR3aXNlLXJlc3VsdFwiLCBcIm9yXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b0JpZ051bWJlcih0b0JOKHRoaXMpLm9yKHZhbHVlKSk7XG4gICAgfVxuICAgIHhvcihvdGhlcikge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRvQk4ob3RoZXIpO1xuICAgICAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkgfHwgdmFsdWUuaXNOZWcoKSkge1xuICAgICAgICAgICAgdGhyb3dGYXVsdChcInVuYm91bmQtYml0d2lzZS1yZXN1bHRcIiwgXCJ4b3JcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvQmlnTnVtYmVyKHRvQk4odGhpcykueG9yKHZhbHVlKSk7XG4gICAgfVxuICAgIG1hc2sodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpIHx8IHZhbHVlIDwgMCkge1xuICAgICAgICAgICAgdGhyb3dGYXVsdChcIm5lZ2F0aXZlLXdpZHRoXCIsIFwibWFza1wiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9CaWdOdW1iZXIodG9CTih0aGlzKS5tYXNrbih2YWx1ZSkpO1xuICAgIH1cbiAgICBzaGwodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpIHx8IHZhbHVlIDwgMCkge1xuICAgICAgICAgICAgdGhyb3dGYXVsdChcIm5lZ2F0aXZlLXdpZHRoXCIsIFwic2hsXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b0JpZ051bWJlcih0b0JOKHRoaXMpLnNobG4odmFsdWUpKTtcbiAgICB9XG4gICAgc2hyKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSB8fCB2YWx1ZSA8IDApIHtcbiAgICAgICAgICAgIHRocm93RmF1bHQoXCJuZWdhdGl2ZS13aWR0aFwiLCBcInNoclwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9CaWdOdW1iZXIodG9CTih0aGlzKS5zaHJuKHZhbHVlKSk7XG4gICAgfVxuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0b0JOKHRoaXMpLmVxKHRvQk4ob3RoZXIpKTtcbiAgICB9XG4gICAgbHQob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRvQk4odGhpcykubHQodG9CTihvdGhlcikpO1xuICAgIH1cbiAgICBsdGUob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRvQk4odGhpcykubHRlKHRvQk4ob3RoZXIpKTtcbiAgICB9XG4gICAgZ3Qob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRvQk4odGhpcykuZ3QodG9CTihvdGhlcikpO1xuICAgIH1cbiAgICBndGUob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRvQk4odGhpcykuZ3RlKHRvQk4ob3RoZXIpKTtcbiAgICB9XG4gICAgaXNOZWdhdGl2ZSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9oZXhbMF0gPT09IFwiLVwiKTtcbiAgICB9XG4gICAgaXNaZXJvKCkge1xuICAgICAgICByZXR1cm4gdG9CTih0aGlzKS5pc1plcm8oKTtcbiAgICB9XG4gICAgdG9OdW1iZXIoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gdG9CTih0aGlzKS50b051bWJlcigpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3dGYXVsdChcIm92ZXJmbG93XCIsIFwidG9OdW1iZXJcIiwgdGhpcy50b1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdG9CaWdJbnQoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gQmlnSW50KHRoaXMudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHsgfVxuICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93RXJyb3IoXCJ0aGlzIHBsYXRmb3JtIGRvZXMgbm90IHN1cHBvcnQgQmlnSW50XCIsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICB2YWx1ZTogdGhpcy50b1N0cmluZygpXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgLy8gTG90cyBvZiBwZW9wbGUgZXhwZWN0IHRoaXMsIHdoaWNoIHdlIGRvIG5vdCBzdXBwb3J0LCBzbyBjaGVjayAoU2VlOiAjODg5KVxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHNbMF0gPT09IDEwKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFfd2FybmVkVG9TdHJpbmdSYWRpeCkge1xuICAgICAgICAgICAgICAgICAgICBfd2FybmVkVG9TdHJpbmdSYWRpeCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKFwiQmlnTnVtYmVyLnRvU3RyaW5nIGRvZXMgbm90IGFjY2VwdCBhbnkgcGFyYW1ldGVyczsgYmFzZS0xMCBpcyBhc3N1bWVkXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFyZ3VtZW50c1swXSA9PT0gMTYpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcIkJpZ051bWJlci50b1N0cmluZyBkb2VzIG5vdCBhY2NlcHQgYW55IHBhcmFtZXRlcnM7IHVzZSBiaWdOdW1iZXIudG9IZXhTdHJpbmcoKVwiLCBMb2dnZXIuZXJyb3JzLlVORVhQRUNURURfQVJHVU1FTlQsIHt9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiQmlnTnVtYmVyLnRvU3RyaW5nIGRvZXMgbm90IGFjY2VwdCBwYXJhbWV0ZXJzXCIsIExvZ2dlci5lcnJvcnMuVU5FWFBFQ1RFRF9BUkdVTUVOVCwge30pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b0JOKHRoaXMpLnRvU3RyaW5nKDEwKTtcbiAgICB9XG4gICAgdG9IZXhTdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oZXg7XG4gICAgfVxuICAgIHRvSlNPTihrZXkpIHtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJCaWdOdW1iZXJcIiwgaGV4OiB0aGlzLnRvSGV4U3RyaW5nKCkgfTtcbiAgICB9XG4gICAgc3RhdGljIGZyb20odmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQmlnTnVtYmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUubWF0Y2goL14tPzB4WzAtOWEtZl0rJC9pKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKF9jb25zdHJ1Y3Rvckd1YXJkLCB0b0hleCh2YWx1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlLm1hdGNoKC9eLT9bMC05XSskLykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlcihfY29uc3RydWN0b3JHdWFyZCwgdG9IZXgobmV3IEJOKHZhbHVlKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIEJpZ051bWJlciBzdHJpbmdcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgJSAxKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dGYXVsdChcInVuZGVyZmxvd1wiLCBcIkJpZ051bWJlci5mcm9tXCIsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZSA+PSBNQVhfU0FGRSB8fCB2YWx1ZSA8PSAtTUFYX1NBRkUpIHtcbiAgICAgICAgICAgICAgICB0aHJvd0ZhdWx0KFwib3ZlcmZsb3dcIiwgXCJCaWdOdW1iZXIuZnJvbVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gQmlnTnVtYmVyLmZyb20oU3RyaW5nKHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYW55VmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgaWYgKHR5cGVvZiAoYW55VmFsdWUpID09PSBcImJpZ2ludFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gQmlnTnVtYmVyLmZyb20oYW55VmFsdWUudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQnl0ZXMoYW55VmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gQmlnTnVtYmVyLmZyb20oaGV4bGlmeShhbnlWYWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbnlWYWx1ZSkge1xuICAgICAgICAgICAgLy8gSGV4YWJsZSBpbnRlcmZhY2UgKHRha2VzIHByaW9yaXR5KVxuICAgICAgICAgICAgaWYgKGFueVZhbHVlLnRvSGV4U3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaGV4ID0gYW55VmFsdWUudG9IZXhTdHJpbmcoKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChoZXgpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBCaWdOdW1iZXIuZnJvbShoZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEZvciBub3csIGhhbmRsZSBsZWdhY3kgSlNPTi1pZmllZCB2YWx1ZXMgKGdvZXMgYXdheSBpbiB2NilcbiAgICAgICAgICAgICAgICBsZXQgaGV4ID0gYW55VmFsdWUuX2hleDtcbiAgICAgICAgICAgICAgICAvLyBOZXctZm9ybSBKU09OXG4gICAgICAgICAgICAgICAgaWYgKGhleCA9PSBudWxsICYmIGFueVZhbHVlLnR5cGUgPT09IFwiQmlnTnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaGV4ID0gYW55VmFsdWUuaGV4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChoZXgpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0hleFN0cmluZyhoZXgpIHx8IChoZXhbMF0gPT09IFwiLVwiICYmIGlzSGV4U3RyaW5nKGhleC5zdWJzdHJpbmcoMSkpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJpZ051bWJlci5mcm9tKGhleCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIEJpZ051bWJlciB2YWx1ZVwiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICB9XG4gICAgc3RhdGljIGlzQmlnTnVtYmVyKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZS5faXNCaWdOdW1iZXIpO1xuICAgIH1cbn1cbi8vIE5vcm1hbGl6ZSB0aGUgaGV4IHN0cmluZ1xuZnVuY3Rpb24gdG9IZXgodmFsdWUpIHtcbiAgICAvLyBGb3IgQk4sIGNhbGwgb24gdGhlIGhleCBzdHJpbmdcbiAgICBpZiAodHlwZW9mICh2YWx1ZSkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIHRvSGV4KHZhbHVlLnRvU3RyaW5nKDE2KSk7XG4gICAgfVxuICAgIC8vIElmIG5lZ2F0aXZlLCBwcmVwZW5kIHRoZSBuZWdhdGl2ZSBzaWduIHRvIHRoZSBub3JtYWxpemVkIHBvc2l0aXZlIHZhbHVlXG4gICAgaWYgKHZhbHVlWzBdID09PSBcIi1cIikge1xuICAgICAgICAvLyBTdHJpcCBvZmYgdGhlIG5lZ2F0aXZlIHNpZ25cbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5zdWJzdHJpbmcoMSk7XG4gICAgICAgIC8vIENhbm5vdCBoYXZlIG11bHRpcGxlIG5lZ2F0aXZlIHNpZ25zIChlLmcuIFwiLS0weDA0XCIpXG4gICAgICAgIGlmICh2YWx1ZVswXSA9PT0gXCItXCIpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGhleFwiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDYWxsIHRvSGV4IG9uIHRoZSBwb3NpdGl2ZSBjb21wb25lbnRcbiAgICAgICAgdmFsdWUgPSB0b0hleCh2YWx1ZSk7XG4gICAgICAgIC8vIERvIG5vdCBhbGxvdyBcIi0weDAwXCJcbiAgICAgICAgaWYgKHZhbHVlID09PSBcIjB4MDBcIikge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5lZ2F0ZSB0aGUgdmFsdWVcbiAgICAgICAgcmV0dXJuIFwiLVwiICsgdmFsdWU7XG4gICAgfVxuICAgIC8vIEFkZCBhIFwiMHhcIiBwcmVmaXggaWYgbWlzc2luZ1xuICAgIGlmICh2YWx1ZS5zdWJzdHJpbmcoMCwgMikgIT09IFwiMHhcIikge1xuICAgICAgICB2YWx1ZSA9IFwiMHhcIiArIHZhbHVlO1xuICAgIH1cbiAgICAvLyBOb3JtYWxpemUgemVyb1xuICAgIGlmICh2YWx1ZSA9PT0gXCIweFwiKSB7XG4gICAgICAgIHJldHVybiBcIjB4MDBcIjtcbiAgICB9XG4gICAgLy8gTWFrZSB0aGUgc3RyaW5nIGV2ZW4gbGVuZ3RoXG4gICAgaWYgKHZhbHVlLmxlbmd0aCAlIDIpIHtcbiAgICAgICAgdmFsdWUgPSBcIjB4MFwiICsgdmFsdWUuc3Vic3RyaW5nKDIpO1xuICAgIH1cbiAgICAvLyBUcmltIHRvIHNtYWxsZXN0IGV2ZW4tbGVuZ3RoIHN0cmluZ1xuICAgIHdoaWxlICh2YWx1ZS5sZW5ndGggPiA0ICYmIHZhbHVlLnN1YnN0cmluZygwLCA0KSA9PT0gXCIweDAwXCIpIHtcbiAgICAgICAgdmFsdWUgPSBcIjB4XCIgKyB2YWx1ZS5zdWJzdHJpbmcoNCk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIHRvQmlnTnVtYmVyKHZhbHVlKSB7XG4gICAgcmV0dXJuIEJpZ051bWJlci5mcm9tKHRvSGV4KHZhbHVlKSk7XG59XG5mdW5jdGlvbiB0b0JOKHZhbHVlKSB7XG4gICAgY29uc3QgaGV4ID0gQmlnTnVtYmVyLmZyb20odmFsdWUpLnRvSGV4U3RyaW5nKCk7XG4gICAgaWYgKGhleFswXSA9PT0gXCItXCIpIHtcbiAgICAgICAgcmV0dXJuIChuZXcgQk4oXCItXCIgKyBoZXguc3Vic3RyaW5nKDMpLCAxNikpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEJOKGhleC5zdWJzdHJpbmcoMiksIDE2KTtcbn1cbmZ1bmN0aW9uIHRocm93RmF1bHQoZmF1bHQsIG9wZXJhdGlvbiwgdmFsdWUpIHtcbiAgICBjb25zdCBwYXJhbXMgPSB7IGZhdWx0OiBmYXVsdCwgb3BlcmF0aW9uOiBvcGVyYXRpb24gfTtcbiAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICBwYXJhbXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGxvZ2dlci50aHJvd0Vycm9yKGZhdWx0LCBMb2dnZXIuZXJyb3JzLk5VTUVSSUNfRkFVTFQsIHBhcmFtcyk7XG59XG4vLyB2YWx1ZSBzaG91bGQgaGF2ZSBubyBwcmVmaXhcbmV4cG9ydCBmdW5jdGlvbiBfYmFzZTM2VG8xNih2YWx1ZSkge1xuICAgIHJldHVybiAobmV3IEJOKHZhbHVlLCAzNikpLnRvU3RyaW5nKDE2KTtcbn1cbi8vIHZhbHVlIHNob3VsZCBoYXZlIG5vIHByZWZpeFxuZXhwb3J0IGZ1bmN0aW9uIF9iYXNlMTZUbzM2KHZhbHVlKSB7XG4gICAgcmV0dXJuIChuZXcgQk4odmFsdWUsIDE2KSkudG9TdHJpbmcoMzYpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmlnbnVtYmVyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ethersproject/bignumber/lib.esm/bignumber.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@ethersproject/bignumber/lib.esm/fixednumber.js":
/*!***********************************************************************!*\
  !*** ../node_modules/@ethersproject/bignumber/lib.esm/fixednumber.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FixedFormat: () => (/* binding */ FixedFormat),\n/* harmony export */   FixedNumber: () => (/* binding */ FixedNumber),\n/* harmony export */   formatFixed: () => (/* binding */ formatFixed),\n/* harmony export */   parseFixed: () => (/* binding */ parseFixed)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/../node_modules/@ethersproject/bytes/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/../node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(ssr)/../node_modules/@ethersproject/bignumber/lib.esm/_version.js\");\n/* harmony import */ var _bignumber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./bignumber */ \"(ssr)/../node_modules/@ethersproject/bignumber/lib.esm/bignumber.js\");\n\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\n\nconst _constructorGuard = {};\nconst Zero = _bignumber__WEBPACK_IMPORTED_MODULE_2__.BigNumber.from(0);\nconst NegativeOne = _bignumber__WEBPACK_IMPORTED_MODULE_2__.BigNumber.from(-1);\nfunction throwFault(message, fault, operation, value) {\n    const params = { fault: fault, operation: operation };\n    if (value !== undefined) {\n        params.value = value;\n    }\n    return logger.throwError(message, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.NUMERIC_FAULT, params);\n}\n// Constant to pull zeros from for multipliers\nlet zeros = \"0\";\nwhile (zeros.length < 256) {\n    zeros += zeros;\n}\n// Returns a string \"1\" followed by decimal \"0\"s\nfunction getMultiplier(decimals) {\n    if (typeof (decimals) !== \"number\") {\n        try {\n            decimals = _bignumber__WEBPACK_IMPORTED_MODULE_2__.BigNumber.from(decimals).toNumber();\n        }\n        catch (e) { }\n    }\n    if (typeof (decimals) === \"number\" && decimals >= 0 && decimals <= 256 && !(decimals % 1)) {\n        return (\"1\" + zeros.substring(0, decimals));\n    }\n    return logger.throwArgumentError(\"invalid decimal size\", \"decimals\", decimals);\n}\nfunction formatFixed(value, decimals) {\n    if (decimals == null) {\n        decimals = 0;\n    }\n    const multiplier = getMultiplier(decimals);\n    // Make sure wei is a big number (convert as necessary)\n    value = _bignumber__WEBPACK_IMPORTED_MODULE_2__.BigNumber.from(value);\n    const negative = value.lt(Zero);\n    if (negative) {\n        value = value.mul(NegativeOne);\n    }\n    let fraction = value.mod(multiplier).toString();\n    while (fraction.length < multiplier.length - 1) {\n        fraction = \"0\" + fraction;\n    }\n    // Strip training 0\n    fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];\n    const whole = value.div(multiplier).toString();\n    if (multiplier.length === 1) {\n        value = whole;\n    }\n    else {\n        value = whole + \".\" + fraction;\n    }\n    if (negative) {\n        value = \"-\" + value;\n    }\n    return value;\n}\nfunction parseFixed(value, decimals) {\n    if (decimals == null) {\n        decimals = 0;\n    }\n    const multiplier = getMultiplier(decimals);\n    if (typeof (value) !== \"string\" || !value.match(/^-?[0-9.]+$/)) {\n        logger.throwArgumentError(\"invalid decimal value\", \"value\", value);\n    }\n    // Is it negative?\n    const negative = (value.substring(0, 1) === \"-\");\n    if (negative) {\n        value = value.substring(1);\n    }\n    if (value === \".\") {\n        logger.throwArgumentError(\"missing value\", \"value\", value);\n    }\n    // Split it into a whole and fractional part\n    const comps = value.split(\".\");\n    if (comps.length > 2) {\n        logger.throwArgumentError(\"too many decimal points\", \"value\", value);\n    }\n    let whole = comps[0], fraction = comps[1];\n    if (!whole) {\n        whole = \"0\";\n    }\n    if (!fraction) {\n        fraction = \"0\";\n    }\n    // Trim trailing zeros\n    while (fraction[fraction.length - 1] === \"0\") {\n        fraction = fraction.substring(0, fraction.length - 1);\n    }\n    // Check the fraction doesn't exceed our decimals size\n    if (fraction.length > multiplier.length - 1) {\n        throwFault(\"fractional component exceeds decimals\", \"underflow\", \"parseFixed\");\n    }\n    // If decimals is 0, we have an empty string for fraction\n    if (fraction === \"\") {\n        fraction = \"0\";\n    }\n    // Fully pad the string with zeros to get to wei\n    while (fraction.length < multiplier.length - 1) {\n        fraction += \"0\";\n    }\n    const wholeValue = _bignumber__WEBPACK_IMPORTED_MODULE_2__.BigNumber.from(whole);\n    const fractionValue = _bignumber__WEBPACK_IMPORTED_MODULE_2__.BigNumber.from(fraction);\n    let wei = (wholeValue.mul(multiplier)).add(fractionValue);\n    if (negative) {\n        wei = wei.mul(NegativeOne);\n    }\n    return wei;\n}\nclass FixedFormat {\n    constructor(constructorGuard, signed, width, decimals) {\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"cannot use FixedFormat constructor; use FixedFormat.from\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new FixedFormat\"\n            });\n        }\n        this.signed = signed;\n        this.width = width;\n        this.decimals = decimals;\n        this.name = (signed ? \"\" : \"u\") + \"fixed\" + String(width) + \"x\" + String(decimals);\n        this._multiplier = getMultiplier(decimals);\n        Object.freeze(this);\n    }\n    static from(value) {\n        if (value instanceof FixedFormat) {\n            return value;\n        }\n        if (typeof (value) === \"number\") {\n            value = `fixed128x${value}`;\n        }\n        let signed = true;\n        let width = 128;\n        let decimals = 18;\n        if (typeof (value) === \"string\") {\n            if (value === \"fixed\") {\n                // defaults...\n            }\n            else if (value === \"ufixed\") {\n                signed = false;\n            }\n            else {\n                const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);\n                if (!match) {\n                    logger.throwArgumentError(\"invalid fixed format\", \"format\", value);\n                }\n                signed = (match[1] !== \"u\");\n                width = parseInt(match[2]);\n                decimals = parseInt(match[3]);\n            }\n        }\n        else if (value) {\n            const check = (key, type, defaultValue) => {\n                if (value[key] == null) {\n                    return defaultValue;\n                }\n                if (typeof (value[key]) !== type) {\n                    logger.throwArgumentError(\"invalid fixed format (\" + key + \" not \" + type + \")\", \"format.\" + key, value[key]);\n                }\n                return value[key];\n            };\n            signed = check(\"signed\", \"boolean\", signed);\n            width = check(\"width\", \"number\", width);\n            decimals = check(\"decimals\", \"number\", decimals);\n        }\n        if (width % 8) {\n            logger.throwArgumentError(\"invalid fixed format width (not byte aligned)\", \"format.width\", width);\n        }\n        if (decimals > 80) {\n            logger.throwArgumentError(\"invalid fixed format (decimals too large)\", \"format.decimals\", decimals);\n        }\n        return new FixedFormat(_constructorGuard, signed, width, decimals);\n    }\n}\nclass FixedNumber {\n    constructor(constructorGuard, hex, value, format) {\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"cannot use FixedNumber constructor; use FixedNumber.from\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new FixedFormat\"\n            });\n        }\n        this.format = format;\n        this._hex = hex;\n        this._value = value;\n        this._isFixedNumber = true;\n        Object.freeze(this);\n    }\n    _checkFormat(other) {\n        if (this.format.name !== other.format.name) {\n            logger.throwArgumentError(\"incompatible format; use fixedNumber.toFormat\", \"other\", other);\n        }\n    }\n    addUnsafe(other) {\n        this._checkFormat(other);\n        const a = parseFixed(this._value, this.format.decimals);\n        const b = parseFixed(other._value, other.format.decimals);\n        return FixedNumber.fromValue(a.add(b), this.format.decimals, this.format);\n    }\n    subUnsafe(other) {\n        this._checkFormat(other);\n        const a = parseFixed(this._value, this.format.decimals);\n        const b = parseFixed(other._value, other.format.decimals);\n        return FixedNumber.fromValue(a.sub(b), this.format.decimals, this.format);\n    }\n    mulUnsafe(other) {\n        this._checkFormat(other);\n        const a = parseFixed(this._value, this.format.decimals);\n        const b = parseFixed(other._value, other.format.decimals);\n        return FixedNumber.fromValue(a.mul(b).div(this.format._multiplier), this.format.decimals, this.format);\n    }\n    divUnsafe(other) {\n        this._checkFormat(other);\n        const a = parseFixed(this._value, this.format.decimals);\n        const b = parseFixed(other._value, other.format.decimals);\n        return FixedNumber.fromValue(a.mul(this.format._multiplier).div(b), this.format.decimals, this.format);\n    }\n    floor() {\n        const comps = this.toString().split(\".\");\n        if (comps.length === 1) {\n            comps.push(\"0\");\n        }\n        let result = FixedNumber.from(comps[0], this.format);\n        const hasFraction = !comps[1].match(/^(0*)$/);\n        if (this.isNegative() && hasFraction) {\n            result = result.subUnsafe(ONE.toFormat(result.format));\n        }\n        return result;\n    }\n    ceiling() {\n        const comps = this.toString().split(\".\");\n        if (comps.length === 1) {\n            comps.push(\"0\");\n        }\n        let result = FixedNumber.from(comps[0], this.format);\n        const hasFraction = !comps[1].match(/^(0*)$/);\n        if (!this.isNegative() && hasFraction) {\n            result = result.addUnsafe(ONE.toFormat(result.format));\n        }\n        return result;\n    }\n    // @TODO: Support other rounding algorithms\n    round(decimals) {\n        if (decimals == null) {\n            decimals = 0;\n        }\n        // If we are already in range, we're done\n        const comps = this.toString().split(\".\");\n        if (comps.length === 1) {\n            comps.push(\"0\");\n        }\n        if (decimals < 0 || decimals > 80 || (decimals % 1)) {\n            logger.throwArgumentError(\"invalid decimal count\", \"decimals\", decimals);\n        }\n        if (comps[1].length <= decimals) {\n            return this;\n        }\n        const factor = FixedNumber.from(\"1\" + zeros.substring(0, decimals), this.format);\n        const bump = BUMP.toFormat(this.format);\n        return this.mulUnsafe(factor).addUnsafe(bump).floor().divUnsafe(factor);\n    }\n    isZero() {\n        return (this._value === \"0.0\" || this._value === \"0\");\n    }\n    isNegative() {\n        return (this._value[0] === \"-\");\n    }\n    toString() { return this._value; }\n    toHexString(width) {\n        if (width == null) {\n            return this._hex;\n        }\n        if (width % 8) {\n            logger.throwArgumentError(\"invalid byte width\", \"width\", width);\n        }\n        const hex = _bignumber__WEBPACK_IMPORTED_MODULE_2__.BigNumber.from(this._hex).fromTwos(this.format.width).toTwos(width).toHexString();\n        return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexZeroPad)(hex, width / 8);\n    }\n    toUnsafeFloat() { return parseFloat(this.toString()); }\n    toFormat(format) {\n        return FixedNumber.fromString(this._value, format);\n    }\n    static fromValue(value, decimals, format) {\n        // If decimals looks more like a format, and there is no format, shift the parameters\n        if (format == null && decimals != null && !(0,_bignumber__WEBPACK_IMPORTED_MODULE_2__.isBigNumberish)(decimals)) {\n            format = decimals;\n            decimals = null;\n        }\n        if (decimals == null) {\n            decimals = 0;\n        }\n        if (format == null) {\n            format = \"fixed\";\n        }\n        return FixedNumber.fromString(formatFixed(value, decimals), FixedFormat.from(format));\n    }\n    static fromString(value, format) {\n        if (format == null) {\n            format = \"fixed\";\n        }\n        const fixedFormat = FixedFormat.from(format);\n        const numeric = parseFixed(value, fixedFormat.decimals);\n        if (!fixedFormat.signed && numeric.lt(Zero)) {\n            throwFault(\"unsigned value cannot be negative\", \"overflow\", \"value\", value);\n        }\n        let hex = null;\n        if (fixedFormat.signed) {\n            hex = numeric.toTwos(fixedFormat.width).toHexString();\n        }\n        else {\n            hex = numeric.toHexString();\n            hex = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexZeroPad)(hex, fixedFormat.width / 8);\n        }\n        const decimal = formatFixed(numeric, fixedFormat.decimals);\n        return new FixedNumber(_constructorGuard, hex, decimal, fixedFormat);\n    }\n    static fromBytes(value, format) {\n        if (format == null) {\n            format = \"fixed\";\n        }\n        const fixedFormat = FixedFormat.from(format);\n        if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.arrayify)(value).length > fixedFormat.width / 8) {\n            throw new Error(\"overflow\");\n        }\n        let numeric = _bignumber__WEBPACK_IMPORTED_MODULE_2__.BigNumber.from(value);\n        if (fixedFormat.signed) {\n            numeric = numeric.fromTwos(fixedFormat.width);\n        }\n        const hex = numeric.toTwos((fixedFormat.signed ? 0 : 1) + fixedFormat.width).toHexString();\n        const decimal = formatFixed(numeric, fixedFormat.decimals);\n        return new FixedNumber(_constructorGuard, hex, decimal, fixedFormat);\n    }\n    static from(value, format) {\n        if (typeof (value) === \"string\") {\n            return FixedNumber.fromString(value, format);\n        }\n        if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.isBytes)(value)) {\n            return FixedNumber.fromBytes(value, format);\n        }\n        try {\n            return FixedNumber.fromValue(value, 0, format);\n        }\n        catch (error) {\n            // Allow NUMERIC_FAULT to bubble up\n            if (error.code !== _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.INVALID_ARGUMENT) {\n                throw error;\n            }\n        }\n        return logger.throwArgumentError(\"invalid FixedNumber value\", \"value\", value);\n    }\n    static isFixedNumber(value) {\n        return !!(value && value._isFixedNumber);\n    }\n}\nconst ONE = FixedNumber.from(1);\nconst BUMP = FixedNumber.from(\"0.5\");\n//# sourceMappingURL=fixednumber.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2JpZ251bWJlci9saWIuZXNtL2ZpeGVkbnVtYmVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQWE7QUFDd0Q7QUFDdEI7QUFDVjtBQUNyQyxtQkFBbUIseURBQU0sQ0FBQyw2Q0FBTztBQUN1QjtBQUN4RDtBQUNBLGFBQWEsaURBQVM7QUFDdEIsb0JBQW9CLGlEQUFTO0FBQzdCO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyx5REFBTTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixpREFBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxpREFBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsaURBQVM7QUFDaEMsMEJBQTBCLGlEQUFTO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLG1FQUFtRSx1QkFBdUIseURBQU07QUFDaEc7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsTUFBTTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsbUVBQW1FLHVCQUF1Qix5REFBTTtBQUNoRztBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaURBQVM7QUFDN0IsZUFBZSxnRUFBVTtBQUN6QjtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELDBEQUFjO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0VBQVU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw4REFBUTtBQUNwQjtBQUNBO0FBQ0Esc0JBQXNCLGlEQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDZEQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHlEQUFNO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xlZGdpdHkteWllbGQtZnJvbnRlbmQvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2JpZ251bWJlci9saWIuZXNtL2ZpeGVkbnVtYmVyLmpzPzg0OTkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgeyBhcnJheWlmeSwgaGV4WmVyb1BhZCwgaXNCeXRlcyB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9ieXRlc1wiO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2xvZ2dlclwiO1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gXCIuL192ZXJzaW9uXCI7XG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyKHZlcnNpb24pO1xuaW1wb3J0IHsgQmlnTnVtYmVyLCBpc0JpZ051bWJlcmlzaCB9IGZyb20gXCIuL2JpZ251bWJlclwiO1xuY29uc3QgX2NvbnN0cnVjdG9yR3VhcmQgPSB7fTtcbmNvbnN0IFplcm8gPSBCaWdOdW1iZXIuZnJvbSgwKTtcbmNvbnN0IE5lZ2F0aXZlT25lID0gQmlnTnVtYmVyLmZyb20oLTEpO1xuZnVuY3Rpb24gdGhyb3dGYXVsdChtZXNzYWdlLCBmYXVsdCwgb3BlcmF0aW9uLCB2YWx1ZSkge1xuICAgIGNvbnN0IHBhcmFtcyA9IHsgZmF1bHQ6IGZhdWx0LCBvcGVyYXRpb246IG9wZXJhdGlvbiB9O1xuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHBhcmFtcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gbG9nZ2VyLnRocm93RXJyb3IobWVzc2FnZSwgTG9nZ2VyLmVycm9ycy5OVU1FUklDX0ZBVUxULCBwYXJhbXMpO1xufVxuLy8gQ29uc3RhbnQgdG8gcHVsbCB6ZXJvcyBmcm9tIGZvciBtdWx0aXBsaWVyc1xubGV0IHplcm9zID0gXCIwXCI7XG53aGlsZSAoemVyb3MubGVuZ3RoIDwgMjU2KSB7XG4gICAgemVyb3MgKz0gemVyb3M7XG59XG4vLyBSZXR1cm5zIGEgc3RyaW5nIFwiMVwiIGZvbGxvd2VkIGJ5IGRlY2ltYWwgXCIwXCJzXG5mdW5jdGlvbiBnZXRNdWx0aXBsaWVyKGRlY2ltYWxzKSB7XG4gICAgaWYgKHR5cGVvZiAoZGVjaW1hbHMpICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkZWNpbWFscyA9IEJpZ051bWJlci5mcm9tKGRlY2ltYWxzKS50b051bWJlcigpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiAoZGVjaW1hbHMpID09PSBcIm51bWJlclwiICYmIGRlY2ltYWxzID49IDAgJiYgZGVjaW1hbHMgPD0gMjU2ICYmICEoZGVjaW1hbHMgJSAxKSkge1xuICAgICAgICByZXR1cm4gKFwiMVwiICsgemVyb3Muc3Vic3RyaW5nKDAsIGRlY2ltYWxzKSk7XG4gICAgfVxuICAgIHJldHVybiBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBkZWNpbWFsIHNpemVcIiwgXCJkZWNpbWFsc1wiLCBkZWNpbWFscyk7XG59XG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0Rml4ZWQodmFsdWUsIGRlY2ltYWxzKSB7XG4gICAgaWYgKGRlY2ltYWxzID09IG51bGwpIHtcbiAgICAgICAgZGVjaW1hbHMgPSAwO1xuICAgIH1cbiAgICBjb25zdCBtdWx0aXBsaWVyID0gZ2V0TXVsdGlwbGllcihkZWNpbWFscyk7XG4gICAgLy8gTWFrZSBzdXJlIHdlaSBpcyBhIGJpZyBudW1iZXIgKGNvbnZlcnQgYXMgbmVjZXNzYXJ5KVxuICAgIHZhbHVlID0gQmlnTnVtYmVyLmZyb20odmFsdWUpO1xuICAgIGNvbnN0IG5lZ2F0aXZlID0gdmFsdWUubHQoWmVybyk7XG4gICAgaWYgKG5lZ2F0aXZlKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUubXVsKE5lZ2F0aXZlT25lKTtcbiAgICB9XG4gICAgbGV0IGZyYWN0aW9uID0gdmFsdWUubW9kKG11bHRpcGxpZXIpLnRvU3RyaW5nKCk7XG4gICAgd2hpbGUgKGZyYWN0aW9uLmxlbmd0aCA8IG11bHRpcGxpZXIubGVuZ3RoIC0gMSkge1xuICAgICAgICBmcmFjdGlvbiA9IFwiMFwiICsgZnJhY3Rpb247XG4gICAgfVxuICAgIC8vIFN0cmlwIHRyYWluaW5nIDBcbiAgICBmcmFjdGlvbiA9IGZyYWN0aW9uLm1hdGNoKC9eKFswLTldKlsxLTldfDApKDAqKS8pWzFdO1xuICAgIGNvbnN0IHdob2xlID0gdmFsdWUuZGl2KG11bHRpcGxpZXIpLnRvU3RyaW5nKCk7XG4gICAgaWYgKG11bHRpcGxpZXIubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHZhbHVlID0gd2hvbGU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YWx1ZSA9IHdob2xlICsgXCIuXCIgKyBmcmFjdGlvbjtcbiAgICB9XG4gICAgaWYgKG5lZ2F0aXZlKSB7XG4gICAgICAgIHZhbHVlID0gXCItXCIgKyB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlRml4ZWQodmFsdWUsIGRlY2ltYWxzKSB7XG4gICAgaWYgKGRlY2ltYWxzID09IG51bGwpIHtcbiAgICAgICAgZGVjaW1hbHMgPSAwO1xuICAgIH1cbiAgICBjb25zdCBtdWx0aXBsaWVyID0gZ2V0TXVsdGlwbGllcihkZWNpbWFscyk7XG4gICAgaWYgKHR5cGVvZiAodmFsdWUpICE9PSBcInN0cmluZ1wiIHx8ICF2YWx1ZS5tYXRjaCgvXi0/WzAtOS5dKyQvKSkge1xuICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBkZWNpbWFsIHZhbHVlXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgIH1cbiAgICAvLyBJcyBpdCBuZWdhdGl2ZT9cbiAgICBjb25zdCBuZWdhdGl2ZSA9ICh2YWx1ZS5zdWJzdHJpbmcoMCwgMSkgPT09IFwiLVwiKTtcbiAgICBpZiAobmVnYXRpdmUpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5zdWJzdHJpbmcoMSk7XG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PT0gXCIuXCIpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcIm1pc3NpbmcgdmFsdWVcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgfVxuICAgIC8vIFNwbGl0IGl0IGludG8gYSB3aG9sZSBhbmQgZnJhY3Rpb25hbCBwYXJ0XG4gICAgY29uc3QgY29tcHMgPSB2YWx1ZS5zcGxpdChcIi5cIik7XG4gICAgaWYgKGNvbXBzLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInRvbyBtYW55IGRlY2ltYWwgcG9pbnRzXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgIH1cbiAgICBsZXQgd2hvbGUgPSBjb21wc1swXSwgZnJhY3Rpb24gPSBjb21wc1sxXTtcbiAgICBpZiAoIXdob2xlKSB7XG4gICAgICAgIHdob2xlID0gXCIwXCI7XG4gICAgfVxuICAgIGlmICghZnJhY3Rpb24pIHtcbiAgICAgICAgZnJhY3Rpb24gPSBcIjBcIjtcbiAgICB9XG4gICAgLy8gVHJpbSB0cmFpbGluZyB6ZXJvc1xuICAgIHdoaWxlIChmcmFjdGlvbltmcmFjdGlvbi5sZW5ndGggLSAxXSA9PT0gXCIwXCIpIHtcbiAgICAgICAgZnJhY3Rpb24gPSBmcmFjdGlvbi5zdWJzdHJpbmcoMCwgZnJhY3Rpb24ubGVuZ3RoIC0gMSk7XG4gICAgfVxuICAgIC8vIENoZWNrIHRoZSBmcmFjdGlvbiBkb2Vzbid0IGV4Y2VlZCBvdXIgZGVjaW1hbHMgc2l6ZVxuICAgIGlmIChmcmFjdGlvbi5sZW5ndGggPiBtdWx0aXBsaWVyLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgdGhyb3dGYXVsdChcImZyYWN0aW9uYWwgY29tcG9uZW50IGV4Y2VlZHMgZGVjaW1hbHNcIiwgXCJ1bmRlcmZsb3dcIiwgXCJwYXJzZUZpeGVkXCIpO1xuICAgIH1cbiAgICAvLyBJZiBkZWNpbWFscyBpcyAwLCB3ZSBoYXZlIGFuIGVtcHR5IHN0cmluZyBmb3IgZnJhY3Rpb25cbiAgICBpZiAoZnJhY3Rpb24gPT09IFwiXCIpIHtcbiAgICAgICAgZnJhY3Rpb24gPSBcIjBcIjtcbiAgICB9XG4gICAgLy8gRnVsbHkgcGFkIHRoZSBzdHJpbmcgd2l0aCB6ZXJvcyB0byBnZXQgdG8gd2VpXG4gICAgd2hpbGUgKGZyYWN0aW9uLmxlbmd0aCA8IG11bHRpcGxpZXIubGVuZ3RoIC0gMSkge1xuICAgICAgICBmcmFjdGlvbiArPSBcIjBcIjtcbiAgICB9XG4gICAgY29uc3Qgd2hvbGVWYWx1ZSA9IEJpZ051bWJlci5mcm9tKHdob2xlKTtcbiAgICBjb25zdCBmcmFjdGlvblZhbHVlID0gQmlnTnVtYmVyLmZyb20oZnJhY3Rpb24pO1xuICAgIGxldCB3ZWkgPSAod2hvbGVWYWx1ZS5tdWwobXVsdGlwbGllcikpLmFkZChmcmFjdGlvblZhbHVlKTtcbiAgICBpZiAobmVnYXRpdmUpIHtcbiAgICAgICAgd2VpID0gd2VpLm11bChOZWdhdGl2ZU9uZSk7XG4gICAgfVxuICAgIHJldHVybiB3ZWk7XG59XG5leHBvcnQgY2xhc3MgRml4ZWRGb3JtYXQge1xuICAgIGNvbnN0cnVjdG9yKGNvbnN0cnVjdG9yR3VhcmQsIHNpZ25lZCwgd2lkdGgsIGRlY2ltYWxzKSB7XG4gICAgICAgIGlmIChjb25zdHJ1Y3Rvckd1YXJkICE9PSBfY29uc3RydWN0b3JHdWFyZCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJjYW5ub3QgdXNlIEZpeGVkRm9ybWF0IGNvbnN0cnVjdG9yOyB1c2UgRml4ZWRGb3JtYXQuZnJvbVwiLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJuZXcgRml4ZWRGb3JtYXRcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zaWduZWQgPSBzaWduZWQ7XG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgdGhpcy5kZWNpbWFscyA9IGRlY2ltYWxzO1xuICAgICAgICB0aGlzLm5hbWUgPSAoc2lnbmVkID8gXCJcIiA6IFwidVwiKSArIFwiZml4ZWRcIiArIFN0cmluZyh3aWR0aCkgKyBcInhcIiArIFN0cmluZyhkZWNpbWFscyk7XG4gICAgICAgIHRoaXMuX211bHRpcGxpZXIgPSBnZXRNdWx0aXBsaWVyKGRlY2ltYWxzKTtcbiAgICAgICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb20odmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRml4ZWRGb3JtYXQpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHZhbHVlID0gYGZpeGVkMTI4eCR7dmFsdWV9YDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc2lnbmVkID0gdHJ1ZTtcbiAgICAgICAgbGV0IHdpZHRoID0gMTI4O1xuICAgICAgICBsZXQgZGVjaW1hbHMgPSAxODtcbiAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IFwiZml4ZWRcIikge1xuICAgICAgICAgICAgICAgIC8vIGRlZmF1bHRzLi4uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSA9PT0gXCJ1Zml4ZWRcIikge1xuICAgICAgICAgICAgICAgIHNpZ25lZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSB2YWx1ZS5tYXRjaCgvXih1PylmaXhlZChbMC05XSspeChbMC05XSspJC8pO1xuICAgICAgICAgICAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgZml4ZWQgZm9ybWF0XCIsIFwiZm9ybWF0XCIsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2lnbmVkID0gKG1hdGNoWzFdICE9PSBcInVcIik7XG4gICAgICAgICAgICAgICAgd2lkdGggPSBwYXJzZUludChtYXRjaFsyXSk7XG4gICAgICAgICAgICAgICAgZGVjaW1hbHMgPSBwYXJzZUludChtYXRjaFszXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoZWNrID0gKGtleSwgdHlwZSwgZGVmYXVsdFZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlW2tleV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mICh2YWx1ZVtrZXldKSAhPT0gdHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBmaXhlZCBmb3JtYXQgKFwiICsga2V5ICsgXCIgbm90IFwiICsgdHlwZSArIFwiKVwiLCBcImZvcm1hdC5cIiArIGtleSwgdmFsdWVba2V5XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZVtrZXldO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHNpZ25lZCA9IGNoZWNrKFwic2lnbmVkXCIsIFwiYm9vbGVhblwiLCBzaWduZWQpO1xuICAgICAgICAgICAgd2lkdGggPSBjaGVjayhcIndpZHRoXCIsIFwibnVtYmVyXCIsIHdpZHRoKTtcbiAgICAgICAgICAgIGRlY2ltYWxzID0gY2hlY2soXCJkZWNpbWFsc1wiLCBcIm51bWJlclwiLCBkZWNpbWFscyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdpZHRoICUgOCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgZml4ZWQgZm9ybWF0IHdpZHRoIChub3QgYnl0ZSBhbGlnbmVkKVwiLCBcImZvcm1hdC53aWR0aFwiLCB3aWR0aCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlY2ltYWxzID4gODApIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGZpeGVkIGZvcm1hdCAoZGVjaW1hbHMgdG9vIGxhcmdlKVwiLCBcImZvcm1hdC5kZWNpbWFsc1wiLCBkZWNpbWFscyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBGaXhlZEZvcm1hdChfY29uc3RydWN0b3JHdWFyZCwgc2lnbmVkLCB3aWR0aCwgZGVjaW1hbHMpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBGaXhlZE51bWJlciB7XG4gICAgY29uc3RydWN0b3IoY29uc3RydWN0b3JHdWFyZCwgaGV4LCB2YWx1ZSwgZm9ybWF0KSB7XG4gICAgICAgIGlmIChjb25zdHJ1Y3Rvckd1YXJkICE9PSBfY29uc3RydWN0b3JHdWFyZCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJjYW5ub3QgdXNlIEZpeGVkTnVtYmVyIGNvbnN0cnVjdG9yOyB1c2UgRml4ZWROdW1iZXIuZnJvbVwiLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJuZXcgRml4ZWRGb3JtYXRcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5mb3JtYXQgPSBmb3JtYXQ7XG4gICAgICAgIHRoaXMuX2hleCA9IGhleDtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5faXNGaXhlZE51bWJlciA9IHRydWU7XG4gICAgICAgIE9iamVjdC5mcmVlemUodGhpcyk7XG4gICAgfVxuICAgIF9jaGVja0Zvcm1hdChvdGhlcikge1xuICAgICAgICBpZiAodGhpcy5mb3JtYXQubmFtZSAhPT0gb3RoZXIuZm9ybWF0Lm5hbWUpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbmNvbXBhdGlibGUgZm9ybWF0OyB1c2UgZml4ZWROdW1iZXIudG9Gb3JtYXRcIiwgXCJvdGhlclwiLCBvdGhlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkVW5zYWZlKG90aGVyKSB7XG4gICAgICAgIHRoaXMuX2NoZWNrRm9ybWF0KG90aGVyKTtcbiAgICAgICAgY29uc3QgYSA9IHBhcnNlRml4ZWQodGhpcy5fdmFsdWUsIHRoaXMuZm9ybWF0LmRlY2ltYWxzKTtcbiAgICAgICAgY29uc3QgYiA9IHBhcnNlRml4ZWQob3RoZXIuX3ZhbHVlLCBvdGhlci5mb3JtYXQuZGVjaW1hbHMpO1xuICAgICAgICByZXR1cm4gRml4ZWROdW1iZXIuZnJvbVZhbHVlKGEuYWRkKGIpLCB0aGlzLmZvcm1hdC5kZWNpbWFscywgdGhpcy5mb3JtYXQpO1xuICAgIH1cbiAgICBzdWJVbnNhZmUob3RoZXIpIHtcbiAgICAgICAgdGhpcy5fY2hlY2tGb3JtYXQob3RoZXIpO1xuICAgICAgICBjb25zdCBhID0gcGFyc2VGaXhlZCh0aGlzLl92YWx1ZSwgdGhpcy5mb3JtYXQuZGVjaW1hbHMpO1xuICAgICAgICBjb25zdCBiID0gcGFyc2VGaXhlZChvdGhlci5fdmFsdWUsIG90aGVyLmZvcm1hdC5kZWNpbWFscyk7XG4gICAgICAgIHJldHVybiBGaXhlZE51bWJlci5mcm9tVmFsdWUoYS5zdWIoYiksIHRoaXMuZm9ybWF0LmRlY2ltYWxzLCB0aGlzLmZvcm1hdCk7XG4gICAgfVxuICAgIG11bFVuc2FmZShvdGhlcikge1xuICAgICAgICB0aGlzLl9jaGVja0Zvcm1hdChvdGhlcik7XG4gICAgICAgIGNvbnN0IGEgPSBwYXJzZUZpeGVkKHRoaXMuX3ZhbHVlLCB0aGlzLmZvcm1hdC5kZWNpbWFscyk7XG4gICAgICAgIGNvbnN0IGIgPSBwYXJzZUZpeGVkKG90aGVyLl92YWx1ZSwgb3RoZXIuZm9ybWF0LmRlY2ltYWxzKTtcbiAgICAgICAgcmV0dXJuIEZpeGVkTnVtYmVyLmZyb21WYWx1ZShhLm11bChiKS5kaXYodGhpcy5mb3JtYXQuX211bHRpcGxpZXIpLCB0aGlzLmZvcm1hdC5kZWNpbWFscywgdGhpcy5mb3JtYXQpO1xuICAgIH1cbiAgICBkaXZVbnNhZmUob3RoZXIpIHtcbiAgICAgICAgdGhpcy5fY2hlY2tGb3JtYXQob3RoZXIpO1xuICAgICAgICBjb25zdCBhID0gcGFyc2VGaXhlZCh0aGlzLl92YWx1ZSwgdGhpcy5mb3JtYXQuZGVjaW1hbHMpO1xuICAgICAgICBjb25zdCBiID0gcGFyc2VGaXhlZChvdGhlci5fdmFsdWUsIG90aGVyLmZvcm1hdC5kZWNpbWFscyk7XG4gICAgICAgIHJldHVybiBGaXhlZE51bWJlci5mcm9tVmFsdWUoYS5tdWwodGhpcy5mb3JtYXQuX211bHRpcGxpZXIpLmRpdihiKSwgdGhpcy5mb3JtYXQuZGVjaW1hbHMsIHRoaXMuZm9ybWF0KTtcbiAgICB9XG4gICAgZmxvb3IoKSB7XG4gICAgICAgIGNvbnN0IGNvbXBzID0gdGhpcy50b1N0cmluZygpLnNwbGl0KFwiLlwiKTtcbiAgICAgICAgaWYgKGNvbXBzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgY29tcHMucHVzaChcIjBcIik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3VsdCA9IEZpeGVkTnVtYmVyLmZyb20oY29tcHNbMF0sIHRoaXMuZm9ybWF0KTtcbiAgICAgICAgY29uc3QgaGFzRnJhY3Rpb24gPSAhY29tcHNbMV0ubWF0Y2goL14oMCopJC8pO1xuICAgICAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkgJiYgaGFzRnJhY3Rpb24pIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zdWJVbnNhZmUoT05FLnRvRm9ybWF0KHJlc3VsdC5mb3JtYXQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBjZWlsaW5nKCkge1xuICAgICAgICBjb25zdCBjb21wcyA9IHRoaXMudG9TdHJpbmcoKS5zcGxpdChcIi5cIik7XG4gICAgICAgIGlmIChjb21wcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGNvbXBzLnB1c2goXCIwXCIpO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXN1bHQgPSBGaXhlZE51bWJlci5mcm9tKGNvbXBzWzBdLCB0aGlzLmZvcm1hdCk7XG4gICAgICAgIGNvbnN0IGhhc0ZyYWN0aW9uID0gIWNvbXBzWzFdLm1hdGNoKC9eKDAqKSQvKTtcbiAgICAgICAgaWYgKCF0aGlzLmlzTmVnYXRpdmUoKSAmJiBoYXNGcmFjdGlvbikge1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmFkZFVuc2FmZShPTkUudG9Gb3JtYXQocmVzdWx0LmZvcm1hdCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8vIEBUT0RPOiBTdXBwb3J0IG90aGVyIHJvdW5kaW5nIGFsZ29yaXRobXNcbiAgICByb3VuZChkZWNpbWFscykge1xuICAgICAgICBpZiAoZGVjaW1hbHMgPT0gbnVsbCkge1xuICAgICAgICAgICAgZGVjaW1hbHMgPSAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlIGFyZSBhbHJlYWR5IGluIHJhbmdlLCB3ZSdyZSBkb25lXG4gICAgICAgIGNvbnN0IGNvbXBzID0gdGhpcy50b1N0cmluZygpLnNwbGl0KFwiLlwiKTtcbiAgICAgICAgaWYgKGNvbXBzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgY29tcHMucHVzaChcIjBcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlY2ltYWxzIDwgMCB8fCBkZWNpbWFscyA+IDgwIHx8IChkZWNpbWFscyAlIDEpKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBkZWNpbWFsIGNvdW50XCIsIFwiZGVjaW1hbHNcIiwgZGVjaW1hbHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb21wc1sxXS5sZW5ndGggPD0gZGVjaW1hbHMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZhY3RvciA9IEZpeGVkTnVtYmVyLmZyb20oXCIxXCIgKyB6ZXJvcy5zdWJzdHJpbmcoMCwgZGVjaW1hbHMpLCB0aGlzLmZvcm1hdCk7XG4gICAgICAgIGNvbnN0IGJ1bXAgPSBCVU1QLnRvRm9ybWF0KHRoaXMuZm9ybWF0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMubXVsVW5zYWZlKGZhY3RvcikuYWRkVW5zYWZlKGJ1bXApLmZsb29yKCkuZGl2VW5zYWZlKGZhY3Rvcik7XG4gICAgfVxuICAgIGlzWmVybygpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLl92YWx1ZSA9PT0gXCIwLjBcIiB8fCB0aGlzLl92YWx1ZSA9PT0gXCIwXCIpO1xuICAgIH1cbiAgICBpc05lZ2F0aXZlKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuX3ZhbHVlWzBdID09PSBcIi1cIik7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkgeyByZXR1cm4gdGhpcy5fdmFsdWU7IH1cbiAgICB0b0hleFN0cmluZyh3aWR0aCkge1xuICAgICAgICBpZiAod2lkdGggPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hleDtcbiAgICAgICAgfVxuICAgICAgICBpZiAod2lkdGggJSA4KSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBieXRlIHdpZHRoXCIsIFwid2lkdGhcIiwgd2lkdGgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhleCA9IEJpZ051bWJlci5mcm9tKHRoaXMuX2hleCkuZnJvbVR3b3ModGhpcy5mb3JtYXQud2lkdGgpLnRvVHdvcyh3aWR0aCkudG9IZXhTdHJpbmcoKTtcbiAgICAgICAgcmV0dXJuIGhleFplcm9QYWQoaGV4LCB3aWR0aCAvIDgpO1xuICAgIH1cbiAgICB0b1Vuc2FmZUZsb2F0KCkgeyByZXR1cm4gcGFyc2VGbG9hdCh0aGlzLnRvU3RyaW5nKCkpOyB9XG4gICAgdG9Gb3JtYXQoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiBGaXhlZE51bWJlci5mcm9tU3RyaW5nKHRoaXMuX3ZhbHVlLCBmb3JtYXQpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbVZhbHVlKHZhbHVlLCBkZWNpbWFscywgZm9ybWF0KSB7XG4gICAgICAgIC8vIElmIGRlY2ltYWxzIGxvb2tzIG1vcmUgbGlrZSBhIGZvcm1hdCwgYW5kIHRoZXJlIGlzIG5vIGZvcm1hdCwgc2hpZnQgdGhlIHBhcmFtZXRlcnNcbiAgICAgICAgaWYgKGZvcm1hdCA9PSBudWxsICYmIGRlY2ltYWxzICE9IG51bGwgJiYgIWlzQmlnTnVtYmVyaXNoKGRlY2ltYWxzKSkge1xuICAgICAgICAgICAgZm9ybWF0ID0gZGVjaW1hbHM7XG4gICAgICAgICAgICBkZWNpbWFscyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlY2ltYWxzID09IG51bGwpIHtcbiAgICAgICAgICAgIGRlY2ltYWxzID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9ybWF0ID09IG51bGwpIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IFwiZml4ZWRcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRml4ZWROdW1iZXIuZnJvbVN0cmluZyhmb3JtYXRGaXhlZCh2YWx1ZSwgZGVjaW1hbHMpLCBGaXhlZEZvcm1hdC5mcm9tKGZvcm1hdCkpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbVN0cmluZyh2YWx1ZSwgZm9ybWF0KSB7XG4gICAgICAgIGlmIChmb3JtYXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgZm9ybWF0ID0gXCJmaXhlZFwiO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZpeGVkRm9ybWF0ID0gRml4ZWRGb3JtYXQuZnJvbShmb3JtYXQpO1xuICAgICAgICBjb25zdCBudW1lcmljID0gcGFyc2VGaXhlZCh2YWx1ZSwgZml4ZWRGb3JtYXQuZGVjaW1hbHMpO1xuICAgICAgICBpZiAoIWZpeGVkRm9ybWF0LnNpZ25lZCAmJiBudW1lcmljLmx0KFplcm8pKSB7XG4gICAgICAgICAgICB0aHJvd0ZhdWx0KFwidW5zaWduZWQgdmFsdWUgY2Fubm90IGJlIG5lZ2F0aXZlXCIsIFwib3ZlcmZsb3dcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGhleCA9IG51bGw7XG4gICAgICAgIGlmIChmaXhlZEZvcm1hdC5zaWduZWQpIHtcbiAgICAgICAgICAgIGhleCA9IG51bWVyaWMudG9Ud29zKGZpeGVkRm9ybWF0LndpZHRoKS50b0hleFN0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaGV4ID0gbnVtZXJpYy50b0hleFN0cmluZygpO1xuICAgICAgICAgICAgaGV4ID0gaGV4WmVyb1BhZChoZXgsIGZpeGVkRm9ybWF0LndpZHRoIC8gOCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVjaW1hbCA9IGZvcm1hdEZpeGVkKG51bWVyaWMsIGZpeGVkRm9ybWF0LmRlY2ltYWxzKTtcbiAgICAgICAgcmV0dXJuIG5ldyBGaXhlZE51bWJlcihfY29uc3RydWN0b3JHdWFyZCwgaGV4LCBkZWNpbWFsLCBmaXhlZEZvcm1hdCk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tQnl0ZXModmFsdWUsIGZvcm1hdCkge1xuICAgICAgICBpZiAoZm9ybWF0ID09IG51bGwpIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IFwiZml4ZWRcIjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmaXhlZEZvcm1hdCA9IEZpeGVkRm9ybWF0LmZyb20oZm9ybWF0KTtcbiAgICAgICAgaWYgKGFycmF5aWZ5KHZhbHVlKS5sZW5ndGggPiBmaXhlZEZvcm1hdC53aWR0aCAvIDgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm92ZXJmbG93XCIpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBudW1lcmljID0gQmlnTnVtYmVyLmZyb20odmFsdWUpO1xuICAgICAgICBpZiAoZml4ZWRGb3JtYXQuc2lnbmVkKSB7XG4gICAgICAgICAgICBudW1lcmljID0gbnVtZXJpYy5mcm9tVHdvcyhmaXhlZEZvcm1hdC53aWR0aCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGV4ID0gbnVtZXJpYy50b1R3b3MoKGZpeGVkRm9ybWF0LnNpZ25lZCA/IDAgOiAxKSArIGZpeGVkRm9ybWF0LndpZHRoKS50b0hleFN0cmluZygpO1xuICAgICAgICBjb25zdCBkZWNpbWFsID0gZm9ybWF0Rml4ZWQobnVtZXJpYywgZml4ZWRGb3JtYXQuZGVjaW1hbHMpO1xuICAgICAgICByZXR1cm4gbmV3IEZpeGVkTnVtYmVyKF9jb25zdHJ1Y3Rvckd1YXJkLCBoZXgsIGRlY2ltYWwsIGZpeGVkRm9ybWF0KTtcbiAgICB9XG4gICAgc3RhdGljIGZyb20odmFsdWUsIGZvcm1hdCkge1xuICAgICAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBGaXhlZE51bWJlci5mcm9tU3RyaW5nKHZhbHVlLCBmb3JtYXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0J5dGVzKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIEZpeGVkTnVtYmVyLmZyb21CeXRlcyh2YWx1ZSwgZm9ybWF0KTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIEZpeGVkTnVtYmVyLmZyb21WYWx1ZSh2YWx1ZSwgMCwgZm9ybWF0KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIEFsbG93IE5VTUVSSUNfRkFVTFQgdG8gYnViYmxlIHVwXG4gICAgICAgICAgICBpZiAoZXJyb3IuY29kZSAhPT0gTG9nZ2VyLmVycm9ycy5JTlZBTElEX0FSR1VNRU5UKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIEZpeGVkTnVtYmVyIHZhbHVlXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgIH1cbiAgICBzdGF0aWMgaXNGaXhlZE51bWJlcih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUuX2lzRml4ZWROdW1iZXIpO1xuICAgIH1cbn1cbmNvbnN0IE9ORSA9IEZpeGVkTnVtYmVyLmZyb20oMSk7XG5jb25zdCBCVU1QID0gRml4ZWROdW1iZXIuZnJvbShcIjAuNVwiKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZpeGVkbnVtYmVyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ethersproject/bignumber/lib.esm/fixednumber.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@ethersproject/bignumber/lib.esm/index.js":
/*!*****************************************************************!*\
  !*** ../node_modules/@ethersproject/bignumber/lib.esm/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BigNumber: () => (/* reexport safe */ _bignumber__WEBPACK_IMPORTED_MODULE_0__.BigNumber),\n/* harmony export */   FixedFormat: () => (/* reexport safe */ _fixednumber__WEBPACK_IMPORTED_MODULE_1__.FixedFormat),\n/* harmony export */   FixedNumber: () => (/* reexport safe */ _fixednumber__WEBPACK_IMPORTED_MODULE_1__.FixedNumber),\n/* harmony export */   _base16To36: () => (/* reexport safe */ _bignumber__WEBPACK_IMPORTED_MODULE_0__._base16To36),\n/* harmony export */   _base36To16: () => (/* reexport safe */ _bignumber__WEBPACK_IMPORTED_MODULE_0__._base36To16),\n/* harmony export */   formatFixed: () => (/* reexport safe */ _fixednumber__WEBPACK_IMPORTED_MODULE_1__.formatFixed),\n/* harmony export */   parseFixed: () => (/* reexport safe */ _fixednumber__WEBPACK_IMPORTED_MODULE_1__.parseFixed)\n/* harmony export */ });\n/* harmony import */ var _bignumber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bignumber */ \"(ssr)/../node_modules/@ethersproject/bignumber/lib.esm/bignumber.js\");\n/* harmony import */ var _fixednumber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./fixednumber */ \"(ssr)/../node_modules/@ethersproject/bignumber/lib.esm/fixednumber.js\");\n\n\n// Internal methods used by address\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2JpZ251bWJlci9saWIuZXNtL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUF3QztBQUMwQztBQUNsRjtBQUN1RDtBQUN2RCIsInNvdXJjZXMiOlsid2VicGFjazovL2xlZGdpdHkteWllbGQtZnJvbnRlbmQvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2JpZ251bWJlci9saWIuZXNtL2luZGV4LmpzPzczNWIiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHsgQmlnTnVtYmVyIH0gZnJvbSBcIi4vYmlnbnVtYmVyXCI7XG5leHBvcnQgeyBmb3JtYXRGaXhlZCwgRml4ZWRGb3JtYXQsIEZpeGVkTnVtYmVyLCBwYXJzZUZpeGVkIH0gZnJvbSBcIi4vZml4ZWRudW1iZXJcIjtcbi8vIEludGVybmFsIG1ldGhvZHMgdXNlZCBieSBhZGRyZXNzXG5leHBvcnQgeyBfYmFzZTE2VG8zNiwgX2Jhc2UzNlRvMTYgfSBmcm9tIFwiLi9iaWdudW1iZXJcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ethersproject/bignumber/lib.esm/index.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@ethersproject/bytes/lib.esm/_version.js":
/*!****************************************************************!*\
  !*** ../node_modules/@ethersproject/bytes/lib.esm/_version.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\nconst version = \"bytes/5.7.0\";\n//# sourceMappingURL=_version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2J5dGVzL2xpYi5lc20vX3ZlcnNpb24uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFPO0FBQ1AiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sZWRnaXR5LXlpZWxkLWZyb250ZW5kLy4uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9ieXRlcy9saWIuZXNtL192ZXJzaW9uLmpzPzY4MWUiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IHZlcnNpb24gPSBcImJ5dGVzLzUuNy4wXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdmVyc2lvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ethersproject/bytes/lib.esm/_version.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@ethersproject/bytes/lib.esm/index.js":
/*!*************************************************************!*\
  !*** ../node_modules/@ethersproject/bytes/lib.esm/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   arrayify: () => (/* binding */ arrayify),\n/* harmony export */   concat: () => (/* binding */ concat),\n/* harmony export */   hexConcat: () => (/* binding */ hexConcat),\n/* harmony export */   hexDataLength: () => (/* binding */ hexDataLength),\n/* harmony export */   hexDataSlice: () => (/* binding */ hexDataSlice),\n/* harmony export */   hexStripZeros: () => (/* binding */ hexStripZeros),\n/* harmony export */   hexValue: () => (/* binding */ hexValue),\n/* harmony export */   hexZeroPad: () => (/* binding */ hexZeroPad),\n/* harmony export */   hexlify: () => (/* binding */ hexlify),\n/* harmony export */   isBytes: () => (/* binding */ isBytes),\n/* harmony export */   isBytesLike: () => (/* binding */ isBytesLike),\n/* harmony export */   isHexString: () => (/* binding */ isHexString),\n/* harmony export */   joinSignature: () => (/* binding */ joinSignature),\n/* harmony export */   splitSignature: () => (/* binding */ splitSignature),\n/* harmony export */   stripZeros: () => (/* binding */ stripZeros),\n/* harmony export */   zeroPad: () => (/* binding */ zeroPad)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/../node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(ssr)/../node_modules/@ethersproject/bytes/lib.esm/_version.js\");\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\n///////////////////////////////\nfunction isHexable(value) {\n    return !!(value.toHexString);\n}\nfunction addSlice(array) {\n    if (array.slice) {\n        return array;\n    }\n    array.slice = function () {\n        const args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    };\n    return array;\n}\nfunction isBytesLike(value) {\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n}\nfunction isInteger(value) {\n    return (typeof (value) === \"number\" && value == value && (value % 1) === 0);\n}\nfunction isBytes(value) {\n    if (value == null) {\n        return false;\n    }\n    if (value.constructor === Uint8Array) {\n        return true;\n    }\n    if (typeof (value) === \"string\") {\n        return false;\n    }\n    if (!isInteger(value.length) || value.length < 0) {\n        return false;\n    }\n    for (let i = 0; i < value.length; i++) {\n        const v = value[i];\n        if (!isInteger(v) || v < 0 || v >= 256) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction arrayify(value, options) {\n    if (!options) {\n        options = {};\n    }\n    if (typeof (value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid arrayify value\");\n        const result = [];\n        while (value) {\n            result.unshift(value & 0xff);\n            value = parseInt(String(value / 256));\n        }\n        if (result.length === 0) {\n            result.push(0);\n        }\n        return addSlice(new Uint8Array(result));\n    }\n    if (options.allowMissingPrefix && typeof (value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n        value = \"0x\" + value;\n    }\n    if (isHexable(value)) {\n        value = value.toHexString();\n    }\n    if (isHexString(value)) {\n        let hex = value.substring(2);\n        if (hex.length % 2) {\n            if (options.hexPad === \"left\") {\n                hex = \"0\" + hex;\n            }\n            else if (options.hexPad === \"right\") {\n                hex += \"0\";\n            }\n            else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        const result = [];\n        for (let i = 0; i < hex.length; i += 2) {\n            result.push(parseInt(hex.substring(i, i + 2), 16));\n        }\n        return addSlice(new Uint8Array(result));\n    }\n    if (isBytes(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\nfunction concat(items) {\n    const objects = items.map(item => arrayify(item));\n    const length = objects.reduce((accum, item) => (accum + item.length), 0);\n    const result = new Uint8Array(length);\n    objects.reduce((offset, object) => {\n        result.set(object, offset);\n        return offset + object.length;\n    }, 0);\n    return addSlice(result);\n}\nfunction stripZeros(value) {\n    let result = arrayify(value);\n    if (result.length === 0) {\n        return result;\n    }\n    // Find the first non-zero entry\n    let start = 0;\n    while (start < result.length && result[start] === 0) {\n        start++;\n    }\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n    return result;\n}\nfunction zeroPad(value, length) {\n    value = arrayify(value);\n    if (value.length > length) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n    }\n    const result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\nfunction isHexString(value, length) {\n    if (typeof (value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false;\n    }\n    if (length && value.length !== 2 + 2 * length) {\n        return false;\n    }\n    return true;\n}\nconst HexCharacters = \"0123456789abcdef\";\nfunction hexlify(value, options) {\n    if (!options) {\n        options = {};\n    }\n    if (typeof (value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid hexlify value\");\n        let hex = \"\";\n        while (value) {\n            hex = HexCharacters[value & 0xf] + hex;\n            value = Math.floor(value / 16);\n        }\n        if (hex.length) {\n            if (hex.length % 2) {\n                hex = \"0\" + hex;\n            }\n            return \"0x\" + hex;\n        }\n        return \"0x00\";\n    }\n    if (typeof (value) === \"bigint\") {\n        value = value.toString(16);\n        if (value.length % 2) {\n            return (\"0x0\" + value);\n        }\n        return \"0x\" + value;\n    }\n    if (options.allowMissingPrefix && typeof (value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n        value = \"0x\" + value;\n    }\n    if (isHexable(value)) {\n        return value.toHexString();\n    }\n    if (isHexString(value)) {\n        if (value.length % 2) {\n            if (options.hexPad === \"left\") {\n                value = \"0x0\" + value.substring(2);\n            }\n            else if (options.hexPad === \"right\") {\n                value += \"0\";\n            }\n            else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        return value.toLowerCase();\n    }\n    if (isBytes(value)) {\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n            let v = value[i];\n            result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n        }\n        return result;\n    }\n    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\nfunction hexDataLength(data) {\n    if (typeof (data) !== \"string\") {\n        data = hexlify(data);\n    }\n    else if (!isHexString(data) || (data.length % 2)) {\n        return null;\n    }\n    return (data.length - 2) / 2;\n}\nfunction hexDataSlice(data, offset, endOffset) {\n    if (typeof (data) !== \"string\") {\n        data = hexlify(data);\n    }\n    else if (!isHexString(data) || (data.length % 2)) {\n        logger.throwArgumentError(\"invalid hexData\", \"value\", data);\n    }\n    offset = 2 + 2 * offset;\n    if (endOffset != null) {\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n    }\n    return \"0x\" + data.substring(offset);\n}\nfunction hexConcat(items) {\n    let result = \"0x\";\n    items.forEach((item) => {\n        result += hexlify(item).substring(2);\n    });\n    return result;\n}\nfunction hexValue(value) {\n    const trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\n    if (trimmed === \"0x\") {\n        return \"0x0\";\n    }\n    return trimmed;\n}\nfunction hexStripZeros(value) {\n    if (typeof (value) !== \"string\") {\n        value = hexlify(value);\n    }\n    if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    value = value.substring(2);\n    let offset = 0;\n    while (offset < value.length && value[offset] === \"0\") {\n        offset++;\n    }\n    return \"0x\" + value.substring(offset);\n}\nfunction hexZeroPad(value, length) {\n    if (typeof (value) !== \"string\") {\n        value = hexlify(value);\n    }\n    else if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    if (value.length > 2 * length + 2) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n    }\n    while (value.length < 2 * length + 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n    return value;\n}\nfunction splitSignature(signature) {\n    const result = {\n        r: \"0x\",\n        s: \"0x\",\n        _vs: \"0x\",\n        recoveryParam: 0,\n        v: 0,\n        yParityAndS: \"0x\",\n        compact: \"0x\"\n    };\n    if (isBytesLike(signature)) {\n        let bytes = arrayify(signature);\n        // Get the r, s and v\n        if (bytes.length === 64) {\n            // EIP-2098; pull the v from the top bit of s and clear it\n            result.v = 27 + (bytes[32] >> 7);\n            bytes[32] &= 0x7f;\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n        }\n        else if (bytes.length === 65) {\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n            result.v = bytes[64];\n        }\n        else {\n            logger.throwArgumentError(\"invalid signature string\", \"signature\", signature);\n        }\n        // Allow a recid to be used as the v\n        if (result.v < 27) {\n            if (result.v === 0 || result.v === 1) {\n                result.v += 27;\n            }\n            else {\n                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n            }\n        }\n        // Compute recoveryParam from v\n        result.recoveryParam = 1 - (result.v % 2);\n        // Compute _vs from recoveryParam and s\n        if (result.recoveryParam) {\n            bytes[32] |= 0x80;\n        }\n        result._vs = hexlify(bytes.slice(32, 64));\n    }\n    else {\n        result.r = signature.r;\n        result.s = signature.s;\n        result.v = signature.v;\n        result.recoveryParam = signature.recoveryParam;\n        result._vs = signature._vs;\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\n        // and verify non-missing s, v and recoveryParam\n        if (result._vs != null) {\n            const vs = zeroPad(arrayify(result._vs), 32);\n            result._vs = hexlify(vs);\n            // Set or check the recid\n            const recoveryParam = ((vs[0] >= 128) ? 1 : 0);\n            if (result.recoveryParam == null) {\n                result.recoveryParam = recoveryParam;\n            }\n            else if (result.recoveryParam !== recoveryParam) {\n                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n            }\n            // Set or check the s\n            vs[0] &= 0x7f;\n            const s = hexlify(vs);\n            if (result.s == null) {\n                result.s = s;\n            }\n            else if (result.s !== s) {\n                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n            }\n        }\n        // Use recid and v to populate each other\n        if (result.recoveryParam == null) {\n            if (result.v == null) {\n                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n            }\n            else if (result.v === 0 || result.v === 1) {\n                result.recoveryParam = result.v;\n            }\n            else {\n                result.recoveryParam = 1 - (result.v % 2);\n            }\n        }\n        else {\n            if (result.v == null) {\n                result.v = 27 + result.recoveryParam;\n            }\n            else {\n                const recId = (result.v === 0 || result.v === 1) ? result.v : (1 - (result.v % 2));\n                if (result.recoveryParam !== recId) {\n                    logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n                }\n            }\n        }\n        if (result.r == null || !isHexString(result.r)) {\n            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n        }\n        else {\n            result.r = hexZeroPad(result.r, 32);\n        }\n        if (result.s == null || !isHexString(result.s)) {\n            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n        }\n        else {\n            result.s = hexZeroPad(result.s, 32);\n        }\n        const vs = arrayify(result.s);\n        if (vs[0] >= 128) {\n            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n        }\n        if (result.recoveryParam) {\n            vs[0] |= 0x80;\n        }\n        const _vs = hexlify(vs);\n        if (result._vs) {\n            if (!isHexString(result._vs)) {\n                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n            }\n            result._vs = hexZeroPad(result._vs, 32);\n        }\n        // Set or check the _vs\n        if (result._vs == null) {\n            result._vs = _vs;\n        }\n        else if (result._vs !== _vs) {\n            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n        }\n    }\n    result.yParityAndS = result._vs;\n    result.compact = result.r + result.yParityAndS.substring(2);\n    return result;\n}\nfunction joinSignature(signature) {\n    signature = splitSignature(signature);\n    return hexlify(concat([\n        signature.r,\n        signature.s,\n        (signature.recoveryParam ? \"0x1c\" : \"0x1b\")\n    ]));\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2J5dGVzL2xpYi5lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWE7QUFDa0M7QUFDVjtBQUNyQyxtQkFBbUIseURBQU0sQ0FBQyw2Q0FBTztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ087QUFDUCxtREFBbUQsZ0JBQWdCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sZWRnaXR5LXlpZWxkLWZyb250ZW5kLy4uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9ieXRlcy9saWIuZXNtL2luZGV4LmpzPzI1YmEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvbG9nZ2VyXCI7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4vX3ZlcnNpb25cIjtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIodmVyc2lvbik7XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5mdW5jdGlvbiBpc0hleGFibGUodmFsdWUpIHtcbiAgICByZXR1cm4gISEodmFsdWUudG9IZXhTdHJpbmcpO1xufVxuZnVuY3Rpb24gYWRkU2xpY2UoYXJyYXkpIHtcbiAgICBpZiAoYXJyYXkuc2xpY2UpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cbiAgICBhcnJheS5zbGljZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3QgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgIHJldHVybiBhZGRTbGljZShuZXcgVWludDhBcnJheShBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkoYXJyYXksIGFyZ3MpKSk7XG4gICAgfTtcbiAgICByZXR1cm4gYXJyYXk7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNCeXRlc0xpa2UodmFsdWUpIHtcbiAgICByZXR1cm4gKChpc0hleFN0cmluZyh2YWx1ZSkgJiYgISh2YWx1ZS5sZW5ndGggJSAyKSkgfHwgaXNCeXRlcyh2YWx1ZSkpO1xufVxuZnVuY3Rpb24gaXNJbnRlZ2VyKHZhbHVlKSB7XG4gICAgcmV0dXJuICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJudW1iZXJcIiAmJiB2YWx1ZSA9PSB2YWx1ZSAmJiAodmFsdWUgJSAxKSA9PT0gMCk7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNCeXRlcyh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHZhbHVlLmNvbnN0cnVjdG9yID09PSBVaW50OEFycmF5KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIWlzSW50ZWdlcih2YWx1ZS5sZW5ndGgpIHx8IHZhbHVlLmxlbmd0aCA8IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHYgPSB2YWx1ZVtpXTtcbiAgICAgICAgaWYgKCFpc0ludGVnZXIodikgfHwgdiA8IDAgfHwgdiA+PSAyNTYpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBhcnJheWlmeSh2YWx1ZSwgb3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0ge307XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBsb2dnZXIuY2hlY2tTYWZlVWludDUzKHZhbHVlLCBcImludmFsaWQgYXJyYXlpZnkgdmFsdWVcIik7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICB3aGlsZSAodmFsdWUpIHtcbiAgICAgICAgICAgIHJlc3VsdC51bnNoaWZ0KHZhbHVlICYgMHhmZik7XG4gICAgICAgICAgICB2YWx1ZSA9IHBhcnNlSW50KFN0cmluZyh2YWx1ZSAvIDI1NikpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWRkU2xpY2UobmV3IFVpbnQ4QXJyYXkocmVzdWx0KSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmFsbG93TWlzc2luZ1ByZWZpeCAmJiB0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIiAmJiB2YWx1ZS5zdWJzdHJpbmcoMCwgMikgIT09IFwiMHhcIikge1xuICAgICAgICB2YWx1ZSA9IFwiMHhcIiArIHZhbHVlO1xuICAgIH1cbiAgICBpZiAoaXNIZXhhYmxlKHZhbHVlKSkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvSGV4U3RyaW5nKCk7XG4gICAgfVxuICAgIGlmIChpc0hleFN0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgbGV0IGhleCA9IHZhbHVlLnN1YnN0cmluZygyKTtcbiAgICAgICAgaWYgKGhleC5sZW5ndGggJSAyKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5oZXhQYWQgPT09IFwibGVmdFwiKSB7XG4gICAgICAgICAgICAgICAgaGV4ID0gXCIwXCIgKyBoZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvcHRpb25zLmhleFBhZCA9PT0gXCJyaWdodFwiKSB7XG4gICAgICAgICAgICAgICAgaGV4ICs9IFwiMFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImhleCBkYXRhIGlzIG9kZC1sZW5ndGhcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaGV4Lmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChwYXJzZUludChoZXguc3Vic3RyaW5nKGksIGkgKyAyKSwgMTYpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWRkU2xpY2UobmV3IFVpbnQ4QXJyYXkocmVzdWx0KSk7XG4gICAgfVxuICAgIGlmIChpc0J5dGVzKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gYWRkU2xpY2UobmV3IFVpbnQ4QXJyYXkodmFsdWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGFycmF5aWZ5IHZhbHVlXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNvbmNhdChpdGVtcykge1xuICAgIGNvbnN0IG9iamVjdHMgPSBpdGVtcy5tYXAoaXRlbSA9PiBhcnJheWlmeShpdGVtKSk7XG4gICAgY29uc3QgbGVuZ3RoID0gb2JqZWN0cy5yZWR1Y2UoKGFjY3VtLCBpdGVtKSA9PiAoYWNjdW0gKyBpdGVtLmxlbmd0aCksIDApO1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gICAgb2JqZWN0cy5yZWR1Y2UoKG9mZnNldCwgb2JqZWN0KSA9PiB7XG4gICAgICAgIHJlc3VsdC5zZXQob2JqZWN0LCBvZmZzZXQpO1xuICAgICAgICByZXR1cm4gb2Zmc2V0ICsgb2JqZWN0Lmxlbmd0aDtcbiAgICB9LCAwKTtcbiAgICByZXR1cm4gYWRkU2xpY2UocmVzdWx0KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzdHJpcFplcm9zKHZhbHVlKSB7XG4gICAgbGV0IHJlc3VsdCA9IGFycmF5aWZ5KHZhbHVlKTtcbiAgICBpZiAocmVzdWx0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvLyBGaW5kIHRoZSBmaXJzdCBub24temVybyBlbnRyeVxuICAgIGxldCBzdGFydCA9IDA7XG4gICAgd2hpbGUgKHN0YXJ0IDwgcmVzdWx0Lmxlbmd0aCAmJiByZXN1bHRbc3RhcnRdID09PSAwKSB7XG4gICAgICAgIHN0YXJ0Kys7XG4gICAgfVxuICAgIC8vIElmIHdlIHN0YXJ0ZWQgd2l0aCB6ZXJvcywgc3RyaXAgdGhlbVxuICAgIGlmIChzdGFydCkge1xuICAgICAgICByZXN1bHQgPSByZXN1bHQuc2xpY2Uoc3RhcnQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHplcm9QYWQodmFsdWUsIGxlbmd0aCkge1xuICAgIHZhbHVlID0gYXJyYXlpZnkodmFsdWUpO1xuICAgIGlmICh2YWx1ZS5sZW5ndGggPiBsZW5ndGgpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInZhbHVlIG91dCBvZiByYW5nZVwiLCBcInZhbHVlXCIsIGFyZ3VtZW50c1swXSk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gICAgcmVzdWx0LnNldCh2YWx1ZSwgbGVuZ3RoIC0gdmFsdWUubGVuZ3RoKTtcbiAgICByZXR1cm4gYWRkU2xpY2UocmVzdWx0KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0hleFN0cmluZyh2YWx1ZSwgbGVuZ3RoKSB7XG4gICAgaWYgKHR5cGVvZiAodmFsdWUpICE9PSBcInN0cmluZ1wiIHx8ICF2YWx1ZS5tYXRjaCgvXjB4WzAtOUEtRmEtZl0qJC8pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGxlbmd0aCAmJiB2YWx1ZS5sZW5ndGggIT09IDIgKyAyICogbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5jb25zdCBIZXhDaGFyYWN0ZXJzID0gXCIwMTIzNDU2Nzg5YWJjZGVmXCI7XG5leHBvcnQgZnVuY3Rpb24gaGV4bGlmeSh2YWx1ZSwgb3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0ge307XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBsb2dnZXIuY2hlY2tTYWZlVWludDUzKHZhbHVlLCBcImludmFsaWQgaGV4bGlmeSB2YWx1ZVwiKTtcbiAgICAgICAgbGV0IGhleCA9IFwiXCI7XG4gICAgICAgIHdoaWxlICh2YWx1ZSkge1xuICAgICAgICAgICAgaGV4ID0gSGV4Q2hhcmFjdGVyc1t2YWx1ZSAmIDB4Zl0gKyBoZXg7XG4gICAgICAgICAgICB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUgLyAxNik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhleC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChoZXgubGVuZ3RoICUgMikge1xuICAgICAgICAgICAgICAgIGhleCA9IFwiMFwiICsgaGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFwiMHhcIiArIGhleDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCIweDAwXCI7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJiaWdpbnRcIikge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCAlIDIpIHtcbiAgICAgICAgICAgIHJldHVybiAoXCIweDBcIiArIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCIweFwiICsgdmFsdWU7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmFsbG93TWlzc2luZ1ByZWZpeCAmJiB0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIiAmJiB2YWx1ZS5zdWJzdHJpbmcoMCwgMikgIT09IFwiMHhcIikge1xuICAgICAgICB2YWx1ZSA9IFwiMHhcIiArIHZhbHVlO1xuICAgIH1cbiAgICBpZiAoaXNIZXhhYmxlKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWUudG9IZXhTdHJpbmcoKTtcbiAgICB9XG4gICAgaWYgKGlzSGV4U3RyaW5nKHZhbHVlKSkge1xuICAgICAgICBpZiAodmFsdWUubGVuZ3RoICUgMikge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuaGV4UGFkID09PSBcImxlZnRcIikge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gXCIweDBcIiArIHZhbHVlLnN1YnN0cmluZygyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG9wdGlvbnMuaGV4UGFkID09PSBcInJpZ2h0XCIpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSArPSBcIjBcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJoZXggZGF0YSBpcyBvZGQtbGVuZ3RoXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbiAgICBpZiAoaXNCeXRlcyh2YWx1ZSkpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFwiMHhcIjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHYgPSB2YWx1ZVtpXTtcbiAgICAgICAgICAgIHJlc3VsdCArPSBIZXhDaGFyYWN0ZXJzWyh2ICYgMHhmMCkgPj4gNF0gKyBIZXhDaGFyYWN0ZXJzW3YgJiAweDBmXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgaGV4bGlmeSB2YWx1ZVwiLCBcInZhbHVlXCIsIHZhbHVlKTtcbn1cbi8qXG5mdW5jdGlvbiB1bm9kZGlmeSh2YWx1ZTogQnl0ZXNMaWtlIHwgSGV4YWJsZSB8IG51bWJlcik6IEJ5dGVzTGlrZSB8IEhleGFibGUgfCBudW1iZXIge1xuICAgIGlmICh0eXBlb2YodmFsdWUpID09PSBcInN0cmluZ1wiICYmIHZhbHVlLmxlbmd0aCAlIDIgJiYgdmFsdWUuc3Vic3RyaW5nKDAsIDIpID09PSBcIjB4XCIpIHtcbiAgICAgICAgcmV0dXJuIFwiMHgwXCIgKyB2YWx1ZS5zdWJzdHJpbmcoMik7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbiovXG5leHBvcnQgZnVuY3Rpb24gaGV4RGF0YUxlbmd0aChkYXRhKSB7XG4gICAgaWYgKHR5cGVvZiAoZGF0YSkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgZGF0YSA9IGhleGxpZnkoZGF0YSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFpc0hleFN0cmluZyhkYXRhKSB8fCAoZGF0YS5sZW5ndGggJSAyKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIChkYXRhLmxlbmd0aCAtIDIpIC8gMjtcbn1cbmV4cG9ydCBmdW5jdGlvbiBoZXhEYXRhU2xpY2UoZGF0YSwgb2Zmc2V0LCBlbmRPZmZzZXQpIHtcbiAgICBpZiAodHlwZW9mIChkYXRhKSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBkYXRhID0gaGV4bGlmeShkYXRhKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIWlzSGV4U3RyaW5nKGRhdGEpIHx8IChkYXRhLmxlbmd0aCAlIDIpKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGhleERhdGFcIiwgXCJ2YWx1ZVwiLCBkYXRhKTtcbiAgICB9XG4gICAgb2Zmc2V0ID0gMiArIDIgKiBvZmZzZXQ7XG4gICAgaWYgKGVuZE9mZnNldCAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBcIjB4XCIgKyBkYXRhLnN1YnN0cmluZyhvZmZzZXQsIDIgKyAyICogZW5kT2Zmc2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIFwiMHhcIiArIGRhdGEuc3Vic3RyaW5nKG9mZnNldCk7XG59XG5leHBvcnQgZnVuY3Rpb24gaGV4Q29uY2F0KGl0ZW1zKSB7XG4gICAgbGV0IHJlc3VsdCA9IFwiMHhcIjtcbiAgICBpdGVtcy5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgIHJlc3VsdCArPSBoZXhsaWZ5KGl0ZW0pLnN1YnN0cmluZygyKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGhleFZhbHVlKHZhbHVlKSB7XG4gICAgY29uc3QgdHJpbW1lZCA9IGhleFN0cmlwWmVyb3MoaGV4bGlmeSh2YWx1ZSwgeyBoZXhQYWQ6IFwibGVmdFwiIH0pKTtcbiAgICBpZiAodHJpbW1lZCA9PT0gXCIweFwiKSB7XG4gICAgICAgIHJldHVybiBcIjB4MFwiO1xuICAgIH1cbiAgICByZXR1cm4gdHJpbW1lZDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBoZXhTdHJpcFplcm9zKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiAodmFsdWUpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHZhbHVlID0gaGV4bGlmeSh2YWx1ZSk7XG4gICAgfVxuICAgIGlmICghaXNIZXhTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGhleCBzdHJpbmdcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgfVxuICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyaW5nKDIpO1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIHdoaWxlIChvZmZzZXQgPCB2YWx1ZS5sZW5ndGggJiYgdmFsdWVbb2Zmc2V0XSA9PT0gXCIwXCIpIHtcbiAgICAgICAgb2Zmc2V0Kys7XG4gICAgfVxuICAgIHJldHVybiBcIjB4XCIgKyB2YWx1ZS5zdWJzdHJpbmcob2Zmc2V0KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBoZXhaZXJvUGFkKHZhbHVlLCBsZW5ndGgpIHtcbiAgICBpZiAodHlwZW9mICh2YWx1ZSkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdmFsdWUgPSBoZXhsaWZ5KHZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIWlzSGV4U3RyaW5nKHZhbHVlKSkge1xuICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBoZXggc3RyaW5nXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgIH1cbiAgICBpZiAodmFsdWUubGVuZ3RoID4gMiAqIGxlbmd0aCArIDIpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInZhbHVlIG91dCBvZiByYW5nZVwiLCBcInZhbHVlXCIsIGFyZ3VtZW50c1sxXSk7XG4gICAgfVxuICAgIHdoaWxlICh2YWx1ZS5sZW5ndGggPCAyICogbGVuZ3RoICsgMikge1xuICAgICAgICB2YWx1ZSA9IFwiMHgwXCIgKyB2YWx1ZS5zdWJzdHJpbmcoMik7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzcGxpdFNpZ25hdHVyZShzaWduYXR1cmUpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgIHI6IFwiMHhcIixcbiAgICAgICAgczogXCIweFwiLFxuICAgICAgICBfdnM6IFwiMHhcIixcbiAgICAgICAgcmVjb3ZlcnlQYXJhbTogMCxcbiAgICAgICAgdjogMCxcbiAgICAgICAgeVBhcml0eUFuZFM6IFwiMHhcIixcbiAgICAgICAgY29tcGFjdDogXCIweFwiXG4gICAgfTtcbiAgICBpZiAoaXNCeXRlc0xpa2Uoc2lnbmF0dXJlKSkge1xuICAgICAgICBsZXQgYnl0ZXMgPSBhcnJheWlmeShzaWduYXR1cmUpO1xuICAgICAgICAvLyBHZXQgdGhlIHIsIHMgYW5kIHZcbiAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCA9PT0gNjQpIHtcbiAgICAgICAgICAgIC8vIEVJUC0yMDk4OyBwdWxsIHRoZSB2IGZyb20gdGhlIHRvcCBiaXQgb2YgcyBhbmQgY2xlYXIgaXRcbiAgICAgICAgICAgIHJlc3VsdC52ID0gMjcgKyAoYnl0ZXNbMzJdID4+IDcpO1xuICAgICAgICAgICAgYnl0ZXNbMzJdICY9IDB4N2Y7XG4gICAgICAgICAgICByZXN1bHQuciA9IGhleGxpZnkoYnl0ZXMuc2xpY2UoMCwgMzIpKTtcbiAgICAgICAgICAgIHJlc3VsdC5zID0gaGV4bGlmeShieXRlcy5zbGljZSgzMiwgNjQpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChieXRlcy5sZW5ndGggPT09IDY1KSB7XG4gICAgICAgICAgICByZXN1bHQuciA9IGhleGxpZnkoYnl0ZXMuc2xpY2UoMCwgMzIpKTtcbiAgICAgICAgICAgIHJlc3VsdC5zID0gaGV4bGlmeShieXRlcy5zbGljZSgzMiwgNjQpKTtcbiAgICAgICAgICAgIHJlc3VsdC52ID0gYnl0ZXNbNjRdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgc2lnbmF0dXJlIHN0cmluZ1wiLCBcInNpZ25hdHVyZVwiLCBzaWduYXR1cmUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFsbG93IGEgcmVjaWQgdG8gYmUgdXNlZCBhcyB0aGUgdlxuICAgICAgICBpZiAocmVzdWx0LnYgPCAyNykge1xuICAgICAgICAgICAgaWYgKHJlc3VsdC52ID09PSAwIHx8IHJlc3VsdC52ID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnYgKz0gMjc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwic2lnbmF0dXJlIGludmFsaWQgdiBieXRlXCIsIFwic2lnbmF0dXJlXCIsIHNpZ25hdHVyZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29tcHV0ZSByZWNvdmVyeVBhcmFtIGZyb20gdlxuICAgICAgICByZXN1bHQucmVjb3ZlcnlQYXJhbSA9IDEgLSAocmVzdWx0LnYgJSAyKTtcbiAgICAgICAgLy8gQ29tcHV0ZSBfdnMgZnJvbSByZWNvdmVyeVBhcmFtIGFuZCBzXG4gICAgICAgIGlmIChyZXN1bHQucmVjb3ZlcnlQYXJhbSkge1xuICAgICAgICAgICAgYnl0ZXNbMzJdIHw9IDB4ODA7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0Ll92cyA9IGhleGxpZnkoYnl0ZXMuc2xpY2UoMzIsIDY0KSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXN1bHQuciA9IHNpZ25hdHVyZS5yO1xuICAgICAgICByZXN1bHQucyA9IHNpZ25hdHVyZS5zO1xuICAgICAgICByZXN1bHQudiA9IHNpZ25hdHVyZS52O1xuICAgICAgICByZXN1bHQucmVjb3ZlcnlQYXJhbSA9IHNpZ25hdHVyZS5yZWNvdmVyeVBhcmFtO1xuICAgICAgICByZXN1bHQuX3ZzID0gc2lnbmF0dXJlLl92cztcbiAgICAgICAgLy8gSWYgdGhlIF92cyBpcyBhdmFpbGFibGUsIHVzZSBpdCB0byBwb3B1bGF0ZSBtaXNzaW5nIHMsIHYgYW5kIHJlY292ZXJ5UGFyYW1cbiAgICAgICAgLy8gYW5kIHZlcmlmeSBub24tbWlzc2luZyBzLCB2IGFuZCByZWNvdmVyeVBhcmFtXG4gICAgICAgIGlmIChyZXN1bHQuX3ZzICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHZzID0gemVyb1BhZChhcnJheWlmeShyZXN1bHQuX3ZzKSwgMzIpO1xuICAgICAgICAgICAgcmVzdWx0Ll92cyA9IGhleGxpZnkodnMpO1xuICAgICAgICAgICAgLy8gU2V0IG9yIGNoZWNrIHRoZSByZWNpZFxuICAgICAgICAgICAgY29uc3QgcmVjb3ZlcnlQYXJhbSA9ICgodnNbMF0gPj0gMTI4KSA/IDEgOiAwKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQucmVjb3ZlcnlQYXJhbSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnJlY292ZXJ5UGFyYW0gPSByZWNvdmVyeVBhcmFtO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocmVzdWx0LnJlY292ZXJ5UGFyYW0gIT09IHJlY292ZXJ5UGFyYW0pIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwic2lnbmF0dXJlIHJlY292ZXJ5UGFyYW0gbWlzbWF0Y2ggX3ZzXCIsIFwic2lnbmF0dXJlXCIsIHNpZ25hdHVyZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTZXQgb3IgY2hlY2sgdGhlIHNcbiAgICAgICAgICAgIHZzWzBdICY9IDB4N2Y7XG4gICAgICAgICAgICBjb25zdCBzID0gaGV4bGlmeSh2cyk7XG4gICAgICAgICAgICBpZiAocmVzdWx0LnMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5zID0gcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJlc3VsdC5zICE9PSBzKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInNpZ25hdHVyZSB2IG1pc21hdGNoIF92c1wiLCBcInNpZ25hdHVyZVwiLCBzaWduYXR1cmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFVzZSByZWNpZCBhbmQgdiB0byBwb3B1bGF0ZSBlYWNoIG90aGVyXG4gICAgICAgIGlmIChyZXN1bHQucmVjb3ZlcnlQYXJhbSA9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAocmVzdWx0LnYgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJzaWduYXR1cmUgbWlzc2luZyB2IGFuZCByZWNvdmVyeVBhcmFtXCIsIFwic2lnbmF0dXJlXCIsIHNpZ25hdHVyZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChyZXN1bHQudiA9PT0gMCB8fCByZXN1bHQudiA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5yZWNvdmVyeVBhcmFtID0gcmVzdWx0LnY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucmVjb3ZlcnlQYXJhbSA9IDEgLSAocmVzdWx0LnYgJSAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHQudiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnYgPSAyNyArIHJlc3VsdC5yZWNvdmVyeVBhcmFtO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVjSWQgPSAocmVzdWx0LnYgPT09IDAgfHwgcmVzdWx0LnYgPT09IDEpID8gcmVzdWx0LnYgOiAoMSAtIChyZXN1bHQudiAlIDIpKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnJlY292ZXJ5UGFyYW0gIT09IHJlY0lkKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJzaWduYXR1cmUgcmVjb3ZlcnlQYXJhbSBtaXNtYXRjaCB2XCIsIFwic2lnbmF0dXJlXCIsIHNpZ25hdHVyZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQuciA9PSBudWxsIHx8ICFpc0hleFN0cmluZyhyZXN1bHQucikpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJzaWduYXR1cmUgbWlzc2luZyBvciBpbnZhbGlkIHJcIiwgXCJzaWduYXR1cmVcIiwgc2lnbmF0dXJlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5yID0gaGV4WmVyb1BhZChyZXN1bHQuciwgMzIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQucyA9PSBudWxsIHx8ICFpc0hleFN0cmluZyhyZXN1bHQucykpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJzaWduYXR1cmUgbWlzc2luZyBvciBpbnZhbGlkIHNcIiwgXCJzaWduYXR1cmVcIiwgc2lnbmF0dXJlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5zID0gaGV4WmVyb1BhZChyZXN1bHQucywgMzIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZzID0gYXJyYXlpZnkocmVzdWx0LnMpO1xuICAgICAgICBpZiAodnNbMF0gPj0gMTI4KSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwic2lnbmF0dXJlIHMgb3V0IG9mIHJhbmdlXCIsIFwic2lnbmF0dXJlXCIsIHNpZ25hdHVyZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdC5yZWNvdmVyeVBhcmFtKSB7XG4gICAgICAgICAgICB2c1swXSB8PSAweDgwO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IF92cyA9IGhleGxpZnkodnMpO1xuICAgICAgICBpZiAocmVzdWx0Ll92cykge1xuICAgICAgICAgICAgaWYgKCFpc0hleFN0cmluZyhyZXN1bHQuX3ZzKSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJzaWduYXR1cmUgaW52YWxpZCBfdnNcIiwgXCJzaWduYXR1cmVcIiwgc2lnbmF0dXJlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5fdnMgPSBoZXhaZXJvUGFkKHJlc3VsdC5fdnMsIDMyKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTZXQgb3IgY2hlY2sgdGhlIF92c1xuICAgICAgICBpZiAocmVzdWx0Ll92cyA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQuX3ZzID0gX3ZzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJlc3VsdC5fdnMgIT09IF92cykge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInNpZ25hdHVyZSBfdnMgbWlzbWF0Y2ggdiBhbmQgc1wiLCBcInNpZ25hdHVyZVwiLCBzaWduYXR1cmUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlc3VsdC55UGFyaXR5QW5kUyA9IHJlc3VsdC5fdnM7XG4gICAgcmVzdWx0LmNvbXBhY3QgPSByZXN1bHQuciArIHJlc3VsdC55UGFyaXR5QW5kUy5zdWJzdHJpbmcoMik7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBqb2luU2lnbmF0dXJlKHNpZ25hdHVyZSkge1xuICAgIHNpZ25hdHVyZSA9IHNwbGl0U2lnbmF0dXJlKHNpZ25hdHVyZSk7XG4gICAgcmV0dXJuIGhleGxpZnkoY29uY2F0KFtcbiAgICAgICAgc2lnbmF0dXJlLnIsXG4gICAgICAgIHNpZ25hdHVyZS5zLFxuICAgICAgICAoc2lnbmF0dXJlLnJlY292ZXJ5UGFyYW0gPyBcIjB4MWNcIiA6IFwiMHgxYlwiKVxuICAgIF0pKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ethersproject/bytes/lib.esm/index.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@ethersproject/constants/lib.esm/addresses.js":
/*!*********************************************************************!*\
  !*** ../node_modules/@ethersproject/constants/lib.esm/addresses.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AddressZero: () => (/* binding */ AddressZero)\n/* harmony export */ });\nconst AddressZero = \"0x0000000000000000000000000000000000000000\";\n//# sourceMappingURL=addresses.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2NvbnN0YW50cy9saWIuZXNtL2FkZHJlc3Nlcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU87QUFDUCIsInNvdXJjZXMiOlsid2VicGFjazovL2xlZGdpdHkteWllbGQtZnJvbnRlbmQvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2NvbnN0YW50cy9saWIuZXNtL2FkZHJlc3Nlcy5qcz83ZjM3Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBBZGRyZXNzWmVybyA9IFwiMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZGRyZXNzZXMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ethersproject/constants/lib.esm/addresses.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@ethersproject/constants/lib.esm/bignumbers.js":
/*!**********************************************************************!*\
  !*** ../node_modules/@ethersproject/constants/lib.esm/bignumbers.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MaxInt256: () => (/* binding */ MaxInt256),\n/* harmony export */   MaxUint256: () => (/* binding */ MaxUint256),\n/* harmony export */   MinInt256: () => (/* binding */ MinInt256),\n/* harmony export */   NegativeOne: () => (/* binding */ NegativeOne),\n/* harmony export */   One: () => (/* binding */ One),\n/* harmony export */   Two: () => (/* binding */ Two),\n/* harmony export */   WeiPerEther: () => (/* binding */ WeiPerEther),\n/* harmony export */   Zero: () => (/* binding */ Zero)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/bignumber */ \"(ssr)/../node_modules/@ethersproject/bignumber/lib.esm/bignumber.js\");\n\nconst NegativeOne = ( /*#__PURE__*/_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_0__.BigNumber.from(-1));\nconst Zero = ( /*#__PURE__*/_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_0__.BigNumber.from(0));\nconst One = ( /*#__PURE__*/_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_0__.BigNumber.from(1));\nconst Two = ( /*#__PURE__*/_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_0__.BigNumber.from(2));\nconst WeiPerEther = ( /*#__PURE__*/_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_0__.BigNumber.from(\"1000000000000000000\"));\nconst MaxUint256 = ( /*#__PURE__*/_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_0__.BigNumber.from(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\"));\nconst MinInt256 = ( /*#__PURE__*/_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_0__.BigNumber.from(\"-0x8000000000000000000000000000000000000000000000000000000000000000\"));\nconst MaxInt256 = ( /*#__PURE__*/_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_0__.BigNumber.from(\"0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\"));\n\n//# sourceMappingURL=bignumbers.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2NvbnN0YW50cy9saWIuZXNtL2JpZ251bWJlcnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQXFEO0FBQ3JELG1DQUFtQywrREFBUztBQUM1Qyw0QkFBNEIsK0RBQVM7QUFDckMsMkJBQTJCLCtEQUFTO0FBQ3BDLDJCQUEyQiwrREFBUztBQUNwQyxtQ0FBbUMsK0RBQVM7QUFDNUMsa0NBQWtDLCtEQUFTO0FBQzNDLGlDQUFpQywrREFBUztBQUMxQyxpQ0FBaUMsK0RBQVM7QUFDNkM7QUFDdkYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sZWRnaXR5LXlpZWxkLWZyb250ZW5kLy4uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9jb25zdGFudHMvbGliLmVzbS9iaWdudW1iZXJzLmpzP2M5N2YiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQmlnTnVtYmVyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2JpZ251bWJlclwiO1xuY29uc3QgTmVnYXRpdmVPbmUgPSAoIC8qI19fUFVSRV9fKi9CaWdOdW1iZXIuZnJvbSgtMSkpO1xuY29uc3QgWmVybyA9ICggLyojX19QVVJFX18qL0JpZ051bWJlci5mcm9tKDApKTtcbmNvbnN0IE9uZSA9ICggLyojX19QVVJFX18qL0JpZ051bWJlci5mcm9tKDEpKTtcbmNvbnN0IFR3byA9ICggLyojX19QVVJFX18qL0JpZ051bWJlci5mcm9tKDIpKTtcbmNvbnN0IFdlaVBlckV0aGVyID0gKCAvKiNfX1BVUkVfXyovQmlnTnVtYmVyLmZyb20oXCIxMDAwMDAwMDAwMDAwMDAwMDAwXCIpKTtcbmNvbnN0IE1heFVpbnQyNTYgPSAoIC8qI19fUFVSRV9fKi9CaWdOdW1iZXIuZnJvbShcIjB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlwiKSk7XG5jb25zdCBNaW5JbnQyNTYgPSAoIC8qI19fUFVSRV9fKi9CaWdOdW1iZXIuZnJvbShcIi0weDgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIikpO1xuY29uc3QgTWF4SW50MjU2ID0gKCAvKiNfX1BVUkVfXyovQmlnTnVtYmVyLmZyb20oXCIweDdmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZcIikpO1xuZXhwb3J0IHsgTmVnYXRpdmVPbmUsIFplcm8sIE9uZSwgVHdvLCBXZWlQZXJFdGhlciwgTWF4VWludDI1NiwgTWluSW50MjU2LCBNYXhJbnQyNTYsIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iaWdudW1iZXJzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ethersproject/constants/lib.esm/bignumbers.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@ethersproject/constants/lib.esm/hashes.js":
/*!******************************************************************!*\
  !*** ../node_modules/@ethersproject/constants/lib.esm/hashes.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HashZero: () => (/* binding */ HashZero)\n/* harmony export */ });\nconst HashZero = \"0x0000000000000000000000000000000000000000000000000000000000000000\";\n//# sourceMappingURL=hashes.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2NvbnN0YW50cy9saWIuZXNtL2hhc2hlcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU87QUFDUCIsInNvdXJjZXMiOlsid2VicGFjazovL2xlZGdpdHkteWllbGQtZnJvbnRlbmQvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2NvbnN0YW50cy9saWIuZXNtL2hhc2hlcy5qcz82MWJhIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBIYXNoWmVybyA9IFwiMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oYXNoZXMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ethersproject/constants/lib.esm/hashes.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@ethersproject/contracts/lib.esm/_version.js":
/*!********************************************************************!*\
  !*** ../node_modules/@ethersproject/contracts/lib.esm/_version.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\nconst version = \"contracts/5.7.0\";\n//# sourceMappingURL=_version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2NvbnRyYWN0cy9saWIuZXNtL192ZXJzaW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBTztBQUNQIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGVkZ2l0eS15aWVsZC1mcm9udGVuZC8uLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvY29udHJhY3RzL2xpYi5lc20vX3ZlcnNpb24uanM/MmU0MyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgdmVyc2lvbiA9IFwiY29udHJhY3RzLzUuNy4wXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdmVyc2lvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ethersproject/contracts/lib.esm/_version.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@ethersproject/contracts/lib.esm/index.js":
/*!*****************************************************************!*\
  !*** ../node_modules/@ethersproject/contracts/lib.esm/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseContract: () => (/* binding */ BaseContract),\n/* harmony export */   Contract: () => (/* binding */ Contract),\n/* harmony export */   ContractFactory: () => (/* binding */ ContractFactory)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_abi__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @ethersproject/abi */ \"(ssr)/../node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js\");\n/* harmony import */ var _ethersproject_abi__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @ethersproject/abi */ \"(ssr)/../node_modules/@ethersproject/abi/lib.esm/interface.js\");\n/* harmony import */ var _ethersproject_abstract_provider__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @ethersproject/abstract-provider */ \"(ssr)/../node_modules/@ethersproject/abstract-provider/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_abstract_signer__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @ethersproject/abstract-signer */ \"(ssr)/../node_modules/@ethersproject/abstract-signer/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_address__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/address */ \"(ssr)/../node_modules/@ethersproject/address/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethersproject/bignumber */ \"(ssr)/../node_modules/@ethersproject/bignumber/lib.esm/bignumber.js\");\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/../node_modules/@ethersproject/bytes/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/../node_modules/@ethersproject/properties/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_transactions__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ethersproject/transactions */ \"(ssr)/../node_modules/@ethersproject/transactions/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/../node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(ssr)/../node_modules/@ethersproject/contracts/lib.esm/_version.js\");\n\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\n\n\n\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\n;\n;\n///////////////////////////////\nconst allowedTransactionKeys = {\n    chainId: true, data: true, from: true, gasLimit: true, gasPrice: true, nonce: true, to: true, value: true,\n    type: true, accessList: true,\n    maxFeePerGas: true, maxPriorityFeePerGas: true,\n    customData: true,\n    ccipReadEnabled: true\n};\nfunction resolveName(resolver, nameOrPromise) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const name = yield nameOrPromise;\n        if (typeof (name) !== \"string\") {\n            logger.throwArgumentError(\"invalid address or ENS name\", \"name\", name);\n        }\n        // If it is already an address, just use it (after adding checksum)\n        try {\n            return (0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_2__.getAddress)(name);\n        }\n        catch (error) { }\n        if (!resolver) {\n            logger.throwError(\"a provider or signer is needed to resolve ENS names\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"resolveName\"\n            });\n        }\n        const address = yield resolver.resolveName(name);\n        if (address == null) {\n            logger.throwArgumentError(\"resolver or addr is not configured for ENS name\", \"name\", name);\n        }\n        return address;\n    });\n}\n// Recursively replaces ENS names with promises to resolve the name and resolves all properties\nfunction resolveAddresses(resolver, value, paramType) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (Array.isArray(paramType)) {\n            return yield Promise.all(paramType.map((paramType, index) => {\n                return resolveAddresses(resolver, ((Array.isArray(value)) ? value[index] : value[paramType.name]), paramType);\n            }));\n        }\n        if (paramType.type === \"address\") {\n            return yield resolveName(resolver, value);\n        }\n        if (paramType.type === \"tuple\") {\n            return yield resolveAddresses(resolver, value, paramType.components);\n        }\n        if (paramType.baseType === \"array\") {\n            if (!Array.isArray(value)) {\n                return Promise.reject(logger.makeError(\"invalid value for array\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.INVALID_ARGUMENT, {\n                    argument: \"value\",\n                    value\n                }));\n            }\n            return yield Promise.all(value.map((v) => resolveAddresses(resolver, v, paramType.arrayChildren)));\n        }\n        return value;\n    });\n}\nfunction populateTransaction(contract, fragment, args) {\n    return __awaiter(this, void 0, void 0, function* () {\n        // If an extra argument is given, it is overrides\n        let overrides = {};\n        if (args.length === fragment.inputs.length + 1 && typeof (args[args.length - 1]) === \"object\") {\n            overrides = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.shallowCopy)(args.pop());\n        }\n        // Make sure the parameter count matches\n        logger.checkArgumentCount(args.length, fragment.inputs.length, \"passed to contract\");\n        // Populate \"from\" override (allow promises)\n        if (contract.signer) {\n            if (overrides.from) {\n                // Contracts with a Signer are from the Signer's frame-of-reference;\n                // but we allow overriding \"from\" if it matches the signer\n                overrides.from = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.resolveProperties)({\n                    override: resolveName(contract.signer, overrides.from),\n                    signer: contract.signer.getAddress()\n                }).then((check) => __awaiter(this, void 0, void 0, function* () {\n                    if ((0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_2__.getAddress)(check.signer) !== check.override) {\n                        logger.throwError(\"Contract with a Signer cannot override from\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n                            operation: \"overrides.from\"\n                        });\n                    }\n                    return check.override;\n                }));\n            }\n            else {\n                overrides.from = contract.signer.getAddress();\n            }\n        }\n        else if (overrides.from) {\n            overrides.from = resolveName(contract.provider, overrides.from);\n            //} else {\n            // Contracts without a signer can override \"from\", and if\n            // unspecified the zero address is used\n            //overrides.from = AddressZero;\n        }\n        // Wait for all dependencies to be resolved (prefer the signer over the provider)\n        const resolved = yield (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.resolveProperties)({\n            args: resolveAddresses(contract.signer || contract.provider, args, fragment.inputs),\n            address: contract.resolvedAddress,\n            overrides: ((0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.resolveProperties)(overrides) || {})\n        });\n        // The ABI coded transaction\n        const data = contract.interface.encodeFunctionData(fragment, resolved.args);\n        const tx = {\n            data: data,\n            to: resolved.address\n        };\n        // Resolved Overrides\n        const ro = resolved.overrides;\n        // Populate simple overrides\n        if (ro.nonce != null) {\n            tx.nonce = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(ro.nonce).toNumber();\n        }\n        if (ro.gasLimit != null) {\n            tx.gasLimit = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(ro.gasLimit);\n        }\n        if (ro.gasPrice != null) {\n            tx.gasPrice = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(ro.gasPrice);\n        }\n        if (ro.maxFeePerGas != null) {\n            tx.maxFeePerGas = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(ro.maxFeePerGas);\n        }\n        if (ro.maxPriorityFeePerGas != null) {\n            tx.maxPriorityFeePerGas = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(ro.maxPriorityFeePerGas);\n        }\n        if (ro.from != null) {\n            tx.from = ro.from;\n        }\n        if (ro.type != null) {\n            tx.type = ro.type;\n        }\n        if (ro.accessList != null) {\n            tx.accessList = (0,_ethersproject_transactions__WEBPACK_IMPORTED_MODULE_5__.accessListify)(ro.accessList);\n        }\n        // If there was no \"gasLimit\" override, but the ABI specifies a default, use it\n        if (tx.gasLimit == null && fragment.gas != null) {\n            // Compute the intrinsic gas cost for this transaction\n            // @TODO: This is based on the yellow paper as of Petersburg; this is something\n            // we may wish to parameterize in v6 as part of the Network object. Since this\n            // is always a non-nil to address, we can ignore G_create, but may wish to add\n            // similar logic to the ContractFactory.\n            let intrinsic = 21000;\n            const bytes = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.arrayify)(data);\n            for (let i = 0; i < bytes.length; i++) {\n                intrinsic += 4;\n                if (bytes[i]) {\n                    intrinsic += 64;\n                }\n            }\n            tx.gasLimit = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(fragment.gas).add(intrinsic);\n        }\n        // Populate \"value\" override\n        if (ro.value) {\n            const roValue = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(ro.value);\n            if (!roValue.isZero() && !fragment.payable) {\n                logger.throwError(\"non-payable method cannot override value\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: \"overrides.value\",\n                    value: overrides.value\n                });\n            }\n            tx.value = roValue;\n        }\n        if (ro.customData) {\n            tx.customData = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.shallowCopy)(ro.customData);\n        }\n        if (ro.ccipReadEnabled) {\n            tx.ccipReadEnabled = !!ro.ccipReadEnabled;\n        }\n        // Remove the overrides\n        delete overrides.nonce;\n        delete overrides.gasLimit;\n        delete overrides.gasPrice;\n        delete overrides.from;\n        delete overrides.value;\n        delete overrides.type;\n        delete overrides.accessList;\n        delete overrides.maxFeePerGas;\n        delete overrides.maxPriorityFeePerGas;\n        delete overrides.customData;\n        delete overrides.ccipReadEnabled;\n        // Make sure there are no stray overrides, which may indicate a\n        // typo or using an unsupported key.\n        const leftovers = Object.keys(overrides).filter((key) => (overrides[key] != null));\n        if (leftovers.length) {\n            logger.throwError(`cannot override ${leftovers.map((l) => JSON.stringify(l)).join(\",\")}`, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"overrides\",\n                overrides: leftovers\n            });\n        }\n        return tx;\n    });\n}\nfunction buildPopulate(contract, fragment) {\n    return function (...args) {\n        return populateTransaction(contract, fragment, args);\n    };\n}\nfunction buildEstimate(contract, fragment) {\n    const signerOrProvider = (contract.signer || contract.provider);\n    return function (...args) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!signerOrProvider) {\n                logger.throwError(\"estimate require a provider or signer\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: \"estimateGas\"\n                });\n            }\n            const tx = yield populateTransaction(contract, fragment, args);\n            return yield signerOrProvider.estimateGas(tx);\n        });\n    };\n}\nfunction addContractWait(contract, tx) {\n    const wait = tx.wait.bind(tx);\n    tx.wait = (confirmations) => {\n        return wait(confirmations).then((receipt) => {\n            receipt.events = receipt.logs.map((log) => {\n                let event = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.deepCopy)(log);\n                let parsed = null;\n                try {\n                    parsed = contract.interface.parseLog(log);\n                }\n                catch (e) { }\n                // Successfully parsed the event log; include it\n                if (parsed) {\n                    event.args = parsed.args;\n                    event.decode = (data, topics) => {\n                        return contract.interface.decodeEventLog(parsed.eventFragment, data, topics);\n                    };\n                    event.event = parsed.name;\n                    event.eventSignature = parsed.signature;\n                }\n                // Useful operations\n                event.removeListener = () => { return contract.provider; };\n                event.getBlock = () => {\n                    return contract.provider.getBlock(receipt.blockHash);\n                };\n                event.getTransaction = () => {\n                    return contract.provider.getTransaction(receipt.transactionHash);\n                };\n                event.getTransactionReceipt = () => {\n                    return Promise.resolve(receipt);\n                };\n                return event;\n            });\n            return receipt;\n        });\n    };\n}\nfunction buildCall(contract, fragment, collapseSimple) {\n    const signerOrProvider = (contract.signer || contract.provider);\n    return function (...args) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Extract the \"blockTag\" override if present\n            let blockTag = undefined;\n            if (args.length === fragment.inputs.length + 1 && typeof (args[args.length - 1]) === \"object\") {\n                const overrides = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.shallowCopy)(args.pop());\n                if (overrides.blockTag != null) {\n                    blockTag = yield overrides.blockTag;\n                }\n                delete overrides.blockTag;\n                args.push(overrides);\n            }\n            // If the contract was just deployed, wait until it is mined\n            if (contract.deployTransaction != null) {\n                yield contract._deployed(blockTag);\n            }\n            // Call a node and get the result\n            const tx = yield populateTransaction(contract, fragment, args);\n            const result = yield signerOrProvider.call(tx, blockTag);\n            try {\n                let value = contract.interface.decodeFunctionResult(fragment, result);\n                if (collapseSimple && fragment.outputs.length === 1) {\n                    value = value[0];\n                }\n                return value;\n            }\n            catch (error) {\n                if (error.code === _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.CALL_EXCEPTION) {\n                    error.address = contract.address;\n                    error.args = args;\n                    error.transaction = tx;\n                }\n                throw error;\n            }\n        });\n    };\n}\nfunction buildSend(contract, fragment) {\n    return function (...args) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!contract.signer) {\n                logger.throwError(\"sending a transaction requires a signer\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: \"sendTransaction\"\n                });\n            }\n            // If the contract was just deployed, wait until it is mined\n            if (contract.deployTransaction != null) {\n                yield contract._deployed();\n            }\n            const txRequest = yield populateTransaction(contract, fragment, args);\n            const tx = yield contract.signer.sendTransaction(txRequest);\n            // Tweak the tx.wait so the receipt has extra properties\n            addContractWait(contract, tx);\n            return tx;\n        });\n    };\n}\nfunction buildDefault(contract, fragment, collapseSimple) {\n    if (fragment.constant) {\n        return buildCall(contract, fragment, collapseSimple);\n    }\n    return buildSend(contract, fragment);\n}\nfunction getEventTag(filter) {\n    if (filter.address && (filter.topics == null || filter.topics.length === 0)) {\n        return \"*\";\n    }\n    return (filter.address || \"*\") + \"@\" + (filter.topics ? filter.topics.map((topic) => {\n        if (Array.isArray(topic)) {\n            return topic.join(\"|\");\n        }\n        return topic;\n    }).join(\":\") : \"\");\n}\nclass RunningEvent {\n    constructor(tag, filter) {\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"tag\", tag);\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"filter\", filter);\n        this._listeners = [];\n    }\n    addListener(listener, once) {\n        this._listeners.push({ listener: listener, once: once });\n    }\n    removeListener(listener) {\n        let done = false;\n        this._listeners = this._listeners.filter((item) => {\n            if (done || item.listener !== listener) {\n                return true;\n            }\n            done = true;\n            return false;\n        });\n    }\n    removeAllListeners() {\n        this._listeners = [];\n    }\n    listeners() {\n        return this._listeners.map((i) => i.listener);\n    }\n    listenerCount() {\n        return this._listeners.length;\n    }\n    run(args) {\n        const listenerCount = this.listenerCount();\n        this._listeners = this._listeners.filter((item) => {\n            const argsCopy = args.slice();\n            // Call the callback in the next event loop\n            setTimeout(() => {\n                item.listener.apply(this, argsCopy);\n            }, 0);\n            // Reschedule it if it not \"once\"\n            return !(item.once);\n        });\n        return listenerCount;\n    }\n    prepareEvent(event) {\n    }\n    // Returns the array that will be applied to an emit\n    getEmit(event) {\n        return [event];\n    }\n}\nclass ErrorRunningEvent extends RunningEvent {\n    constructor() {\n        super(\"error\", null);\n    }\n}\n// @TODO Fragment should inherit Wildcard? and just override getEmit?\n//       or have a common abstract super class, with enough constructor\n//       options to configure both.\n// A Fragment Event will populate all the properties that Wildcard\n// will, and additionally dereference the arguments when emitting\nclass FragmentRunningEvent extends RunningEvent {\n    constructor(address, contractInterface, fragment, topics) {\n        const filter = {\n            address: address\n        };\n        let topic = contractInterface.getEventTopic(fragment);\n        if (topics) {\n            if (topic !== topics[0]) {\n                logger.throwArgumentError(\"topic mismatch\", \"topics\", topics);\n            }\n            filter.topics = topics.slice();\n        }\n        else {\n            filter.topics = [topic];\n        }\n        super(getEventTag(filter), filter);\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"address\", address);\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"interface\", contractInterface);\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"fragment\", fragment);\n    }\n    prepareEvent(event) {\n        super.prepareEvent(event);\n        event.event = this.fragment.name;\n        event.eventSignature = this.fragment.format();\n        event.decode = (data, topics) => {\n            return this.interface.decodeEventLog(this.fragment, data, topics);\n        };\n        try {\n            event.args = this.interface.decodeEventLog(this.fragment, event.data, event.topics);\n        }\n        catch (error) {\n            event.args = null;\n            event.decodeError = error;\n        }\n    }\n    getEmit(event) {\n        const errors = (0,_ethersproject_abi__WEBPACK_IMPORTED_MODULE_7__.checkResultErrors)(event.args);\n        if (errors.length) {\n            throw errors[0].error;\n        }\n        const args = (event.args || []).slice();\n        args.push(event);\n        return args;\n    }\n}\n// A Wildcard Event will attempt to populate:\n//  - event            The name of the event name\n//  - eventSignature   The full signature of the event\n//  - decode           A function to decode data and topics\n//  - args             The decoded data and topics\nclass WildcardRunningEvent extends RunningEvent {\n    constructor(address, contractInterface) {\n        super(\"*\", { address: address });\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"address\", address);\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"interface\", contractInterface);\n    }\n    prepareEvent(event) {\n        super.prepareEvent(event);\n        try {\n            const parsed = this.interface.parseLog(event);\n            event.event = parsed.name;\n            event.eventSignature = parsed.signature;\n            event.decode = (data, topics) => {\n                return this.interface.decodeEventLog(parsed.eventFragment, data, topics);\n            };\n            event.args = parsed.args;\n        }\n        catch (error) {\n            // No matching event\n        }\n    }\n}\nclass BaseContract {\n    constructor(addressOrName, contractInterface, signerOrProvider) {\n        // @TODO: Maybe still check the addressOrName looks like a valid address or name?\n        //address = getAddress(address);\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"interface\", (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.getStatic)(new.target, \"getInterface\")(contractInterface));\n        if (signerOrProvider == null) {\n            (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"provider\", null);\n            (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"signer\", null);\n        }\n        else if (_ethersproject_abstract_signer__WEBPACK_IMPORTED_MODULE_8__.Signer.isSigner(signerOrProvider)) {\n            (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"provider\", signerOrProvider.provider || null);\n            (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"signer\", signerOrProvider);\n        }\n        else if (_ethersproject_abstract_provider__WEBPACK_IMPORTED_MODULE_9__.Provider.isProvider(signerOrProvider)) {\n            (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"provider\", signerOrProvider);\n            (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"signer\", null);\n        }\n        else {\n            logger.throwArgumentError(\"invalid signer or provider\", \"signerOrProvider\", signerOrProvider);\n        }\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"callStatic\", {});\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"estimateGas\", {});\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"functions\", {});\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"populateTransaction\", {});\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"filters\", {});\n        {\n            const uniqueFilters = {};\n            Object.keys(this.interface.events).forEach((eventSignature) => {\n                const event = this.interface.events[eventSignature];\n                (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this.filters, eventSignature, (...args) => {\n                    return {\n                        address: this.address,\n                        topics: this.interface.encodeFilterTopics(event, args)\n                    };\n                });\n                if (!uniqueFilters[event.name]) {\n                    uniqueFilters[event.name] = [];\n                }\n                uniqueFilters[event.name].push(eventSignature);\n            });\n            Object.keys(uniqueFilters).forEach((name) => {\n                const filters = uniqueFilters[name];\n                if (filters.length === 1) {\n                    (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this.filters, name, this.filters[filters[0]]);\n                }\n                else {\n                    logger.warn(`Duplicate definition of ${name} (${filters.join(\", \")})`);\n                }\n            });\n        }\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"_runningEvents\", {});\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"_wrappedEmits\", {});\n        if (addressOrName == null) {\n            logger.throwArgumentError(\"invalid contract address or ENS name\", \"addressOrName\", addressOrName);\n        }\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"address\", addressOrName);\n        if (this.provider) {\n            (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"resolvedAddress\", resolveName(this.provider, addressOrName));\n        }\n        else {\n            try {\n                (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"resolvedAddress\", Promise.resolve((0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_2__.getAddress)(addressOrName)));\n            }\n            catch (error) {\n                // Without a provider, we cannot use ENS names\n                logger.throwError(\"provider is required to use ENS name as contract address\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: \"new Contract\"\n                });\n            }\n        }\n        // Swallow bad ENS names to prevent Unhandled Exceptions\n        this.resolvedAddress.catch((e) => { });\n        const uniqueNames = {};\n        const uniqueSignatures = {};\n        Object.keys(this.interface.functions).forEach((signature) => {\n            const fragment = this.interface.functions[signature];\n            // Check that the signature is unique; if not the ABI generation has\n            // not been cleaned or may be incorrectly generated\n            if (uniqueSignatures[signature]) {\n                logger.warn(`Duplicate ABI entry for ${JSON.stringify(signature)}`);\n                return;\n            }\n            uniqueSignatures[signature] = true;\n            // Track unique names; we only expose bare named functions if they\n            // are ambiguous\n            {\n                const name = fragment.name;\n                if (!uniqueNames[`%${name}`]) {\n                    uniqueNames[`%${name}`] = [];\n                }\n                uniqueNames[`%${name}`].push(signature);\n            }\n            if (this[signature] == null) {\n                (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, signature, buildDefault(this, fragment, true));\n            }\n            // We do not collapse simple calls on this bucket, which allows\n            // frameworks to safely use this without introspection as well as\n            // allows decoding error recovery.\n            if (this.functions[signature] == null) {\n                (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this.functions, signature, buildDefault(this, fragment, false));\n            }\n            if (this.callStatic[signature] == null) {\n                (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this.callStatic, signature, buildCall(this, fragment, true));\n            }\n            if (this.populateTransaction[signature] == null) {\n                (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this.populateTransaction, signature, buildPopulate(this, fragment));\n            }\n            if (this.estimateGas[signature] == null) {\n                (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this.estimateGas, signature, buildEstimate(this, fragment));\n            }\n        });\n        Object.keys(uniqueNames).forEach((name) => {\n            // Ambiguous names to not get attached as bare names\n            const signatures = uniqueNames[name];\n            if (signatures.length > 1) {\n                return;\n            }\n            // Strip off the leading \"%\" used for prototype protection\n            name = name.substring(1);\n            const signature = signatures[0];\n            // If overwriting a member property that is null, swallow the error\n            try {\n                if (this[name] == null) {\n                    (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, name, this[signature]);\n                }\n            }\n            catch (e) { }\n            if (this.functions[name] == null) {\n                (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this.functions, name, this.functions[signature]);\n            }\n            if (this.callStatic[name] == null) {\n                (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this.callStatic, name, this.callStatic[signature]);\n            }\n            if (this.populateTransaction[name] == null) {\n                (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this.populateTransaction, name, this.populateTransaction[signature]);\n            }\n            if (this.estimateGas[name] == null) {\n                (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this.estimateGas, name, this.estimateGas[signature]);\n            }\n        });\n    }\n    static getContractAddress(transaction) {\n        return (0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_2__.getContractAddress)(transaction);\n    }\n    static getInterface(contractInterface) {\n        if (_ethersproject_abi__WEBPACK_IMPORTED_MODULE_10__.Interface.isInterface(contractInterface)) {\n            return contractInterface;\n        }\n        return new _ethersproject_abi__WEBPACK_IMPORTED_MODULE_10__.Interface(contractInterface);\n    }\n    // @TODO: Allow timeout?\n    deployed() {\n        return this._deployed();\n    }\n    _deployed(blockTag) {\n        if (!this._deployedPromise) {\n            // If we were just deployed, we know the transaction we should occur in\n            if (this.deployTransaction) {\n                this._deployedPromise = this.deployTransaction.wait().then(() => {\n                    return this;\n                });\n            }\n            else {\n                // @TODO: Once we allow a timeout to be passed in, we will wait\n                // up to that many blocks for getCode\n                // Otherwise, poll for our code to be deployed\n                this._deployedPromise = this.provider.getCode(this.address, blockTag).then((code) => {\n                    if (code === \"0x\") {\n                        logger.throwError(\"contract not deployed\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n                            contractAddress: this.address,\n                            operation: \"getDeployed\"\n                        });\n                    }\n                    return this;\n                });\n            }\n        }\n        return this._deployedPromise;\n    }\n    // @TODO:\n    // estimateFallback(overrides?: TransactionRequest): Promise<BigNumber>\n    // @TODO:\n    // estimateDeploy(bytecode: string, ...args): Promise<BigNumber>\n    fallback(overrides) {\n        if (!this.signer) {\n            logger.throwError(\"sending a transactions require a signer\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, { operation: \"sendTransaction(fallback)\" });\n        }\n        const tx = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.shallowCopy)(overrides || {});\n        [\"from\", \"to\"].forEach(function (key) {\n            if (tx[key] == null) {\n                return;\n            }\n            logger.throwError(\"cannot override \" + key, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, { operation: key });\n        });\n        tx.to = this.resolvedAddress;\n        return this.deployed().then(() => {\n            return this.signer.sendTransaction(tx);\n        });\n    }\n    // Reconnect to a different signer or provider\n    connect(signerOrProvider) {\n        if (typeof (signerOrProvider) === \"string\") {\n            signerOrProvider = new _ethersproject_abstract_signer__WEBPACK_IMPORTED_MODULE_8__.VoidSigner(signerOrProvider, this.provider);\n        }\n        const contract = new (this.constructor)(this.address, this.interface, signerOrProvider);\n        if (this.deployTransaction) {\n            (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(contract, \"deployTransaction\", this.deployTransaction);\n        }\n        return contract;\n    }\n    // Re-attach to a different on-chain instance of this contract\n    attach(addressOrName) {\n        return new (this.constructor)(addressOrName, this.interface, this.signer || this.provider);\n    }\n    static isIndexed(value) {\n        return _ethersproject_abi__WEBPACK_IMPORTED_MODULE_10__.Indexed.isIndexed(value);\n    }\n    _normalizeRunningEvent(runningEvent) {\n        // Already have an instance of this event running; we can re-use it\n        if (this._runningEvents[runningEvent.tag]) {\n            return this._runningEvents[runningEvent.tag];\n        }\n        return runningEvent;\n    }\n    _getRunningEvent(eventName) {\n        if (typeof (eventName) === \"string\") {\n            // Listen for \"error\" events (if your contract has an error event, include\n            // the full signature to bypass this special event keyword)\n            if (eventName === \"error\") {\n                return this._normalizeRunningEvent(new ErrorRunningEvent());\n            }\n            // Listen for any event that is registered\n            if (eventName === \"event\") {\n                return this._normalizeRunningEvent(new RunningEvent(\"event\", null));\n            }\n            // Listen for any event\n            if (eventName === \"*\") {\n                return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));\n            }\n            // Get the event Fragment (throws if ambiguous/unknown event)\n            const fragment = this.interface.getEvent(eventName);\n            return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment));\n        }\n        // We have topics to filter by...\n        if (eventName.topics && eventName.topics.length > 0) {\n            // Is it a known topichash? (throws if no matching topichash)\n            try {\n                const topic = eventName.topics[0];\n                if (typeof (topic) !== \"string\") {\n                    throw new Error(\"invalid topic\"); // @TODO: May happen for anonymous events\n                }\n                const fragment = this.interface.getEvent(topic);\n                return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment, eventName.topics));\n            }\n            catch (error) { }\n            // Filter by the unknown topichash\n            const filter = {\n                address: this.address,\n                topics: eventName.topics\n            };\n            return this._normalizeRunningEvent(new RunningEvent(getEventTag(filter), filter));\n        }\n        return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));\n    }\n    _checkRunningEvents(runningEvent) {\n        if (runningEvent.listenerCount() === 0) {\n            delete this._runningEvents[runningEvent.tag];\n            // If we have a poller for this, remove it\n            const emit = this._wrappedEmits[runningEvent.tag];\n            if (emit && runningEvent.filter) {\n                this.provider.off(runningEvent.filter, emit);\n                delete this._wrappedEmits[runningEvent.tag];\n            }\n        }\n    }\n    // Subclasses can override this to gracefully recover\n    // from parse errors if they wish\n    _wrapEvent(runningEvent, log, listener) {\n        const event = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.deepCopy)(log);\n        event.removeListener = () => {\n            if (!listener) {\n                return;\n            }\n            runningEvent.removeListener(listener);\n            this._checkRunningEvents(runningEvent);\n        };\n        event.getBlock = () => { return this.provider.getBlock(log.blockHash); };\n        event.getTransaction = () => { return this.provider.getTransaction(log.transactionHash); };\n        event.getTransactionReceipt = () => { return this.provider.getTransactionReceipt(log.transactionHash); };\n        // This may throw if the topics and data mismatch the signature\n        runningEvent.prepareEvent(event);\n        return event;\n    }\n    _addEventListener(runningEvent, listener, once) {\n        if (!this.provider) {\n            logger.throwError(\"events require a provider or a signer with a provider\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, { operation: \"once\" });\n        }\n        runningEvent.addListener(listener, once);\n        // Track this running event and its listeners (may already be there; but no hard in updating)\n        this._runningEvents[runningEvent.tag] = runningEvent;\n        // If we are not polling the provider, start polling\n        if (!this._wrappedEmits[runningEvent.tag]) {\n            const wrappedEmit = (log) => {\n                let event = this._wrapEvent(runningEvent, log, listener);\n                // Try to emit the result for the parameterized event...\n                if (event.decodeError == null) {\n                    try {\n                        const args = runningEvent.getEmit(event);\n                        this.emit(runningEvent.filter, ...args);\n                    }\n                    catch (error) {\n                        event.decodeError = error.error;\n                    }\n                }\n                // Always emit \"event\" for fragment-base events\n                if (runningEvent.filter != null) {\n                    this.emit(\"event\", event);\n                }\n                // Emit \"error\" if there was an error\n                if (event.decodeError != null) {\n                    this.emit(\"error\", event.decodeError, event);\n                }\n            };\n            this._wrappedEmits[runningEvent.tag] = wrappedEmit;\n            // Special events, like \"error\" do not have a filter\n            if (runningEvent.filter != null) {\n                this.provider.on(runningEvent.filter, wrappedEmit);\n            }\n        }\n    }\n    queryFilter(event, fromBlockOrBlockhash, toBlock) {\n        const runningEvent = this._getRunningEvent(event);\n        const filter = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.shallowCopy)(runningEvent.filter);\n        if (typeof (fromBlockOrBlockhash) === \"string\" && (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.isHexString)(fromBlockOrBlockhash, 32)) {\n            if (toBlock != null) {\n                logger.throwArgumentError(\"cannot specify toBlock with blockhash\", \"toBlock\", toBlock);\n            }\n            filter.blockHash = fromBlockOrBlockhash;\n        }\n        else {\n            filter.fromBlock = ((fromBlockOrBlockhash != null) ? fromBlockOrBlockhash : 0);\n            filter.toBlock = ((toBlock != null) ? toBlock : \"latest\");\n        }\n        return this.provider.getLogs(filter).then((logs) => {\n            return logs.map((log) => this._wrapEvent(runningEvent, log, null));\n        });\n    }\n    on(event, listener) {\n        this._addEventListener(this._getRunningEvent(event), listener, false);\n        return this;\n    }\n    once(event, listener) {\n        this._addEventListener(this._getRunningEvent(event), listener, true);\n        return this;\n    }\n    emit(eventName, ...args) {\n        if (!this.provider) {\n            return false;\n        }\n        const runningEvent = this._getRunningEvent(eventName);\n        const result = (runningEvent.run(args) > 0);\n        // May have drained all the \"once\" events; check for living events\n        this._checkRunningEvents(runningEvent);\n        return result;\n    }\n    listenerCount(eventName) {\n        if (!this.provider) {\n            return 0;\n        }\n        if (eventName == null) {\n            return Object.keys(this._runningEvents).reduce((accum, key) => {\n                return accum + this._runningEvents[key].listenerCount();\n            }, 0);\n        }\n        return this._getRunningEvent(eventName).listenerCount();\n    }\n    listeners(eventName) {\n        if (!this.provider) {\n            return [];\n        }\n        if (eventName == null) {\n            const result = [];\n            for (let tag in this._runningEvents) {\n                this._runningEvents[tag].listeners().forEach((listener) => {\n                    result.push(listener);\n                });\n            }\n            return result;\n        }\n        return this._getRunningEvent(eventName).listeners();\n    }\n    removeAllListeners(eventName) {\n        if (!this.provider) {\n            return this;\n        }\n        if (eventName == null) {\n            for (const tag in this._runningEvents) {\n                const runningEvent = this._runningEvents[tag];\n                runningEvent.removeAllListeners();\n                this._checkRunningEvents(runningEvent);\n            }\n            return this;\n        }\n        // Delete any listeners\n        const runningEvent = this._getRunningEvent(eventName);\n        runningEvent.removeAllListeners();\n        this._checkRunningEvents(runningEvent);\n        return this;\n    }\n    off(eventName, listener) {\n        if (!this.provider) {\n            return this;\n        }\n        const runningEvent = this._getRunningEvent(eventName);\n        runningEvent.removeListener(listener);\n        this._checkRunningEvents(runningEvent);\n        return this;\n    }\n    removeListener(eventName, listener) {\n        return this.off(eventName, listener);\n    }\n}\nclass Contract extends BaseContract {\n}\nclass ContractFactory {\n    constructor(contractInterface, bytecode, signer) {\n        let bytecodeHex = null;\n        if (typeof (bytecode) === \"string\") {\n            bytecodeHex = bytecode;\n        }\n        else if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.isBytes)(bytecode)) {\n            bytecodeHex = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexlify)(bytecode);\n        }\n        else if (bytecode && typeof (bytecode.object) === \"string\") {\n            // Allow the bytecode object from the Solidity compiler\n            bytecodeHex = bytecode.object;\n        }\n        else {\n            // Crash in the next verification step\n            bytecodeHex = \"!\";\n        }\n        // Make sure it is 0x prefixed\n        if (bytecodeHex.substring(0, 2) !== \"0x\") {\n            bytecodeHex = \"0x\" + bytecodeHex;\n        }\n        // Make sure the final result is valid bytecode\n        if (!(0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.isHexString)(bytecodeHex) || (bytecodeHex.length % 2)) {\n            logger.throwArgumentError(\"invalid bytecode\", \"bytecode\", bytecode);\n        }\n        // If we have a signer, make sure it is valid\n        if (signer && !_ethersproject_abstract_signer__WEBPACK_IMPORTED_MODULE_8__.Signer.isSigner(signer)) {\n            logger.throwArgumentError(\"invalid signer\", \"signer\", signer);\n        }\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"bytecode\", bytecodeHex);\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"interface\", (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.getStatic)(new.target, \"getInterface\")(contractInterface));\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"signer\", signer || null);\n    }\n    // @TODO: Future; rename to populateTransaction?\n    getDeployTransaction(...args) {\n        let tx = {};\n        // If we have 1 additional argument, we allow transaction overrides\n        if (args.length === this.interface.deploy.inputs.length + 1 && typeof (args[args.length - 1]) === \"object\") {\n            tx = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.shallowCopy)(args.pop());\n            for (const key in tx) {\n                if (!allowedTransactionKeys[key]) {\n                    throw new Error(\"unknown transaction override \" + key);\n                }\n            }\n        }\n        // Do not allow these to be overridden in a deployment transaction\n        [\"data\", \"from\", \"to\"].forEach((key) => {\n            if (tx[key] == null) {\n                return;\n            }\n            logger.throwError(\"cannot override \" + key, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, { operation: key });\n        });\n        if (tx.value) {\n            const value = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(tx.value);\n            if (!value.isZero() && !this.interface.deploy.payable) {\n                logger.throwError(\"non-payable constructor cannot override value\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: \"overrides.value\",\n                    value: tx.value\n                });\n            }\n        }\n        // Make sure the call matches the constructor signature\n        logger.checkArgumentCount(args.length, this.interface.deploy.inputs.length, \" in Contract constructor\");\n        // Set the data to the bytecode + the encoded constructor arguments\n        tx.data = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexlify)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.concat)([\n            this.bytecode,\n            this.interface.encodeDeploy(args)\n        ]));\n        return tx;\n    }\n    deploy(...args) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let overrides = {};\n            // If 1 extra parameter was passed in, it contains overrides\n            if (args.length === this.interface.deploy.inputs.length + 1) {\n                overrides = args.pop();\n            }\n            // Make sure the call matches the constructor signature\n            logger.checkArgumentCount(args.length, this.interface.deploy.inputs.length, \" in Contract constructor\");\n            // Resolve ENS names and promises in the arguments\n            const params = yield resolveAddresses(this.signer, args, this.interface.deploy.inputs);\n            params.push(overrides);\n            // Get the deployment transaction (with optional overrides)\n            const unsignedTx = this.getDeployTransaction(...params);\n            // Send the deployment transaction\n            const tx = yield this.signer.sendTransaction(unsignedTx);\n            const address = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.getStatic)(this.constructor, \"getContractAddress\")(tx);\n            const contract = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.getStatic)(this.constructor, \"getContract\")(address, this.interface, this.signer);\n            // Add the modified wait that wraps events\n            addContractWait(contract, tx);\n            (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(contract, \"deployTransaction\", tx);\n            return contract;\n        });\n    }\n    attach(address) {\n        return (this.constructor).getContract(address, this.interface, this.signer);\n    }\n    connect(signer) {\n        return new (this.constructor)(this.interface, this.bytecode, signer);\n    }\n    static fromSolidity(compilerOutput, signer) {\n        if (compilerOutput == null) {\n            logger.throwError(\"missing compiler output\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.MISSING_ARGUMENT, { argument: \"compilerOutput\" });\n        }\n        if (typeof (compilerOutput) === \"string\") {\n            compilerOutput = JSON.parse(compilerOutput);\n        }\n        const abi = compilerOutput.abi;\n        let bytecode = null;\n        if (compilerOutput.bytecode) {\n            bytecode = compilerOutput.bytecode;\n        }\n        else if (compilerOutput.evm && compilerOutput.evm.bytecode) {\n            bytecode = compilerOutput.evm.bytecode;\n        }\n        return new this(abi, bytecode, signer);\n    }\n    static getInterface(contractInterface) {\n        return Contract.getInterface(contractInterface);\n    }\n    static getContractAddress(tx) {\n        return (0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_2__.getContractAddress)(tx);\n    }\n    static getContract(address, contractInterface, signer) {\n        return new Contract(address, contractInterface, signer);\n    }\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2NvbnRyYWN0cy9saWIuZXNtL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWE7QUFDYixpQkFBaUIsU0FBSSxJQUFJLFNBQUk7QUFDN0IsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDMkU7QUFDZjtBQUNRO0FBQ0k7QUFDbkI7QUFDa0M7QUFDeUI7QUFDcEQ7QUFDYjtBQUNWO0FBQ3JDLG1CQUFtQix5REFBTSxDQUFDLDZDQUFPO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixrRUFBVTtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxxRkFBcUYseURBQU07QUFDM0Y7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRix5REFBTTtBQUN4RjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzRUFBVztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLDRFQUFpQjtBQUNsRDtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLHdCQUF3QixrRUFBVTtBQUNsQyx5RkFBeUYseURBQU07QUFDL0Y7QUFDQSx5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QTtBQUNBLHlEQUF5RCx5REFBTSw0QkFBNEIsNEJBQTRCO0FBQ3ZIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMEVBQWtCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xlZGdpdHkteWllbGQtZnJvbnRlbmQvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2NvbnRyYWN0cy9saWIuZXNtL2luZGV4LmpzPzRjZTMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbmltcG9ydCB7IGNoZWNrUmVzdWx0RXJyb3JzLCBJbmRleGVkLCBJbnRlcmZhY2UgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYWJpXCI7XG5pbXBvcnQgeyBQcm92aWRlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9hYnN0cmFjdC1wcm92aWRlclwiO1xuaW1wb3J0IHsgU2lnbmVyLCBWb2lkU2lnbmVyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2Fic3RyYWN0LXNpZ25lclwiO1xuaW1wb3J0IHsgZ2V0QWRkcmVzcywgZ2V0Q29udHJhY3RBZGRyZXNzIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2FkZHJlc3NcIjtcbmltcG9ydCB7IEJpZ051bWJlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9iaWdudW1iZXJcIjtcbmltcG9ydCB7IGFycmF5aWZ5LCBjb25jYXQsIGhleGxpZnksIGlzQnl0ZXMsIGlzSGV4U3RyaW5nIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2J5dGVzXCI7XG5pbXBvcnQgeyBkZWZpbmVSZWFkT25seSwgZGVlcENvcHksIGdldFN0YXRpYywgcmVzb2x2ZVByb3BlcnRpZXMsIHNoYWxsb3dDb3B5IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3Byb3BlcnRpZXNcIjtcbmltcG9ydCB7IGFjY2Vzc0xpc3RpZnkgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvdHJhbnNhY3Rpb25zXCI7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvbG9nZ2VyXCI7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4vX3ZlcnNpb25cIjtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIodmVyc2lvbik7XG47XG47XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5jb25zdCBhbGxvd2VkVHJhbnNhY3Rpb25LZXlzID0ge1xuICAgIGNoYWluSWQ6IHRydWUsIGRhdGE6IHRydWUsIGZyb206IHRydWUsIGdhc0xpbWl0OiB0cnVlLCBnYXNQcmljZTogdHJ1ZSwgbm9uY2U6IHRydWUsIHRvOiB0cnVlLCB2YWx1ZTogdHJ1ZSxcbiAgICB0eXBlOiB0cnVlLCBhY2Nlc3NMaXN0OiB0cnVlLFxuICAgIG1heEZlZVBlckdhczogdHJ1ZSwgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IHRydWUsXG4gICAgY3VzdG9tRGF0YTogdHJ1ZSxcbiAgICBjY2lwUmVhZEVuYWJsZWQ6IHRydWVcbn07XG5mdW5jdGlvbiByZXNvbHZlTmFtZShyZXNvbHZlciwgbmFtZU9yUHJvbWlzZSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSB5aWVsZCBuYW1lT3JQcm9taXNlO1xuICAgICAgICBpZiAodHlwZW9mIChuYW1lKSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgYWRkcmVzcyBvciBFTlMgbmFtZVwiLCBcIm5hbWVcIiwgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgaXQgaXMgYWxyZWFkeSBhbiBhZGRyZXNzLCBqdXN0IHVzZSBpdCAoYWZ0ZXIgYWRkaW5nIGNoZWNrc3VtKVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGdldEFkZHJlc3MobmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgaWYgKCFyZXNvbHZlcikge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJhIHByb3ZpZGVyIG9yIHNpZ25lciBpcyBuZWVkZWQgdG8gcmVzb2x2ZSBFTlMgbmFtZXNcIiwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwicmVzb2x2ZU5hbWVcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IHlpZWxkIHJlc29sdmVyLnJlc29sdmVOYW1lKG5hbWUpO1xuICAgICAgICBpZiAoYWRkcmVzcyA9PSBudWxsKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwicmVzb2x2ZXIgb3IgYWRkciBpcyBub3QgY29uZmlndXJlZCBmb3IgRU5TIG5hbWVcIiwgXCJuYW1lXCIsIG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhZGRyZXNzO1xuICAgIH0pO1xufVxuLy8gUmVjdXJzaXZlbHkgcmVwbGFjZXMgRU5TIG5hbWVzIHdpdGggcHJvbWlzZXMgdG8gcmVzb2x2ZSB0aGUgbmFtZSBhbmQgcmVzb2x2ZXMgYWxsIHByb3BlcnRpZXNcbmZ1bmN0aW9uIHJlc29sdmVBZGRyZXNzZXMocmVzb2x2ZXIsIHZhbHVlLCBwYXJhbVR5cGUpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJhbVR5cGUpKSB7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgUHJvbWlzZS5hbGwocGFyYW1UeXBlLm1hcCgocGFyYW1UeXBlLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlQWRkcmVzc2VzKHJlc29sdmVyLCAoKEFycmF5LmlzQXJyYXkodmFsdWUpKSA/IHZhbHVlW2luZGV4XSA6IHZhbHVlW3BhcmFtVHlwZS5uYW1lXSksIHBhcmFtVHlwZSk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmFtVHlwZS50eXBlID09PSBcImFkZHJlc3NcIikge1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc29sdmVOYW1lKHJlc29sdmVyLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmFtVHlwZS50eXBlID09PSBcInR1cGxlXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNvbHZlQWRkcmVzc2VzKHJlc29sdmVyLCB2YWx1ZSwgcGFyYW1UeXBlLmNvbXBvbmVudHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJhbVR5cGUuYmFzZVR5cGUgPT09IFwiYXJyYXlcIikge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChsb2dnZXIubWFrZUVycm9yKFwiaW52YWxpZCB2YWx1ZSBmb3IgYXJyYXlcIiwgTG9nZ2VyLmVycm9ycy5JTlZBTElEX0FSR1VNRU5ULCB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50OiBcInZhbHVlXCIsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIFByb21pc2UuYWxsKHZhbHVlLm1hcCgodikgPT4gcmVzb2x2ZUFkZHJlc3NlcyhyZXNvbHZlciwgdiwgcGFyYW1UeXBlLmFycmF5Q2hpbGRyZW4pKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gcG9wdWxhdGVUcmFuc2FjdGlvbihjb250cmFjdCwgZnJhZ21lbnQsIGFyZ3MpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAvLyBJZiBhbiBleHRyYSBhcmd1bWVudCBpcyBnaXZlbiwgaXQgaXMgb3ZlcnJpZGVzXG4gICAgICAgIGxldCBvdmVycmlkZXMgPSB7fTtcbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSBmcmFnbWVudC5pbnB1dHMubGVuZ3RoICsgMSAmJiB0eXBlb2YgKGFyZ3NbYXJncy5sZW5ndGggLSAxXSkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIG92ZXJyaWRlcyA9IHNoYWxsb3dDb3B5KGFyZ3MucG9wKCkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgcGFyYW1ldGVyIGNvdW50IG1hdGNoZXNcbiAgICAgICAgbG9nZ2VyLmNoZWNrQXJndW1lbnRDb3VudChhcmdzLmxlbmd0aCwgZnJhZ21lbnQuaW5wdXRzLmxlbmd0aCwgXCJwYXNzZWQgdG8gY29udHJhY3RcIik7XG4gICAgICAgIC8vIFBvcHVsYXRlIFwiZnJvbVwiIG92ZXJyaWRlIChhbGxvdyBwcm9taXNlcylcbiAgICAgICAgaWYgKGNvbnRyYWN0LnNpZ25lcikge1xuICAgICAgICAgICAgaWYgKG92ZXJyaWRlcy5mcm9tKSB7XG4gICAgICAgICAgICAgICAgLy8gQ29udHJhY3RzIHdpdGggYSBTaWduZXIgYXJlIGZyb20gdGhlIFNpZ25lcidzIGZyYW1lLW9mLXJlZmVyZW5jZTtcbiAgICAgICAgICAgICAgICAvLyBidXQgd2UgYWxsb3cgb3ZlcnJpZGluZyBcImZyb21cIiBpZiBpdCBtYXRjaGVzIHRoZSBzaWduZXJcbiAgICAgICAgICAgICAgICBvdmVycmlkZXMuZnJvbSA9IHJlc29sdmVQcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgICAgICAgICAgb3ZlcnJpZGU6IHJlc29sdmVOYW1lKGNvbnRyYWN0LnNpZ25lciwgb3ZlcnJpZGVzLmZyb20pLFxuICAgICAgICAgICAgICAgICAgICBzaWduZXI6IGNvbnRyYWN0LnNpZ25lci5nZXRBZGRyZXNzKClcbiAgICAgICAgICAgICAgICB9KS50aGVuKChjaGVjaykgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZ2V0QWRkcmVzcyhjaGVjay5zaWduZXIpICE9PSBjaGVjay5vdmVycmlkZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJDb250cmFjdCB3aXRoIGEgU2lnbmVyIGNhbm5vdCBvdmVycmlkZSBmcm9tXCIsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcIm92ZXJyaWRlcy5mcm9tXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGVjay5vdmVycmlkZTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdmVycmlkZXMuZnJvbSA9IGNvbnRyYWN0LnNpZ25lci5nZXRBZGRyZXNzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3ZlcnJpZGVzLmZyb20pIHtcbiAgICAgICAgICAgIG92ZXJyaWRlcy5mcm9tID0gcmVzb2x2ZU5hbWUoY29udHJhY3QucHJvdmlkZXIsIG92ZXJyaWRlcy5mcm9tKTtcbiAgICAgICAgICAgIC8vfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIENvbnRyYWN0cyB3aXRob3V0IGEgc2lnbmVyIGNhbiBvdmVycmlkZSBcImZyb21cIiwgYW5kIGlmXG4gICAgICAgICAgICAvLyB1bnNwZWNpZmllZCB0aGUgemVybyBhZGRyZXNzIGlzIHVzZWRcbiAgICAgICAgICAgIC8vb3ZlcnJpZGVzLmZyb20gPSBBZGRyZXNzWmVybztcbiAgICAgICAgfVxuICAgICAgICAvLyBXYWl0IGZvciBhbGwgZGVwZW5kZW5jaWVzIHRvIGJlIHJlc29sdmVkIChwcmVmZXIgdGhlIHNpZ25lciBvdmVyIHRoZSBwcm92aWRlcilcbiAgICAgICAgY29uc3QgcmVzb2x2ZWQgPSB5aWVsZCByZXNvbHZlUHJvcGVydGllcyh7XG4gICAgICAgICAgICBhcmdzOiByZXNvbHZlQWRkcmVzc2VzKGNvbnRyYWN0LnNpZ25lciB8fCBjb250cmFjdC5wcm92aWRlciwgYXJncywgZnJhZ21lbnQuaW5wdXRzKSxcbiAgICAgICAgICAgIGFkZHJlc3M6IGNvbnRyYWN0LnJlc29sdmVkQWRkcmVzcyxcbiAgICAgICAgICAgIG92ZXJyaWRlczogKHJlc29sdmVQcm9wZXJ0aWVzKG92ZXJyaWRlcykgfHwge30pXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBUaGUgQUJJIGNvZGVkIHRyYW5zYWN0aW9uXG4gICAgICAgIGNvbnN0IGRhdGEgPSBjb250cmFjdC5pbnRlcmZhY2UuZW5jb2RlRnVuY3Rpb25EYXRhKGZyYWdtZW50LCByZXNvbHZlZC5hcmdzKTtcbiAgICAgICAgY29uc3QgdHggPSB7XG4gICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgdG86IHJlc29sdmVkLmFkZHJlc3NcbiAgICAgICAgfTtcbiAgICAgICAgLy8gUmVzb2x2ZWQgT3ZlcnJpZGVzXG4gICAgICAgIGNvbnN0IHJvID0gcmVzb2x2ZWQub3ZlcnJpZGVzO1xuICAgICAgICAvLyBQb3B1bGF0ZSBzaW1wbGUgb3ZlcnJpZGVzXG4gICAgICAgIGlmIChyby5ub25jZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0eC5ub25jZSA9IEJpZ051bWJlci5mcm9tKHJvLm5vbmNlKS50b051bWJlcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyby5nYXNMaW1pdCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0eC5nYXNMaW1pdCA9IEJpZ051bWJlci5mcm9tKHJvLmdhc0xpbWl0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocm8uZ2FzUHJpY2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgdHguZ2FzUHJpY2UgPSBCaWdOdW1iZXIuZnJvbShyby5nYXNQcmljZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJvLm1heEZlZVBlckdhcyAhPSBudWxsKSB7XG4gICAgICAgICAgICB0eC5tYXhGZWVQZXJHYXMgPSBCaWdOdW1iZXIuZnJvbShyby5tYXhGZWVQZXJHYXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyby5tYXhQcmlvcml0eUZlZVBlckdhcyAhPSBudWxsKSB7XG4gICAgICAgICAgICB0eC5tYXhQcmlvcml0eUZlZVBlckdhcyA9IEJpZ051bWJlci5mcm9tKHJvLm1heFByaW9yaXR5RmVlUGVyR2FzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocm8uZnJvbSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0eC5mcm9tID0gcm8uZnJvbTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocm8udHlwZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0eC50eXBlID0gcm8udHlwZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocm8uYWNjZXNzTGlzdCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0eC5hY2Nlc3NMaXN0ID0gYWNjZXNzTGlzdGlmeShyby5hY2Nlc3NMaXN0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGVyZSB3YXMgbm8gXCJnYXNMaW1pdFwiIG92ZXJyaWRlLCBidXQgdGhlIEFCSSBzcGVjaWZpZXMgYSBkZWZhdWx0LCB1c2UgaXRcbiAgICAgICAgaWYgKHR4Lmdhc0xpbWl0ID09IG51bGwgJiYgZnJhZ21lbnQuZ2FzICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIENvbXB1dGUgdGhlIGludHJpbnNpYyBnYXMgY29zdCBmb3IgdGhpcyB0cmFuc2FjdGlvblxuICAgICAgICAgICAgLy8gQFRPRE86IFRoaXMgaXMgYmFzZWQgb24gdGhlIHllbGxvdyBwYXBlciBhcyBvZiBQZXRlcnNidXJnOyB0aGlzIGlzIHNvbWV0aGluZ1xuICAgICAgICAgICAgLy8gd2UgbWF5IHdpc2ggdG8gcGFyYW1ldGVyaXplIGluIHY2IGFzIHBhcnQgb2YgdGhlIE5ldHdvcmsgb2JqZWN0LiBTaW5jZSB0aGlzXG4gICAgICAgICAgICAvLyBpcyBhbHdheXMgYSBub24tbmlsIHRvIGFkZHJlc3MsIHdlIGNhbiBpZ25vcmUgR19jcmVhdGUsIGJ1dCBtYXkgd2lzaCB0byBhZGRcbiAgICAgICAgICAgIC8vIHNpbWlsYXIgbG9naWMgdG8gdGhlIENvbnRyYWN0RmFjdG9yeS5cbiAgICAgICAgICAgIGxldCBpbnRyaW5zaWMgPSAyMTAwMDtcbiAgICAgICAgICAgIGNvbnN0IGJ5dGVzID0gYXJyYXlpZnkoZGF0YSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaW50cmluc2ljICs9IDQ7XG4gICAgICAgICAgICAgICAgaWYgKGJ5dGVzW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIGludHJpbnNpYyArPSA2NDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0eC5nYXNMaW1pdCA9IEJpZ051bWJlci5mcm9tKGZyYWdtZW50LmdhcykuYWRkKGludHJpbnNpYyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUG9wdWxhdGUgXCJ2YWx1ZVwiIG92ZXJyaWRlXG4gICAgICAgIGlmIChyby52YWx1ZSkge1xuICAgICAgICAgICAgY29uc3Qgcm9WYWx1ZSA9IEJpZ051bWJlci5mcm9tKHJvLnZhbHVlKTtcbiAgICAgICAgICAgIGlmICghcm9WYWx1ZS5pc1plcm8oKSAmJiAhZnJhZ21lbnQucGF5YWJsZSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwibm9uLXBheWFibGUgbWV0aG9kIGNhbm5vdCBvdmVycmlkZSB2YWx1ZVwiLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwib3ZlcnJpZGVzLnZhbHVlXCIsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBvdmVycmlkZXMudmFsdWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHR4LnZhbHVlID0gcm9WYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocm8uY3VzdG9tRGF0YSkge1xuICAgICAgICAgICAgdHguY3VzdG9tRGF0YSA9IHNoYWxsb3dDb3B5KHJvLmN1c3RvbURhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyby5jY2lwUmVhZEVuYWJsZWQpIHtcbiAgICAgICAgICAgIHR4LmNjaXBSZWFkRW5hYmxlZCA9ICEhcm8uY2NpcFJlYWRFbmFibGVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlbW92ZSB0aGUgb3ZlcnJpZGVzXG4gICAgICAgIGRlbGV0ZSBvdmVycmlkZXMubm9uY2U7XG4gICAgICAgIGRlbGV0ZSBvdmVycmlkZXMuZ2FzTGltaXQ7XG4gICAgICAgIGRlbGV0ZSBvdmVycmlkZXMuZ2FzUHJpY2U7XG4gICAgICAgIGRlbGV0ZSBvdmVycmlkZXMuZnJvbTtcbiAgICAgICAgZGVsZXRlIG92ZXJyaWRlcy52YWx1ZTtcbiAgICAgICAgZGVsZXRlIG92ZXJyaWRlcy50eXBlO1xuICAgICAgICBkZWxldGUgb3ZlcnJpZGVzLmFjY2Vzc0xpc3Q7XG4gICAgICAgIGRlbGV0ZSBvdmVycmlkZXMubWF4RmVlUGVyR2FzO1xuICAgICAgICBkZWxldGUgb3ZlcnJpZGVzLm1heFByaW9yaXR5RmVlUGVyR2FzO1xuICAgICAgICBkZWxldGUgb3ZlcnJpZGVzLmN1c3RvbURhdGE7XG4gICAgICAgIGRlbGV0ZSBvdmVycmlkZXMuY2NpcFJlYWRFbmFibGVkO1xuICAgICAgICAvLyBNYWtlIHN1cmUgdGhlcmUgYXJlIG5vIHN0cmF5IG92ZXJyaWRlcywgd2hpY2ggbWF5IGluZGljYXRlIGFcbiAgICAgICAgLy8gdHlwbyBvciB1c2luZyBhbiB1bnN1cHBvcnRlZCBrZXkuXG4gICAgICAgIGNvbnN0IGxlZnRvdmVycyA9IE9iamVjdC5rZXlzKG92ZXJyaWRlcykuZmlsdGVyKChrZXkpID0+IChvdmVycmlkZXNba2V5XSAhPSBudWxsKSk7XG4gICAgICAgIGlmIChsZWZ0b3ZlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihgY2Fubm90IG92ZXJyaWRlICR7bGVmdG92ZXJzLm1hcCgobCkgPT4gSlNPTi5zdHJpbmdpZnkobCkpLmpvaW4oXCIsXCIpfWAsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcIm92ZXJyaWRlc1wiLFxuICAgICAgICAgICAgICAgIG92ZXJyaWRlczogbGVmdG92ZXJzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHg7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBidWlsZFBvcHVsYXRlKGNvbnRyYWN0LCBmcmFnbWVudCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICByZXR1cm4gcG9wdWxhdGVUcmFuc2FjdGlvbihjb250cmFjdCwgZnJhZ21lbnQsIGFyZ3MpO1xuICAgIH07XG59XG5mdW5jdGlvbiBidWlsZEVzdGltYXRlKGNvbnRyYWN0LCBmcmFnbWVudCkge1xuICAgIGNvbnN0IHNpZ25lck9yUHJvdmlkZXIgPSAoY29udHJhY3Quc2lnbmVyIHx8IGNvbnRyYWN0LnByb3ZpZGVyKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICghc2lnbmVyT3JQcm92aWRlcikge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiZXN0aW1hdGUgcmVxdWlyZSBhIHByb3ZpZGVyIG9yIHNpZ25lclwiLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwiZXN0aW1hdGVHYXNcIlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdHggPSB5aWVsZCBwb3B1bGF0ZVRyYW5zYWN0aW9uKGNvbnRyYWN0LCBmcmFnbWVudCwgYXJncyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgc2lnbmVyT3JQcm92aWRlci5lc3RpbWF0ZUdhcyh0eCk7XG4gICAgICAgIH0pO1xuICAgIH07XG59XG5mdW5jdGlvbiBhZGRDb250cmFjdFdhaXQoY29udHJhY3QsIHR4KSB7XG4gICAgY29uc3Qgd2FpdCA9IHR4LndhaXQuYmluZCh0eCk7XG4gICAgdHgud2FpdCA9IChjb25maXJtYXRpb25zKSA9PiB7XG4gICAgICAgIHJldHVybiB3YWl0KGNvbmZpcm1hdGlvbnMpLnRoZW4oKHJlY2VpcHQpID0+IHtcbiAgICAgICAgICAgIHJlY2VpcHQuZXZlbnRzID0gcmVjZWlwdC5sb2dzLm1hcCgobG9nKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGV2ZW50ID0gZGVlcENvcHkobG9nKTtcbiAgICAgICAgICAgICAgICBsZXQgcGFyc2VkID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZWQgPSBjb250cmFjdC5pbnRlcmZhY2UucGFyc2VMb2cobG9nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHsgfVxuICAgICAgICAgICAgICAgIC8vIFN1Y2Nlc3NmdWxseSBwYXJzZWQgdGhlIGV2ZW50IGxvZzsgaW5jbHVkZSBpdFxuICAgICAgICAgICAgICAgIGlmIChwYXJzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuYXJncyA9IHBhcnNlZC5hcmdzO1xuICAgICAgICAgICAgICAgICAgICBldmVudC5kZWNvZGUgPSAoZGF0YSwgdG9waWNzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udHJhY3QuaW50ZXJmYWNlLmRlY29kZUV2ZW50TG9nKHBhcnNlZC5ldmVudEZyYWdtZW50LCBkYXRhLCB0b3BpY3MpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBldmVudC5ldmVudCA9IHBhcnNlZC5uYW1lO1xuICAgICAgICAgICAgICAgICAgICBldmVudC5ldmVudFNpZ25hdHVyZSA9IHBhcnNlZC5zaWduYXR1cmU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFVzZWZ1bCBvcGVyYXRpb25zXG4gICAgICAgICAgICAgICAgZXZlbnQucmVtb3ZlTGlzdGVuZXIgPSAoKSA9PiB7IHJldHVybiBjb250cmFjdC5wcm92aWRlcjsgfTtcbiAgICAgICAgICAgICAgICBldmVudC5nZXRCbG9jayA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRyYWN0LnByb3ZpZGVyLmdldEJsb2NrKHJlY2VpcHQuYmxvY2tIYXNoKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGV2ZW50LmdldFRyYW5zYWN0aW9uID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udHJhY3QucHJvdmlkZXIuZ2V0VHJhbnNhY3Rpb24ocmVjZWlwdC50cmFuc2FjdGlvbkhhc2gpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgZXZlbnQuZ2V0VHJhbnNhY3Rpb25SZWNlaXB0ID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlY2VpcHQpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVjZWlwdDtcbiAgICAgICAgfSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGJ1aWxkQ2FsbChjb250cmFjdCwgZnJhZ21lbnQsIGNvbGxhcHNlU2ltcGxlKSB7XG4gICAgY29uc3Qgc2lnbmVyT3JQcm92aWRlciA9IChjb250cmFjdC5zaWduZXIgfHwgY29udHJhY3QucHJvdmlkZXIpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgLy8gRXh0cmFjdCB0aGUgXCJibG9ja1RhZ1wiIG92ZXJyaWRlIGlmIHByZXNlbnRcbiAgICAgICAgICAgIGxldCBibG9ja1RhZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gZnJhZ21lbnQuaW5wdXRzLmxlbmd0aCArIDEgJiYgdHlwZW9mIChhcmdzW2FyZ3MubGVuZ3RoIC0gMV0pID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3ZlcnJpZGVzID0gc2hhbGxvd0NvcHkoYXJncy5wb3AoKSk7XG4gICAgICAgICAgICAgICAgaWYgKG92ZXJyaWRlcy5ibG9ja1RhZyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGJsb2NrVGFnID0geWllbGQgb3ZlcnJpZGVzLmJsb2NrVGFnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWxldGUgb3ZlcnJpZGVzLmJsb2NrVGFnO1xuICAgICAgICAgICAgICAgIGFyZ3MucHVzaChvdmVycmlkZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgdGhlIGNvbnRyYWN0IHdhcyBqdXN0IGRlcGxveWVkLCB3YWl0IHVudGlsIGl0IGlzIG1pbmVkXG4gICAgICAgICAgICBpZiAoY29udHJhY3QuZGVwbG95VHJhbnNhY3Rpb24gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHlpZWxkIGNvbnRyYWN0Ll9kZXBsb3llZChibG9ja1RhZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDYWxsIGEgbm9kZSBhbmQgZ2V0IHRoZSByZXN1bHRcbiAgICAgICAgICAgIGNvbnN0IHR4ID0geWllbGQgcG9wdWxhdGVUcmFuc2FjdGlvbihjb250cmFjdCwgZnJhZ21lbnQsIGFyZ3MpO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geWllbGQgc2lnbmVyT3JQcm92aWRlci5jYWxsKHR4LCBibG9ja1RhZyk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IGNvbnRyYWN0LmludGVyZmFjZS5kZWNvZGVGdW5jdGlvblJlc3VsdChmcmFnbWVudCwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICBpZiAoY29sbGFwc2VTaW1wbGUgJiYgZnJhZ21lbnQub3V0cHV0cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZVswXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09IExvZ2dlci5lcnJvcnMuQ0FMTF9FWENFUFRJT04pIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IuYWRkcmVzcyA9IGNvbnRyYWN0LmFkZHJlc3M7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLmFyZ3MgPSBhcmdzO1xuICAgICAgICAgICAgICAgICAgICBlcnJvci50cmFuc2FjdGlvbiA9IHR4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGJ1aWxkU2VuZChjb250cmFjdCwgZnJhZ21lbnQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICghY29udHJhY3Quc2lnbmVyKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJzZW5kaW5nIGEgdHJhbnNhY3Rpb24gcmVxdWlyZXMgYSBzaWduZXJcIiwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcInNlbmRUcmFuc2FjdGlvblwiXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB0aGUgY29udHJhY3Qgd2FzIGp1c3QgZGVwbG95ZWQsIHdhaXQgdW50aWwgaXQgaXMgbWluZWRcbiAgICAgICAgICAgIGlmIChjb250cmFjdC5kZXBsb3lUcmFuc2FjdGlvbiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgY29udHJhY3QuX2RlcGxveWVkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0eFJlcXVlc3QgPSB5aWVsZCBwb3B1bGF0ZVRyYW5zYWN0aW9uKGNvbnRyYWN0LCBmcmFnbWVudCwgYXJncyk7XG4gICAgICAgICAgICBjb25zdCB0eCA9IHlpZWxkIGNvbnRyYWN0LnNpZ25lci5zZW5kVHJhbnNhY3Rpb24odHhSZXF1ZXN0KTtcbiAgICAgICAgICAgIC8vIFR3ZWFrIHRoZSB0eC53YWl0IHNvIHRoZSByZWNlaXB0IGhhcyBleHRyYSBwcm9wZXJ0aWVzXG4gICAgICAgICAgICBhZGRDb250cmFjdFdhaXQoY29udHJhY3QsIHR4KTtcbiAgICAgICAgICAgIHJldHVybiB0eDtcbiAgICAgICAgfSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGJ1aWxkRGVmYXVsdChjb250cmFjdCwgZnJhZ21lbnQsIGNvbGxhcHNlU2ltcGxlKSB7XG4gICAgaWYgKGZyYWdtZW50LmNvbnN0YW50KSB7XG4gICAgICAgIHJldHVybiBidWlsZENhbGwoY29udHJhY3QsIGZyYWdtZW50LCBjb2xsYXBzZVNpbXBsZSk7XG4gICAgfVxuICAgIHJldHVybiBidWlsZFNlbmQoY29udHJhY3QsIGZyYWdtZW50KTtcbn1cbmZ1bmN0aW9uIGdldEV2ZW50VGFnKGZpbHRlcikge1xuICAgIGlmIChmaWx0ZXIuYWRkcmVzcyAmJiAoZmlsdGVyLnRvcGljcyA9PSBudWxsIHx8IGZpbHRlci50b3BpY3MubGVuZ3RoID09PSAwKSkge1xuICAgICAgICByZXR1cm4gXCIqXCI7XG4gICAgfVxuICAgIHJldHVybiAoZmlsdGVyLmFkZHJlc3MgfHwgXCIqXCIpICsgXCJAXCIgKyAoZmlsdGVyLnRvcGljcyA/IGZpbHRlci50b3BpY3MubWFwKCh0b3BpYykgPT4ge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0b3BpYykpIHtcbiAgICAgICAgICAgIHJldHVybiB0b3BpYy5qb2luKFwifFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9waWM7XG4gICAgfSkuam9pbihcIjpcIikgOiBcIlwiKTtcbn1cbmNsYXNzIFJ1bm5pbmdFdmVudCB7XG4gICAgY29uc3RydWN0b3IodGFnLCBmaWx0ZXIpIHtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJ0YWdcIiwgdGFnKTtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJmaWx0ZXJcIiwgZmlsdGVyKTtcbiAgICAgICAgdGhpcy5fbGlzdGVuZXJzID0gW107XG4gICAgfVxuICAgIGFkZExpc3RlbmVyKGxpc3RlbmVyLCBvbmNlKSB7XG4gICAgICAgIHRoaXMuX2xpc3RlbmVycy5wdXNoKHsgbGlzdGVuZXI6IGxpc3RlbmVyLCBvbmNlOiBvbmNlIH0pO1xuICAgIH1cbiAgICByZW1vdmVMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgICAgICBsZXQgZG9uZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9saXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnMuZmlsdGVyKChpdGVtKSA9PiB7XG4gICAgICAgICAgICBpZiAoZG9uZSB8fCBpdGVtLmxpc3RlbmVyICE9PSBsaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZW1vdmVBbGxMaXN0ZW5lcnMoKSB7XG4gICAgICAgIHRoaXMuX2xpc3RlbmVycyA9IFtdO1xuICAgIH1cbiAgICBsaXN0ZW5lcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9saXN0ZW5lcnMubWFwKChpKSA9PiBpLmxpc3RlbmVyKTtcbiAgICB9XG4gICAgbGlzdGVuZXJDb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xpc3RlbmVycy5sZW5ndGg7XG4gICAgfVxuICAgIHJ1bihhcmdzKSB7XG4gICAgICAgIGNvbnN0IGxpc3RlbmVyQ291bnQgPSB0aGlzLmxpc3RlbmVyQ291bnQoKTtcbiAgICAgICAgdGhpcy5fbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzLmZpbHRlcigoaXRlbSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYXJnc0NvcHkgPSBhcmdzLnNsaWNlKCk7XG4gICAgICAgICAgICAvLyBDYWxsIHRoZSBjYWxsYmFjayBpbiB0aGUgbmV4dCBldmVudCBsb29wXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBpdGVtLmxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3NDb3B5KTtcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgLy8gUmVzY2hlZHVsZSBpdCBpZiBpdCBub3QgXCJvbmNlXCJcbiAgICAgICAgICAgIHJldHVybiAhKGl0ZW0ub25jZSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbGlzdGVuZXJDb3VudDtcbiAgICB9XG4gICAgcHJlcGFyZUV2ZW50KGV2ZW50KSB7XG4gICAgfVxuICAgIC8vIFJldHVybnMgdGhlIGFycmF5IHRoYXQgd2lsbCBiZSBhcHBsaWVkIHRvIGFuIGVtaXRcbiAgICBnZXRFbWl0KGV2ZW50KSB7XG4gICAgICAgIHJldHVybiBbZXZlbnRdO1xuICAgIH1cbn1cbmNsYXNzIEVycm9yUnVubmluZ0V2ZW50IGV4dGVuZHMgUnVubmluZ0V2ZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoXCJlcnJvclwiLCBudWxsKTtcbiAgICB9XG59XG4vLyBAVE9ETyBGcmFnbWVudCBzaG91bGQgaW5oZXJpdCBXaWxkY2FyZD8gYW5kIGp1c3Qgb3ZlcnJpZGUgZ2V0RW1pdD9cbi8vICAgICAgIG9yIGhhdmUgYSBjb21tb24gYWJzdHJhY3Qgc3VwZXIgY2xhc3MsIHdpdGggZW5vdWdoIGNvbnN0cnVjdG9yXG4vLyAgICAgICBvcHRpb25zIHRvIGNvbmZpZ3VyZSBib3RoLlxuLy8gQSBGcmFnbWVudCBFdmVudCB3aWxsIHBvcHVsYXRlIGFsbCB0aGUgcHJvcGVydGllcyB0aGF0IFdpbGRjYXJkXG4vLyB3aWxsLCBhbmQgYWRkaXRpb25hbGx5IGRlcmVmZXJlbmNlIHRoZSBhcmd1bWVudHMgd2hlbiBlbWl0dGluZ1xuY2xhc3MgRnJhZ21lbnRSdW5uaW5nRXZlbnQgZXh0ZW5kcyBSdW5uaW5nRXZlbnQge1xuICAgIGNvbnN0cnVjdG9yKGFkZHJlc3MsIGNvbnRyYWN0SW50ZXJmYWNlLCBmcmFnbWVudCwgdG9waWNzKSB7XG4gICAgICAgIGNvbnN0IGZpbHRlciA9IHtcbiAgICAgICAgICAgIGFkZHJlc3M6IGFkZHJlc3NcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHRvcGljID0gY29udHJhY3RJbnRlcmZhY2UuZ2V0RXZlbnRUb3BpYyhmcmFnbWVudCk7XG4gICAgICAgIGlmICh0b3BpY3MpIHtcbiAgICAgICAgICAgIGlmICh0b3BpYyAhPT0gdG9waWNzWzBdKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInRvcGljIG1pc21hdGNoXCIsIFwidG9waWNzXCIsIHRvcGljcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaWx0ZXIudG9waWNzID0gdG9waWNzLnNsaWNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmaWx0ZXIudG9waWNzID0gW3RvcGljXTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcihnZXRFdmVudFRhZyhmaWx0ZXIpLCBmaWx0ZXIpO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcImFkZHJlc3NcIiwgYWRkcmVzcyk7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiaW50ZXJmYWNlXCIsIGNvbnRyYWN0SW50ZXJmYWNlKTtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJmcmFnbWVudFwiLCBmcmFnbWVudCk7XG4gICAgfVxuICAgIHByZXBhcmVFdmVudChldmVudCkge1xuICAgICAgICBzdXBlci5wcmVwYXJlRXZlbnQoZXZlbnQpO1xuICAgICAgICBldmVudC5ldmVudCA9IHRoaXMuZnJhZ21lbnQubmFtZTtcbiAgICAgICAgZXZlbnQuZXZlbnRTaWduYXR1cmUgPSB0aGlzLmZyYWdtZW50LmZvcm1hdCgpO1xuICAgICAgICBldmVudC5kZWNvZGUgPSAoZGF0YSwgdG9waWNzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbnRlcmZhY2UuZGVjb2RlRXZlbnRMb2codGhpcy5mcmFnbWVudCwgZGF0YSwgdG9waWNzKTtcbiAgICAgICAgfTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGV2ZW50LmFyZ3MgPSB0aGlzLmludGVyZmFjZS5kZWNvZGVFdmVudExvZyh0aGlzLmZyYWdtZW50LCBldmVudC5kYXRhLCBldmVudC50b3BpY3MpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgZXZlbnQuYXJncyA9IG51bGw7XG4gICAgICAgICAgICBldmVudC5kZWNvZGVFcnJvciA9IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldEVtaXQoZXZlbnQpIHtcbiAgICAgICAgY29uc3QgZXJyb3JzID0gY2hlY2tSZXN1bHRFcnJvcnMoZXZlbnQuYXJncyk7XG4gICAgICAgIGlmIChlcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcnNbMF0uZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXJncyA9IChldmVudC5hcmdzIHx8IFtdKS5zbGljZSgpO1xuICAgICAgICBhcmdzLnB1c2goZXZlbnQpO1xuICAgICAgICByZXR1cm4gYXJncztcbiAgICB9XG59XG4vLyBBIFdpbGRjYXJkIEV2ZW50IHdpbGwgYXR0ZW1wdCB0byBwb3B1bGF0ZTpcbi8vICAtIGV2ZW50ICAgICAgICAgICAgVGhlIG5hbWUgb2YgdGhlIGV2ZW50IG5hbWVcbi8vICAtIGV2ZW50U2lnbmF0dXJlICAgVGhlIGZ1bGwgc2lnbmF0dXJlIG9mIHRoZSBldmVudFxuLy8gIC0gZGVjb2RlICAgICAgICAgICBBIGZ1bmN0aW9uIHRvIGRlY29kZSBkYXRhIGFuZCB0b3BpY3Ncbi8vICAtIGFyZ3MgICAgICAgICAgICAgVGhlIGRlY29kZWQgZGF0YSBhbmQgdG9waWNzXG5jbGFzcyBXaWxkY2FyZFJ1bm5pbmdFdmVudCBleHRlbmRzIFJ1bm5pbmdFdmVudCB7XG4gICAgY29uc3RydWN0b3IoYWRkcmVzcywgY29udHJhY3RJbnRlcmZhY2UpIHtcbiAgICAgICAgc3VwZXIoXCIqXCIsIHsgYWRkcmVzczogYWRkcmVzcyB9KTtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJhZGRyZXNzXCIsIGFkZHJlc3MpO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcImludGVyZmFjZVwiLCBjb250cmFjdEludGVyZmFjZSk7XG4gICAgfVxuICAgIHByZXBhcmVFdmVudChldmVudCkge1xuICAgICAgICBzdXBlci5wcmVwYXJlRXZlbnQoZXZlbnQpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcGFyc2VkID0gdGhpcy5pbnRlcmZhY2UucGFyc2VMb2coZXZlbnQpO1xuICAgICAgICAgICAgZXZlbnQuZXZlbnQgPSBwYXJzZWQubmFtZTtcbiAgICAgICAgICAgIGV2ZW50LmV2ZW50U2lnbmF0dXJlID0gcGFyc2VkLnNpZ25hdHVyZTtcbiAgICAgICAgICAgIGV2ZW50LmRlY29kZSA9IChkYXRhLCB0b3BpY3MpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbnRlcmZhY2UuZGVjb2RlRXZlbnRMb2cocGFyc2VkLmV2ZW50RnJhZ21lbnQsIGRhdGEsIHRvcGljcyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXZlbnQuYXJncyA9IHBhcnNlZC5hcmdzO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgLy8gTm8gbWF0Y2hpbmcgZXZlbnRcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBCYXNlQ29udHJhY3Qge1xuICAgIGNvbnN0cnVjdG9yKGFkZHJlc3NPck5hbWUsIGNvbnRyYWN0SW50ZXJmYWNlLCBzaWduZXJPclByb3ZpZGVyKSB7XG4gICAgICAgIC8vIEBUT0RPOiBNYXliZSBzdGlsbCBjaGVjayB0aGUgYWRkcmVzc09yTmFtZSBsb29rcyBsaWtlIGEgdmFsaWQgYWRkcmVzcyBvciBuYW1lP1xuICAgICAgICAvL2FkZHJlc3MgPSBnZXRBZGRyZXNzKGFkZHJlc3MpO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcImludGVyZmFjZVwiLCBnZXRTdGF0aWMobmV3LnRhcmdldCwgXCJnZXRJbnRlcmZhY2VcIikoY29udHJhY3RJbnRlcmZhY2UpKTtcbiAgICAgICAgaWYgKHNpZ25lck9yUHJvdmlkZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJwcm92aWRlclwiLCBudWxsKTtcbiAgICAgICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwic2lnbmVyXCIsIG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFNpZ25lci5pc1NpZ25lcihzaWduZXJPclByb3ZpZGVyKSkge1xuICAgICAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJwcm92aWRlclwiLCBzaWduZXJPclByb3ZpZGVyLnByb3ZpZGVyIHx8IG51bGwpO1xuICAgICAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJzaWduZXJcIiwgc2lnbmVyT3JQcm92aWRlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoUHJvdmlkZXIuaXNQcm92aWRlcihzaWduZXJPclByb3ZpZGVyKSkge1xuICAgICAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJwcm92aWRlclwiLCBzaWduZXJPclByb3ZpZGVyKTtcbiAgICAgICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwic2lnbmVyXCIsIG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgc2lnbmVyIG9yIHByb3ZpZGVyXCIsIFwic2lnbmVyT3JQcm92aWRlclwiLCBzaWduZXJPclByb3ZpZGVyKTtcbiAgICAgICAgfVxuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcImNhbGxTdGF0aWNcIiwge30pO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcImVzdGltYXRlR2FzXCIsIHt9KTtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJmdW5jdGlvbnNcIiwge30pO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcInBvcHVsYXRlVHJhbnNhY3Rpb25cIiwge30pO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcImZpbHRlcnNcIiwge30pO1xuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCB1bmlxdWVGaWx0ZXJzID0ge307XG4gICAgICAgICAgICBPYmplY3Qua2V5cyh0aGlzLmludGVyZmFjZS5ldmVudHMpLmZvckVhY2goKGV2ZW50U2lnbmF0dXJlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXZlbnQgPSB0aGlzLmludGVyZmFjZS5ldmVudHNbZXZlbnRTaWduYXR1cmVdO1xuICAgICAgICAgICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMuZmlsdGVycywgZXZlbnRTaWduYXR1cmUsICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzOiB0aGlzLmFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3BpY3M6IHRoaXMuaW50ZXJmYWNlLmVuY29kZUZpbHRlclRvcGljcyhldmVudCwgYXJncylcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoIXVuaXF1ZUZpbHRlcnNbZXZlbnQubmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgdW5pcXVlRmlsdGVyc1tldmVudC5uYW1lXSA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB1bmlxdWVGaWx0ZXJzW2V2ZW50Lm5hbWVdLnB1c2goZXZlbnRTaWduYXR1cmUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyh1bmlxdWVGaWx0ZXJzKS5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmlsdGVycyA9IHVuaXF1ZUZpbHRlcnNbbmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKGZpbHRlcnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMuZmlsdGVycywgbmFtZSwgdGhpcy5maWx0ZXJzW2ZpbHRlcnNbMF1dKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKGBEdXBsaWNhdGUgZGVmaW5pdGlvbiBvZiAke25hbWV9ICgke2ZpbHRlcnMuam9pbihcIiwgXCIpfSlgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcIl9ydW5uaW5nRXZlbnRzXCIsIHt9KTtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJfd3JhcHBlZEVtaXRzXCIsIHt9KTtcbiAgICAgICAgaWYgKGFkZHJlc3NPck5hbWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgY29udHJhY3QgYWRkcmVzcyBvciBFTlMgbmFtZVwiLCBcImFkZHJlc3NPck5hbWVcIiwgYWRkcmVzc09yTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJhZGRyZXNzXCIsIGFkZHJlc3NPck5hbWUpO1xuICAgICAgICBpZiAodGhpcy5wcm92aWRlcikge1xuICAgICAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJyZXNvbHZlZEFkZHJlc3NcIiwgcmVzb2x2ZU5hbWUodGhpcy5wcm92aWRlciwgYWRkcmVzc09yTmFtZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcInJlc29sdmVkQWRkcmVzc1wiLCBQcm9taXNlLnJlc29sdmUoZ2V0QWRkcmVzcyhhZGRyZXNzT3JOYW1lKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgLy8gV2l0aG91dCBhIHByb3ZpZGVyLCB3ZSBjYW5ub3QgdXNlIEVOUyBuYW1lc1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwicHJvdmlkZXIgaXMgcmVxdWlyZWQgdG8gdXNlIEVOUyBuYW1lIGFzIGNvbnRyYWN0IGFkZHJlc3NcIiwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcIm5ldyBDb250cmFjdFwiXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3dhbGxvdyBiYWQgRU5TIG5hbWVzIHRvIHByZXZlbnQgVW5oYW5kbGVkIEV4Y2VwdGlvbnNcbiAgICAgICAgdGhpcy5yZXNvbHZlZEFkZHJlc3MuY2F0Y2goKGUpID0+IHsgfSk7XG4gICAgICAgIGNvbnN0IHVuaXF1ZU5hbWVzID0ge307XG4gICAgICAgIGNvbnN0IHVuaXF1ZVNpZ25hdHVyZXMgPSB7fTtcbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5pbnRlcmZhY2UuZnVuY3Rpb25zKS5mb3JFYWNoKChzaWduYXR1cmUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZyYWdtZW50ID0gdGhpcy5pbnRlcmZhY2UuZnVuY3Rpb25zW3NpZ25hdHVyZV07XG4gICAgICAgICAgICAvLyBDaGVjayB0aGF0IHRoZSBzaWduYXR1cmUgaXMgdW5pcXVlOyBpZiBub3QgdGhlIEFCSSBnZW5lcmF0aW9uIGhhc1xuICAgICAgICAgICAgLy8gbm90IGJlZW4gY2xlYW5lZCBvciBtYXkgYmUgaW5jb3JyZWN0bHkgZ2VuZXJhdGVkXG4gICAgICAgICAgICBpZiAodW5pcXVlU2lnbmF0dXJlc1tzaWduYXR1cmVdKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oYER1cGxpY2F0ZSBBQkkgZW50cnkgZm9yICR7SlNPTi5zdHJpbmdpZnkoc2lnbmF0dXJlKX1gKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1bmlxdWVTaWduYXR1cmVzW3NpZ25hdHVyZV0gPSB0cnVlO1xuICAgICAgICAgICAgLy8gVHJhY2sgdW5pcXVlIG5hbWVzOyB3ZSBvbmx5IGV4cG9zZSBiYXJlIG5hbWVkIGZ1bmN0aW9ucyBpZiB0aGV5XG4gICAgICAgICAgICAvLyBhcmUgYW1iaWd1b3VzXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmFtZSA9IGZyYWdtZW50Lm5hbWU7XG4gICAgICAgICAgICAgICAgaWYgKCF1bmlxdWVOYW1lc1tgJSR7bmFtZX1gXSkge1xuICAgICAgICAgICAgICAgICAgICB1bmlxdWVOYW1lc1tgJSR7bmFtZX1gXSA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB1bmlxdWVOYW1lc1tgJSR7bmFtZX1gXS5wdXNoKHNpZ25hdHVyZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpc1tzaWduYXR1cmVdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBzaWduYXR1cmUsIGJ1aWxkRGVmYXVsdCh0aGlzLCBmcmFnbWVudCwgdHJ1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV2UgZG8gbm90IGNvbGxhcHNlIHNpbXBsZSBjYWxscyBvbiB0aGlzIGJ1Y2tldCwgd2hpY2ggYWxsb3dzXG4gICAgICAgICAgICAvLyBmcmFtZXdvcmtzIHRvIHNhZmVseSB1c2UgdGhpcyB3aXRob3V0IGludHJvc3BlY3Rpb24gYXMgd2VsbCBhc1xuICAgICAgICAgICAgLy8gYWxsb3dzIGRlY29kaW5nIGVycm9yIHJlY292ZXJ5LlxuICAgICAgICAgICAgaWYgKHRoaXMuZnVuY3Rpb25zW3NpZ25hdHVyZV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMuZnVuY3Rpb25zLCBzaWduYXR1cmUsIGJ1aWxkRGVmYXVsdCh0aGlzLCBmcmFnbWVudCwgZmFsc2UpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNhbGxTdGF0aWNbc2lnbmF0dXJlXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcy5jYWxsU3RhdGljLCBzaWduYXR1cmUsIGJ1aWxkQ2FsbCh0aGlzLCBmcmFnbWVudCwgdHJ1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMucG9wdWxhdGVUcmFuc2FjdGlvbltzaWduYXR1cmVdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLnBvcHVsYXRlVHJhbnNhY3Rpb24sIHNpZ25hdHVyZSwgYnVpbGRQb3B1bGF0ZSh0aGlzLCBmcmFnbWVudCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuZXN0aW1hdGVHYXNbc2lnbmF0dXJlXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcy5lc3RpbWF0ZUdhcywgc2lnbmF0dXJlLCBidWlsZEVzdGltYXRlKHRoaXMsIGZyYWdtZW50KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3Qua2V5cyh1bmlxdWVOYW1lcykuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgICAgICAgICAgLy8gQW1iaWd1b3VzIG5hbWVzIHRvIG5vdCBnZXQgYXR0YWNoZWQgYXMgYmFyZSBuYW1lc1xuICAgICAgICAgICAgY29uc3Qgc2lnbmF0dXJlcyA9IHVuaXF1ZU5hbWVzW25hbWVdO1xuICAgICAgICAgICAgaWYgKHNpZ25hdHVyZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFN0cmlwIG9mZiB0aGUgbGVhZGluZyBcIiVcIiB1c2VkIGZvciBwcm90b3R5cGUgcHJvdGVjdGlvblxuICAgICAgICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgY29uc3Qgc2lnbmF0dXJlID0gc2lnbmF0dXJlc1swXTtcbiAgICAgICAgICAgIC8vIElmIG92ZXJ3cml0aW5nIGEgbWVtYmVyIHByb3BlcnR5IHRoYXQgaXMgbnVsbCwgc3dhbGxvdyB0aGUgZXJyb3JcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXNbbmFtZV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBuYW1lLCB0aGlzW3NpZ25hdHVyZV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICAgICAgICAgIGlmICh0aGlzLmZ1bmN0aW9uc1tuYW1lXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcy5mdW5jdGlvbnMsIG5hbWUsIHRoaXMuZnVuY3Rpb25zW3NpZ25hdHVyZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY2FsbFN0YXRpY1tuYW1lXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcy5jYWxsU3RhdGljLCBuYW1lLCB0aGlzLmNhbGxTdGF0aWNbc2lnbmF0dXJlXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5wb3B1bGF0ZVRyYW5zYWN0aW9uW25hbWVdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLnBvcHVsYXRlVHJhbnNhY3Rpb24sIG5hbWUsIHRoaXMucG9wdWxhdGVUcmFuc2FjdGlvbltzaWduYXR1cmVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmVzdGltYXRlR2FzW25hbWVdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLmVzdGltYXRlR2FzLCBuYW1lLCB0aGlzLmVzdGltYXRlR2FzW3NpZ25hdHVyZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdGljIGdldENvbnRyYWN0QWRkcmVzcyh0cmFuc2FjdGlvbikge1xuICAgICAgICByZXR1cm4gZ2V0Q29udHJhY3RBZGRyZXNzKHRyYW5zYWN0aW9uKTtcbiAgICB9XG4gICAgc3RhdGljIGdldEludGVyZmFjZShjb250cmFjdEludGVyZmFjZSkge1xuICAgICAgICBpZiAoSW50ZXJmYWNlLmlzSW50ZXJmYWNlKGNvbnRyYWN0SW50ZXJmYWNlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRyYWN0SW50ZXJmYWNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgSW50ZXJmYWNlKGNvbnRyYWN0SW50ZXJmYWNlKTtcbiAgICB9XG4gICAgLy8gQFRPRE86IEFsbG93IHRpbWVvdXQ/XG4gICAgZGVwbG95ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZXBsb3llZCgpO1xuICAgIH1cbiAgICBfZGVwbG95ZWQoYmxvY2tUYWcpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9kZXBsb3llZFByb21pc2UpIHtcbiAgICAgICAgICAgIC8vIElmIHdlIHdlcmUganVzdCBkZXBsb3llZCwgd2Uga25vdyB0aGUgdHJhbnNhY3Rpb24gd2Ugc2hvdWxkIG9jY3VyIGluXG4gICAgICAgICAgICBpZiAodGhpcy5kZXBsb3lUcmFuc2FjdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RlcGxveWVkUHJvbWlzZSA9IHRoaXMuZGVwbG95VHJhbnNhY3Rpb24ud2FpdCgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEBUT0RPOiBPbmNlIHdlIGFsbG93IGEgdGltZW91dCB0byBiZSBwYXNzZWQgaW4sIHdlIHdpbGwgd2FpdFxuICAgICAgICAgICAgICAgIC8vIHVwIHRvIHRoYXQgbWFueSBibG9ja3MgZm9yIGdldENvZGVcbiAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UsIHBvbGwgZm9yIG91ciBjb2RlIHRvIGJlIGRlcGxveWVkXG4gICAgICAgICAgICAgICAgdGhpcy5fZGVwbG95ZWRQcm9taXNlID0gdGhpcy5wcm92aWRlci5nZXRDb2RlKHRoaXMuYWRkcmVzcywgYmxvY2tUYWcpLnRoZW4oKGNvZGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUgPT09IFwiMHhcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJjb250cmFjdCBub3QgZGVwbG95ZWRcIiwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250cmFjdEFkZHJlc3M6IHRoaXMuYWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwiZ2V0RGVwbG95ZWRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlcGxveWVkUHJvbWlzZTtcbiAgICB9XG4gICAgLy8gQFRPRE86XG4gICAgLy8gZXN0aW1hdGVGYWxsYmFjayhvdmVycmlkZXM/OiBUcmFuc2FjdGlvblJlcXVlc3QpOiBQcm9taXNlPEJpZ051bWJlcj5cbiAgICAvLyBAVE9ETzpcbiAgICAvLyBlc3RpbWF0ZURlcGxveShieXRlY29kZTogc3RyaW5nLCAuLi5hcmdzKTogUHJvbWlzZTxCaWdOdW1iZXI+XG4gICAgZmFsbGJhY2sob3ZlcnJpZGVzKSB7XG4gICAgICAgIGlmICghdGhpcy5zaWduZXIpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwic2VuZGluZyBhIHRyYW5zYWN0aW9ucyByZXF1aXJlIGEgc2lnbmVyXCIsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7IG9wZXJhdGlvbjogXCJzZW5kVHJhbnNhY3Rpb24oZmFsbGJhY2spXCIgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHggPSBzaGFsbG93Q29weShvdmVycmlkZXMgfHwge30pO1xuICAgICAgICBbXCJmcm9tXCIsIFwidG9cIl0uZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBpZiAodHhba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJjYW5ub3Qgb3ZlcnJpZGUgXCIgKyBrZXksIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7IG9wZXJhdGlvbjoga2V5IH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdHgudG8gPSB0aGlzLnJlc29sdmVkQWRkcmVzcztcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVwbG95ZWQoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNpZ25lci5zZW5kVHJhbnNhY3Rpb24odHgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gUmVjb25uZWN0IHRvIGEgZGlmZmVyZW50IHNpZ25lciBvciBwcm92aWRlclxuICAgIGNvbm5lY3Qoc2lnbmVyT3JQcm92aWRlcikge1xuICAgICAgICBpZiAodHlwZW9mIChzaWduZXJPclByb3ZpZGVyKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgc2lnbmVyT3JQcm92aWRlciA9IG5ldyBWb2lkU2lnbmVyKHNpZ25lck9yUHJvdmlkZXIsIHRoaXMucHJvdmlkZXIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbnRyYWN0ID0gbmV3ICh0aGlzLmNvbnN0cnVjdG9yKSh0aGlzLmFkZHJlc3MsIHRoaXMuaW50ZXJmYWNlLCBzaWduZXJPclByb3ZpZGVyKTtcbiAgICAgICAgaWYgKHRoaXMuZGVwbG95VHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgIGRlZmluZVJlYWRPbmx5KGNvbnRyYWN0LCBcImRlcGxveVRyYW5zYWN0aW9uXCIsIHRoaXMuZGVwbG95VHJhbnNhY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb250cmFjdDtcbiAgICB9XG4gICAgLy8gUmUtYXR0YWNoIHRvIGEgZGlmZmVyZW50IG9uLWNoYWluIGluc3RhbmNlIG9mIHRoaXMgY29udHJhY3RcbiAgICBhdHRhY2goYWRkcmVzc09yTmFtZSkge1xuICAgICAgICByZXR1cm4gbmV3ICh0aGlzLmNvbnN0cnVjdG9yKShhZGRyZXNzT3JOYW1lLCB0aGlzLmludGVyZmFjZSwgdGhpcy5zaWduZXIgfHwgdGhpcy5wcm92aWRlcik7XG4gICAgfVxuICAgIHN0YXRpYyBpc0luZGV4ZWQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIEluZGV4ZWQuaXNJbmRleGVkKHZhbHVlKTtcbiAgICB9XG4gICAgX25vcm1hbGl6ZVJ1bm5pbmdFdmVudChydW5uaW5nRXZlbnQpIHtcbiAgICAgICAgLy8gQWxyZWFkeSBoYXZlIGFuIGluc3RhbmNlIG9mIHRoaXMgZXZlbnQgcnVubmluZzsgd2UgY2FuIHJlLXVzZSBpdFxuICAgICAgICBpZiAodGhpcy5fcnVubmluZ0V2ZW50c1tydW5uaW5nRXZlbnQudGFnXSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3J1bm5pbmdFdmVudHNbcnVubmluZ0V2ZW50LnRhZ107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJ1bm5pbmdFdmVudDtcbiAgICB9XG4gICAgX2dldFJ1bm5pbmdFdmVudChldmVudE5hbWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAoZXZlbnROYW1lKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgLy8gTGlzdGVuIGZvciBcImVycm9yXCIgZXZlbnRzIChpZiB5b3VyIGNvbnRyYWN0IGhhcyBhbiBlcnJvciBldmVudCwgaW5jbHVkZVxuICAgICAgICAgICAgLy8gdGhlIGZ1bGwgc2lnbmF0dXJlIHRvIGJ5cGFzcyB0aGlzIHNwZWNpYWwgZXZlbnQga2V5d29yZClcbiAgICAgICAgICAgIGlmIChldmVudE5hbWUgPT09IFwiZXJyb3JcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9ub3JtYWxpemVSdW5uaW5nRXZlbnQobmV3IEVycm9yUnVubmluZ0V2ZW50KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTGlzdGVuIGZvciBhbnkgZXZlbnQgdGhhdCBpcyByZWdpc3RlcmVkXG4gICAgICAgICAgICBpZiAoZXZlbnROYW1lID09PSBcImV2ZW50XCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbm9ybWFsaXplUnVubmluZ0V2ZW50KG5ldyBSdW5uaW5nRXZlbnQoXCJldmVudFwiLCBudWxsKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBMaXN0ZW4gZm9yIGFueSBldmVudFxuICAgICAgICAgICAgaWYgKGV2ZW50TmFtZSA9PT0gXCIqXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbm9ybWFsaXplUnVubmluZ0V2ZW50KG5ldyBXaWxkY2FyZFJ1bm5pbmdFdmVudCh0aGlzLmFkZHJlc3MsIHRoaXMuaW50ZXJmYWNlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBHZXQgdGhlIGV2ZW50IEZyYWdtZW50ICh0aHJvd3MgaWYgYW1iaWd1b3VzL3Vua25vd24gZXZlbnQpXG4gICAgICAgICAgICBjb25zdCBmcmFnbWVudCA9IHRoaXMuaW50ZXJmYWNlLmdldEV2ZW50KGV2ZW50TmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbm9ybWFsaXplUnVubmluZ0V2ZW50KG5ldyBGcmFnbWVudFJ1bm5pbmdFdmVudCh0aGlzLmFkZHJlc3MsIHRoaXMuaW50ZXJmYWNlLCBmcmFnbWVudCkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdlIGhhdmUgdG9waWNzIHRvIGZpbHRlciBieS4uLlxuICAgICAgICBpZiAoZXZlbnROYW1lLnRvcGljcyAmJiBldmVudE5hbWUudG9waWNzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIC8vIElzIGl0IGEga25vd24gdG9waWNoYXNoPyAodGhyb3dzIGlmIG5vIG1hdGNoaW5nIHRvcGljaGFzaClcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9waWMgPSBldmVudE5hbWUudG9waWNzWzBdO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKHRvcGljKSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHRvcGljXCIpOyAvLyBAVE9ETzogTWF5IGhhcHBlbiBmb3IgYW5vbnltb3VzIGV2ZW50c1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBmcmFnbWVudCA9IHRoaXMuaW50ZXJmYWNlLmdldEV2ZW50KHRvcGljKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbm9ybWFsaXplUnVubmluZ0V2ZW50KG5ldyBGcmFnbWVudFJ1bm5pbmdFdmVudCh0aGlzLmFkZHJlc3MsIHRoaXMuaW50ZXJmYWNlLCBmcmFnbWVudCwgZXZlbnROYW1lLnRvcGljcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgICAgIC8vIEZpbHRlciBieSB0aGUgdW5rbm93biB0b3BpY2hhc2hcbiAgICAgICAgICAgIGNvbnN0IGZpbHRlciA9IHtcbiAgICAgICAgICAgICAgICBhZGRyZXNzOiB0aGlzLmFkZHJlc3MsXG4gICAgICAgICAgICAgICAgdG9waWNzOiBldmVudE5hbWUudG9waWNzXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25vcm1hbGl6ZVJ1bm5pbmdFdmVudChuZXcgUnVubmluZ0V2ZW50KGdldEV2ZW50VGFnKGZpbHRlciksIGZpbHRlcikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9ub3JtYWxpemVSdW5uaW5nRXZlbnQobmV3IFdpbGRjYXJkUnVubmluZ0V2ZW50KHRoaXMuYWRkcmVzcywgdGhpcy5pbnRlcmZhY2UpKTtcbiAgICB9XG4gICAgX2NoZWNrUnVubmluZ0V2ZW50cyhydW5uaW5nRXZlbnQpIHtcbiAgICAgICAgaWYgKHJ1bm5pbmdFdmVudC5saXN0ZW5lckNvdW50KCkgPT09IDApIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9ydW5uaW5nRXZlbnRzW3J1bm5pbmdFdmVudC50YWddO1xuICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSBhIHBvbGxlciBmb3IgdGhpcywgcmVtb3ZlIGl0XG4gICAgICAgICAgICBjb25zdCBlbWl0ID0gdGhpcy5fd3JhcHBlZEVtaXRzW3J1bm5pbmdFdmVudC50YWddO1xuICAgICAgICAgICAgaWYgKGVtaXQgJiYgcnVubmluZ0V2ZW50LmZpbHRlcikge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvdmlkZXIub2ZmKHJ1bm5pbmdFdmVudC5maWx0ZXIsIGVtaXQpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl93cmFwcGVkRW1pdHNbcnVubmluZ0V2ZW50LnRhZ107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gU3ViY2xhc3NlcyBjYW4gb3ZlcnJpZGUgdGhpcyB0byBncmFjZWZ1bGx5IHJlY292ZXJcbiAgICAvLyBmcm9tIHBhcnNlIGVycm9ycyBpZiB0aGV5IHdpc2hcbiAgICBfd3JhcEV2ZW50KHJ1bm5pbmdFdmVudCwgbG9nLCBsaXN0ZW5lcikge1xuICAgICAgICBjb25zdCBldmVudCA9IGRlZXBDb3B5KGxvZyk7XG4gICAgICAgIGV2ZW50LnJlbW92ZUxpc3RlbmVyID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFsaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJ1bm5pbmdFdmVudC5yZW1vdmVMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgICAgICAgICB0aGlzLl9jaGVja1J1bm5pbmdFdmVudHMocnVubmluZ0V2ZW50KTtcbiAgICAgICAgfTtcbiAgICAgICAgZXZlbnQuZ2V0QmxvY2sgPSAoKSA9PiB7IHJldHVybiB0aGlzLnByb3ZpZGVyLmdldEJsb2NrKGxvZy5ibG9ja0hhc2gpOyB9O1xuICAgICAgICBldmVudC5nZXRUcmFuc2FjdGlvbiA9ICgpID0+IHsgcmV0dXJuIHRoaXMucHJvdmlkZXIuZ2V0VHJhbnNhY3Rpb24obG9nLnRyYW5zYWN0aW9uSGFzaCk7IH07XG4gICAgICAgIGV2ZW50LmdldFRyYW5zYWN0aW9uUmVjZWlwdCA9ICgpID0+IHsgcmV0dXJuIHRoaXMucHJvdmlkZXIuZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KGxvZy50cmFuc2FjdGlvbkhhc2gpOyB9O1xuICAgICAgICAvLyBUaGlzIG1heSB0aHJvdyBpZiB0aGUgdG9waWNzIGFuZCBkYXRhIG1pc21hdGNoIHRoZSBzaWduYXR1cmVcbiAgICAgICAgcnVubmluZ0V2ZW50LnByZXBhcmVFdmVudChldmVudCk7XG4gICAgICAgIHJldHVybiBldmVudDtcbiAgICB9XG4gICAgX2FkZEV2ZW50TGlzdGVuZXIocnVubmluZ0V2ZW50LCBsaXN0ZW5lciwgb25jZSkge1xuICAgICAgICBpZiAoIXRoaXMucHJvdmlkZXIpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiZXZlbnRzIHJlcXVpcmUgYSBwcm92aWRlciBvciBhIHNpZ25lciB3aXRoIGEgcHJvdmlkZXJcIiwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHsgb3BlcmF0aW9uOiBcIm9uY2VcIiB9KTtcbiAgICAgICAgfVxuICAgICAgICBydW5uaW5nRXZlbnQuYWRkTGlzdGVuZXIobGlzdGVuZXIsIG9uY2UpO1xuICAgICAgICAvLyBUcmFjayB0aGlzIHJ1bm5pbmcgZXZlbnQgYW5kIGl0cyBsaXN0ZW5lcnMgKG1heSBhbHJlYWR5IGJlIHRoZXJlOyBidXQgbm8gaGFyZCBpbiB1cGRhdGluZylcbiAgICAgICAgdGhpcy5fcnVubmluZ0V2ZW50c1tydW5uaW5nRXZlbnQudGFnXSA9IHJ1bm5pbmdFdmVudDtcbiAgICAgICAgLy8gSWYgd2UgYXJlIG5vdCBwb2xsaW5nIHRoZSBwcm92aWRlciwgc3RhcnQgcG9sbGluZ1xuICAgICAgICBpZiAoIXRoaXMuX3dyYXBwZWRFbWl0c1tydW5uaW5nRXZlbnQudGFnXSkge1xuICAgICAgICAgICAgY29uc3Qgd3JhcHBlZEVtaXQgPSAobG9nKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGV2ZW50ID0gdGhpcy5fd3JhcEV2ZW50KHJ1bm5pbmdFdmVudCwgbG9nLCBsaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgLy8gVHJ5IHRvIGVtaXQgdGhlIHJlc3VsdCBmb3IgdGhlIHBhcmFtZXRlcml6ZWQgZXZlbnQuLi5cbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQuZGVjb2RlRXJyb3IgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYXJncyA9IHJ1bm5pbmdFdmVudC5nZXRFbWl0KGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChydW5uaW5nRXZlbnQuZmlsdGVyLCAuLi5hcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LmRlY29kZUVycm9yID0gZXJyb3IuZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQWx3YXlzIGVtaXQgXCJldmVudFwiIGZvciBmcmFnbWVudC1iYXNlIGV2ZW50c1xuICAgICAgICAgICAgICAgIGlmIChydW5uaW5nRXZlbnQuZmlsdGVyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZXZlbnRcIiwgZXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBFbWl0IFwiZXJyb3JcIiBpZiB0aGVyZSB3YXMgYW4gZXJyb3JcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQuZGVjb2RlRXJyb3IgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJlcnJvclwiLCBldmVudC5kZWNvZGVFcnJvciwgZXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLl93cmFwcGVkRW1pdHNbcnVubmluZ0V2ZW50LnRhZ10gPSB3cmFwcGVkRW1pdDtcbiAgICAgICAgICAgIC8vIFNwZWNpYWwgZXZlbnRzLCBsaWtlIFwiZXJyb3JcIiBkbyBub3QgaGF2ZSBhIGZpbHRlclxuICAgICAgICAgICAgaWYgKHJ1bm5pbmdFdmVudC5maWx0ZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvdmlkZXIub24ocnVubmluZ0V2ZW50LmZpbHRlciwgd3JhcHBlZEVtaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXJ5RmlsdGVyKGV2ZW50LCBmcm9tQmxvY2tPckJsb2NraGFzaCwgdG9CbG9jaykge1xuICAgICAgICBjb25zdCBydW5uaW5nRXZlbnQgPSB0aGlzLl9nZXRSdW5uaW5nRXZlbnQoZXZlbnQpO1xuICAgICAgICBjb25zdCBmaWx0ZXIgPSBzaGFsbG93Q29weShydW5uaW5nRXZlbnQuZmlsdGVyKTtcbiAgICAgICAgaWYgKHR5cGVvZiAoZnJvbUJsb2NrT3JCbG9ja2hhc2gpID09PSBcInN0cmluZ1wiICYmIGlzSGV4U3RyaW5nKGZyb21CbG9ja09yQmxvY2toYXNoLCAzMikpIHtcbiAgICAgICAgICAgIGlmICh0b0Jsb2NrICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiY2Fubm90IHNwZWNpZnkgdG9CbG9jayB3aXRoIGJsb2NraGFzaFwiLCBcInRvQmxvY2tcIiwgdG9CbG9jayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaWx0ZXIuYmxvY2tIYXNoID0gZnJvbUJsb2NrT3JCbG9ja2hhc2g7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmaWx0ZXIuZnJvbUJsb2NrID0gKChmcm9tQmxvY2tPckJsb2NraGFzaCAhPSBudWxsKSA/IGZyb21CbG9ja09yQmxvY2toYXNoIDogMCk7XG4gICAgICAgICAgICBmaWx0ZXIudG9CbG9jayA9ICgodG9CbG9jayAhPSBudWxsKSA/IHRvQmxvY2sgOiBcImxhdGVzdFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlci5nZXRMb2dzKGZpbHRlcikudGhlbigobG9ncykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGxvZ3MubWFwKChsb2cpID0+IHRoaXMuX3dyYXBFdmVudChydW5uaW5nRXZlbnQsIGxvZywgbnVsbCkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgb24oZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuX2FkZEV2ZW50TGlzdGVuZXIodGhpcy5fZ2V0UnVubmluZ0V2ZW50KGV2ZW50KSwgbGlzdGVuZXIsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIG9uY2UoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuX2FkZEV2ZW50TGlzdGVuZXIodGhpcy5fZ2V0UnVubmluZ0V2ZW50KGV2ZW50KSwgbGlzdGVuZXIsIHRydWUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZW1pdChldmVudE5hbWUsIC4uLmFyZ3MpIHtcbiAgICAgICAgaWYgKCF0aGlzLnByb3ZpZGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcnVubmluZ0V2ZW50ID0gdGhpcy5fZ2V0UnVubmluZ0V2ZW50KGV2ZW50TmFtZSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IChydW5uaW5nRXZlbnQucnVuKGFyZ3MpID4gMCk7XG4gICAgICAgIC8vIE1heSBoYXZlIGRyYWluZWQgYWxsIHRoZSBcIm9uY2VcIiBldmVudHM7IGNoZWNrIGZvciBsaXZpbmcgZXZlbnRzXG4gICAgICAgIHRoaXMuX2NoZWNrUnVubmluZ0V2ZW50cyhydW5uaW5nRXZlbnQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBsaXN0ZW5lckNvdW50KGV2ZW50TmFtZSkge1xuICAgICAgICBpZiAoIXRoaXMucHJvdmlkZXIpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChldmVudE5hbWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX3J1bm5pbmdFdmVudHMpLnJlZHVjZSgoYWNjdW0sIGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBhY2N1bSArIHRoaXMuX3J1bm5pbmdFdmVudHNba2V5XS5saXN0ZW5lckNvdW50KCk7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0UnVubmluZ0V2ZW50KGV2ZW50TmFtZSkubGlzdGVuZXJDb3VudCgpO1xuICAgIH1cbiAgICBsaXN0ZW5lcnMoZXZlbnROYW1lKSB7XG4gICAgICAgIGlmICghdGhpcy5wcm92aWRlcikge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChldmVudE5hbWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCB0YWcgaW4gdGhpcy5fcnVubmluZ0V2ZW50cykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3J1bm5pbmdFdmVudHNbdGFnXS5saXN0ZW5lcnMoKS5mb3JFYWNoKChsaXN0ZW5lcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChsaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRSdW5uaW5nRXZlbnQoZXZlbnROYW1lKS5saXN0ZW5lcnMoKTtcbiAgICB9XG4gICAgcmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50TmFtZSkge1xuICAgICAgICBpZiAoIXRoaXMucHJvdmlkZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChldmVudE5hbWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCB0YWcgaW4gdGhpcy5fcnVubmluZ0V2ZW50cykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJ1bm5pbmdFdmVudCA9IHRoaXMuX3J1bm5pbmdFdmVudHNbdGFnXTtcbiAgICAgICAgICAgICAgICBydW5uaW5nRXZlbnQucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2hlY2tSdW5uaW5nRXZlbnRzKHJ1bm5pbmdFdmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICAvLyBEZWxldGUgYW55IGxpc3RlbmVyc1xuICAgICAgICBjb25zdCBydW5uaW5nRXZlbnQgPSB0aGlzLl9nZXRSdW5uaW5nRXZlbnQoZXZlbnROYW1lKTtcbiAgICAgICAgcnVubmluZ0V2ZW50LnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgICB0aGlzLl9jaGVja1J1bm5pbmdFdmVudHMocnVubmluZ0V2ZW50KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIG9mZihldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICghdGhpcy5wcm92aWRlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcnVubmluZ0V2ZW50ID0gdGhpcy5fZ2V0UnVubmluZ0V2ZW50KGV2ZW50TmFtZSk7XG4gICAgICAgIHJ1bm5pbmdFdmVudC5yZW1vdmVMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgICAgIHRoaXMuX2NoZWNrUnVubmluZ0V2ZW50cyhydW5uaW5nRXZlbnQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmVtb3ZlTGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gdGhpcy5vZmYoZXZlbnROYW1lLCBsaXN0ZW5lcik7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIENvbnRyYWN0IGV4dGVuZHMgQmFzZUNvbnRyYWN0IHtcbn1cbmV4cG9ydCBjbGFzcyBDb250cmFjdEZhY3Rvcnkge1xuICAgIGNvbnN0cnVjdG9yKGNvbnRyYWN0SW50ZXJmYWNlLCBieXRlY29kZSwgc2lnbmVyKSB7XG4gICAgICAgIGxldCBieXRlY29kZUhleCA9IG51bGw7XG4gICAgICAgIGlmICh0eXBlb2YgKGJ5dGVjb2RlKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgYnl0ZWNvZGVIZXggPSBieXRlY29kZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0J5dGVzKGJ5dGVjb2RlKSkge1xuICAgICAgICAgICAgYnl0ZWNvZGVIZXggPSBoZXhsaWZ5KGJ5dGVjb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChieXRlY29kZSAmJiB0eXBlb2YgKGJ5dGVjb2RlLm9iamVjdCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIC8vIEFsbG93IHRoZSBieXRlY29kZSBvYmplY3QgZnJvbSB0aGUgU29saWRpdHkgY29tcGlsZXJcbiAgICAgICAgICAgIGJ5dGVjb2RlSGV4ID0gYnl0ZWNvZGUub2JqZWN0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gQ3Jhc2ggaW4gdGhlIG5leHQgdmVyaWZpY2F0aW9uIHN0ZXBcbiAgICAgICAgICAgIGJ5dGVjb2RlSGV4ID0gXCIhXCI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTWFrZSBzdXJlIGl0IGlzIDB4IHByZWZpeGVkXG4gICAgICAgIGlmIChieXRlY29kZUhleC5zdWJzdHJpbmcoMCwgMikgIT09IFwiMHhcIikge1xuICAgICAgICAgICAgYnl0ZWNvZGVIZXggPSBcIjB4XCIgKyBieXRlY29kZUhleDtcbiAgICAgICAgfVxuICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIGZpbmFsIHJlc3VsdCBpcyB2YWxpZCBieXRlY29kZVxuICAgICAgICBpZiAoIWlzSGV4U3RyaW5nKGJ5dGVjb2RlSGV4KSB8fCAoYnl0ZWNvZGVIZXgubGVuZ3RoICUgMikpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGJ5dGVjb2RlXCIsIFwiYnl0ZWNvZGVcIiwgYnl0ZWNvZGUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlIGhhdmUgYSBzaWduZXIsIG1ha2Ugc3VyZSBpdCBpcyB2YWxpZFxuICAgICAgICBpZiAoc2lnbmVyICYmICFTaWduZXIuaXNTaWduZXIoc2lnbmVyKSkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgc2lnbmVyXCIsIFwic2lnbmVyXCIsIHNpZ25lcik7XG4gICAgICAgIH1cbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJieXRlY29kZVwiLCBieXRlY29kZUhleCk7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiaW50ZXJmYWNlXCIsIGdldFN0YXRpYyhuZXcudGFyZ2V0LCBcImdldEludGVyZmFjZVwiKShjb250cmFjdEludGVyZmFjZSkpO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcInNpZ25lclwiLCBzaWduZXIgfHwgbnVsbCk7XG4gICAgfVxuICAgIC8vIEBUT0RPOiBGdXR1cmU7IHJlbmFtZSB0byBwb3B1bGF0ZVRyYW5zYWN0aW9uP1xuICAgIGdldERlcGxveVRyYW5zYWN0aW9uKC4uLmFyZ3MpIHtcbiAgICAgICAgbGV0IHR4ID0ge307XG4gICAgICAgIC8vIElmIHdlIGhhdmUgMSBhZGRpdGlvbmFsIGFyZ3VtZW50LCB3ZSBhbGxvdyB0cmFuc2FjdGlvbiBvdmVycmlkZXNcbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSB0aGlzLmludGVyZmFjZS5kZXBsb3kuaW5wdXRzLmxlbmd0aCArIDEgJiYgdHlwZW9mIChhcmdzW2FyZ3MubGVuZ3RoIC0gMV0pID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICB0eCA9IHNoYWxsb3dDb3B5KGFyZ3MucG9wKCkpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdHgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWFsbG93ZWRUcmFuc2FjdGlvbktleXNba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIHRyYW5zYWN0aW9uIG92ZXJyaWRlIFwiICsga2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gRG8gbm90IGFsbG93IHRoZXNlIHRvIGJlIG92ZXJyaWRkZW4gaW4gYSBkZXBsb3ltZW50IHRyYW5zYWN0aW9uXG4gICAgICAgIFtcImRhdGFcIiwgXCJmcm9tXCIsIFwidG9cIl0uZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICBpZiAodHhba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJjYW5ub3Qgb3ZlcnJpZGUgXCIgKyBrZXksIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7IG9wZXJhdGlvbjoga2V5IH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHR4LnZhbHVlKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IEJpZ051bWJlci5mcm9tKHR4LnZhbHVlKTtcbiAgICAgICAgICAgIGlmICghdmFsdWUuaXNaZXJvKCkgJiYgIXRoaXMuaW50ZXJmYWNlLmRlcGxveS5wYXlhYmxlKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJub24tcGF5YWJsZSBjb25zdHJ1Y3RvciBjYW5ub3Qgb3ZlcnJpZGUgdmFsdWVcIiwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcIm92ZXJyaWRlcy52YWx1ZVwiLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdHgudmFsdWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIGNhbGwgbWF0Y2hlcyB0aGUgY29uc3RydWN0b3Igc2lnbmF0dXJlXG4gICAgICAgIGxvZ2dlci5jaGVja0FyZ3VtZW50Q291bnQoYXJncy5sZW5ndGgsIHRoaXMuaW50ZXJmYWNlLmRlcGxveS5pbnB1dHMubGVuZ3RoLCBcIiBpbiBDb250cmFjdCBjb25zdHJ1Y3RvclwiKTtcbiAgICAgICAgLy8gU2V0IHRoZSBkYXRhIHRvIHRoZSBieXRlY29kZSArIHRoZSBlbmNvZGVkIGNvbnN0cnVjdG9yIGFyZ3VtZW50c1xuICAgICAgICB0eC5kYXRhID0gaGV4bGlmeShjb25jYXQoW1xuICAgICAgICAgICAgdGhpcy5ieXRlY29kZSxcbiAgICAgICAgICAgIHRoaXMuaW50ZXJmYWNlLmVuY29kZURlcGxveShhcmdzKVxuICAgICAgICBdKSk7XG4gICAgICAgIHJldHVybiB0eDtcbiAgICB9XG4gICAgZGVwbG95KC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGxldCBvdmVycmlkZXMgPSB7fTtcbiAgICAgICAgICAgIC8vIElmIDEgZXh0cmEgcGFyYW1ldGVyIHdhcyBwYXNzZWQgaW4sIGl0IGNvbnRhaW5zIG92ZXJyaWRlc1xuICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSB0aGlzLmludGVyZmFjZS5kZXBsb3kuaW5wdXRzLmxlbmd0aCArIDEpIHtcbiAgICAgICAgICAgICAgICBvdmVycmlkZXMgPSBhcmdzLnBvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBjYWxsIG1hdGNoZXMgdGhlIGNvbnN0cnVjdG9yIHNpZ25hdHVyZVxuICAgICAgICAgICAgbG9nZ2VyLmNoZWNrQXJndW1lbnRDb3VudChhcmdzLmxlbmd0aCwgdGhpcy5pbnRlcmZhY2UuZGVwbG95LmlucHV0cy5sZW5ndGgsIFwiIGluIENvbnRyYWN0IGNvbnN0cnVjdG9yXCIpO1xuICAgICAgICAgICAgLy8gUmVzb2x2ZSBFTlMgbmFtZXMgYW5kIHByb21pc2VzIGluIHRoZSBhcmd1bWVudHNcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IHlpZWxkIHJlc29sdmVBZGRyZXNzZXModGhpcy5zaWduZXIsIGFyZ3MsIHRoaXMuaW50ZXJmYWNlLmRlcGxveS5pbnB1dHMpO1xuICAgICAgICAgICAgcGFyYW1zLnB1c2gob3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIC8vIEdldCB0aGUgZGVwbG95bWVudCB0cmFuc2FjdGlvbiAod2l0aCBvcHRpb25hbCBvdmVycmlkZXMpXG4gICAgICAgICAgICBjb25zdCB1bnNpZ25lZFR4ID0gdGhpcy5nZXREZXBsb3lUcmFuc2FjdGlvbiguLi5wYXJhbXMpO1xuICAgICAgICAgICAgLy8gU2VuZCB0aGUgZGVwbG95bWVudCB0cmFuc2FjdGlvblxuICAgICAgICAgICAgY29uc3QgdHggPSB5aWVsZCB0aGlzLnNpZ25lci5zZW5kVHJhbnNhY3Rpb24odW5zaWduZWRUeCk7XG4gICAgICAgICAgICBjb25zdCBhZGRyZXNzID0gZ2V0U3RhdGljKHRoaXMuY29uc3RydWN0b3IsIFwiZ2V0Q29udHJhY3RBZGRyZXNzXCIpKHR4KTtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRyYWN0ID0gZ2V0U3RhdGljKHRoaXMuY29uc3RydWN0b3IsIFwiZ2V0Q29udHJhY3RcIikoYWRkcmVzcywgdGhpcy5pbnRlcmZhY2UsIHRoaXMuc2lnbmVyKTtcbiAgICAgICAgICAgIC8vIEFkZCB0aGUgbW9kaWZpZWQgd2FpdCB0aGF0IHdyYXBzIGV2ZW50c1xuICAgICAgICAgICAgYWRkQ29udHJhY3RXYWl0KGNvbnRyYWN0LCB0eCk7XG4gICAgICAgICAgICBkZWZpbmVSZWFkT25seShjb250cmFjdCwgXCJkZXBsb3lUcmFuc2FjdGlvblwiLCB0eCk7XG4gICAgICAgICAgICByZXR1cm4gY29udHJhY3Q7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhdHRhY2goYWRkcmVzcykge1xuICAgICAgICByZXR1cm4gKHRoaXMuY29uc3RydWN0b3IpLmdldENvbnRyYWN0KGFkZHJlc3MsIHRoaXMuaW50ZXJmYWNlLCB0aGlzLnNpZ25lcik7XG4gICAgfVxuICAgIGNvbm5lY3Qoc2lnbmVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgKHRoaXMuY29uc3RydWN0b3IpKHRoaXMuaW50ZXJmYWNlLCB0aGlzLmJ5dGVjb2RlLCBzaWduZXIpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbVNvbGlkaXR5KGNvbXBpbGVyT3V0cHV0LCBzaWduZXIpIHtcbiAgICAgICAgaWYgKGNvbXBpbGVyT3V0cHV0ID09IG51bGwpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwibWlzc2luZyBjb21waWxlciBvdXRwdXRcIiwgTG9nZ2VyLmVycm9ycy5NSVNTSU5HX0FSR1VNRU5ULCB7IGFyZ3VtZW50OiBcImNvbXBpbGVyT3V0cHV0XCIgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAoY29tcGlsZXJPdXRwdXQpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBjb21waWxlck91dHB1dCA9IEpTT04ucGFyc2UoY29tcGlsZXJPdXRwdXQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFiaSA9IGNvbXBpbGVyT3V0cHV0LmFiaTtcbiAgICAgICAgbGV0IGJ5dGVjb2RlID0gbnVsbDtcbiAgICAgICAgaWYgKGNvbXBpbGVyT3V0cHV0LmJ5dGVjb2RlKSB7XG4gICAgICAgICAgICBieXRlY29kZSA9IGNvbXBpbGVyT3V0cHV0LmJ5dGVjb2RlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbXBpbGVyT3V0cHV0LmV2bSAmJiBjb21waWxlck91dHB1dC5ldm0uYnl0ZWNvZGUpIHtcbiAgICAgICAgICAgIGJ5dGVjb2RlID0gY29tcGlsZXJPdXRwdXQuZXZtLmJ5dGVjb2RlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgdGhpcyhhYmksIGJ5dGVjb2RlLCBzaWduZXIpO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0SW50ZXJmYWNlKGNvbnRyYWN0SW50ZXJmYWNlKSB7XG4gICAgICAgIHJldHVybiBDb250cmFjdC5nZXRJbnRlcmZhY2UoY29udHJhY3RJbnRlcmZhY2UpO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0Q29udHJhY3RBZGRyZXNzKHR4KSB7XG4gICAgICAgIHJldHVybiBnZXRDb250cmFjdEFkZHJlc3ModHgpO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0Q29udHJhY3QoYWRkcmVzcywgY29udHJhY3RJbnRlcmZhY2UsIHNpZ25lcikge1xuICAgICAgICByZXR1cm4gbmV3IENvbnRyYWN0KGFkZHJlc3MsIGNvbnRyYWN0SW50ZXJmYWNlLCBzaWduZXIpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ethersproject/contracts/lib.esm/index.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@ethersproject/hash/lib.esm/_version.js":
/*!***************************************************************!*\
  !*** ../node_modules/@ethersproject/hash/lib.esm/_version.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\nconst version = \"hash/5.7.0\";\n//# sourceMappingURL=_version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2hhc2gvbGliLmVzbS9fdmVyc2lvbi5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU87QUFDUCIsInNvdXJjZXMiOlsid2VicGFjazovL2xlZGdpdHkteWllbGQtZnJvbnRlbmQvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2hhc2gvbGliLmVzbS9fdmVyc2lvbi5qcz83ZjZhIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCB2ZXJzaW9uID0gXCJoYXNoLzUuNy4wXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdmVyc2lvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ethersproject/hash/lib.esm/_version.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@ethersproject/hash/lib.esm/ens-normalize/decoder.js":
/*!****************************************************************************!*\
  !*** ../node_modules/@ethersproject/hash/lib.esm/ens-normalize/decoder.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decode_arithmetic: () => (/* binding */ decode_arithmetic),\n/* harmony export */   read_compressed_payload: () => (/* binding */ read_compressed_payload),\n/* harmony export */   read_emoji_trie: () => (/* binding */ read_emoji_trie),\n/* harmony export */   read_mapped_map: () => (/* binding */ read_mapped_map),\n/* harmony export */   read_member_array: () => (/* binding */ read_member_array),\n/* harmony export */   read_payload: () => (/* binding */ read_payload),\n/* harmony export */   read_zero_terminated_array: () => (/* binding */ read_zero_terminated_array),\n/* harmony export */   signed: () => (/* binding */ signed)\n/* harmony export */ });\n/**\n * MIT License\n *\n * Copyright (c) 2021 Andrew Raffensperger\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n *\n * This is a near carbon-copy of the original source (link below) with the\n * TypeScript typings added and a few tweaks to make it ES3-compatible.\n *\n * See: https://github.com/adraffy/ens-normalize.js\n */\n// https://github.com/behnammodi/polyfill/blob/master/array.polyfill.js\nfunction flat(array, depth) {\n    if (depth == null) {\n        depth = 1;\n    }\n    const result = [];\n    const forEach = result.forEach;\n    const flatDeep = function (arr, depth) {\n        forEach.call(arr, function (val) {\n            if (depth > 0 && Array.isArray(val)) {\n                flatDeep(val, depth - 1);\n            }\n            else {\n                result.push(val);\n            }\n        });\n    };\n    flatDeep(array, depth);\n    return result;\n}\nfunction fromEntries(array) {\n    const result = {};\n    for (let i = 0; i < array.length; i++) {\n        const value = array[i];\n        result[value[0]] = value[1];\n    }\n    return result;\n}\nfunction decode_arithmetic(bytes) {\n    let pos = 0;\n    function u16() { return (bytes[pos++] << 8) | bytes[pos++]; }\n    // decode the frequency table\n    let symbol_count = u16();\n    let total = 1;\n    let acc = [0, 1]; // first symbol has frequency 1\n    for (let i = 1; i < symbol_count; i++) {\n        acc.push(total += u16());\n    }\n    // skip the sized-payload that the last 3 symbols index into\n    let skip = u16();\n    let pos_payload = pos;\n    pos += skip;\n    let read_width = 0;\n    let read_buffer = 0;\n    function read_bit() {\n        if (read_width == 0) {\n            // this will read beyond end of buffer\n            // but (undefined|0) => zero pad\n            read_buffer = (read_buffer << 8) | bytes[pos++];\n            read_width = 8;\n        }\n        return (read_buffer >> --read_width) & 1;\n    }\n    const N = 31;\n    const FULL = Math.pow(2, N);\n    const HALF = FULL >>> 1;\n    const QRTR = HALF >> 1;\n    const MASK = FULL - 1;\n    // fill register\n    let register = 0;\n    for (let i = 0; i < N; i++)\n        register = (register << 1) | read_bit();\n    let symbols = [];\n    let low = 0;\n    let range = FULL; // treat like a float\n    while (true) {\n        let value = Math.floor((((register - low + 1) * total) - 1) / range);\n        let start = 0;\n        let end = symbol_count;\n        while (end - start > 1) { // binary search\n            let mid = (start + end) >>> 1;\n            if (value < acc[mid]) {\n                end = mid;\n            }\n            else {\n                start = mid;\n            }\n        }\n        if (start == 0)\n            break; // first symbol is end mark\n        symbols.push(start);\n        let a = low + Math.floor(range * acc[start] / total);\n        let b = low + Math.floor(range * acc[start + 1] / total) - 1;\n        while (((a ^ b) & HALF) == 0) {\n            register = (register << 1) & MASK | read_bit();\n            a = (a << 1) & MASK;\n            b = (b << 1) & MASK | 1;\n        }\n        while (a & ~b & QRTR) {\n            register = (register & HALF) | ((register << 1) & (MASK >>> 1)) | read_bit();\n            a = (a << 1) ^ HALF;\n            b = ((b ^ HALF) << 1) | HALF | 1;\n        }\n        low = a;\n        range = 1 + b - a;\n    }\n    let offset = symbol_count - 4;\n    return symbols.map(x => {\n        switch (x - offset) {\n            case 3: return offset + 0x10100 + ((bytes[pos_payload++] << 16) | (bytes[pos_payload++] << 8) | bytes[pos_payload++]);\n            case 2: return offset + 0x100 + ((bytes[pos_payload++] << 8) | bytes[pos_payload++]);\n            case 1: return offset + bytes[pos_payload++];\n            default: return x - 1;\n        }\n    });\n}\n// returns an iterator which returns the next symbol\nfunction read_payload(v) {\n    let pos = 0;\n    return () => v[pos++];\n}\nfunction read_compressed_payload(bytes) {\n    return read_payload(decode_arithmetic(bytes));\n}\n// eg. [0,1,2,3...] => [0,-1,1,-2,...]\nfunction signed(i) {\n    return (i & 1) ? (~i >> 1) : (i >> 1);\n}\nfunction read_counts(n, next) {\n    let v = Array(n);\n    for (let i = 0; i < n; i++)\n        v[i] = 1 + next();\n    return v;\n}\nfunction read_ascending(n, next) {\n    let v = Array(n);\n    for (let i = 0, x = -1; i < n; i++)\n        v[i] = x += 1 + next();\n    return v;\n}\nfunction read_deltas(n, next) {\n    let v = Array(n);\n    for (let i = 0, x = 0; i < n; i++)\n        v[i] = x += signed(next());\n    return v;\n}\nfunction read_member_array(next, lookup) {\n    let v = read_ascending(next(), next);\n    let n = next();\n    let vX = read_ascending(n, next);\n    let vN = read_counts(n, next);\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < vN[i]; j++) {\n            v.push(vX[i] + j);\n        }\n    }\n    return lookup ? v.map(x => lookup[x]) : v;\n}\n// returns array of \n// [x, ys] => single replacement rule\n// [x, ys, n, dx, dx] => linear map\nfunction read_mapped_map(next) {\n    let ret = [];\n    while (true) {\n        let w = next();\n        if (w == 0)\n            break;\n        ret.push(read_linear_table(w, next));\n    }\n    while (true) {\n        let w = next() - 1;\n        if (w < 0)\n            break;\n        ret.push(read_replacement_table(w, next));\n    }\n    return fromEntries(flat(ret));\n}\nfunction read_zero_terminated_array(next) {\n    let v = [];\n    while (true) {\n        let i = next();\n        if (i == 0)\n            break;\n        v.push(i);\n    }\n    return v;\n}\nfunction read_transposed(n, w, next) {\n    let m = Array(n).fill(undefined).map(() => []);\n    for (let i = 0; i < w; i++) {\n        read_deltas(n, next).forEach((x, j) => m[j].push(x));\n    }\n    return m;\n}\nfunction read_linear_table(w, next) {\n    let dx = 1 + next();\n    let dy = next();\n    let vN = read_zero_terminated_array(next);\n    let m = read_transposed(vN.length, 1 + w, next);\n    return flat(m.map((v, i) => {\n        const x = v[0], ys = v.slice(1);\n        //let [x, ...ys] = v;\n        //return Array(vN[i]).fill().map((_, j) => {\n        return Array(vN[i]).fill(undefined).map((_, j) => {\n            let j_dy = j * dy;\n            return [x + j * dx, ys.map(y => y + j_dy)];\n        });\n    }));\n}\nfunction read_replacement_table(w, next) {\n    let n = 1 + next();\n    let m = read_transposed(n, 1 + w, next);\n    return m.map(v => [v[0], v.slice(1)]);\n}\nfunction read_emoji_trie(next) {\n    let sorted = read_member_array(next).sort((a, b) => a - b);\n    return read();\n    function read() {\n        let branches = [];\n        while (true) {\n            let keys = read_member_array(next, sorted);\n            if (keys.length == 0)\n                break;\n            branches.push({ set: new Set(keys), node: read() });\n        }\n        branches.sort((a, b) => b.set.size - a.set.size); // sort by likelihood\n        let temp = next();\n        let valid = temp % 3;\n        temp = (temp / 3) | 0;\n        let fe0f = !!(temp & 1);\n        temp >>= 1;\n        let save = temp == 1;\n        let check = temp == 2;\n        return { branches, valid, fe0f, save, check };\n    }\n}\n//# sourceMappingURL=decoder.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2hhc2gvbGliLmVzbS9lbnMtbm9ybWFsaXplL2RlY29kZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsT0FBTztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLE9BQU87QUFDbEM7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCLHdCQUF3QixXQUFXO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsa0NBQWtDO0FBQzlEO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xlZGdpdHkteWllbGQtZnJvbnRlbmQvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2hhc2gvbGliLmVzbS9lbnMtbm9ybWFsaXplL2RlY29kZXIuanM/Nzk4ZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIE1JVCBMaWNlbnNlXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDIxIEFuZHJldyBSYWZmZW5zcGVyZ2VyXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gKiBTT0ZUV0FSRS5cbiAqXG4gKiBUaGlzIGlzIGEgbmVhciBjYXJib24tY29weSBvZiB0aGUgb3JpZ2luYWwgc291cmNlIChsaW5rIGJlbG93KSB3aXRoIHRoZVxuICogVHlwZVNjcmlwdCB0eXBpbmdzIGFkZGVkIGFuZCBhIGZldyB0d2Vha3MgdG8gbWFrZSBpdCBFUzMtY29tcGF0aWJsZS5cbiAqXG4gKiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9hZHJhZmZ5L2Vucy1ub3JtYWxpemUuanNcbiAqL1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL2JlaG5hbW1vZGkvcG9seWZpbGwvYmxvYi9tYXN0ZXIvYXJyYXkucG9seWZpbGwuanNcbmZ1bmN0aW9uIGZsYXQoYXJyYXksIGRlcHRoKSB7XG4gICAgaWYgKGRlcHRoID09IG51bGwpIHtcbiAgICAgICAgZGVwdGggPSAxO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBjb25zdCBmb3JFYWNoID0gcmVzdWx0LmZvckVhY2g7XG4gICAgY29uc3QgZmxhdERlZXAgPSBmdW5jdGlvbiAoYXJyLCBkZXB0aCkge1xuICAgICAgICBmb3JFYWNoLmNhbGwoYXJyLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICBpZiAoZGVwdGggPiAwICYmIEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgICAgICAgICAgIGZsYXREZWVwKHZhbCwgZGVwdGggLSAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgZmxhdERlZXAoYXJyYXksIGRlcHRoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZnJvbUVudHJpZXMoYXJyYXkpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gYXJyYXlbaV07XG4gICAgICAgIHJlc3VsdFt2YWx1ZVswXV0gPSB2YWx1ZVsxXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVfYXJpdGhtZXRpYyhieXRlcykge1xuICAgIGxldCBwb3MgPSAwO1xuICAgIGZ1bmN0aW9uIHUxNigpIHsgcmV0dXJuIChieXRlc1twb3MrK10gPDwgOCkgfCBieXRlc1twb3MrK107IH1cbiAgICAvLyBkZWNvZGUgdGhlIGZyZXF1ZW5jeSB0YWJsZVxuICAgIGxldCBzeW1ib2xfY291bnQgPSB1MTYoKTtcbiAgICBsZXQgdG90YWwgPSAxO1xuICAgIGxldCBhY2MgPSBbMCwgMV07IC8vIGZpcnN0IHN5bWJvbCBoYXMgZnJlcXVlbmN5IDFcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IHN5bWJvbF9jb3VudDsgaSsrKSB7XG4gICAgICAgIGFjYy5wdXNoKHRvdGFsICs9IHUxNigpKTtcbiAgICB9XG4gICAgLy8gc2tpcCB0aGUgc2l6ZWQtcGF5bG9hZCB0aGF0IHRoZSBsYXN0IDMgc3ltYm9scyBpbmRleCBpbnRvXG4gICAgbGV0IHNraXAgPSB1MTYoKTtcbiAgICBsZXQgcG9zX3BheWxvYWQgPSBwb3M7XG4gICAgcG9zICs9IHNraXA7XG4gICAgbGV0IHJlYWRfd2lkdGggPSAwO1xuICAgIGxldCByZWFkX2J1ZmZlciA9IDA7XG4gICAgZnVuY3Rpb24gcmVhZF9iaXQoKSB7XG4gICAgICAgIGlmIChyZWFkX3dpZHRoID09IDApIHtcbiAgICAgICAgICAgIC8vIHRoaXMgd2lsbCByZWFkIGJleW9uZCBlbmQgb2YgYnVmZmVyXG4gICAgICAgICAgICAvLyBidXQgKHVuZGVmaW5lZHwwKSA9PiB6ZXJvIHBhZFxuICAgICAgICAgICAgcmVhZF9idWZmZXIgPSAocmVhZF9idWZmZXIgPDwgOCkgfCBieXRlc1twb3MrK107XG4gICAgICAgICAgICByZWFkX3dpZHRoID0gODtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKHJlYWRfYnVmZmVyID4+IC0tcmVhZF93aWR0aCkgJiAxO1xuICAgIH1cbiAgICBjb25zdCBOID0gMzE7XG4gICAgY29uc3QgRlVMTCA9IE1hdGgucG93KDIsIE4pO1xuICAgIGNvbnN0IEhBTEYgPSBGVUxMID4+PiAxO1xuICAgIGNvbnN0IFFSVFIgPSBIQUxGID4+IDE7XG4gICAgY29uc3QgTUFTSyA9IEZVTEwgLSAxO1xuICAgIC8vIGZpbGwgcmVnaXN0ZXJcbiAgICBsZXQgcmVnaXN0ZXIgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTjsgaSsrKVxuICAgICAgICByZWdpc3RlciA9IChyZWdpc3RlciA8PCAxKSB8IHJlYWRfYml0KCk7XG4gICAgbGV0IHN5bWJvbHMgPSBbXTtcbiAgICBsZXQgbG93ID0gMDtcbiAgICBsZXQgcmFuZ2UgPSBGVUxMOyAvLyB0cmVhdCBsaWtlIGEgZmxvYXRcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBsZXQgdmFsdWUgPSBNYXRoLmZsb29yKCgoKHJlZ2lzdGVyIC0gbG93ICsgMSkgKiB0b3RhbCkgLSAxKSAvIHJhbmdlKTtcbiAgICAgICAgbGV0IHN0YXJ0ID0gMDtcbiAgICAgICAgbGV0IGVuZCA9IHN5bWJvbF9jb3VudDtcbiAgICAgICAgd2hpbGUgKGVuZCAtIHN0YXJ0ID4gMSkgeyAvLyBiaW5hcnkgc2VhcmNoXG4gICAgICAgICAgICBsZXQgbWlkID0gKHN0YXJ0ICsgZW5kKSA+Pj4gMTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA8IGFjY1ttaWRdKSB7XG4gICAgICAgICAgICAgICAgZW5kID0gbWlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSBtaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXJ0ID09IDApXG4gICAgICAgICAgICBicmVhazsgLy8gZmlyc3Qgc3ltYm9sIGlzIGVuZCBtYXJrXG4gICAgICAgIHN5bWJvbHMucHVzaChzdGFydCk7XG4gICAgICAgIGxldCBhID0gbG93ICsgTWF0aC5mbG9vcihyYW5nZSAqIGFjY1tzdGFydF0gLyB0b3RhbCk7XG4gICAgICAgIGxldCBiID0gbG93ICsgTWF0aC5mbG9vcihyYW5nZSAqIGFjY1tzdGFydCArIDFdIC8gdG90YWwpIC0gMTtcbiAgICAgICAgd2hpbGUgKCgoYSBeIGIpICYgSEFMRikgPT0gMCkge1xuICAgICAgICAgICAgcmVnaXN0ZXIgPSAocmVnaXN0ZXIgPDwgMSkgJiBNQVNLIHwgcmVhZF9iaXQoKTtcbiAgICAgICAgICAgIGEgPSAoYSA8PCAxKSAmIE1BU0s7XG4gICAgICAgICAgICBiID0gKGIgPDwgMSkgJiBNQVNLIHwgMTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoYSAmIH5iICYgUVJUUikge1xuICAgICAgICAgICAgcmVnaXN0ZXIgPSAocmVnaXN0ZXIgJiBIQUxGKSB8ICgocmVnaXN0ZXIgPDwgMSkgJiAoTUFTSyA+Pj4gMSkpIHwgcmVhZF9iaXQoKTtcbiAgICAgICAgICAgIGEgPSAoYSA8PCAxKSBeIEhBTEY7XG4gICAgICAgICAgICBiID0gKChiIF4gSEFMRikgPDwgMSkgfCBIQUxGIHwgMTtcbiAgICAgICAgfVxuICAgICAgICBsb3cgPSBhO1xuICAgICAgICByYW5nZSA9IDEgKyBiIC0gYTtcbiAgICB9XG4gICAgbGV0IG9mZnNldCA9IHN5bWJvbF9jb3VudCAtIDQ7XG4gICAgcmV0dXJuIHN5bWJvbHMubWFwKHggPT4ge1xuICAgICAgICBzd2l0Y2ggKHggLSBvZmZzZXQpIHtcbiAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuIG9mZnNldCArIDB4MTAxMDAgKyAoKGJ5dGVzW3Bvc19wYXlsb2FkKytdIDw8IDE2KSB8IChieXRlc1twb3NfcGF5bG9hZCsrXSA8PCA4KSB8IGJ5dGVzW3Bvc19wYXlsb2FkKytdKTtcbiAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIG9mZnNldCArIDB4MTAwICsgKChieXRlc1twb3NfcGF5bG9hZCsrXSA8PCA4KSB8IGJ5dGVzW3Bvc19wYXlsb2FkKytdKTtcbiAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIG9mZnNldCArIGJ5dGVzW3Bvc19wYXlsb2FkKytdO1xuICAgICAgICAgICAgZGVmYXVsdDogcmV0dXJuIHggLSAxO1xuICAgICAgICB9XG4gICAgfSk7XG59XG4vLyByZXR1cm5zIGFuIGl0ZXJhdG9yIHdoaWNoIHJldHVybnMgdGhlIG5leHQgc3ltYm9sXG5leHBvcnQgZnVuY3Rpb24gcmVhZF9wYXlsb2FkKHYpIHtcbiAgICBsZXQgcG9zID0gMDtcbiAgICByZXR1cm4gKCkgPT4gdltwb3MrK107XG59XG5leHBvcnQgZnVuY3Rpb24gcmVhZF9jb21wcmVzc2VkX3BheWxvYWQoYnl0ZXMpIHtcbiAgICByZXR1cm4gcmVhZF9wYXlsb2FkKGRlY29kZV9hcml0aG1ldGljKGJ5dGVzKSk7XG59XG4vLyBlZy4gWzAsMSwyLDMuLi5dID0+IFswLC0xLDEsLTIsLi4uXVxuZXhwb3J0IGZ1bmN0aW9uIHNpZ25lZChpKSB7XG4gICAgcmV0dXJuIChpICYgMSkgPyAofmkgPj4gMSkgOiAoaSA+PiAxKTtcbn1cbmZ1bmN0aW9uIHJlYWRfY291bnRzKG4sIG5leHQpIHtcbiAgICBsZXQgdiA9IEFycmF5KG4pO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKVxuICAgICAgICB2W2ldID0gMSArIG5leHQoKTtcbiAgICByZXR1cm4gdjtcbn1cbmZ1bmN0aW9uIHJlYWRfYXNjZW5kaW5nKG4sIG5leHQpIHtcbiAgICBsZXQgdiA9IEFycmF5KG4pO1xuICAgIGZvciAobGV0IGkgPSAwLCB4ID0gLTE7IGkgPCBuOyBpKyspXG4gICAgICAgIHZbaV0gPSB4ICs9IDEgKyBuZXh0KCk7XG4gICAgcmV0dXJuIHY7XG59XG5mdW5jdGlvbiByZWFkX2RlbHRhcyhuLCBuZXh0KSB7XG4gICAgbGV0IHYgPSBBcnJheShuKTtcbiAgICBmb3IgKGxldCBpID0gMCwgeCA9IDA7IGkgPCBuOyBpKyspXG4gICAgICAgIHZbaV0gPSB4ICs9IHNpZ25lZChuZXh0KCkpO1xuICAgIHJldHVybiB2O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJlYWRfbWVtYmVyX2FycmF5KG5leHQsIGxvb2t1cCkge1xuICAgIGxldCB2ID0gcmVhZF9hc2NlbmRpbmcobmV4dCgpLCBuZXh0KTtcbiAgICBsZXQgbiA9IG5leHQoKTtcbiAgICBsZXQgdlggPSByZWFkX2FzY2VuZGluZyhuLCBuZXh0KTtcbiAgICBsZXQgdk4gPSByZWFkX2NvdW50cyhuLCBuZXh0KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHZOW2ldOyBqKyspIHtcbiAgICAgICAgICAgIHYucHVzaCh2WFtpXSArIGopO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsb29rdXAgPyB2Lm1hcCh4ID0+IGxvb2t1cFt4XSkgOiB2O1xufVxuLy8gcmV0dXJucyBhcnJheSBvZiBcbi8vIFt4LCB5c10gPT4gc2luZ2xlIHJlcGxhY2VtZW50IHJ1bGVcbi8vIFt4LCB5cywgbiwgZHgsIGR4XSA9PiBsaW5lYXIgbWFwXG5leHBvcnQgZnVuY3Rpb24gcmVhZF9tYXBwZWRfbWFwKG5leHQpIHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgbGV0IHcgPSBuZXh0KCk7XG4gICAgICAgIGlmICh3ID09IDApXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgcmV0LnB1c2gocmVhZF9saW5lYXJfdGFibGUodywgbmV4dCkpO1xuICAgIH1cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBsZXQgdyA9IG5leHQoKSAtIDE7XG4gICAgICAgIGlmICh3IDwgMClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICByZXQucHVzaChyZWFkX3JlcGxhY2VtZW50X3RhYmxlKHcsIG5leHQpKTtcbiAgICB9XG4gICAgcmV0dXJuIGZyb21FbnRyaWVzKGZsYXQocmV0KSk7XG59XG5leHBvcnQgZnVuY3Rpb24gcmVhZF96ZXJvX3Rlcm1pbmF0ZWRfYXJyYXkobmV4dCkge1xuICAgIGxldCB2ID0gW107XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgbGV0IGkgPSBuZXh0KCk7XG4gICAgICAgIGlmIChpID09IDApXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgdi5wdXNoKGkpO1xuICAgIH1cbiAgICByZXR1cm4gdjtcbn1cbmZ1bmN0aW9uIHJlYWRfdHJhbnNwb3NlZChuLCB3LCBuZXh0KSB7XG4gICAgbGV0IG0gPSBBcnJheShuKS5maWxsKHVuZGVmaW5lZCkubWFwKCgpID0+IFtdKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHc7IGkrKykge1xuICAgICAgICByZWFkX2RlbHRhcyhuLCBuZXh0KS5mb3JFYWNoKCh4LCBqKSA9PiBtW2pdLnB1c2goeCkpO1xuICAgIH1cbiAgICByZXR1cm4gbTtcbn1cbmZ1bmN0aW9uIHJlYWRfbGluZWFyX3RhYmxlKHcsIG5leHQpIHtcbiAgICBsZXQgZHggPSAxICsgbmV4dCgpO1xuICAgIGxldCBkeSA9IG5leHQoKTtcbiAgICBsZXQgdk4gPSByZWFkX3plcm9fdGVybWluYXRlZF9hcnJheShuZXh0KTtcbiAgICBsZXQgbSA9IHJlYWRfdHJhbnNwb3NlZCh2Ti5sZW5ndGgsIDEgKyB3LCBuZXh0KTtcbiAgICByZXR1cm4gZmxhdChtLm1hcCgodiwgaSkgPT4ge1xuICAgICAgICBjb25zdCB4ID0gdlswXSwgeXMgPSB2LnNsaWNlKDEpO1xuICAgICAgICAvL2xldCBbeCwgLi4ueXNdID0gdjtcbiAgICAgICAgLy9yZXR1cm4gQXJyYXkodk5baV0pLmZpbGwoKS5tYXAoKF8sIGopID0+IHtcbiAgICAgICAgcmV0dXJuIEFycmF5KHZOW2ldKS5maWxsKHVuZGVmaW5lZCkubWFwKChfLCBqKSA9PiB7XG4gICAgICAgICAgICBsZXQgal9keSA9IGogKiBkeTtcbiAgICAgICAgICAgIHJldHVybiBbeCArIGogKiBkeCwgeXMubWFwKHkgPT4geSArIGpfZHkpXTtcbiAgICAgICAgfSk7XG4gICAgfSkpO1xufVxuZnVuY3Rpb24gcmVhZF9yZXBsYWNlbWVudF90YWJsZSh3LCBuZXh0KSB7XG4gICAgbGV0IG4gPSAxICsgbmV4dCgpO1xuICAgIGxldCBtID0gcmVhZF90cmFuc3Bvc2VkKG4sIDEgKyB3LCBuZXh0KTtcbiAgICByZXR1cm4gbS5tYXAodiA9PiBbdlswXSwgdi5zbGljZSgxKV0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJlYWRfZW1vamlfdHJpZShuZXh0KSB7XG4gICAgbGV0IHNvcnRlZCA9IHJlYWRfbWVtYmVyX2FycmF5KG5leHQpLnNvcnQoKGEsIGIpID0+IGEgLSBiKTtcbiAgICByZXR1cm4gcmVhZCgpO1xuICAgIGZ1bmN0aW9uIHJlYWQoKSB7XG4gICAgICAgIGxldCBicmFuY2hlcyA9IFtdO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgbGV0IGtleXMgPSByZWFkX21lbWJlcl9hcnJheShuZXh0LCBzb3J0ZWQpO1xuICAgICAgICAgICAgaWYgKGtleXMubGVuZ3RoID09IDApXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBicmFuY2hlcy5wdXNoKHsgc2V0OiBuZXcgU2V0KGtleXMpLCBub2RlOiByZWFkKCkgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJhbmNoZXMuc29ydCgoYSwgYikgPT4gYi5zZXQuc2l6ZSAtIGEuc2V0LnNpemUpOyAvLyBzb3J0IGJ5IGxpa2VsaWhvb2RcbiAgICAgICAgbGV0IHRlbXAgPSBuZXh0KCk7XG4gICAgICAgIGxldCB2YWxpZCA9IHRlbXAgJSAzO1xuICAgICAgICB0ZW1wID0gKHRlbXAgLyAzKSB8IDA7XG4gICAgICAgIGxldCBmZTBmID0gISEodGVtcCAmIDEpO1xuICAgICAgICB0ZW1wID4+PSAxO1xuICAgICAgICBsZXQgc2F2ZSA9IHRlbXAgPT0gMTtcbiAgICAgICAgbGV0IGNoZWNrID0gdGVtcCA9PSAyO1xuICAgICAgICByZXR1cm4geyBicmFuY2hlcywgdmFsaWQsIGZlMGYsIHNhdmUsIGNoZWNrIH07XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVjb2Rlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ethersproject/hash/lib.esm/ens-normalize/decoder.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@ethersproject/hash/lib.esm/ens-normalize/include.js":
/*!****************************************************************************!*\
  !*** ../node_modules/@ethersproject/hash/lib.esm/ens-normalize/include.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getData: () => (/* binding */ getData)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_base64__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/base64 */ \"(ssr)/../node_modules/@ethersproject/base64/lib.esm/base64.js\");\n/* harmony import */ var _decoder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./decoder.js */ \"(ssr)/../node_modules/@ethersproject/hash/lib.esm/ens-normalize/decoder.js\");\n/**\n * MIT License\n *\n * Copyright (c) 2021 Andrew Raffensperger\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n *\n * This is a near carbon-copy of the original source (link below) with the\n * TypeScript typings added and a few tweaks to make it ES3-compatible.\n *\n * See: https://github.com/adraffy/ens-normalize.js\n */\n\n\nfunction getData() {\n    return (0,_decoder_js__WEBPACK_IMPORTED_MODULE_0__.read_compressed_payload)((0,_ethersproject_base64__WEBPACK_IMPORTED_MODULE_1__.decode)('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'));\n}\n//# sourceMappingURL=include.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2hhc2gvbGliLmVzbS9lbnMtbm9ybWFsaXplL2luY2x1ZGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDK0M7QUFDUTtBQUNoRDtBQUNQLFdBQVcsb0VBQXVCLENBQUMsNkRBQU07QUFDekM7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xlZGdpdHkteWllbGQtZnJvbnRlbmQvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2hhc2gvbGliLmVzbS9lbnMtbm9ybWFsaXplL2luY2x1ZGUuanM/NGNmNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIE1JVCBMaWNlbnNlXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDIxIEFuZHJldyBSYWZmZW5zcGVyZ2VyXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gKiBTT0ZUV0FSRS5cbiAqXG4gKiBUaGlzIGlzIGEgbmVhciBjYXJib24tY29weSBvZiB0aGUgb3JpZ2luYWwgc291cmNlIChsaW5rIGJlbG93KSB3aXRoIHRoZVxuICogVHlwZVNjcmlwdCB0eXBpbmdzIGFkZGVkIGFuZCBhIGZldyB0d2Vha3MgdG8gbWFrZSBpdCBFUzMtY29tcGF0aWJsZS5cbiAqXG4gKiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9hZHJhZmZ5L2Vucy1ub3JtYWxpemUuanNcbiAqL1xuaW1wb3J0IHsgZGVjb2RlIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2Jhc2U2NFwiO1xuaW1wb3J0IHsgcmVhZF9jb21wcmVzc2VkX3BheWxvYWQgfSBmcm9tICcuL2RlY29kZXIuanMnO1xuZXhwb3J0IGZ1bmN0aW9uIGdldERhdGEoKSB7XG4gICAgcmV0dXJuIHJlYWRfY29tcHJlc3NlZF9wYXlsb2FkKGRlY29kZSgnQUVRRjJBTzJERXNBMndJckFHc0JSQUJ4QU44QVp3Q2NBRXdBcWdBMEFHd0FVZ0J5QURjQVRBQVZBRllBSVFBeUFDRUFLQUFZQUZnQUd3QWpBQlFBTUFBbUFESUFGQUFmQUJRQUt3QVRBQ29BRGdBYkFBOEFIUUFZQUJvQUdRQXhBRGdBTEFBb0FEd0FFd0E5QUJNQUdnQVJBQTRBRHdBV0FCTUFGZ0FJQUE4QUhnUVhCWU1BNUJISkFTOEp0QVlvQWU0QUV4b3ppMFVBSDIxdEFhTW5CVDhDcm5JeWhyTURoUmdEeWdJQlVBRUhjb0ZIVVBlOEFYQmpBZXdDamdEUVI4SUlDSWNFY1FMd0FUWENEZ3p2SHdCbUJvSE5BcXNCZEJjVUF5a2dEaEFNU2hza01nbzhBWThqcUFRZkFVQWZIdzhCRHc4N01pb0dsQ0lQQndaQ2E0RUxhdE1BQU1zcEpWZ3NEbDhBSWhja1NnOFhBSGR2VHdCY0lRRWlEVDRPUGhVcWJ5RUNBRW9BUzM0QWVqOFlieDgzSmdUL1h3OGdIeFovN3c4UklDeFBIQTl2QncrUGZ3OFBId0FQRnYrZkFzQXZDYzh2RXI4aXZ3RC9FUThCb2w4T0VCYS9BNzhocndBUENVOHZFU052dndXZkh3TmZBVm9ESHIrWkFBRUQzNFlhQWRKUEFLN1BMd1NFZ0RMSEFHbzFQejhQdng5ZlV3TXJwYjhPLzU4VlR6QVBJQm9YSXlRSk5GOGhwd0lWQVQ4WUdBVUFERE5CYVgzUkFNb21KQ2c5RWhVZUEyOU1BQnNaQlRNTkppcGpPaGMxOWdjSURSOGJCd1FIRWdnQ1dpNkRJZ0x1QVFZQStCQUZDaGEzQTVYaUFFc3FNN1VGRmdGTGhBTWpGVE1ZRTFLbG53NzRuUlZCRy9BU0NtMEJZUk4vQnJzVTNWb1d5K1MwdlY4TFF4K3ZOOGdGMkFDMkFLNUVBV3dBcGdZREttQUFyb1EwTkRRMEFUK09DZzd3QUFJSFJBYnBOZ1ZjQlYwQVBUQTVCZmJQRmdNTHpjWUwvUXFxQTgyZUJBTEtDalFDanFZQ2h0MC9rMitPQXNYUUFvUDNBU1RLRGdEdzZBQ0tBVVlDTXBJS0pwUmFBRTRBNXdvbUFCelp2czBSRUVLaUFDSVFBZDVRZEFFQ0FqNFl3Zy93R3FZMkFWZ0FZQURZdkFvQ0dBRXViQTBndkFZMkFMQUFicGJ2cXB5RUFHQUVwZ1FBSmdBRzdnQWdBRUFDbWdoVUZ3Q3FBTXBBSU5RSXdDNER0aFJBQVBjeWNLZ0Fwb0lkQUJ3QmZDaXNBQm9BVHdCcUFTSUF2aG5TQlA4YUgvRUNlQUtYQXE0ME5qZ0RCVHdGWVFVNkFYczNvQUJnQUQ0WE5nbWNDWTFlQ2w1dElGWmVVcUdneW9OSEFCZ0FFUUFhQUJOd1dRQW1BQk1BVFBNYTNUMzRBRGxkeXBybU0xTTJYb2NpVVFnTHp2d0FYVDN4QUJnQUVRQWFBQk53SUdGQW5BREQ4QUFnQUQ0QkJKV3phQ2NJQUlFQkZNQVd3S29BQWRxOUJXQUY1d0xRcEFMRXRRQUtVU0drYWhSNEduSk0rZ3NBd0NnZUZBaVVBRUNRMEJRdUw4QUFJQUFBQURLZUloZWNsdkZxUUFBRVRyNGlBTXhJQVJNZ0FNSW9IaFFJQW4wRTBwRFFGQzRIaHpub0FBQUFJQUkyQzAvNGx2RnFRQUFFVGdCSkp3WUNBeTRBQmdZQUZBQThNQktZRUg0ZVJoVGtBalllRmNnQUNBWUFlQUJzT3F5UTVnUndEYXlxdWdFZ2FJSUF0Z29BQ2dEbUVBQm1CQVdHbWU1T0JKSkEybTRjRGVvQW1JVFdBWHdyTWdPZ0FHd0JDaDZDQlhZRjFUemcxd0tBQUZkaXVBQlJBRndBWFFCc0FHOEFkZ0JyQUhZQWJ3Q0VBSEV3ZnhRQlZFNVRFUUFEVkZoVEJ3QkRBTklMQXFjQ3pnTFRBcFFDclFMNnZBQU1BTDhBUExoTkJLa0U2Z2xHS1RBVTREcjROMkVZRXdCQ2tBQktrOHJIQWJZQm13SW9BaVU0QWpmL0FxNENvd0NBQU5JQ2h6Z2FOQnNDc1RnZU9EY0ZYcmdDbFFLZEFxUUJpUUdZQXFzQ3NqVHNOSHNmTlBBMGl4c0FXVFdpT0FNRlBEUVNOQ2syQkRaSE5vdzJUVFpVTmhrMjhKazlWekkzUWtFb0FvSUNvUUt3QXFjQVFBQXhCVjRGWGJTOUJXNDdZa0lYUDFjaVVxczA1RFMvRndBQlV3SlcxMWU2bkh1WVptU2gvUkFZQThvTUt2WjhLQVNvVUFKWVdBSjZJTEFzQVpTb3FqcGdBMG9jQklobURnRFdBQWF3UkRRb0FBY3VBajVpQUhBQlppUjJBSWdpSGdDYUFVNjhBQ3h1SEFHMHlnTThNaVpJQWxnQmRGNEdhZ0pxQVBaT0hBTXVCZ29BVGtZQXNBQmlBSGdBTUxvR0RQajBIcEtFQkFBT0pnQXVBTGdnVEFIV0FlQU1FRGJkMjBVZWdlMEFEd0FXQURrQVFnQTlPSGQrMk1VUVpCQmhCZ05ORGt4eFB4VVFBckVQcXd2cUVSb00xaXJRMDkwQU5LNEg4QU5ZQi9BRFdBTllCL0FIOEFOWUIvQURXQU5ZQTFnRFdCd1A4Qi9ZeFJCa0QwMEVjZ1dUQlpBRTJ3aUlKazRSaGdjdENOZFVFblFqSEV3RFNnRUJJeXBKSVR1WU14QWxSMHdSVFFnSUFUWkhiS3g5UFFOTU1iQlUrcENuQTlBeVZEbHhCZ01lZGhLbEFDOFBlQ0UxdWs2RGVreHhwUXBRVDdOWDl3QkZCZ0FTcXdBUzVnQkpEU2dBVUN3R1BRQkk0elRZQUJOR0FFMmJBRTNLQUV4ZEdBQkthQWJnQUZCWEFGQ09BRkJKQUJJMlNXZE9iQUxET3EwLy9Rb21DWmh2d0hkVEJrSVFIQ2VtRVBnTU5BRzJBVHdON2t2WkJQSUdQQVRLSDM0WkdnL09sWjBJcGkzZURPNG01QzZpZ0ZzajlpcUVCZTVMOVR6ZUMwNVJhUTlhQzJZSjVEcGtnVThESWdFT0lvd0szZzA2Q0c0UTlBcktiQTNtRVVZSE9nUFdTWnNBcGdjQ0N4SWROaFcySmhGaXJRc0tPWGdHL0JyM0M1QW1zQk1xZXYwRjFCb2lCazRCS2hzQUFOQXU2SVd4V2pKY0hVOWdCZ1FMSmlQSUZLbFFJUTBtUUxoNFNSb2NCeFlscWdLU1EzRktpRkUzSHBRaDl6dytEV2N1RkZGOUIvWThCaGxRQzRJOG4wYXNSUThSMHo2T1BVa2lTa3d0QkRhQUxEQW5qQW5RRDRZTXVueHpBVm9KSWdteURISVRNaEVZTjhZSU9nY2FMcGNsSnhZSUlrYVdZSnNFK0tBRDlCUFNBd3dGUUFsQ0J4UUR0aHd1RXk4VktnVU9nU1hZQXZRMjFpNjBBcEJXZ1FFWUJjd1BKaC9nRUZGSDRRN3FDSndDWmdPRUpld0FMaFVpQUJnaW5BaEVaQUJnajlsVEJpN01DTWhxYlNOMUEyZ1U2R0lSZEFlU0RsZ0hxQncwRmNBYzRuREpYZ3lHQ1Npa3NBbGNBWFlKbWdGZ0JPUUlDalZjaktFZ1FtZFVpMWtZbkNCaVFVQmQvUUl5REdZVm9FUytoM2tDakE5c0Vod0JOZ0YwQnpvTkFnSjRFZTRSYkJDV0NPeUdCVFcyTS9rNkpnUlFJWVFnRWdvb0ExQnN6d3NvSnZvTStXb0JwQkpqQXcwMFBuZnZaNnhndHlVWC9nY2FNc1pCWVNIeUM1TlB6Z3lkR3NJWVExUXZHZVVId0FQMEd2UW42MEZZQmdBRHBBUVVPazR6N3dTK0Myb0lqQWxBQUVvT3BCZ0gyQmhyQ25LTTBRRXlqQUc0bWdOWWtvUUNjSkFHT0FjTUFHZ01pQVY2NWdBZUFxZ0lwQUFHQU5BRFdBQTZBcTRIbmdBYUFJWkNBVDRES0RBQkl1WUNrQU9VQ0RMTUFaWXdBZlFxQkJ6RURCWUErRGh1U3dMRHNnS0FhMmFqQmQ1WkFvOENTallCVGlZRUJrOUlVZ093Y3VJQTNBQk1CaFRnU0FFV3JFdk1HK1JFQWVCd0xBRElBUHdBQmpZSEJrSUJ6Z0gwYmdDNEFXQUxNZ21qdExZQlR1b3FBSVFBRm13QjJBS0tBTjRBTmdDQThnRlVBRTRGV3ZvRjFBSlFTZ0VTTWhrc1dHSUJ2QU1nQVRRQkRnQjZCc3lPcHNvSUlBUnVCOVFDRUJ3VjRnTHZMd2UyQWdNaTRCUE9Rc1lDdmQ5V0FESVhVdTVlWndxb0NxZGVhQUMwWVRRSE1uTTlVUUFQSDZrK3lBZHkvQlpJaVFJbVN3QlE1Z0JRUXpTYU5URldTVFlCcHdHcUtRSzM4QUZ0cXdCSS93SzM3Z0szclFLM3NBSzYyODBDMGdLMzNBSzN6eEFBVUVJQVVEOVNrbEtEQXJla0FydzVBRVFBekFIQ08xNDdXVHRlTzFrN1hqdFpPMTQ3V1R0ZU8xa0RtQ2hZSTAzQVZVMG9KcWtLYlY5R1lld01wdzNWUk1rNlNoUGNZRkpnTXhQSkxiZ1V3aFhQSlZjWlBocTlKd1lsNVZVS0R3VXQxR1l4Q0MwMGRoZTlBRUFwYVlOQ1k0Y2VNUXBNSE9oVGtsVDVMUndBc2t1ak03QU5yUnNXUkVFRlNIWHVZaXNXRHdvakFtU0NBbUpEWEU2d1hEY2hBcUg0QW1pWkFtWUtBcCtGT0J3TUFtWThBbVluQkc4RWdBTi9GQU4ra3prSE9YZ1lPWU02SkNRQ2JCNENNamM0Q3dKdHlBSnRyL0NMQURSb1Jpd0JhQURmQU9JQVN3WUhtUXlPQVA4TXd3QU90Z0ozTUFKMm8wQUNlVXhFQW5pN0hsM2NSYTlHOUFKOFFBSjZ5UUo5Q2dKODhVZ0JTSDVrSlFBc0ZrbFpTbHdXR0VyTkF0RUNBdEROU3lnRGlGQURoK2RFeHBFekF2S2lYUVFEQTY5THowd3VKZ1RRVFUxTnNBS0xRQUtLMmNJY0NCNUVhQWE0QW80NEFvNWRRWmlDQW83YUFvNWRlVkcxVXpZTFV0VlVoZ0tUL0FLVERRRHFBQjFWSDFXd1ZkRUhMQndwbG9jeTRuaG5SVHc2QXBlZ0F1K3pXQ0twQUZvbUFwYVFBcFo5blFDcVdhMWFDb0pPQUR3Q2xyWUNsazljUlZ6U0Fwbk1BcGxsWE10ZENCb0NuSnc1d3pxZUFwd1hBcCtjQXA2NWl3QWVFRElyRUFLZDhnS2Vrd0MyUG1FMVlmQUNudFFDb0c4QnFnS2VvQ0FDbmsrbVk4bGtLQ1lzQWlld0FpWi9BcUQ4QXFCTjJBS21NQUtsendLb0FBQitBcWZ6YUgxb3NnQUVTbW9kYXRJQ3JPUUNySzhDcldnQ3JRTUNWeDRDVmQwQ3NlTFlBeDlQYkpnQ3NyNE9BckxwR0d6aGJXUnRTV0FESmM0Q3RsMDhRRzZSQXlsR0FyaGZBcmxJRmdLNUszaHdOM0RpQXIwYUF5MnpBeklTQXI2SmNnTURNM0lDdmh0ekkzTlFBc1BNQXNNRmM0TjBURFpHZE9FRFBLZ0RQSnNEUGNBQ3hYMEN4a2dDeGhHS0FzaHFVZ0xJUlFMSlVBTEpMd0prbmdMZDAzaDZZbml2ZVNaTDBRTVlwR2NEQW1IMUdmU1ZKWHNNWHBOZXZCSUN6MndDejIwd1RGVFQ5QlNnQU1ldUFzOTBBU3JyQTA0VGZrd0dBdHdvQXR1TEF0SlFBMUpkQTFOZ0FRSURWWTJBaWtBQnpCZnVZVVoyQUlMUGc0NEMyc2dDMmQrRUVZUktwejBEaHFZQU1BTmtENFp5V3ZvQVZnTGZaZ0xldVhSNEF1SXc3UlVCOHpFb0FmU2NBZkxUaUFMcjlBTHBjWG9BQXVyNkF1cmxBUHBJQWJvQzdvb0M2NTJXcTVjRUF1NUFBNFhobUhwdzRYR2lBdk1FQUdvRGpoZVpsQUwzRkFPUmJ3T1NpQUwzbVFMNTJnTDRaNW9kbXF5OE9Kc2ZBNTJFQXY3N0FSd0FPcDhkbjdRREJZNERwbXNEcHRvQTBzWURCbXVoaWFJR0NnTU1TZ0ZnQVNBQ3RnTkdBSndFZ0xwb0JnQzhCR3pBRW93Y2dnQ0VEQzZrZGpvQUpBTTBDNUlLUm9BQlpDZ2lBSXp3M0FZQkxBQ2tmbmc5b2dpZ2tnTm1XQU42QUVRQ3Zya0VWcVRHQXdDc0JSYkFBKzRpUWtNQ0hSMDcyakkyUFRiVU5zazJSalk1TnZBMjNUWktOaVUzRURjWk41SStSVHhEUlRCQ0prSzVWQllLRmhaZndRQ1d5Z1UzQUpCUkhwdStPeXRnTnhhNjFBNDBHTXNZanNuN0JWd0ZYUVZjQlYwRmFBVmRCVndGWFFWY0JWMEZYQVZkQlZ3RlhVc2FDTnlLQUs0QUFRVUhCd0tVN29JQ29XMWU3akFFemdQeEErWUR3Z0NrQkZEQXdBREFCS3pBQU94RkxoaXRBMVVGVERleVBrTStiajUxUWtSQ3V3VFFXV1E4WCswQVdCWXpzQUNOQTh4d3pBR203RVovUWlzb0NUQWJMRHM2Zm5MZmI4SDJHY2NzYmdGdzEzTTFIQVZrQlcvSnhzbTlDTlJPOEU4RkREMEZCUXc5RmtjQ2xPWUNvTUZlZ3BEZkFEZ2NNaUEyQUpRQUNCOEFzaWdLQUl6SUVBSktlQklBcFk1eVBaUUlBS1FpSGI0ZnZqNUJLU1JQUXJaQ096MG9YeXhnT3l3ZktBbkdiZ01DbFFhQ0FrSUxYZ2RlQ0Q5SUlHVWdRajVmUG9ZK2RUNTJBbzVDTTBkQVg5QlRWRzlTRHpGd1dUUUFieEJ6SkYvbE9FSVFRZ2xDQ2tLSklBbHM1QWNDbFFJQ29LUE1PREVGeGhpNktTQWJpeWZJUnJNanRDZ2RXQ0FrUGxGQklpdENzRUpSekFiTUFWL09FeVF6RGcwT0FRUUVKMzZpMzI4L01rOUF5YkRKc1FscTN0RFJBcFVLQWtGelhmMWQvajl1QUxZUDZoQ29GZ0NUR0Q4a1BzRktRaW9icm0wK3pqMEtTRDhrUG5WQ1JCd01EeUpSVEhGZ01USmE1cndYUWlRMllmSS9KRDdCTUVKRUhHSU5UdzRUT0ZsSVJ6d0pPMGljTVFweVB5USt3ekpDUkJ2NkRWZ25LQjAxTmdVS2oyYndZek1xQ29Ca3puQmdFRit6WURJb2N3UklYK05nSGo0SElDTmZoMkM0Q3dkd0ZXcFRHL2xnVWhZR0F3UmZ2MlRzOG1BYVh6VmdtbC9YWUlKZnVXQzRISTFnVUY5cFlKWmdNUjZpbFFITUFPd0xBbERSZWZDMGluNEFYQUVKQTZQakN3YzBJYW1PQU5NTUNBRUNSUURGTlJUWkJnZCtDd1FsUkErcjYrZ0xCREVGQm53VUJYZ0tBVElBcndBR1JBQUhBM2NEZEFOMkEza0Rkd045QTNvRGRRTjdBMzBEZkFONEEzb0RmUUFZRUFBbEF0WUFTd01BVUFGc0FIY0tBSGNBbWdCM0FIVUFkUUIyQUhWdThVZ0F5Z0RBQUhjQWRRQjFBSFlBZFFBTENnQjNBQXNBbWdCM0FBc0NPd0IzQUF0dThVZ0F5Z0RBQUhnS0FKb0Fkd0IzQUhVQWRRQjJBSFVBZUFCMUFIVUFkZ0IxYnZGSUFNb0F3QUFMQ2dDYUFIY0FDd0IzQUFzQ093QjNBQXR1OFVnQXlnREFBSDRBQ3dHZ0FMY0Jwd0M2QWFoZEF1MENPd0x0YnZGSUFNb0F3QUFMQ2dDYUF1MEFDd0x0QUFzQ093THRBQXR1OFVnQXlnREFBMjRBQ3dOdkFBdTBWc1FBQXpzQUFCQ2tqVUlwQUFzQVVJdXNPZ2dXY2dNZUJ4VnNHd0w2N1UvMkhsem1XT0VlT2dBTEFTdnVBQXNlQWZwS1VwbnBHZ1lKRENJWk02WXlBUlVFOVRocUFENWlYUWduQUpZSlBuT3p3MFpBRVp4RUtzSUFrQTREaEFIblRBSUR4eFVESzBseENRbFBZZ0l2SVFWWUpRQlZxRTFHYWtVQUtHWWlEVG9TQkExRXRBWUFYUUpZQUlGOEdnTUhSeUFBSUFqT2U5WW5jZWtSQUEwS0FDVXJqd0U3QXljNkFBWVdBcWFpS0c0TWNFY3FBTm9OMytNZzlUd0NCaElrdUNueStKd1VRMjlMMDA4Smx1Unh1M0srb0FkcWlIT3FGSDBBRzVTVUlmVUo1U3hDR2Z4ZGlwUnpxVG1UNFY1WmIrcjFVbzRWbStOcVNTRWwybU52UjJKaElhOFNwWU82bnRkd0ZYSENXVENLOGYyK0h4bzd1aUczZHJEeWNBdUtJTVA1YmhpMDZBQ25xQXJIMXJ6NFJxZy8vbG02U2dKR0VWYkY5eEpISVNhUjZIeHF4U25rdzZzaERuZWxIS05FZkdVWFNKUkoxR2NzbXRKdzI1eHJaTURLOWdYU20xL1lNa2RYNC82TktZT2R0ay9OUTMvTm5EQVNqVGMzZlBqSWpXLzVzVmZWT2JYMm9URFdrcjFkRjlmM2t4QnNEMy8zYVFPOGhQZlJ6K2UwdUVpSnF0MTE2MWdyaXU3Z3o4aEREd3RweStGK0JXdGVmbktIWlBBeGNab1dibnpuaEpweTBlODQyajM2YmNOekduSUV1c2dHWDBhOFp4c25qY1NzUERaMDl5WjM2ZkNRYnJpSGVRNzJKUk1JTE5sNmVQUGYySFdvVndnV0FtMWZiM1Yyc0FZMCtCNnJBWHFTd1BCZ3NlVm1vcXNCVFNybTkxK1hhc01ZWXlTSThlZVJ4SDNadkhrTXozQlE1YUozaVVWYllQTk0zLzdlbVJ0amxzTWd2LzlWeVRzeXQvbUsrOGZnV2VUNlNvRmFjbFhxbjQyZEFJc3ZBYXJGNXZOTldIektTa0tRLzhIZms1WldLN3I5eWxpT3Nvb3lCalJoZmtIUDRRMkRrV1hRaTZGRy85ci9Jd2Jta1Y1VDdKU29wSEtuMXBKd205dGI1T3Qwb3lOMVoybVBwS1hIVHh4Mm5sSzA4ZktrMWhFWUE4V2dWVldMNWxneDBpVHYrS2RvakplVTIzWkRqbWl1YlhPeFZYSktLaTJXanVoMkhMWk9GTGlTQzdUbHM1U01oNGYrUGo2eFVTck5qRnFMR2VoUk5COGxDMFFTTE5ta0pKeC93U0czTW5qRTlUMUNrUHdKSTB3SDJsZnp3RVRJaVZxVXhnMGRmdTVxMzlHdCtod2RjeGtoaE52UTRUeXJCY2VvZjNNaHMvSXhGY2kxSG1IcjRGTVpnWEVFY3pQaUdDeDBIUnd6QXFEcTJqOUFWbTFrd04wbVJWTFdMeWxndG9QTmFwRjVjWTRZMXdKaC9lMEJCd1pqNDRZZ1pyRE5xdkQvOUh2N0dGWWRVUWVESnVRM0VXSTRIYUtxYXZVMVhqQy9uNDFrVDRMNzlrcUdxMGtMaGRUWnZnUDNUQTNmUzBvelZ6KzVwaVpzb090SXZCVUZvTUtiTmNtQkw2WXh4YVVBdXNIQjM4WHJTOGRRTW5Rd0pmVVVrcFJvR3I1QVVlV2ljdkJUenlLOWc3Nyt5Q2tmNVBBeXNMN3IvSmpjWmdyYnZScE1XOWl5YXhadktPNmNlWk4yRXdJeEt3VkZQdXZGdWlFUEdDb2FnYk1vK1NweWRMclhxQnpOQ0RHRkNyTy9ya2N3YTJ4aG9rUVo1Q2RaMEFzVTNKZlNxSjZuNUkxNFlBK1AvdUFnZmhQVTg0VGx3N2NFRmZwN0FFRThleTRzUDEyUFR0NENvZHMxR1JnRE9CNXh2eWlSNW0rQng4TzVuQkNOY3RVOEJldmZWNUEwOHg2UkhkNWpjd1BUTURTWkpPZWRJWjFjR1E3MDRseGJBenFaT1AwNVp4YU9naHpTZHZGQkhZcW9tQVRBUnlBQURLNGVsUDhMeTNJclVaS2ZXaDIzWHkyMHVCVW1MUzRQZmFndTkrb3lWYTJpUGdxUlAzRjJDVFVzdko3K1JZbk44ZkZaYlUvSFZ2eHZjRkZES2tpVHFWNVVCWjNHejU0SkFLQnlpOWhrS01aSnZ1R2djU1lYRm13MDhVeW9ReVZkZlREMS9kTWtDSFhjVEdBS2VST2dBcnN2bVJyUVRMVU9YaW9PSEdLMlFrakh1b1lGZ1hjaVpvVEpkNkZzNXExUVgxRytwL2UyNmhZc0VmN1FaRDFubkl5bC9TRmtOdFlZbW1CaHBCcnhsOVdiWTBZcEhXUnV3MkxsL3RqOW1EOFA0c25WekpsNEY5SisxYXJWZVRiOUU1cjJJTEgwNHFTdGp4UU53bjNtNFlOcXhtYU5iTEFxVzJUTjZMaWR3dUpScVMrTlhidHF4b2VEWHB4ZUdXbXh6U2tXeGpreUNrWDROUVJtZTZxNVNBY0MrTTcrOUVUZkEvRXdyelFhaktha0N3WXlldW5QNlpGbHhVMm9NRW4xUHozMXplU3RXNzRHNDA2WkpGQ2wxd0FYSW9VS2tXb3RZRXBPdVhCMXVWTnhKNjNkcEpFcWZ4QmVwdHdJSE5yUHo4QmxsWm9JY0JvWHdnZkorOFZBVW5WUHZSdmV4bncwTWEvV2lHWXVKTzV5OFFUdkVZQmlnRm1oVXhZNVJxekU4T2N5d04vOG00VVlybGFuaUpPNzVYUTZLU285K3RXSGx1K2hNaTBVVmRpS1FwN05lbG5vWlV6TmFJeUJQVmVPd0s2R05wK0ZmSHVQT295aGFXdU52VFlGa3Z4c2NNUVdEaCt6ZUZDRmtnd2JYZnRpVjIzeXdKNCt1d1JxbWc5azNLendJUXB6cHB0OERCQk9NYnJxd1FNNUdiMDVzRXdkS3pNaUFxT2xvYUEvbHIwS0ErMXByMC8rSGlXb2lJakhBL3dpcjJuSXVTM1BlVS9qaTNPNlp3b3hjUjFTWjlGaHRMQzVTMEZJekZoYkJXY0dWUC9LcHhPUFNpVW9BZFdVcHFLSCsrNlNjejUwN2lDY3hZSTZyZE1CSUNQSlplYTdPY21lRnc1bU9iSlNpcXBqZzJVb1dOSXMrY0ZoeURTdDZnZVY1cWdpM0Z1bm13d0RvR1NNZ2VyRk9aR1gxbTBkTUNZbzVYT3J1eE8wNjNkd0VOSzlEYm5WTTl3WUZSRXpoNHZ5VTFXWVlKL0xSUnA2b3hnanFQL1g1YTgvNEFmNnA2TldrUWZlcnpCbVhtZTB6WS80bndNSm0vd2QxdElxU3dHeitFM3hQRUFPb1psSml0M1hkZEQ3L0JUMXBsbHpPeCs4Ym1RdEFOUS9TNmZaZXhjNnFpM1crUTJ4Y21YVFVodVM1bXBIUVJ2Y3haVU4wUzUrUEw5bFhXVUFhUlpoRUg4aFRkQWN1Tk1NQ3VWTktURUd0U1VLTmkzTzZLaFNhVHpjazhjc1oydldSWitkN21XOGM0SUt3WElZZDI1Uy96SWZ0UGt3UHp1ZmpFdk9IV1ZEMW0rRmpwRFZVVFYwREdEdUhqNlFuYUV3THUvZEVnZExRT2c5RTFTcm85WEhKOHlrTEF3dFB1K3B4cUtEdUZleHFPTjFzS1FtN3J3YkUxRTY4VUNmQS9lcm92clRDRytEQlNOZzBsNGdvRFF2Wk42dU5sYnlMcGNaQXdqMlVjbHljdkxwSVpNZ3Y0eVJscGIzWXVNZnRvem9yYmNHVkh0L1ZlRFYzK0ZkZjFUUDBpdWFDc1BpMkc0WGVHaHN5RjF1YlZEeGtvSmhtbmlRMC9qU2cvZVlNTDlLTGZuQ0ZnSVNXa3A5MWVhdVIzSVF2RUQwbkFQWEsrNmhQQ1lzK24zK2hDWmJpc2ttVk1HMmRhKzBFc1pQb25VZUlZOEViZnVzUVhqc0svZUZEYW9zYlBqRWZRUzBSS0c3eWo1R0c2OU03TWVPMUhtaVVZb2NneWdKSEw2TTFxelVERHdVU21yOTlWN1NkcjJGM0pqUUFKWStGMHlIMzNJdjMrQzlNMzhlTUw3Z1RnbU51L3IyYlVNaVB2cFliWjZ2MS9JYUVTaXJCSE5hN21QS240ZEVtWWc3di8rSFFnUE4xRzc5akJRMStzb3lkZkRDMnIraDJCbC9LSWM1S2pNSzdPSDZuYjFqTHNOZjBFSFZlMktCaUU1MW94NjM2dXlHNkxobzB0M0ozNEw1UVkvaWxFM21pa2FGNEhLWEcxbUcxckNldlQxVnY2R2F2bHR4b1FlL2JNcnBadlJnZ25CeFNFUEVlRXprRWRPeFRuUFhIVmpVWWR3OEpZdmpCL283RWVnYzNNYStOVXhMTG5zSzBrSmxpblBtVUh6SEd0cms1K0NBYlZ6Rk9CcXB5eTNRVlVuelREZkMvMFhEOTQvb2tIK09CK2k3Zzlsb2xoV0lqU25mSWIrRXE0M1pYT1dtd3ZqeVYvcXFEK3QwZSs3bVRFTTc0cVAvT3p0OG5tQzdtUnB5dTYzT0I0S25VekZjMDc0U3FveVBVQWdNKy9USkdGbzZUNDRFSG5RVTRYNHo2cWFublZxZ3cvVTd6Q3B3Y21YVjFBdWJJcnZPbWtLSGF6SkFSNTVlUGpwNXRMQnNOOHZBcXMzTkFIZGNFSE9SMnhRMGxzTkFGelNVdXhGUUNGWXZYTFpKZE9qOXA0Zk5xNnAwSEJHVWlrMll6YUk0eHlTeTkxS3poUTArcTFoanh2SW1Sd1BSZjc2dENobFJraFJDaTc0TlhaOXFVTmVJd1ArczVwKzNtNW53UGROT0hnU0xENzluN085bTFuMXVESGlNbnRxNG5rWXdWNU9aMUVOYlh4RmQ0UGdybHZhdlpzeVVPNE1xWWxxcW4xTzhXL0kxZEVacTVkWGhyYkVUTGFaSWJDMktqL0FhL1FNK2ZxVU9IZGYwdFhBUTFodVozY21XRUNXU1h5LzQzajM1K012cTl4d3M3SktzZXJpWjFwRVdLYzhxbHpOckdQVUdjVmdPYTljUEpZSUpzR25KVEFVc0VjRE9FVlVMTzV4MHJYQmlqYzFsZ1hFelFRS2hST2Y4eklWODJ3OGVzd2M3OFlYMTFLWUxXUVJjZ0hOSkVsQnhmWHI3MmxTMlJCU2wwN3FUS29yTzJ1VURacjNzRmhZc3ZuaExabjBBOTRLUnpKLzdERUdJQWhXNVpXRnBMOGdFd3UxYUxBOU11V1p6TndsOE96ZTlZK2JYK3Y5Z3l3UlZub0I1SS84a1hUWFUzMTQxeVJMWXJJT096NlNPbnlITnk0U2llcXprQlhoYXJqZmpxcTFxNnRrbGFFYkE4UWZtMkRhSVBzN09UcS9udkpCaktmTzJIOWJIMmNDTWgxKzVnc3BmeWN1OGYvY3V1Um10RGp5cVo3dUNJTXlqZFYzYStwM2ZxbVhzUng0QzhsdWpleklGSG5RaVZUWExYdUkxWHJ3TjMrc2lZWWoySEhUdkVTVXg4RGxPVFhwYWs5cUZSSytMM21nSjFXc0Q3RjRjdTFhSm9Gb1lRbnUrd0dETU9qSk0za2lCUVdIQ2N2aEovSFJkeG9kT1FwNDVZWmFPVEEyMk5iNFhLQ1Z4cWtid01ZRmh6WVFZSUFuQ1c4RlcxNHVmOThqaFVHMnpyS2hRUTBxMENFcTB0NW5YeXZVeXZSOER2RDY5TFUrZzNpK0hGV1FNUThQcVp1SEQrc05LQVYwK002RUpDMHN6cTdyRXI3QjViUThCY05IenZETWM5ZXFCNVpDUWRUZjgwT2JuNHV6andwWVU3U0lTZHRWMFFHYTlEM1dyaDJCRFF0cEJLeGFORlYrL0N5MlAvU3YrOHM3VWQwRmQ3NFg0K28vVE56dFdnRVRVYXB5K21hak5RNjhMcTNlZTBaTzQ4VkViVFpZaUgxQ280T2xmV2VmODJSV2V5VVhvN3dvTTAzUHlhcEdmaWtUblFpbm9OcTV6NXZlTHBlTVYzSENBTVRhWm1BMW9HTEFuN1hTM1hZc3orWEs3Vk1Rc2M0WEtybURYT0xVL3BTWFZOVXE4ZElxVGJhLy8vM3g2TGlMUzZ4czF4dUNBWVNmY1EzK3JRZ211N3V2ZjNUSEt0NU9vbzk3VHFjYlJxeHg3RUFTaXphUUNCUWxsRy9yWXhWYXBNTGd0TGJaUzY0dzFNREJNWFgrUFFwQktOd3FVS09mMkREUkRVWFFmOUVoT1MwUWo0blRtbEE4ZHpTTHovRzFkK1VkOE1UeS82Z2hoZGlMcGVlckdZL1VsRE9maXVxRnNNVVU1L1VZbFArQkFtZ1JMdU5wdnJVYUxsVmtycURpZXZOVkVBd0YrNENvTTFNWlRtanhqSk1zS0pxK3U4WmQ3dE5DVUZ5NkxpeVlYUkpRNFZ5dkVRRkZhQ0dLc3hJd1FrazdFelo2TFRKcTJoVXVQaHZBVytnUW5TRzZKK01zekMrN1FDUkhjbnFEZHlOUko2VDl4eVM4N0E2TUR1dGJ6S0d2R2t0cGJYcXR6V3RYYjlIc2ZLMmNCTW9tak45YTR5K1RhSkxuWHhBZVgvSFd6bWY0Y1I0dkFMdC9QNHc0cWdLWTA0bWw0WmRMT2luRllTNmN1cDNHLzFpZTQrdDFlT25wQk5scUdxczc1aWx6a1Q0K0RzWlF4TnZhU0tKLy82ekliYmsvTTdMT2hGbVJjLzFSK2tCdHo3SkZHZFptL0NPb3RJZHZRb1hwVHFQLzF1cUVVbUNiL1FXb0dMTXdPNUFOY0h6eGRZNDhJR1A1K0orektPVEJGWjRQaWQrR1RNK1dxMTJNVi9IODZ4RUpwdEJhNlQrcDNrZ3B3TGVkTWFuQkhDMkdnTnJGcG9OMnhuck16OVdGV1gvOC95Z1NCa2F2cTJVdjdGZENzTEVZTHU5TExJdkFVMGJOUkR0ellsKy92WG1qcEl2dUpGWWptSTBpbTZRRVlxbkllTXNOalhHNHZJdXRJR0hpamVBRy85RURCb3pLVjVjbGRrSGJMeEhoMjV2VCtaRXpiaFhscXZwektKd2NFZ2ZOd0xBS0ZlbzAvcHZFRTEwWERCK0VYUlRYdFN6Sm96UUtGRkFKaE14WWtWYUNXK0U5QUw3dE1lVThhY3hpZEhxemI2bFg0NjkxVXNEcHkvTExSbVQrZXBnVzU2KzVDdzh0QjRrTVV2NnM5bGgzZVJLYnlHcytILzRtUU1hWXpQVGYyT09kb2tFbit6emd2b0QzRnFOS2s4UXFHQVhWc3FjR2RYclQ2MmZTUGtSMnZST0ZpNjhBNnNlODZVeFJVazRjYWpmUHlDQzRHNXdEaEQrek5xNGpvZFE0dTRuL20zN0xyMzZuNExJQUFzVnIwMmRGaTlBaXdBODFNWXMycm00ZURsRE5tZE1SdkVLUkhmQndXNURkTU5wMGpQRlpNZUFScUYvd0w0WEJmZCtFTUxCZk16cEg1R0g2TmFXKzF2cnZNZGcrVnhEemF0azNNWGdPM3JvM1AvRHBjQzYrTW80TXlTSmhLSmhTUjAxU0dHR3A1aFBXbXJyVWdydjNsRG5QK0hoY0kzbnQzWXFCb1ZBVlRCQVFUNWl1aFRnOG52UHRkOFplWWo2dzF4NlJxR1VCclNrdTcrTjErQmFhc1p2alRrNjRSb0lEbEw4YnJwRWNKeDNPbVk3akxvWnNzd2R0bWhmQy9HMjFsbFhoSVRPd212UkREZVRUUGJ5QVNPYTE2Y0Y1L0ExZlpBaWRKcHFqdTN3WUF5OWF2UFIxeWE2ZU5wOUs4WFlycnR1eGxxaStiREt3bGZyWWRSMFJSaUtSVlRMT0g4NStaWTdYU216UnBmWkJKamFUYTgxVkRjSkhwWm5ablNRTEFTR1lXOWw1MVpWL2g3ZVZ6VGkzSHY2aFVzZ2MvNTFBcUpSVGtwYkZWTFhYc3pvQkw4bkJYMHUvMGpCTFQ4bkgrZkplUGJyd1VSVDU4T1krVWllUmpkMXZzMDR3MFZHNVZOMlU2TW9HWmtRektOL3B0ejBRMzY2ZHhvVEdtajdpMU5RR0hpOUdnbnF1WEZZZHJDZlpCbWViN3MwVDZ5cmRsWkg1Y1p1d0hGeUlKL2tBdEdzVGcweEg1dGFBQXE0NEJBazFDUGs5S1ZWYnFRenJDVWlGZEYvNmd0bFBROGJISGMxRzFXOTJNWEdaNUhFSGZ0eUxZczhtYkQvOXhZUlVXa0htbE0wekMyaWxKbG5OZ1Y0YmZBTHBRZ2h4T1VvWkw3VlRxdENISWFRU1htK1lVTW5wa1h5Ym5WK0E2eGxtMkNWeThmbjBYbG0yWFJhMCt6ek9hMjFKV1dtaXhmaVBNU0NaN3FBNHJTOTNWTjNwa3BGMXM1VG9uUWppc0hmN2lVOVpHdlVQT0FLWmNSMXBiZVZmL1VsN09oZXBHQ2FJZDl3T3RxbzdwSjd5TGNCWjBwRmtPRjI4eTR6RUkva2NVTm11dEJIYVFwQmROTTh2akNTNkhaUm9ra2VvODhUQkFqR3lHN1NSKzZ2VWdUY3lLOUltYWxqMGt1eHowd21LK2J5UVUxMUFpSkZrL3lhNWROZHVSQ2xjblU2NHlHdS9pZVdTZU9vczF0M2VwK1JQSVdRMnB5VFlWYlpsdFRic2I3Tml3U2kzQVYrOEtMV2s3THhDbmZaVWV0RU04VGhuc1NvR0gzOC9ueUF3Rmd1SnA4Rmp2bEh0Y1dadVU0aFB2YTBySGZyMFVoT09KL0Y2dlM2MkZXN0t6a21SbGwySEVjN29VcTRmeWk1VDcwVmw3WVZJZnNQSFVDZEhlc2Y5TGs3V05WV083NUpEa1liTUk4VE9XOEpLVnRMWTlkNlVKUklUTzhvS28weFMrbzk5WXkwNGluaUdIQWFHajg4a0VXZ3d2ME9ySGRZL25yNzZET0dOUzU5aFhDR1h6VEtVdkRsOWlLcExTV1lOMWx4SWV5eXdkTnBUa2hheTc0dzJqRlQ2TlM4cWtqbzVDeEExeWZTWXdwNkFKSVpOS0llRUs1UEpBVzdPUmdXZ3dwMFZnellwcW92TXJXeGJ1K0RHWjZMaGllMVJBcXB6bThWVXpLSk9IM21Deld1VE9Mc04zVlQvZHYyZWVZZTlVamJSOFlUQnNMejdxNjBWTjFzVTUxayt1bTFmOEp4RDVwUGhiaFNDOHJSYUI0NTR0bWg2WVVXckpJMytHV1kwcWVXaW9qL3Ria1lJVE9rSmFldUd0NEpySnZIQStsMEd1N2tZN1hPYWEwNWFsTW5SV1ZDWHFGZ0xJd1NZNHVGNTlVZTVTVTRRS3VjL0hhbUR4YnIweDZjc0NldFhHb1A3UW4xQmsvSjlEc3luTy9VRDZpWjFIeXJ6K2ppdDBoREN3aS9FOU9qZ0tUYkIzWlFLUS8wWk92ZXZmTkhHME5LNEFqM0NwN05wUmswN1JUMWkvUzBFTDkzQWc4R1JnS0k5Q2ZwYWpLeUs2K0pqL1BJMUtPNS84NVZBd3oyQXd6UDhGVEJiMDc1SXhDWHY2VDlSVnZXVDJ0VWFxeERTOTJ6ckdVYld6VVlrOW1TczgycEVDSCtma3FzRHQ5M1ZXKys0WXNSL2RIQ1ljUVNZVE8vS2FCTURqOUxTRC9KLyt6MjBLcThYdlpVQUlIdG05aFJQUDNJdGJ1QXUySG01bGtQczkycGQ3a0N4Z1JzMHhPVkJuWjEzY2NkQTBhdW5yd3Y5U2RxRWxKUkMzZytvQ3Urblh5Q2dtWFVzOXlNalRNQUlIZnhaVithUEtjWmVVQld0MDU3WG84NUtzMUlyNWd6RUhDV3FaRWhyTFpNdUYxMXppR3RGUVVkcy9FRVNhamhhZ3pjS3N4YW1jU1p4R3RoNFVJSSthZFBoUWtVbngyV3lOKzRZV1IrcjNmOE1ua3lHRnVSNHpqenhKUzhXc1FZUjVQVHlSYUQ5aXhhNk1oNzQxbkJIYnpmalhIc2tHRHExNzl4YVJOckNJQjF6MXhSZldmanF3MnBIYzF6azl4bFBwTDhzUVdBSXVFVFpaaGJubUw1NHJjZVhWTlJ2VWlLcnJxSWtlb2dzbDBYWGIxN3lsTmIwZjRHQTlXZDQ0dmZmRUc4RlNaR0hFTDJmYmFUR1JjU2lDZUE4UG1BL2Y2SHo4SENTNzZmWFVId2d3a3pTd2xJNzFla1o3RmFwbWxrL0tDK0hzOGhVY3czTjJMTjVMaGtWWXlpellGbC91UGVWUDVsc29KSGhoZld2dlNXcnVDVVcxWmNKT2V1VGJyRGd5d0ovcUcwN2daSnBsblR2TGNZZE5hSDBLTVlPWU1HWCtyQjROR1BGbVFzTmFJd2xXcmZDZXp4cmU4elhCcnNNVCtlZFZMYkxxTjFCcUI3NkpINEJ2WlRxVUlNZkd3UEdFbitFbm1UVjg2ZlBCYVliRkwzREZFaGpCNDVDZXdrWEVBdEp4azQvTXMycFBYbmFScWRreTBIT1lkY1VjRTJ6Y1hxNHZhSXZXMi92MG5IRkpIMlhYZTIydWVEbXEvMThYR3RFTFNxODVqOVg4cTB0Y05TU0tKSVg4RlR1SkYvUGY4ajVQaHFHMnUrb3N2c0x4WXJ2dmZlVkpMKzR0a2NYY3I5SlY3djBFUm1qL1g2Zk0zTkM0ajZkUzErOVVtcjJvUGF2cWlBeWRUWlBMTU5SR1kyM0xPOXpBVkRseTdqRCs3MEc1VFBQTGRoUklsNFd4Y1lqTG5NK1NOY0oyNkZPcmtySVNVdFBPYkl6NVpiM0FHNjEya3JucHkxNVJNVysxY1FqbG5XRkk2NTM4cWt5OWF4ZDJvSm1ISUhQMDhLeVAwdWJHTytUUU5PWXV2MnVoMTd5Q0l2UjhWY1N0dzdvMWcwTk02MHNrKzhUcTdZZklCSnJ0cDUzR2t2elhIN09BMHA4L24vdTFzYXRmL1ZKaHRSMWw4V2E2R21hdWc3aGFTcGFDYVlRYXg2dGEwbWt1dGxiK2VBT1NHMWFvYk04MUQ5QTRpUzFSUmx6QkJvVlg2dFUxUzZXRTJOOU9SWTZEZmVMUkM0bDlSdnI1aDk1WERXQjJtUjFkNFdGdWRwc2dWWXdpVHdUMzFsanNrRDhaeURPbG01RGtHaDlOL1VCLzBBSTVYdmI4WkJtYWkyaFE0QldNcUZ3WW56eHdCMjZZSFNPdjlXZ1kzSlhudm9OKzJSNHJxR1ZoL0xMRE10cEZQK1NwTUdKTld2YklsNVNPb2RiQ2N6VzJSS2xla3NQb1VlR0V6cmp0S0hWZHRaQStrZnFPK3JWeC9pY2xDcXdvb3BlcHZKcFNURGpUK2I5R1d5bEdSRjhFRGJHbHc2ZVV6bUpNOTVPdm96K2t3TFgzYzJmVGpGZVlFc0U3dlVabTNtcWRHSnVLaDJ3OS9RR1NhcVJIczk5YVNjR09kRHFrRmNBQ29xZGJCb1FxcWphbWhINlE5bmczOUpDZzNsckdKd2Q1MFFrOW92bnFCVHI4TU1FN1BzMndpVmZ5Z1VtUG9VQkpKZkpXWDVOZGEwbnVuY2JGa0E9PScpKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluY2x1ZGUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ethersproject/hash/lib.esm/ens-normalize/include.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@ethersproject/hash/lib.esm/ens-normalize/lib.js":
/*!************************************************************************!*\
  !*** ../node_modules/@ethersproject/hash/lib.esm/ens-normalize/lib.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ens_normalize: () => (/* binding */ ens_normalize),\n/* harmony export */   ens_normalize_post_check: () => (/* binding */ ens_normalize_post_check)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_strings__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/strings */ \"(ssr)/../node_modules/@ethersproject/strings/lib.esm/utf8.js\");\n/* harmony import */ var _include_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./include.js */ \"(ssr)/../node_modules/@ethersproject/hash/lib.esm/ens-normalize/include.js\");\n/* harmony import */ var _decoder_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./decoder.js */ \"(ssr)/../node_modules/@ethersproject/hash/lib.esm/ens-normalize/decoder.js\");\n/**\n * MIT License\n *\n * Copyright (c) 2021 Andrew Raffensperger\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n *\n * This is a near carbon-copy of the original source (link below) with the\n * TypeScript typings added and a few tweaks to make it ES3-compatible.\n *\n * See: https://github.com/adraffy/ens-normalize.js\n */\n\n\nconst r = (0,_include_js__WEBPACK_IMPORTED_MODULE_0__.getData)();\n\n// @TODO: This should be lazily loaded\nconst VALID = new Set((0,_decoder_js__WEBPACK_IMPORTED_MODULE_1__.read_member_array)(r));\nconst IGNORED = new Set((0,_decoder_js__WEBPACK_IMPORTED_MODULE_1__.read_member_array)(r));\nconst MAPPED = (0,_decoder_js__WEBPACK_IMPORTED_MODULE_1__.read_mapped_map)(r);\nconst EMOJI_ROOT = (0,_decoder_js__WEBPACK_IMPORTED_MODULE_1__.read_emoji_trie)(r);\n//const NFC_CHECK = new Set(read_member_array(r, Array.from(VALID.values()).sort((a, b) => a - b)));\n//const STOP = 0x2E;\nconst HYPHEN = 0x2D;\nconst UNDERSCORE = 0x5F;\nfunction explode_cp(name) {\n    return (0,_ethersproject_strings__WEBPACK_IMPORTED_MODULE_2__.toUtf8CodePoints)(name);\n}\nfunction filter_fe0f(cps) {\n    return cps.filter(cp => cp != 0xFE0F);\n}\nfunction ens_normalize_post_check(name) {\n    for (let label of name.split('.')) {\n        let cps = explode_cp(label);\n        try {\n            for (let i = cps.lastIndexOf(UNDERSCORE) - 1; i >= 0; i--) {\n                if (cps[i] !== UNDERSCORE) {\n                    throw new Error(`underscore only allowed at start`);\n                }\n            }\n            if (cps.length >= 4 && cps.every(cp => cp < 0x80) && cps[2] === HYPHEN && cps[3] === HYPHEN) {\n                throw new Error(`invalid label extension`);\n            }\n        }\n        catch (err) {\n            throw new Error(`Invalid label \"${label}\": ${err.message}`);\n        }\n    }\n    return name;\n}\nfunction ens_normalize(name) {\n    return ens_normalize_post_check(normalize(name, filter_fe0f));\n}\nfunction normalize(name, emoji_filter) {\n    let input = explode_cp(name).reverse(); // flip for pop\n    let output = [];\n    while (input.length) {\n        let emoji = consume_emoji_reversed(input);\n        if (emoji) {\n            output.push(...emoji_filter(emoji));\n            continue;\n        }\n        let cp = input.pop();\n        if (VALID.has(cp)) {\n            output.push(cp);\n            continue;\n        }\n        if (IGNORED.has(cp)) {\n            continue;\n        }\n        let cps = MAPPED[cp];\n        if (cps) {\n            output.push(...cps);\n            continue;\n        }\n        throw new Error(`Disallowed codepoint: 0x${cp.toString(16).toUpperCase()}`);\n    }\n    return ens_normalize_post_check(nfc(String.fromCodePoint(...output)));\n}\nfunction nfc(s) {\n    return s.normalize('NFC');\n}\nfunction consume_emoji_reversed(cps, eaten) {\n    var _a;\n    let node = EMOJI_ROOT;\n    let emoji;\n    let saved;\n    let stack = [];\n    let pos = cps.length;\n    if (eaten)\n        eaten.length = 0; // clear input buffer (if needed)\n    while (pos) {\n        let cp = cps[--pos];\n        node = (_a = node.branches.find(x => x.set.has(cp))) === null || _a === void 0 ? void 0 : _a.node;\n        if (!node)\n            break;\n        if (node.save) { // remember\n            saved = cp;\n        }\n        else if (node.check) { // check exclusion\n            if (cp === saved)\n                break;\n        }\n        stack.push(cp);\n        if (node.fe0f) {\n            stack.push(0xFE0F);\n            if (pos > 0 && cps[pos - 1] == 0xFE0F)\n                pos--; // consume optional FE0F\n        }\n        if (node.valid) { // this is a valid emoji (so far)\n            emoji = stack.slice(); // copy stack\n            if (node.valid == 2)\n                emoji.splice(1, 1); // delete FE0F at position 1 (RGI ZWJ don't follow spec!)\n            if (eaten)\n                eaten.push(...cps.slice(pos).reverse()); // copy input (if needed)\n            cps.length = pos; // truncate\n        }\n    }\n    return emoji;\n}\n//# sourceMappingURL=lib.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2hhc2gvbGliLmVzbS9lbnMtbm9ybWFsaXplL2xpYi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQzBEO0FBQ25CO0FBQ3ZDLFVBQVUsb0RBQU87QUFDa0U7QUFDbkY7QUFDQSxzQkFBc0IsOERBQWlCO0FBQ3ZDLHdCQUF3Qiw4REFBaUI7QUFDekMsZUFBZSw0REFBZTtBQUM5QixtQkFBbUIsNERBQWU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsd0VBQWdCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsUUFBUTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsTUFBTSxLQUFLLFlBQVk7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELDhCQUE4QjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBLDBCQUEwQjtBQUMxQixtQ0FBbUM7QUFDbkM7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQSx5REFBeUQ7QUFDekQsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sZWRnaXR5LXlpZWxkLWZyb250ZW5kLy4uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9oYXNoL2xpYi5lc20vZW5zLW5vcm1hbGl6ZS9saWIuanM/NTcxOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIE1JVCBMaWNlbnNlXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDIxIEFuZHJldyBSYWZmZW5zcGVyZ2VyXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gKiBTT0ZUV0FSRS5cbiAqXG4gKiBUaGlzIGlzIGEgbmVhciBjYXJib24tY29weSBvZiB0aGUgb3JpZ2luYWwgc291cmNlIChsaW5rIGJlbG93KSB3aXRoIHRoZVxuICogVHlwZVNjcmlwdCB0eXBpbmdzIGFkZGVkIGFuZCBhIGZldyB0d2Vha3MgdG8gbWFrZSBpdCBFUzMtY29tcGF0aWJsZS5cbiAqXG4gKiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9hZHJhZmZ5L2Vucy1ub3JtYWxpemUuanNcbiAqL1xuaW1wb3J0IHsgdG9VdGY4Q29kZVBvaW50cyB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9zdHJpbmdzXCI7XG5pbXBvcnQgeyBnZXREYXRhIH0gZnJvbSAnLi9pbmNsdWRlLmpzJztcbmNvbnN0IHIgPSBnZXREYXRhKCk7XG5pbXBvcnQgeyByZWFkX21lbWJlcl9hcnJheSwgcmVhZF9tYXBwZWRfbWFwLCByZWFkX2Vtb2ppX3RyaWUgfSBmcm9tICcuL2RlY29kZXIuanMnO1xuLy8gQFRPRE86IFRoaXMgc2hvdWxkIGJlIGxhemlseSBsb2FkZWRcbmNvbnN0IFZBTElEID0gbmV3IFNldChyZWFkX21lbWJlcl9hcnJheShyKSk7XG5jb25zdCBJR05PUkVEID0gbmV3IFNldChyZWFkX21lbWJlcl9hcnJheShyKSk7XG5jb25zdCBNQVBQRUQgPSByZWFkX21hcHBlZF9tYXAocik7XG5jb25zdCBFTU9KSV9ST09UID0gcmVhZF9lbW9qaV90cmllKHIpO1xuLy9jb25zdCBORkNfQ0hFQ0sgPSBuZXcgU2V0KHJlYWRfbWVtYmVyX2FycmF5KHIsIEFycmF5LmZyb20oVkFMSUQudmFsdWVzKCkpLnNvcnQoKGEsIGIpID0+IGEgLSBiKSkpO1xuLy9jb25zdCBTVE9QID0gMHgyRTtcbmNvbnN0IEhZUEhFTiA9IDB4MkQ7XG5jb25zdCBVTkRFUlNDT1JFID0gMHg1RjtcbmZ1bmN0aW9uIGV4cGxvZGVfY3AobmFtZSkge1xuICAgIHJldHVybiB0b1V0ZjhDb2RlUG9pbnRzKG5hbWUpO1xufVxuZnVuY3Rpb24gZmlsdGVyX2ZlMGYoY3BzKSB7XG4gICAgcmV0dXJuIGNwcy5maWx0ZXIoY3AgPT4gY3AgIT0gMHhGRTBGKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBlbnNfbm9ybWFsaXplX3Bvc3RfY2hlY2sobmFtZSkge1xuICAgIGZvciAobGV0IGxhYmVsIG9mIG5hbWUuc3BsaXQoJy4nKSkge1xuICAgICAgICBsZXQgY3BzID0gZXhwbG9kZV9jcChsYWJlbCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gY3BzLmxhc3RJbmRleE9mKFVOREVSU0NPUkUpIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICBpZiAoY3BzW2ldICE9PSBVTkRFUlNDT1JFKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5kZXJzY29yZSBvbmx5IGFsbG93ZWQgYXQgc3RhcnRgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3BzLmxlbmd0aCA+PSA0ICYmIGNwcy5ldmVyeShjcCA9PiBjcCA8IDB4ODApICYmIGNwc1syXSA9PT0gSFlQSEVOICYmIGNwc1szXSA9PT0gSFlQSEVOKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGxhYmVsIGV4dGVuc2lvbmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBsYWJlbCBcIiR7bGFiZWx9XCI6ICR7ZXJyLm1lc3NhZ2V9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5hbWU7XG59XG5leHBvcnQgZnVuY3Rpb24gZW5zX25vcm1hbGl6ZShuYW1lKSB7XG4gICAgcmV0dXJuIGVuc19ub3JtYWxpemVfcG9zdF9jaGVjayhub3JtYWxpemUobmFtZSwgZmlsdGVyX2ZlMGYpKTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZShuYW1lLCBlbW9qaV9maWx0ZXIpIHtcbiAgICBsZXQgaW5wdXQgPSBleHBsb2RlX2NwKG5hbWUpLnJldmVyc2UoKTsgLy8gZmxpcCBmb3IgcG9wXG4gICAgbGV0IG91dHB1dCA9IFtdO1xuICAgIHdoaWxlIChpbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgbGV0IGVtb2ppID0gY29uc3VtZV9lbW9qaV9yZXZlcnNlZChpbnB1dCk7XG4gICAgICAgIGlmIChlbW9qaSkge1xuICAgICAgICAgICAgb3V0cHV0LnB1c2goLi4uZW1vamlfZmlsdGVyKGVtb2ppKSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY3AgPSBpbnB1dC5wb3AoKTtcbiAgICAgICAgaWYgKFZBTElELmhhcyhjcCkpIHtcbiAgICAgICAgICAgIG91dHB1dC5wdXNoKGNwKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChJR05PUkVELmhhcyhjcCkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjcHMgPSBNQVBQRURbY3BdO1xuICAgICAgICBpZiAoY3BzKSB7XG4gICAgICAgICAgICBvdXRwdXQucHVzaCguLi5jcHMpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEaXNhbGxvd2VkIGNvZGVwb2ludDogMHgke2NwLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpfWApO1xuICAgIH1cbiAgICByZXR1cm4gZW5zX25vcm1hbGl6ZV9wb3N0X2NoZWNrKG5mYyhTdHJpbmcuZnJvbUNvZGVQb2ludCguLi5vdXRwdXQpKSk7XG59XG5mdW5jdGlvbiBuZmMocykge1xuICAgIHJldHVybiBzLm5vcm1hbGl6ZSgnTkZDJyk7XG59XG5mdW5jdGlvbiBjb25zdW1lX2Vtb2ppX3JldmVyc2VkKGNwcywgZWF0ZW4pIHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IG5vZGUgPSBFTU9KSV9ST09UO1xuICAgIGxldCBlbW9qaTtcbiAgICBsZXQgc2F2ZWQ7XG4gICAgbGV0IHN0YWNrID0gW107XG4gICAgbGV0IHBvcyA9IGNwcy5sZW5ndGg7XG4gICAgaWYgKGVhdGVuKVxuICAgICAgICBlYXRlbi5sZW5ndGggPSAwOyAvLyBjbGVhciBpbnB1dCBidWZmZXIgKGlmIG5lZWRlZClcbiAgICB3aGlsZSAocG9zKSB7XG4gICAgICAgIGxldCBjcCA9IGNwc1stLXBvc107XG4gICAgICAgIG5vZGUgPSAoX2EgPSBub2RlLmJyYW5jaGVzLmZpbmQoeCA9PiB4LnNldC5oYXMoY3ApKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm5vZGU7XG4gICAgICAgIGlmICghbm9kZSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBpZiAobm9kZS5zYXZlKSB7IC8vIHJlbWVtYmVyXG4gICAgICAgICAgICBzYXZlZCA9IGNwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGUuY2hlY2spIHsgLy8gY2hlY2sgZXhjbHVzaW9uXG4gICAgICAgICAgICBpZiAoY3AgPT09IHNhdmVkKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0YWNrLnB1c2goY3ApO1xuICAgICAgICBpZiAobm9kZS5mZTBmKSB7XG4gICAgICAgICAgICBzdGFjay5wdXNoKDB4RkUwRik7XG4gICAgICAgICAgICBpZiAocG9zID4gMCAmJiBjcHNbcG9zIC0gMV0gPT0gMHhGRTBGKVxuICAgICAgICAgICAgICAgIHBvcy0tOyAvLyBjb25zdW1lIG9wdGlvbmFsIEZFMEZcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS52YWxpZCkgeyAvLyB0aGlzIGlzIGEgdmFsaWQgZW1vamkgKHNvIGZhcilcbiAgICAgICAgICAgIGVtb2ppID0gc3RhY2suc2xpY2UoKTsgLy8gY29weSBzdGFja1xuICAgICAgICAgICAgaWYgKG5vZGUudmFsaWQgPT0gMilcbiAgICAgICAgICAgICAgICBlbW9qaS5zcGxpY2UoMSwgMSk7IC8vIGRlbGV0ZSBGRTBGIGF0IHBvc2l0aW9uIDEgKFJHSSBaV0ogZG9uJ3QgZm9sbG93IHNwZWMhKVxuICAgICAgICAgICAgaWYgKGVhdGVuKVxuICAgICAgICAgICAgICAgIGVhdGVuLnB1c2goLi4uY3BzLnNsaWNlKHBvcykucmV2ZXJzZSgpKTsgLy8gY29weSBpbnB1dCAoaWYgbmVlZGVkKVxuICAgICAgICAgICAgY3BzLmxlbmd0aCA9IHBvczsgLy8gdHJ1bmNhdGVcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZW1vamk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1saWIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ethersproject/hash/lib.esm/ens-normalize/lib.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@ethersproject/hash/lib.esm/id.js":
/*!*********************************************************!*\
  !*** ../node_modules/@ethersproject/hash/lib.esm/id.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   id: () => (/* binding */ id)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/keccak256 */ \"(ssr)/../node_modules/@ethersproject/keccak256/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_strings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/strings */ \"(ssr)/../node_modules/@ethersproject/strings/lib.esm/utf8.js\");\n\n\nfunction id(text) {\n    return (0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_0__.keccak256)((0,_ethersproject_strings__WEBPACK_IMPORTED_MODULE_1__.toUtf8Bytes)(text));\n}\n//# sourceMappingURL=id.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2hhc2gvbGliLmVzbS9pZC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBcUQ7QUFDQTtBQUM5QztBQUNQLFdBQVcsbUVBQVMsQ0FBQyxtRUFBVztBQUNoQztBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGVkZ2l0eS15aWVsZC1mcm9udGVuZC8uLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvaGFzaC9saWIuZXNtL2lkLmpzPzk5NWUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsga2VjY2FrMjU2IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2tlY2NhazI1NlwiO1xuaW1wb3J0IHsgdG9VdGY4Qnl0ZXMgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3Qvc3RyaW5nc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIGlkKHRleHQpIHtcbiAgICByZXR1cm4ga2VjY2FrMjU2KHRvVXRmOEJ5dGVzKHRleHQpKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlkLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ethersproject/hash/lib.esm/id.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@ethersproject/hash/lib.esm/namehash.js":
/*!***************************************************************!*\
  !*** ../node_modules/@ethersproject/hash/lib.esm/namehash.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   dnsEncode: () => (/* binding */ dnsEncode),\n/* harmony export */   ensNormalize: () => (/* binding */ ensNormalize),\n/* harmony export */   isValidName: () => (/* binding */ isValidName),\n/* harmony export */   namehash: () => (/* binding */ namehash)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/../node_modules/@ethersproject/bytes/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_strings__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/strings */ \"(ssr)/../node_modules/@ethersproject/strings/lib.esm/utf8.js\");\n/* harmony import */ var _ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethersproject/keccak256 */ \"(ssr)/../node_modules/@ethersproject/keccak256/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/../node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(ssr)/../node_modules/@ethersproject/hash/lib.esm/_version.js\");\n/* harmony import */ var _ens_normalize_lib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ens-normalize/lib */ \"(ssr)/../node_modules/@ethersproject/hash/lib.esm/ens-normalize/lib.js\");\n\n\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\n\nconst Zeros = new Uint8Array(32);\nZeros.fill(0);\nfunction checkComponent(comp) {\n    if (comp.length === 0) {\n        throw new Error(\"invalid ENS name; empty component\");\n    }\n    return comp;\n}\nfunction ensNameSplit(name) {\n    const bytes = (0,_ethersproject_strings__WEBPACK_IMPORTED_MODULE_2__.toUtf8Bytes)((0,_ens_normalize_lib__WEBPACK_IMPORTED_MODULE_3__.ens_normalize)(name));\n    const comps = [];\n    if (name.length === 0) {\n        return comps;\n    }\n    let last = 0;\n    for (let i = 0; i < bytes.length; i++) {\n        const d = bytes[i];\n        // A separator (i.e. \".\"); copy this component\n        if (d === 0x2e) {\n            comps.push(checkComponent(bytes.slice(last, i)));\n            last = i + 1;\n        }\n    }\n    // There was a stray separator at the end of the name\n    if (last >= bytes.length) {\n        throw new Error(\"invalid ENS name; empty component\");\n    }\n    comps.push(checkComponent(bytes.slice(last)));\n    return comps;\n}\nfunction ensNormalize(name) {\n    return ensNameSplit(name).map((comp) => (0,_ethersproject_strings__WEBPACK_IMPORTED_MODULE_2__.toUtf8String)(comp)).join(\".\");\n}\nfunction isValidName(name) {\n    try {\n        return (ensNameSplit(name).length !== 0);\n    }\n    catch (error) { }\n    return false;\n}\nfunction namehash(name) {\n    /* istanbul ignore if */\n    if (typeof (name) !== \"string\") {\n        logger.throwArgumentError(\"invalid ENS name; not a string\", \"name\", name);\n    }\n    let result = Zeros;\n    const comps = ensNameSplit(name);\n    while (comps.length) {\n        result = (0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_4__.keccak256)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__.concat)([result, (0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_4__.keccak256)(comps.pop())]));\n    }\n    return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__.hexlify)(result);\n}\nfunction dnsEncode(name) {\n    return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__.hexlify)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__.concat)(ensNameSplit(name).map((comp) => {\n        // DNS does not allow components over 63 bytes in length\n        if (comp.length > 63) {\n            throw new Error(\"invalid DNS encoded entry; length exceeds 63 bytes\");\n        }\n        const bytes = new Uint8Array(comp.length + 1);\n        bytes.set(comp, 1);\n        bytes[0] = bytes.length - 1;\n        return bytes;\n    }))) + \"00\";\n}\n//# sourceMappingURL=namehash.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2hhc2gvbGliLmVzbS9uYW1laGFzaC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQXVEO0FBQ1k7QUFDZDtBQUNOO0FBQ1Y7QUFDckMsbUJBQW1CLHlEQUFNLENBQUMsNkNBQU87QUFDbUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsbUVBQVcsQ0FBQyxpRUFBYTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsNENBQTRDLG9FQUFZO0FBQ3hEO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsbUVBQVMsQ0FBQyw0REFBTSxVQUFVLG1FQUFTO0FBQ3BEO0FBQ0EsV0FBVyw2REFBTztBQUNsQjtBQUNPO0FBQ1AsV0FBVyw2REFBTyxDQUFDLDREQUFNO0FBQ3pCO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGVkZ2l0eS15aWVsZC1mcm9udGVuZC8uLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvaGFzaC9saWIuZXNtL25hbWVoYXNoLmpzPzUwY2YiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY29uY2F0LCBoZXhsaWZ5IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2J5dGVzXCI7XG5pbXBvcnQgeyB0b1V0ZjhCeXRlcywgdG9VdGY4U3RyaW5nIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3N0cmluZ3NcIjtcbmltcG9ydCB7IGtlY2NhazI1NiB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9rZWNjYWsyNTZcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi9fdmVyc2lvblwiO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcih2ZXJzaW9uKTtcbmltcG9ydCB7IGVuc19ub3JtYWxpemUgfSBmcm9tIFwiLi9lbnMtbm9ybWFsaXplL2xpYlwiO1xuY29uc3QgWmVyb3MgPSBuZXcgVWludDhBcnJheSgzMik7XG5aZXJvcy5maWxsKDApO1xuZnVuY3Rpb24gY2hlY2tDb21wb25lbnQoY29tcCkge1xuICAgIGlmIChjb21wLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIEVOUyBuYW1lOyBlbXB0eSBjb21wb25lbnRcIik7XG4gICAgfVxuICAgIHJldHVybiBjb21wO1xufVxuZnVuY3Rpb24gZW5zTmFtZVNwbGl0KG5hbWUpIHtcbiAgICBjb25zdCBieXRlcyA9IHRvVXRmOEJ5dGVzKGVuc19ub3JtYWxpemUobmFtZSkpO1xuICAgIGNvbnN0IGNvbXBzID0gW107XG4gICAgaWYgKG5hbWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBjb21wcztcbiAgICB9XG4gICAgbGV0IGxhc3QgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgZCA9IGJ5dGVzW2ldO1xuICAgICAgICAvLyBBIHNlcGFyYXRvciAoaS5lLiBcIi5cIik7IGNvcHkgdGhpcyBjb21wb25lbnRcbiAgICAgICAgaWYgKGQgPT09IDB4MmUpIHtcbiAgICAgICAgICAgIGNvbXBzLnB1c2goY2hlY2tDb21wb25lbnQoYnl0ZXMuc2xpY2UobGFzdCwgaSkpKTtcbiAgICAgICAgICAgIGxhc3QgPSBpICsgMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBUaGVyZSB3YXMgYSBzdHJheSBzZXBhcmF0b3IgYXQgdGhlIGVuZCBvZiB0aGUgbmFtZVxuICAgIGlmIChsYXN0ID49IGJ5dGVzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIEVOUyBuYW1lOyBlbXB0eSBjb21wb25lbnRcIik7XG4gICAgfVxuICAgIGNvbXBzLnB1c2goY2hlY2tDb21wb25lbnQoYnl0ZXMuc2xpY2UobGFzdCkpKTtcbiAgICByZXR1cm4gY29tcHM7XG59XG5leHBvcnQgZnVuY3Rpb24gZW5zTm9ybWFsaXplKG5hbWUpIHtcbiAgICByZXR1cm4gZW5zTmFtZVNwbGl0KG5hbWUpLm1hcCgoY29tcCkgPT4gdG9VdGY4U3RyaW5nKGNvbXApKS5qb2luKFwiLlwiKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkTmFtZShuYW1lKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIChlbnNOYW1lU3BsaXQobmFtZSkubGVuZ3RoICE9PSAwKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnQgZnVuY3Rpb24gbmFtZWhhc2gobmFtZSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICh0eXBlb2YgKG5hbWUpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIEVOUyBuYW1lOyBub3QgYSBzdHJpbmdcIiwgXCJuYW1lXCIsIG5hbWUpO1xuICAgIH1cbiAgICBsZXQgcmVzdWx0ID0gWmVyb3M7XG4gICAgY29uc3QgY29tcHMgPSBlbnNOYW1lU3BsaXQobmFtZSk7XG4gICAgd2hpbGUgKGNvbXBzLmxlbmd0aCkge1xuICAgICAgICByZXN1bHQgPSBrZWNjYWsyNTYoY29uY2F0KFtyZXN1bHQsIGtlY2NhazI1Nihjb21wcy5wb3AoKSldKSk7XG4gICAgfVxuICAgIHJldHVybiBoZXhsaWZ5KHJlc3VsdCk7XG59XG5leHBvcnQgZnVuY3Rpb24gZG5zRW5jb2RlKG5hbWUpIHtcbiAgICByZXR1cm4gaGV4bGlmeShjb25jYXQoZW5zTmFtZVNwbGl0KG5hbWUpLm1hcCgoY29tcCkgPT4ge1xuICAgICAgICAvLyBETlMgZG9lcyBub3QgYWxsb3cgY29tcG9uZW50cyBvdmVyIDYzIGJ5dGVzIGluIGxlbmd0aFxuICAgICAgICBpZiAoY29tcC5sZW5ndGggPiA2Mykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBETlMgZW5jb2RlZCBlbnRyeTsgbGVuZ3RoIGV4Y2VlZHMgNjMgYnl0ZXNcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShjb21wLmxlbmd0aCArIDEpO1xuICAgICAgICBieXRlcy5zZXQoY29tcCwgMSk7XG4gICAgICAgIGJ5dGVzWzBdID0gYnl0ZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIH0pKSkgKyBcIjAwXCI7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1uYW1laGFzaC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ethersproject/hash/lib.esm/namehash.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@ethersproject/hash/lib.esm/typed-data.js":
/*!*****************************************************************!*\
  !*** ../node_modules/@ethersproject/hash/lib.esm/typed-data.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TypedDataEncoder: () => (/* binding */ TypedDataEncoder)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_address__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethersproject/address */ \"(ssr)/../node_modules/@ethersproject/address/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/bignumber */ \"(ssr)/../node_modules/@ethersproject/bignumber/lib.esm/bignumber.js\");\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/../node_modules/@ethersproject/bytes/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ethersproject/keccak256 */ \"(ssr)/../node_modules/@ethersproject/keccak256/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/../node_modules/@ethersproject/properties/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/../node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(ssr)/../node_modules/@ethersproject/hash/lib.esm/_version.js\");\n/* harmony import */ var _id__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./id */ \"(ssr)/../node_modules/@ethersproject/hash/lib.esm/id.js\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\n\nconst padding = new Uint8Array(32);\npadding.fill(0);\nconst NegativeOne = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_2__.BigNumber.from(-1);\nconst Zero = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_2__.BigNumber.from(0);\nconst One = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_2__.BigNumber.from(1);\nconst MaxUint256 = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_2__.BigNumber.from(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\nfunction hexPadRight(value) {\n    const bytes = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.arrayify)(value);\n    const padOffset = bytes.length % 32;\n    if (padOffset) {\n        return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexConcat)([bytes, padding.slice(padOffset)]);\n    }\n    return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexlify)(bytes);\n}\nconst hexTrue = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexZeroPad)(One.toHexString(), 32);\nconst hexFalse = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexZeroPad)(Zero.toHexString(), 32);\nconst domainFieldTypes = {\n    name: \"string\",\n    version: \"string\",\n    chainId: \"uint256\",\n    verifyingContract: \"address\",\n    salt: \"bytes32\"\n};\nconst domainFieldNames = [\n    \"name\", \"version\", \"chainId\", \"verifyingContract\", \"salt\"\n];\nfunction checkString(key) {\n    return function (value) {\n        if (typeof (value) !== \"string\") {\n            logger.throwArgumentError(`invalid domain value for ${JSON.stringify(key)}`, `domain.${key}`, value);\n        }\n        return value;\n    };\n}\nconst domainChecks = {\n    name: checkString(\"name\"),\n    version: checkString(\"version\"),\n    chainId: function (value) {\n        try {\n            return _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_2__.BigNumber.from(value).toString();\n        }\n        catch (error) { }\n        return logger.throwArgumentError(`invalid domain value for \"chainId\"`, \"domain.chainId\", value);\n    },\n    verifyingContract: function (value) {\n        try {\n            return (0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_4__.getAddress)(value).toLowerCase();\n        }\n        catch (error) { }\n        return logger.throwArgumentError(`invalid domain value \"verifyingContract\"`, \"domain.verifyingContract\", value);\n    },\n    salt: function (value) {\n        try {\n            const bytes = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.arrayify)(value);\n            if (bytes.length !== 32) {\n                throw new Error(\"bad length\");\n            }\n            return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexlify)(bytes);\n        }\n        catch (error) { }\n        return logger.throwArgumentError(`invalid domain value \"salt\"`, \"domain.salt\", value);\n    }\n};\nfunction getBaseEncoder(type) {\n    // intXX and uintXX\n    {\n        const match = type.match(/^(u?)int(\\d*)$/);\n        if (match) {\n            const signed = (match[1] === \"\");\n            const width = parseInt(match[2] || \"256\");\n            if (width % 8 !== 0 || width > 256 || (match[2] && match[2] !== String(width))) {\n                logger.throwArgumentError(\"invalid numeric width\", \"type\", type);\n            }\n            const boundsUpper = MaxUint256.mask(signed ? (width - 1) : width);\n            const boundsLower = signed ? boundsUpper.add(One).mul(NegativeOne) : Zero;\n            return function (value) {\n                const v = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_2__.BigNumber.from(value);\n                if (v.lt(boundsLower) || v.gt(boundsUpper)) {\n                    logger.throwArgumentError(`value out-of-bounds for ${type}`, \"value\", value);\n                }\n                return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexZeroPad)(v.toTwos(256).toHexString(), 32);\n            };\n        }\n    }\n    // bytesXX\n    {\n        const match = type.match(/^bytes(\\d+)$/);\n        if (match) {\n            const width = parseInt(match[1]);\n            if (width === 0 || width > 32 || match[1] !== String(width)) {\n                logger.throwArgumentError(\"invalid bytes width\", \"type\", type);\n            }\n            return function (value) {\n                const bytes = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.arrayify)(value);\n                if (bytes.length !== width) {\n                    logger.throwArgumentError(`invalid length for ${type}`, \"value\", value);\n                }\n                return hexPadRight(value);\n            };\n        }\n    }\n    switch (type) {\n        case \"address\": return function (value) {\n            return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexZeroPad)((0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_4__.getAddress)(value), 32);\n        };\n        case \"bool\": return function (value) {\n            return ((!value) ? hexFalse : hexTrue);\n        };\n        case \"bytes\": return function (value) {\n            return (0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_5__.keccak256)(value);\n        };\n        case \"string\": return function (value) {\n            return (0,_id__WEBPACK_IMPORTED_MODULE_6__.id)(value);\n        };\n    }\n    return null;\n}\nfunction encodeType(name, fields) {\n    return `${name}(${fields.map(({ name, type }) => (type + \" \" + name)).join(\",\")})`;\n}\nclass TypedDataEncoder {\n    constructor(types) {\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_7__.defineReadOnly)(this, \"types\", Object.freeze((0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_7__.deepCopy)(types)));\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_7__.defineReadOnly)(this, \"_encoderCache\", {});\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_7__.defineReadOnly)(this, \"_types\", {});\n        // Link struct types to their direct child structs\n        const links = {};\n        // Link structs to structs which contain them as a child\n        const parents = {};\n        // Link all subtypes within a given struct\n        const subtypes = {};\n        Object.keys(types).forEach((type) => {\n            links[type] = {};\n            parents[type] = [];\n            subtypes[type] = {};\n        });\n        for (const name in types) {\n            const uniqueNames = {};\n            types[name].forEach((field) => {\n                // Check each field has a unique name\n                if (uniqueNames[field.name]) {\n                    logger.throwArgumentError(`duplicate variable name ${JSON.stringify(field.name)} in ${JSON.stringify(name)}`, \"types\", types);\n                }\n                uniqueNames[field.name] = true;\n                // Get the base type (drop any array specifiers)\n                const baseType = field.type.match(/^([^\\x5b]*)(\\x5b|$)/)[1];\n                if (baseType === name) {\n                    logger.throwArgumentError(`circular type reference to ${JSON.stringify(baseType)}`, \"types\", types);\n                }\n                // Is this a base encoding type?\n                const encoder = getBaseEncoder(baseType);\n                if (encoder) {\n                    return;\n                }\n                if (!parents[baseType]) {\n                    logger.throwArgumentError(`unknown type ${JSON.stringify(baseType)}`, \"types\", types);\n                }\n                // Add linkage\n                parents[baseType].push(name);\n                links[name][baseType] = true;\n            });\n        }\n        // Deduce the primary type\n        const primaryTypes = Object.keys(parents).filter((n) => (parents[n].length === 0));\n        if (primaryTypes.length === 0) {\n            logger.throwArgumentError(\"missing primary type\", \"types\", types);\n        }\n        else if (primaryTypes.length > 1) {\n            logger.throwArgumentError(`ambiguous primary types or unused types: ${primaryTypes.map((t) => (JSON.stringify(t))).join(\", \")}`, \"types\", types);\n        }\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_7__.defineReadOnly)(this, \"primaryType\", primaryTypes[0]);\n        // Check for circular type references\n        function checkCircular(type, found) {\n            if (found[type]) {\n                logger.throwArgumentError(`circular type reference to ${JSON.stringify(type)}`, \"types\", types);\n            }\n            found[type] = true;\n            Object.keys(links[type]).forEach((child) => {\n                if (!parents[child]) {\n                    return;\n                }\n                // Recursively check children\n                checkCircular(child, found);\n                // Mark all ancestors as having this decendant\n                Object.keys(found).forEach((subtype) => {\n                    subtypes[subtype][child] = true;\n                });\n            });\n            delete found[type];\n        }\n        checkCircular(this.primaryType, {});\n        // Compute each fully describe type\n        for (const name in subtypes) {\n            const st = Object.keys(subtypes[name]);\n            st.sort();\n            this._types[name] = encodeType(name, types[name]) + st.map((t) => encodeType(t, types[t])).join(\"\");\n        }\n    }\n    getEncoder(type) {\n        let encoder = this._encoderCache[type];\n        if (!encoder) {\n            encoder = this._encoderCache[type] = this._getEncoder(type);\n        }\n        return encoder;\n    }\n    _getEncoder(type) {\n        // Basic encoder type (address, bool, uint256, etc)\n        {\n            const encoder = getBaseEncoder(type);\n            if (encoder) {\n                return encoder;\n            }\n        }\n        // Array\n        const match = type.match(/^(.*)(\\x5b(\\d*)\\x5d)$/);\n        if (match) {\n            const subtype = match[1];\n            const subEncoder = this.getEncoder(subtype);\n            const length = parseInt(match[3]);\n            return (value) => {\n                if (length >= 0 && value.length !== length) {\n                    logger.throwArgumentError(\"array length mismatch; expected length ${ arrayLength }\", \"value\", value);\n                }\n                let result = value.map(subEncoder);\n                if (this._types[subtype]) {\n                    result = result.map(_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_5__.keccak256);\n                }\n                return (0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_5__.keccak256)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexConcat)(result));\n            };\n        }\n        // Struct\n        const fields = this.types[type];\n        if (fields) {\n            const encodedType = (0,_id__WEBPACK_IMPORTED_MODULE_6__.id)(this._types[type]);\n            return (value) => {\n                const values = fields.map(({ name, type }) => {\n                    const result = this.getEncoder(type)(value[name]);\n                    if (this._types[type]) {\n                        return (0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_5__.keccak256)(result);\n                    }\n                    return result;\n                });\n                values.unshift(encodedType);\n                return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexConcat)(values);\n            };\n        }\n        return logger.throwArgumentError(`unknown type: ${type}`, \"type\", type);\n    }\n    encodeType(name) {\n        const result = this._types[name];\n        if (!result) {\n            logger.throwArgumentError(`unknown type: ${JSON.stringify(name)}`, \"name\", name);\n        }\n        return result;\n    }\n    encodeData(type, value) {\n        return this.getEncoder(type)(value);\n    }\n    hashStruct(name, value) {\n        return (0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_5__.keccak256)(this.encodeData(name, value));\n    }\n    encode(value) {\n        return this.encodeData(this.primaryType, value);\n    }\n    hash(value) {\n        return this.hashStruct(this.primaryType, value);\n    }\n    _visit(type, value, callback) {\n        // Basic encoder type (address, bool, uint256, etc)\n        {\n            const encoder = getBaseEncoder(type);\n            if (encoder) {\n                return callback(type, value);\n            }\n        }\n        // Array\n        const match = type.match(/^(.*)(\\x5b(\\d*)\\x5d)$/);\n        if (match) {\n            const subtype = match[1];\n            const length = parseInt(match[3]);\n            if (length >= 0 && value.length !== length) {\n                logger.throwArgumentError(\"array length mismatch; expected length ${ arrayLength }\", \"value\", value);\n            }\n            return value.map((v) => this._visit(subtype, v, callback));\n        }\n        // Struct\n        const fields = this.types[type];\n        if (fields) {\n            return fields.reduce((accum, { name, type }) => {\n                accum[name] = this._visit(type, value[name], callback);\n                return accum;\n            }, {});\n        }\n        return logger.throwArgumentError(`unknown type: ${type}`, \"type\", type);\n    }\n    visit(value, callback) {\n        return this._visit(this.primaryType, value, callback);\n    }\n    static from(types) {\n        return new TypedDataEncoder(types);\n    }\n    static getPrimaryType(types) {\n        return TypedDataEncoder.from(types).primaryType;\n    }\n    static hashStruct(name, types, value) {\n        return TypedDataEncoder.from(types).hashStruct(name, value);\n    }\n    static hashDomain(domain) {\n        const domainFields = [];\n        for (const name in domain) {\n            const type = domainFieldTypes[name];\n            if (!type) {\n                logger.throwArgumentError(`invalid typed-data domain key: ${JSON.stringify(name)}`, \"domain\", domain);\n            }\n            domainFields.push({ name, type });\n        }\n        domainFields.sort((a, b) => {\n            return domainFieldNames.indexOf(a.name) - domainFieldNames.indexOf(b.name);\n        });\n        return TypedDataEncoder.hashStruct(\"EIP712Domain\", { EIP712Domain: domainFields }, domain);\n    }\n    static encode(domain, types, value) {\n        return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexConcat)([\n            \"0x1901\",\n            TypedDataEncoder.hashDomain(domain),\n            TypedDataEncoder.from(types).hash(value)\n        ]);\n    }\n    static hash(domain, types, value) {\n        return (0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_5__.keccak256)(TypedDataEncoder.encode(domain, types, value));\n    }\n    // Replaces all address types with ENS names with their looked up address\n    static resolveNames(domain, types, value, resolveName) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Make a copy to isolate it from the object passed in\n            domain = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_7__.shallowCopy)(domain);\n            // Look up all ENS names\n            const ensCache = {};\n            // Do we need to look up the domain's verifyingContract?\n            if (domain.verifyingContract && !(0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.isHexString)(domain.verifyingContract, 20)) {\n                ensCache[domain.verifyingContract] = \"0x\";\n            }\n            // We are going to use the encoder to visit all the base values\n            const encoder = TypedDataEncoder.from(types);\n            // Get a list of all the addresses\n            encoder.visit(value, (type, value) => {\n                if (type === \"address\" && !(0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.isHexString)(value, 20)) {\n                    ensCache[value] = \"0x\";\n                }\n                return value;\n            });\n            // Lookup each name\n            for (const name in ensCache) {\n                ensCache[name] = yield resolveName(name);\n            }\n            // Replace the domain verifyingContract if needed\n            if (domain.verifyingContract && ensCache[domain.verifyingContract]) {\n                domain.verifyingContract = ensCache[domain.verifyingContract];\n            }\n            // Replace all ENS names with their address\n            value = encoder.visit(value, (type, value) => {\n                if (type === \"address\" && ensCache[value]) {\n                    return ensCache[value];\n                }\n                return value;\n            });\n            return { domain, value };\n        });\n    }\n    static getPayload(domain, types, value) {\n        // Validate the domain fields\n        TypedDataEncoder.hashDomain(domain);\n        // Derive the EIP712Domain Struct reference type\n        const domainValues = {};\n        const domainTypes = [];\n        domainFieldNames.forEach((name) => {\n            const value = domain[name];\n            if (value == null) {\n                return;\n            }\n            domainValues[name] = domainChecks[name](value);\n            domainTypes.push({ name, type: domainFieldTypes[name] });\n        });\n        const encoder = TypedDataEncoder.from(types);\n        const typesWithDomain = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_7__.shallowCopy)(types);\n        if (typesWithDomain.EIP712Domain) {\n            logger.throwArgumentError(\"types must not contain EIP712Domain type\", \"types.EIP712Domain\", types);\n        }\n        else {\n            typesWithDomain.EIP712Domain = domainTypes;\n        }\n        // Validate the data structures and types\n        encoder.encode(value);\n        return {\n            types: typesWithDomain,\n            domain: domainValues,\n            primaryType: encoder.primaryType,\n            message: encoder.visit(value, (type, value) => {\n                // bytes\n                if (type.match(/^bytes(\\d*)/)) {\n                    return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexlify)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.arrayify)(value));\n                }\n                // uint or int\n                if (type.match(/^u?int/)) {\n                    return _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_2__.BigNumber.from(value).toString();\n                }\n                switch (type) {\n                    case \"address\":\n                        return value.toLowerCase();\n                    case \"bool\":\n                        return !!value;\n                    case \"string\":\n                        if (typeof (value) !== \"string\") {\n                            logger.throwArgumentError(`invalid string`, \"value\", value);\n                        }\n                        return value;\n                }\n                return logger.throwArgumentError(\"unsupported type\", \"type\", type);\n            })\n        };\n    }\n}\n//# sourceMappingURL=typed-data.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2hhc2gvbGliLmVzbS90eXBlZC1kYXRhLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBLGlCQUFpQixTQUFJLElBQUksU0FBSTtBQUM3Qiw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNvRDtBQUNDO0FBQ3dDO0FBQ3hDO0FBQzZCO0FBQ25DO0FBQ1Y7QUFDckMsbUJBQW1CLHlEQUFNLENBQUMsNkNBQU87QUFDUDtBQUMxQjtBQUNBO0FBQ0Esb0JBQW9CLCtEQUFTO0FBQzdCLGFBQWEsK0RBQVM7QUFDdEIsWUFBWSwrREFBUztBQUNyQixtQkFBbUIsK0RBQVM7QUFDNUI7QUFDQSxrQkFBa0IsOERBQVE7QUFDMUI7QUFDQTtBQUNBLGVBQWUsK0RBQVM7QUFDeEI7QUFDQSxXQUFXLDZEQUFPO0FBQ2xCO0FBQ0EsZ0JBQWdCLGdFQUFVO0FBQzFCLGlCQUFpQixnRUFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxvQkFBb0IsYUFBYSxJQUFJO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwrREFBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLG1CQUFtQixrRUFBVTtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDBCQUEwQiw4REFBUTtBQUNsQztBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsNkRBQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBLGdDQUFnQyxZQUFZO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCw2REFBNkQsNEJBQTRCO0FBQ3pGO0FBQ0E7QUFDQSxlQUFlLCtEQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUVBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixzRUFBVztBQUNoQztBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsaUVBQVc7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGlFQUFXO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLHFCQUFxQjtBQUNyQixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isb0NBQW9DO0FBQ25FLFNBQVM7QUFDVDtBQUNBLGdDQUFnQyxzRUFBVztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsNkRBQU8sQ0FBQyw4REFBUTtBQUMzQztBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsK0RBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sZWRnaXR5LXlpZWxkLWZyb250ZW5kLy4uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9oYXNoL2xpYi5lc20vdHlwZWQtZGF0YS5qcz8yM2ZhIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuaW1wb3J0IHsgZ2V0QWRkcmVzcyB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9hZGRyZXNzXCI7XG5pbXBvcnQgeyBCaWdOdW1iZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYmlnbnVtYmVyXCI7XG5pbXBvcnQgeyBhcnJheWlmeSwgaGV4Q29uY2F0LCBoZXhsaWZ5LCBoZXhaZXJvUGFkLCBpc0hleFN0cmluZyB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9ieXRlc1wiO1xuaW1wb3J0IHsga2VjY2FrMjU2IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2tlY2NhazI1NlwiO1xuaW1wb3J0IHsgZGVlcENvcHksIGRlZmluZVJlYWRPbmx5LCBzaGFsbG93Q29weSB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9wcm9wZXJ0aWVzXCI7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvbG9nZ2VyXCI7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4vX3ZlcnNpb25cIjtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIodmVyc2lvbik7XG5pbXBvcnQgeyBpZCB9IGZyb20gXCIuL2lkXCI7XG5jb25zdCBwYWRkaW5nID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xucGFkZGluZy5maWxsKDApO1xuY29uc3QgTmVnYXRpdmVPbmUgPSBCaWdOdW1iZXIuZnJvbSgtMSk7XG5jb25zdCBaZXJvID0gQmlnTnVtYmVyLmZyb20oMCk7XG5jb25zdCBPbmUgPSBCaWdOdW1iZXIuZnJvbSgxKTtcbmNvbnN0IE1heFVpbnQyNTYgPSBCaWdOdW1iZXIuZnJvbShcIjB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlwiKTtcbmZ1bmN0aW9uIGhleFBhZFJpZ2h0KHZhbHVlKSB7XG4gICAgY29uc3QgYnl0ZXMgPSBhcnJheWlmeSh2YWx1ZSk7XG4gICAgY29uc3QgcGFkT2Zmc2V0ID0gYnl0ZXMubGVuZ3RoICUgMzI7XG4gICAgaWYgKHBhZE9mZnNldCkge1xuICAgICAgICByZXR1cm4gaGV4Q29uY2F0KFtieXRlcywgcGFkZGluZy5zbGljZShwYWRPZmZzZXQpXSk7XG4gICAgfVxuICAgIHJldHVybiBoZXhsaWZ5KGJ5dGVzKTtcbn1cbmNvbnN0IGhleFRydWUgPSBoZXhaZXJvUGFkKE9uZS50b0hleFN0cmluZygpLCAzMik7XG5jb25zdCBoZXhGYWxzZSA9IGhleFplcm9QYWQoWmVyby50b0hleFN0cmluZygpLCAzMik7XG5jb25zdCBkb21haW5GaWVsZFR5cGVzID0ge1xuICAgIG5hbWU6IFwic3RyaW5nXCIsXG4gICAgdmVyc2lvbjogXCJzdHJpbmdcIixcbiAgICBjaGFpbklkOiBcInVpbnQyNTZcIixcbiAgICB2ZXJpZnlpbmdDb250cmFjdDogXCJhZGRyZXNzXCIsXG4gICAgc2FsdDogXCJieXRlczMyXCJcbn07XG5jb25zdCBkb21haW5GaWVsZE5hbWVzID0gW1xuICAgIFwibmFtZVwiLCBcInZlcnNpb25cIiwgXCJjaGFpbklkXCIsIFwidmVyaWZ5aW5nQ29udHJhY3RcIiwgXCJzYWx0XCJcbl07XG5mdW5jdGlvbiBjaGVja1N0cmluZyhrZXkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKHZhbHVlKSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihgaW52YWxpZCBkb21haW4gdmFsdWUgZm9yICR7SlNPTi5zdHJpbmdpZnkoa2V5KX1gLCBgZG9tYWluLiR7a2V5fWAsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbn1cbmNvbnN0IGRvbWFpbkNoZWNrcyA9IHtcbiAgICBuYW1lOiBjaGVja1N0cmluZyhcIm5hbWVcIiksXG4gICAgdmVyc2lvbjogY2hlY2tTdHJpbmcoXCJ2ZXJzaW9uXCIpLFxuICAgIGNoYWluSWQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIEJpZ051bWJlci5mcm9tKHZhbHVlKS50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKGBpbnZhbGlkIGRvbWFpbiB2YWx1ZSBmb3IgXCJjaGFpbklkXCJgLCBcImRvbWFpbi5jaGFpbklkXCIsIHZhbHVlKTtcbiAgICB9LFxuICAgIHZlcmlmeWluZ0NvbnRyYWN0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBnZXRBZGRyZXNzKHZhbHVlKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKGBpbnZhbGlkIGRvbWFpbiB2YWx1ZSBcInZlcmlmeWluZ0NvbnRyYWN0XCJgLCBcImRvbWFpbi52ZXJpZnlpbmdDb250cmFjdFwiLCB2YWx1ZSk7XG4gICAgfSxcbiAgICBzYWx0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGJ5dGVzID0gYXJyYXlpZnkodmFsdWUpO1xuICAgICAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCAhPT0gMzIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJiYWQgbGVuZ3RoXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGhleGxpZnkoYnl0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKGBpbnZhbGlkIGRvbWFpbiB2YWx1ZSBcInNhbHRcImAsIFwiZG9tYWluLnNhbHRcIiwgdmFsdWUpO1xuICAgIH1cbn07XG5mdW5jdGlvbiBnZXRCYXNlRW5jb2Rlcih0eXBlKSB7XG4gICAgLy8gaW50WFggYW5kIHVpbnRYWFxuICAgIHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSB0eXBlLm1hdGNoKC9eKHU/KWludChcXGQqKSQvKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBjb25zdCBzaWduZWQgPSAobWF0Y2hbMV0gPT09IFwiXCIpO1xuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSBwYXJzZUludChtYXRjaFsyXSB8fCBcIjI1NlwiKTtcbiAgICAgICAgICAgIGlmICh3aWR0aCAlIDggIT09IDAgfHwgd2lkdGggPiAyNTYgfHwgKG1hdGNoWzJdICYmIG1hdGNoWzJdICE9PSBTdHJpbmcod2lkdGgpKSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIG51bWVyaWMgd2lkdGhcIiwgXCJ0eXBlXCIsIHR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYm91bmRzVXBwZXIgPSBNYXhVaW50MjU2Lm1hc2soc2lnbmVkID8gKHdpZHRoIC0gMSkgOiB3aWR0aCk7XG4gICAgICAgICAgICBjb25zdCBib3VuZHNMb3dlciA9IHNpZ25lZCA/IGJvdW5kc1VwcGVyLmFkZChPbmUpLm11bChOZWdhdGl2ZU9uZSkgOiBaZXJvO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHYgPSBCaWdOdW1iZXIuZnJvbSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHYubHQoYm91bmRzTG93ZXIpIHx8IHYuZ3QoYm91bmRzVXBwZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoYHZhbHVlIG91dC1vZi1ib3VuZHMgZm9yICR7dHlwZX1gLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhleFplcm9QYWQodi50b1R3b3MoMjU2KS50b0hleFN0cmluZygpLCAzMik7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGJ5dGVzWFhcbiAgICB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gdHlwZS5tYXRjaCgvXmJ5dGVzKFxcZCspJC8pO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gcGFyc2VJbnQobWF0Y2hbMV0pO1xuICAgICAgICAgICAgaWYgKHdpZHRoID09PSAwIHx8IHdpZHRoID4gMzIgfHwgbWF0Y2hbMV0gIT09IFN0cmluZyh3aWR0aCkpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBieXRlcyB3aWR0aFwiLCBcInR5cGVcIiwgdHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYnl0ZXMgPSBhcnJheWlmeSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCAhPT0gd2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihgaW52YWxpZCBsZW5ndGggZm9yICR7dHlwZX1gLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhleFBhZFJpZ2h0KHZhbHVlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgXCJhZGRyZXNzXCI6IHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBoZXhaZXJvUGFkKGdldEFkZHJlc3ModmFsdWUpLCAzMik7XG4gICAgICAgIH07XG4gICAgICAgIGNhc2UgXCJib29sXCI6IHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiAoKCF2YWx1ZSkgPyBoZXhGYWxzZSA6IGhleFRydWUpO1xuICAgICAgICB9O1xuICAgICAgICBjYXNlIFwiYnl0ZXNcIjogcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGtlY2NhazI1Nih2YWx1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjogcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGlkKHZhbHVlKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBlbmNvZGVUeXBlKG5hbWUsIGZpZWxkcykge1xuICAgIHJldHVybiBgJHtuYW1lfSgke2ZpZWxkcy5tYXAoKHsgbmFtZSwgdHlwZSB9KSA9PiAodHlwZSArIFwiIFwiICsgbmFtZSkpLmpvaW4oXCIsXCIpfSlgO1xufVxuZXhwb3J0IGNsYXNzIFR5cGVkRGF0YUVuY29kZXIge1xuICAgIGNvbnN0cnVjdG9yKHR5cGVzKSB7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwidHlwZXNcIiwgT2JqZWN0LmZyZWV6ZShkZWVwQ29weSh0eXBlcykpKTtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJfZW5jb2RlckNhY2hlXCIsIHt9KTtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJfdHlwZXNcIiwge30pO1xuICAgICAgICAvLyBMaW5rIHN0cnVjdCB0eXBlcyB0byB0aGVpciBkaXJlY3QgY2hpbGQgc3RydWN0c1xuICAgICAgICBjb25zdCBsaW5rcyA9IHt9O1xuICAgICAgICAvLyBMaW5rIHN0cnVjdHMgdG8gc3RydWN0cyB3aGljaCBjb250YWluIHRoZW0gYXMgYSBjaGlsZFxuICAgICAgICBjb25zdCBwYXJlbnRzID0ge307XG4gICAgICAgIC8vIExpbmsgYWxsIHN1YnR5cGVzIHdpdGhpbiBhIGdpdmVuIHN0cnVjdFxuICAgICAgICBjb25zdCBzdWJ0eXBlcyA9IHt9O1xuICAgICAgICBPYmplY3Qua2V5cyh0eXBlcykuZm9yRWFjaCgodHlwZSkgPT4ge1xuICAgICAgICAgICAgbGlua3NbdHlwZV0gPSB7fTtcbiAgICAgICAgICAgIHBhcmVudHNbdHlwZV0gPSBbXTtcbiAgICAgICAgICAgIHN1YnR5cGVzW3R5cGVdID0ge307XG4gICAgICAgIH0pO1xuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gdHlwZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHVuaXF1ZU5hbWVzID0ge307XG4gICAgICAgICAgICB0eXBlc1tuYW1lXS5mb3JFYWNoKChmaWVsZCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIENoZWNrIGVhY2ggZmllbGQgaGFzIGEgdW5pcXVlIG5hbWVcbiAgICAgICAgICAgICAgICBpZiAodW5pcXVlTmFtZXNbZmllbGQubmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihgZHVwbGljYXRlIHZhcmlhYmxlIG5hbWUgJHtKU09OLnN0cmluZ2lmeShmaWVsZC5uYW1lKX0gaW4gJHtKU09OLnN0cmluZ2lmeShuYW1lKX1gLCBcInR5cGVzXCIsIHR5cGVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdW5pcXVlTmFtZXNbZmllbGQubmFtZV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgYmFzZSB0eXBlIChkcm9wIGFueSBhcnJheSBzcGVjaWZpZXJzKVxuICAgICAgICAgICAgICAgIGNvbnN0IGJhc2VUeXBlID0gZmllbGQudHlwZS5tYXRjaCgvXihbXlxceDViXSopKFxceDVifCQpLylbMV07XG4gICAgICAgICAgICAgICAgaWYgKGJhc2VUeXBlID09PSBuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoYGNpcmN1bGFyIHR5cGUgcmVmZXJlbmNlIHRvICR7SlNPTi5zdHJpbmdpZnkoYmFzZVR5cGUpfWAsIFwidHlwZXNcIiwgdHlwZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJcyB0aGlzIGEgYmFzZSBlbmNvZGluZyB0eXBlP1xuICAgICAgICAgICAgICAgIGNvbnN0IGVuY29kZXIgPSBnZXRCYXNlRW5jb2RlcihiYXNlVHlwZSk7XG4gICAgICAgICAgICAgICAgaWYgKGVuY29kZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXBhcmVudHNbYmFzZVR5cGVdKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoYHVua25vd24gdHlwZSAke0pTT04uc3RyaW5naWZ5KGJhc2VUeXBlKX1gLCBcInR5cGVzXCIsIHR5cGVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQWRkIGxpbmthZ2VcbiAgICAgICAgICAgICAgICBwYXJlbnRzW2Jhc2VUeXBlXS5wdXNoKG5hbWUpO1xuICAgICAgICAgICAgICAgIGxpbmtzW25hbWVdW2Jhc2VUeXBlXSA9IHRydWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBEZWR1Y2UgdGhlIHByaW1hcnkgdHlwZVxuICAgICAgICBjb25zdCBwcmltYXJ5VHlwZXMgPSBPYmplY3Qua2V5cyhwYXJlbnRzKS5maWx0ZXIoKG4pID0+IChwYXJlbnRzW25dLmxlbmd0aCA9PT0gMCkpO1xuICAgICAgICBpZiAocHJpbWFyeVR5cGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcIm1pc3NpbmcgcHJpbWFyeSB0eXBlXCIsIFwidHlwZXNcIiwgdHlwZXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByaW1hcnlUeXBlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKGBhbWJpZ3VvdXMgcHJpbWFyeSB0eXBlcyBvciB1bnVzZWQgdHlwZXM6ICR7cHJpbWFyeVR5cGVzLm1hcCgodCkgPT4gKEpTT04uc3RyaW5naWZ5KHQpKSkuam9pbihcIiwgXCIpfWAsIFwidHlwZXNcIiwgdHlwZXMpO1xuICAgICAgICB9XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwicHJpbWFyeVR5cGVcIiwgcHJpbWFyeVR5cGVzWzBdKTtcbiAgICAgICAgLy8gQ2hlY2sgZm9yIGNpcmN1bGFyIHR5cGUgcmVmZXJlbmNlc1xuICAgICAgICBmdW5jdGlvbiBjaGVja0NpcmN1bGFyKHR5cGUsIGZvdW5kKSB7XG4gICAgICAgICAgICBpZiAoZm91bmRbdHlwZV0pIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKGBjaXJjdWxhciB0eXBlIHJlZmVyZW5jZSB0byAke0pTT04uc3RyaW5naWZ5KHR5cGUpfWAsIFwidHlwZXNcIiwgdHlwZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm91bmRbdHlwZV0gPSB0cnVlO1xuICAgICAgICAgICAgT2JqZWN0LmtleXMobGlua3NbdHlwZV0pLmZvckVhY2goKGNoaWxkKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJlbnRzW2NoaWxkXSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNoZWNrIGNoaWxkcmVuXG4gICAgICAgICAgICAgICAgY2hlY2tDaXJjdWxhcihjaGlsZCwgZm91bmQpO1xuICAgICAgICAgICAgICAgIC8vIE1hcmsgYWxsIGFuY2VzdG9ycyBhcyBoYXZpbmcgdGhpcyBkZWNlbmRhbnRcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhmb3VuZCkuZm9yRWFjaCgoc3VidHlwZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBzdWJ0eXBlc1tzdWJ0eXBlXVtjaGlsZF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkZWxldGUgZm91bmRbdHlwZV07XG4gICAgICAgIH1cbiAgICAgICAgY2hlY2tDaXJjdWxhcih0aGlzLnByaW1hcnlUeXBlLCB7fSk7XG4gICAgICAgIC8vIENvbXB1dGUgZWFjaCBmdWxseSBkZXNjcmliZSB0eXBlXG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiBzdWJ0eXBlcykge1xuICAgICAgICAgICAgY29uc3Qgc3QgPSBPYmplY3Qua2V5cyhzdWJ0eXBlc1tuYW1lXSk7XG4gICAgICAgICAgICBzdC5zb3J0KCk7XG4gICAgICAgICAgICB0aGlzLl90eXBlc1tuYW1lXSA9IGVuY29kZVR5cGUobmFtZSwgdHlwZXNbbmFtZV0pICsgc3QubWFwKCh0KSA9PiBlbmNvZGVUeXBlKHQsIHR5cGVzW3RdKSkuam9pbihcIlwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRFbmNvZGVyKHR5cGUpIHtcbiAgICAgICAgbGV0IGVuY29kZXIgPSB0aGlzLl9lbmNvZGVyQ2FjaGVbdHlwZV07XG4gICAgICAgIGlmICghZW5jb2Rlcikge1xuICAgICAgICAgICAgZW5jb2RlciA9IHRoaXMuX2VuY29kZXJDYWNoZVt0eXBlXSA9IHRoaXMuX2dldEVuY29kZXIodHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVuY29kZXI7XG4gICAgfVxuICAgIF9nZXRFbmNvZGVyKHR5cGUpIHtcbiAgICAgICAgLy8gQmFzaWMgZW5jb2RlciB0eXBlIChhZGRyZXNzLCBib29sLCB1aW50MjU2LCBldGMpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IGVuY29kZXIgPSBnZXRCYXNlRW5jb2Rlcih0eXBlKTtcbiAgICAgICAgICAgIGlmIChlbmNvZGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVuY29kZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXJyYXlcbiAgICAgICAgY29uc3QgbWF0Y2ggPSB0eXBlLm1hdGNoKC9eKC4qKShcXHg1YihcXGQqKVxceDVkKSQvKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBjb25zdCBzdWJ0eXBlID0gbWF0Y2hbMV07XG4gICAgICAgICAgICBjb25zdCBzdWJFbmNvZGVyID0gdGhpcy5nZXRFbmNvZGVyKHN1YnR5cGUpO1xuICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gcGFyc2VJbnQobWF0Y2hbM10pO1xuICAgICAgICAgICAgcmV0dXJuICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChsZW5ndGggPj0gMCAmJiB2YWx1ZS5sZW5ndGggIT09IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiYXJyYXkgbGVuZ3RoIG1pc21hdGNoOyBleHBlY3RlZCBsZW5ndGggJHsgYXJyYXlMZW5ndGggfVwiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHZhbHVlLm1hcChzdWJFbmNvZGVyKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fdHlwZXNbc3VidHlwZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0Lm1hcChrZWNjYWsyNTYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ga2VjY2FrMjU2KGhleENvbmNhdChyZXN1bHQpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3RydWN0XG4gICAgICAgIGNvbnN0IGZpZWxkcyA9IHRoaXMudHlwZXNbdHlwZV07XG4gICAgICAgIGlmIChmaWVsZHMpIHtcbiAgICAgICAgICAgIGNvbnN0IGVuY29kZWRUeXBlID0gaWQodGhpcy5fdHlwZXNbdHlwZV0pO1xuICAgICAgICAgICAgcmV0dXJuICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlcyA9IGZpZWxkcy5tYXAoKHsgbmFtZSwgdHlwZSB9KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuZ2V0RW5jb2Rlcih0eXBlKSh2YWx1ZVtuYW1lXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl90eXBlc1t0eXBlXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGtlY2NhazI1NihyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdmFsdWVzLnVuc2hpZnQoZW5jb2RlZFR5cGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBoZXhDb25jYXQodmFsdWVzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoYHVua25vd24gdHlwZTogJHt0eXBlfWAsIFwidHlwZVwiLCB0eXBlKTtcbiAgICB9XG4gICAgZW5jb2RlVHlwZShuYW1lKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX3R5cGVzW25hbWVdO1xuICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihgdW5rbm93biB0eXBlOiAke0pTT04uc3RyaW5naWZ5KG5hbWUpfWAsIFwibmFtZVwiLCBuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBlbmNvZGVEYXRhKHR5cGUsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEVuY29kZXIodHlwZSkodmFsdWUpO1xuICAgIH1cbiAgICBoYXNoU3RydWN0KG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBrZWNjYWsyNTYodGhpcy5lbmNvZGVEYXRhKG5hbWUsIHZhbHVlKSk7XG4gICAgfVxuICAgIGVuY29kZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGVEYXRhKHRoaXMucHJpbWFyeVR5cGUsIHZhbHVlKTtcbiAgICB9XG4gICAgaGFzaCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5oYXNoU3RydWN0KHRoaXMucHJpbWFyeVR5cGUsIHZhbHVlKTtcbiAgICB9XG4gICAgX3Zpc2l0KHR5cGUsIHZhbHVlLCBjYWxsYmFjaykge1xuICAgICAgICAvLyBCYXNpYyBlbmNvZGVyIHR5cGUgKGFkZHJlc3MsIGJvb2wsIHVpbnQyNTYsIGV0YylcbiAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgZW5jb2RlciA9IGdldEJhc2VFbmNvZGVyKHR5cGUpO1xuICAgICAgICAgICAgaWYgKGVuY29kZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sodHlwZSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEFycmF5XG4gICAgICAgIGNvbnN0IG1hdGNoID0gdHlwZS5tYXRjaCgvXiguKikoXFx4NWIoXFxkKilcXHg1ZCkkLyk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgY29uc3Qgc3VidHlwZSA9IG1hdGNoWzFdO1xuICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gcGFyc2VJbnQobWF0Y2hbM10pO1xuICAgICAgICAgICAgaWYgKGxlbmd0aCA+PSAwICYmIHZhbHVlLmxlbmd0aCAhPT0gbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImFycmF5IGxlbmd0aCBtaXNtYXRjaDsgZXhwZWN0ZWQgbGVuZ3RoICR7IGFycmF5TGVuZ3RoIH1cIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUubWFwKCh2KSA9PiB0aGlzLl92aXNpdChzdWJ0eXBlLCB2LCBjYWxsYmFjaykpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFN0cnVjdFxuICAgICAgICBjb25zdCBmaWVsZHMgPSB0aGlzLnR5cGVzW3R5cGVdO1xuICAgICAgICBpZiAoZmllbGRzKSB7XG4gICAgICAgICAgICByZXR1cm4gZmllbGRzLnJlZHVjZSgoYWNjdW0sIHsgbmFtZSwgdHlwZSB9KSA9PiB7XG4gICAgICAgICAgICAgICAgYWNjdW1bbmFtZV0gPSB0aGlzLl92aXNpdCh0eXBlLCB2YWx1ZVtuYW1lXSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIHJldHVybiBhY2N1bTtcbiAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihgdW5rbm93biB0eXBlOiAke3R5cGV9YCwgXCJ0eXBlXCIsIHR5cGUpO1xuICAgIH1cbiAgICB2aXNpdCh2YWx1ZSwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Zpc2l0KHRoaXMucHJpbWFyeVR5cGUsIHZhbHVlLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tKHR5cGVzKSB7XG4gICAgICAgIHJldHVybiBuZXcgVHlwZWREYXRhRW5jb2Rlcih0eXBlcyk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRQcmltYXJ5VHlwZSh0eXBlcykge1xuICAgICAgICByZXR1cm4gVHlwZWREYXRhRW5jb2Rlci5mcm9tKHR5cGVzKS5wcmltYXJ5VHlwZTtcbiAgICB9XG4gICAgc3RhdGljIGhhc2hTdHJ1Y3QobmFtZSwgdHlwZXMsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBUeXBlZERhdGFFbmNvZGVyLmZyb20odHlwZXMpLmhhc2hTdHJ1Y3QobmFtZSwgdmFsdWUpO1xuICAgIH1cbiAgICBzdGF0aWMgaGFzaERvbWFpbihkb21haW4pIHtcbiAgICAgICAgY29uc3QgZG9tYWluRmllbGRzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiBkb21haW4pIHtcbiAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBkb21haW5GaWVsZFR5cGVzW25hbWVdO1xuICAgICAgICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihgaW52YWxpZCB0eXBlZC1kYXRhIGRvbWFpbiBrZXk6ICR7SlNPTi5zdHJpbmdpZnkobmFtZSl9YCwgXCJkb21haW5cIiwgZG9tYWluKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvbWFpbkZpZWxkcy5wdXNoKHsgbmFtZSwgdHlwZSB9KTtcbiAgICAgICAgfVxuICAgICAgICBkb21haW5GaWVsZHMuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGRvbWFpbkZpZWxkTmFtZXMuaW5kZXhPZihhLm5hbWUpIC0gZG9tYWluRmllbGROYW1lcy5pbmRleE9mKGIubmFtZSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gVHlwZWREYXRhRW5jb2Rlci5oYXNoU3RydWN0KFwiRUlQNzEyRG9tYWluXCIsIHsgRUlQNzEyRG9tYWluOiBkb21haW5GaWVsZHMgfSwgZG9tYWluKTtcbiAgICB9XG4gICAgc3RhdGljIGVuY29kZShkb21haW4sIHR5cGVzLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gaGV4Q29uY2F0KFtcbiAgICAgICAgICAgIFwiMHgxOTAxXCIsXG4gICAgICAgICAgICBUeXBlZERhdGFFbmNvZGVyLmhhc2hEb21haW4oZG9tYWluKSxcbiAgICAgICAgICAgIFR5cGVkRGF0YUVuY29kZXIuZnJvbSh0eXBlcykuaGFzaCh2YWx1ZSlcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIHN0YXRpYyBoYXNoKGRvbWFpbiwgdHlwZXMsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBrZWNjYWsyNTYoVHlwZWREYXRhRW5jb2Rlci5lbmNvZGUoZG9tYWluLCB0eXBlcywgdmFsdWUpKTtcbiAgICB9XG4gICAgLy8gUmVwbGFjZXMgYWxsIGFkZHJlc3MgdHlwZXMgd2l0aCBFTlMgbmFtZXMgd2l0aCB0aGVpciBsb29rZWQgdXAgYWRkcmVzc1xuICAgIHN0YXRpYyByZXNvbHZlTmFtZXMoZG9tYWluLCB0eXBlcywgdmFsdWUsIHJlc29sdmVOYW1lKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAvLyBNYWtlIGEgY29weSB0byBpc29sYXRlIGl0IGZyb20gdGhlIG9iamVjdCBwYXNzZWQgaW5cbiAgICAgICAgICAgIGRvbWFpbiA9IHNoYWxsb3dDb3B5KGRvbWFpbik7XG4gICAgICAgICAgICAvLyBMb29rIHVwIGFsbCBFTlMgbmFtZXNcbiAgICAgICAgICAgIGNvbnN0IGVuc0NhY2hlID0ge307XG4gICAgICAgICAgICAvLyBEbyB3ZSBuZWVkIHRvIGxvb2sgdXAgdGhlIGRvbWFpbidzIHZlcmlmeWluZ0NvbnRyYWN0P1xuICAgICAgICAgICAgaWYgKGRvbWFpbi52ZXJpZnlpbmdDb250cmFjdCAmJiAhaXNIZXhTdHJpbmcoZG9tYWluLnZlcmlmeWluZ0NvbnRyYWN0LCAyMCkpIHtcbiAgICAgICAgICAgICAgICBlbnNDYWNoZVtkb21haW4udmVyaWZ5aW5nQ29udHJhY3RdID0gXCIweFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV2UgYXJlIGdvaW5nIHRvIHVzZSB0aGUgZW5jb2RlciB0byB2aXNpdCBhbGwgdGhlIGJhc2UgdmFsdWVzXG4gICAgICAgICAgICBjb25zdCBlbmNvZGVyID0gVHlwZWREYXRhRW5jb2Rlci5mcm9tKHR5cGVzKTtcbiAgICAgICAgICAgIC8vIEdldCBhIGxpc3Qgb2YgYWxsIHRoZSBhZGRyZXNzZXNcbiAgICAgICAgICAgIGVuY29kZXIudmlzaXQodmFsdWUsICh0eXBlLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSBcImFkZHJlc3NcIiAmJiAhaXNIZXhTdHJpbmcodmFsdWUsIDIwKSkge1xuICAgICAgICAgICAgICAgICAgICBlbnNDYWNoZVt2YWx1ZV0gPSBcIjB4XCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gTG9va3VwIGVhY2ggbmFtZVxuICAgICAgICAgICAgZm9yIChjb25zdCBuYW1lIGluIGVuc0NhY2hlKSB7XG4gICAgICAgICAgICAgICAgZW5zQ2FjaGVbbmFtZV0gPSB5aWVsZCByZXNvbHZlTmFtZShuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJlcGxhY2UgdGhlIGRvbWFpbiB2ZXJpZnlpbmdDb250cmFjdCBpZiBuZWVkZWRcbiAgICAgICAgICAgIGlmIChkb21haW4udmVyaWZ5aW5nQ29udHJhY3QgJiYgZW5zQ2FjaGVbZG9tYWluLnZlcmlmeWluZ0NvbnRyYWN0XSkge1xuICAgICAgICAgICAgICAgIGRvbWFpbi52ZXJpZnlpbmdDb250cmFjdCA9IGVuc0NhY2hlW2RvbWFpbi52ZXJpZnlpbmdDb250cmFjdF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZXBsYWNlIGFsbCBFTlMgbmFtZXMgd2l0aCB0aGVpciBhZGRyZXNzXG4gICAgICAgICAgICB2YWx1ZSA9IGVuY29kZXIudmlzaXQodmFsdWUsICh0eXBlLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSBcImFkZHJlc3NcIiAmJiBlbnNDYWNoZVt2YWx1ZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVuc0NhY2hlW3ZhbHVlXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4geyBkb21haW4sIHZhbHVlIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0UGF5bG9hZChkb21haW4sIHR5cGVzLCB2YWx1ZSkge1xuICAgICAgICAvLyBWYWxpZGF0ZSB0aGUgZG9tYWluIGZpZWxkc1xuICAgICAgICBUeXBlZERhdGFFbmNvZGVyLmhhc2hEb21haW4oZG9tYWluKTtcbiAgICAgICAgLy8gRGVyaXZlIHRoZSBFSVA3MTJEb21haW4gU3RydWN0IHJlZmVyZW5jZSB0eXBlXG4gICAgICAgIGNvbnN0IGRvbWFpblZhbHVlcyA9IHt9O1xuICAgICAgICBjb25zdCBkb21haW5UeXBlcyA9IFtdO1xuICAgICAgICBkb21haW5GaWVsZE5hbWVzLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZG9tYWluW25hbWVdO1xuICAgICAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkb21haW5WYWx1ZXNbbmFtZV0gPSBkb21haW5DaGVja3NbbmFtZV0odmFsdWUpO1xuICAgICAgICAgICAgZG9tYWluVHlwZXMucHVzaCh7IG5hbWUsIHR5cGU6IGRvbWFpbkZpZWxkVHlwZXNbbmFtZV0gfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBlbmNvZGVyID0gVHlwZWREYXRhRW5jb2Rlci5mcm9tKHR5cGVzKTtcbiAgICAgICAgY29uc3QgdHlwZXNXaXRoRG9tYWluID0gc2hhbGxvd0NvcHkodHlwZXMpO1xuICAgICAgICBpZiAodHlwZXNXaXRoRG9tYWluLkVJUDcxMkRvbWFpbikge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInR5cGVzIG11c3Qgbm90IGNvbnRhaW4gRUlQNzEyRG9tYWluIHR5cGVcIiwgXCJ0eXBlcy5FSVA3MTJEb21haW5cIiwgdHlwZXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdHlwZXNXaXRoRG9tYWluLkVJUDcxMkRvbWFpbiA9IGRvbWFpblR5cGVzO1xuICAgICAgICB9XG4gICAgICAgIC8vIFZhbGlkYXRlIHRoZSBkYXRhIHN0cnVjdHVyZXMgYW5kIHR5cGVzXG4gICAgICAgIGVuY29kZXIuZW5jb2RlKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGVzOiB0eXBlc1dpdGhEb21haW4sXG4gICAgICAgICAgICBkb21haW46IGRvbWFpblZhbHVlcyxcbiAgICAgICAgICAgIHByaW1hcnlUeXBlOiBlbmNvZGVyLnByaW1hcnlUeXBlLFxuICAgICAgICAgICAgbWVzc2FnZTogZW5jb2Rlci52aXNpdCh2YWx1ZSwgKHR5cGUsIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gYnl0ZXNcbiAgICAgICAgICAgICAgICBpZiAodHlwZS5tYXRjaCgvXmJ5dGVzKFxcZCopLykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhleGxpZnkoYXJyYXlpZnkodmFsdWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gdWludCBvciBpbnRcbiAgICAgICAgICAgICAgICBpZiAodHlwZS5tYXRjaCgvXnU/aW50LykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJpZ051bWJlci5mcm9tKHZhbHVlKS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImFkZHJlc3NcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiYm9vbFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEhdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKHZhbHVlKSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoYGludmFsaWQgc3RyaW5nYCwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwidW5zdXBwb3J0ZWQgdHlwZVwiLCBcInR5cGVcIiwgdHlwZSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICB9O1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGVkLWRhdGEuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ethersproject/hash/lib.esm/typed-data.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@ethersproject/keccak256/lib.esm/index.js":
/*!*****************************************************************!*\
  !*** ../node_modules/@ethersproject/keccak256/lib.esm/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   keccak256: () => (/* binding */ keccak256)\n/* harmony export */ });\n/* harmony import */ var js_sha3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! js-sha3 */ \"(ssr)/../node_modules/js-sha3/src/sha3.js\");\n/* harmony import */ var js_sha3__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(js_sha3__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/../node_modules/@ethersproject/bytes/lib.esm/index.js\");\n\n\n\nfunction keccak256(data) {\n    return '0x' + js_sha3__WEBPACK_IMPORTED_MODULE_0___default().keccak_256((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__.arrayify)(data));\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2tlY2NhazI1Ni9saWIuZXNtL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBYTtBQUNjO0FBQ3FCO0FBQ3pDO0FBQ1Asa0JBQWtCLHlEQUFlLENBQUMsOERBQVE7QUFDMUM7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xlZGdpdHkteWllbGQtZnJvbnRlbmQvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2tlY2NhazI1Ni9saWIuZXNtL2luZGV4LmpzPzExZWEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgc2hhMyBmcm9tIFwianMtc2hhM1wiO1xuaW1wb3J0IHsgYXJyYXlpZnkgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYnl0ZXNcIjtcbmV4cG9ydCBmdW5jdGlvbiBrZWNjYWsyNTYoZGF0YSkge1xuICAgIHJldHVybiAnMHgnICsgc2hhMy5rZWNjYWtfMjU2KGFycmF5aWZ5KGRhdGEpKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ethersproject/keccak256/lib.esm/index.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@ethersproject/logger/lib.esm/_version.js":
/*!*****************************************************************!*\
  !*** ../node_modules/@ethersproject/logger/lib.esm/_version.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\nconst version = \"logger/5.7.0\";\n//# sourceMappingURL=_version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2xvZ2dlci9saWIuZXNtL192ZXJzaW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBTztBQUNQIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGVkZ2l0eS15aWVsZC1mcm9udGVuZC8uLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvbG9nZ2VyL2xpYi5lc20vX3ZlcnNpb24uanM/YjE2MSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgdmVyc2lvbiA9IFwibG9nZ2VyLzUuNy4wXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdmVyc2lvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ethersproject/logger/lib.esm/_version.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@ethersproject/logger/lib.esm/index.js":
/*!**************************************************************!*\
  !*** ../node_modules/@ethersproject/logger/lib.esm/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ErrorCode: () => (/* binding */ ErrorCode),\n/* harmony export */   LogLevel: () => (/* binding */ LogLevel),\n/* harmony export */   Logger: () => (/* binding */ Logger)\n/* harmony export */ });\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_version */ \"(ssr)/../node_modules/@ethersproject/logger/lib.esm/_version.js\");\n\nlet _permanentCensorErrors = false;\nlet _censorErrors = false;\nconst LogLevels = { debug: 1, \"default\": 2, info: 2, warning: 3, error: 4, off: 5 };\nlet _logLevel = LogLevels[\"default\"];\n\nlet _globalLogger = null;\nfunction _checkNormalize() {\n    try {\n        const missing = [];\n        // Make sure all forms of normalization are supported\n        [\"NFD\", \"NFC\", \"NFKD\", \"NFKC\"].forEach((form) => {\n            try {\n                if (\"test\".normalize(form) !== \"test\") {\n                    throw new Error(\"bad normalize\");\n                }\n                ;\n            }\n            catch (error) {\n                missing.push(form);\n            }\n        });\n        if (missing.length) {\n            throw new Error(\"missing \" + missing.join(\", \"));\n        }\n        if (String.fromCharCode(0xe9).normalize(\"NFD\") !== String.fromCharCode(0x65, 0x0301)) {\n            throw new Error(\"broken implementation\");\n        }\n    }\n    catch (error) {\n        return error.message;\n    }\n    return null;\n}\nconst _normalizeError = _checkNormalize();\nvar LogLevel;\n(function (LogLevel) {\n    LogLevel[\"DEBUG\"] = \"DEBUG\";\n    LogLevel[\"INFO\"] = \"INFO\";\n    LogLevel[\"WARNING\"] = \"WARNING\";\n    LogLevel[\"ERROR\"] = \"ERROR\";\n    LogLevel[\"OFF\"] = \"OFF\";\n})(LogLevel || (LogLevel = {}));\nvar ErrorCode;\n(function (ErrorCode) {\n    ///////////////////\n    // Generic Errors\n    // Unknown Error\n    ErrorCode[\"UNKNOWN_ERROR\"] = \"UNKNOWN_ERROR\";\n    // Not Implemented\n    ErrorCode[\"NOT_IMPLEMENTED\"] = \"NOT_IMPLEMENTED\";\n    // Unsupported Operation\n    //   - operation\n    ErrorCode[\"UNSUPPORTED_OPERATION\"] = \"UNSUPPORTED_OPERATION\";\n    // Network Error (i.e. Ethereum Network, such as an invalid chain ID)\n    //   - event (\"noNetwork\" is not re-thrown in provider.ready; otherwise thrown)\n    ErrorCode[\"NETWORK_ERROR\"] = \"NETWORK_ERROR\";\n    // Some sort of bad response from the server\n    ErrorCode[\"SERVER_ERROR\"] = \"SERVER_ERROR\";\n    // Timeout\n    ErrorCode[\"TIMEOUT\"] = \"TIMEOUT\";\n    ///////////////////\n    // Operational  Errors\n    // Buffer Overrun\n    ErrorCode[\"BUFFER_OVERRUN\"] = \"BUFFER_OVERRUN\";\n    // Numeric Fault\n    //   - operation: the operation being executed\n    //   - fault: the reason this faulted\n    ErrorCode[\"NUMERIC_FAULT\"] = \"NUMERIC_FAULT\";\n    ///////////////////\n    // Argument Errors\n    // Missing new operator to an object\n    //  - name: The name of the class\n    ErrorCode[\"MISSING_NEW\"] = \"MISSING_NEW\";\n    // Invalid argument (e.g. value is incompatible with type) to a function:\n    //   - argument: The argument name that was invalid\n    //   - value: The value of the argument\n    ErrorCode[\"INVALID_ARGUMENT\"] = \"INVALID_ARGUMENT\";\n    // Missing argument to a function:\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    ErrorCode[\"MISSING_ARGUMENT\"] = \"MISSING_ARGUMENT\";\n    // Too many arguments\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    ErrorCode[\"UNEXPECTED_ARGUMENT\"] = \"UNEXPECTED_ARGUMENT\";\n    ///////////////////\n    // Blockchain Errors\n    // Call exception\n    //  - transaction: the transaction\n    //  - address?: the contract address\n    //  - args?: The arguments passed into the function\n    //  - method?: The Solidity method signature\n    //  - errorSignature?: The EIP848 error signature\n    //  - errorArgs?: The EIP848 error parameters\n    //  - reason: The reason (only for EIP848 \"Error(string)\")\n    ErrorCode[\"CALL_EXCEPTION\"] = \"CALL_EXCEPTION\";\n    // Insufficient funds (< value + gasLimit * gasPrice)\n    //   - transaction: the transaction attempted\n    ErrorCode[\"INSUFFICIENT_FUNDS\"] = \"INSUFFICIENT_FUNDS\";\n    // Nonce has already been used\n    //   - transaction: the transaction attempted\n    ErrorCode[\"NONCE_EXPIRED\"] = \"NONCE_EXPIRED\";\n    // The replacement fee for the transaction is too low\n    //   - transaction: the transaction attempted\n    ErrorCode[\"REPLACEMENT_UNDERPRICED\"] = \"REPLACEMENT_UNDERPRICED\";\n    // The gas limit could not be estimated\n    //   - transaction: the transaction passed to estimateGas\n    ErrorCode[\"UNPREDICTABLE_GAS_LIMIT\"] = \"UNPREDICTABLE_GAS_LIMIT\";\n    // The transaction was replaced by one with a higher gas price\n    //   - reason: \"cancelled\", \"replaced\" or \"repriced\"\n    //   - cancelled: true if reason == \"cancelled\" or reason == \"replaced\")\n    //   - hash: original transaction hash\n    //   - replacement: the full TransactionsResponse for the replacement\n    //   - receipt: the receipt of the replacement\n    ErrorCode[\"TRANSACTION_REPLACED\"] = \"TRANSACTION_REPLACED\";\n    ///////////////////\n    // Interaction Errors\n    // The user rejected the action, such as signing a message or sending\n    // a transaction\n    ErrorCode[\"ACTION_REJECTED\"] = \"ACTION_REJECTED\";\n})(ErrorCode || (ErrorCode = {}));\n;\nconst HEX = \"0123456789abcdef\";\nclass Logger {\n    constructor(version) {\n        Object.defineProperty(this, \"version\", {\n            enumerable: true,\n            value: version,\n            writable: false\n        });\n    }\n    _log(logLevel, args) {\n        const level = logLevel.toLowerCase();\n        if (LogLevels[level] == null) {\n            this.throwArgumentError(\"invalid log level name\", \"logLevel\", logLevel);\n        }\n        if (_logLevel > LogLevels[level]) {\n            return;\n        }\n        console.log.apply(console, args);\n    }\n    debug(...args) {\n        this._log(Logger.levels.DEBUG, args);\n    }\n    info(...args) {\n        this._log(Logger.levels.INFO, args);\n    }\n    warn(...args) {\n        this._log(Logger.levels.WARNING, args);\n    }\n    makeError(message, code, params) {\n        // Errors are being censored\n        if (_censorErrors) {\n            return this.makeError(\"censored error\", code, {});\n        }\n        if (!code) {\n            code = Logger.errors.UNKNOWN_ERROR;\n        }\n        if (!params) {\n            params = {};\n        }\n        const messageDetails = [];\n        Object.keys(params).forEach((key) => {\n            const value = params[key];\n            try {\n                if (value instanceof Uint8Array) {\n                    let hex = \"\";\n                    for (let i = 0; i < value.length; i++) {\n                        hex += HEX[value[i] >> 4];\n                        hex += HEX[value[i] & 0x0f];\n                    }\n                    messageDetails.push(key + \"=Uint8Array(0x\" + hex + \")\");\n                }\n                else {\n                    messageDetails.push(key + \"=\" + JSON.stringify(value));\n                }\n            }\n            catch (error) {\n                messageDetails.push(key + \"=\" + JSON.stringify(params[key].toString()));\n            }\n        });\n        messageDetails.push(`code=${code}`);\n        messageDetails.push(`version=${this.version}`);\n        const reason = message;\n        let url = \"\";\n        switch (code) {\n            case ErrorCode.NUMERIC_FAULT: {\n                url = \"NUMERIC_FAULT\";\n                const fault = message;\n                switch (fault) {\n                    case \"overflow\":\n                    case \"underflow\":\n                    case \"division-by-zero\":\n                        url += \"-\" + fault;\n                        break;\n                    case \"negative-power\":\n                    case \"negative-width\":\n                        url += \"-unsupported\";\n                        break;\n                    case \"unbound-bitwise-result\":\n                        url += \"-unbound-result\";\n                        break;\n                }\n                break;\n            }\n            case ErrorCode.CALL_EXCEPTION:\n            case ErrorCode.INSUFFICIENT_FUNDS:\n            case ErrorCode.MISSING_NEW:\n            case ErrorCode.NONCE_EXPIRED:\n            case ErrorCode.REPLACEMENT_UNDERPRICED:\n            case ErrorCode.TRANSACTION_REPLACED:\n            case ErrorCode.UNPREDICTABLE_GAS_LIMIT:\n                url = code;\n                break;\n        }\n        if (url) {\n            message += \" [ See: https:/\\/links.ethers.org/v5-errors-\" + url + \" ]\";\n        }\n        if (messageDetails.length) {\n            message += \" (\" + messageDetails.join(\", \") + \")\";\n        }\n        // @TODO: Any??\n        const error = new Error(message);\n        error.reason = reason;\n        error.code = code;\n        Object.keys(params).forEach(function (key) {\n            error[key] = params[key];\n        });\n        return error;\n    }\n    throwError(message, code, params) {\n        throw this.makeError(message, code, params);\n    }\n    throwArgumentError(message, name, value) {\n        return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {\n            argument: name,\n            value: value\n        });\n    }\n    assert(condition, message, code, params) {\n        if (!!condition) {\n            return;\n        }\n        this.throwError(message, code, params);\n    }\n    assertArgument(condition, message, name, value) {\n        if (!!condition) {\n            return;\n        }\n        this.throwArgumentError(message, name, value);\n    }\n    checkNormalize(message) {\n        if (message == null) {\n            message = \"platform missing String.prototype.normalize\";\n        }\n        if (_normalizeError) {\n            this.throwError(\"platform missing String.prototype.normalize\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"String.prototype.normalize\", form: _normalizeError\n            });\n        }\n    }\n    checkSafeUint53(value, message) {\n        if (typeof (value) !== \"number\") {\n            return;\n        }\n        if (message == null) {\n            message = \"value not safe\";\n        }\n        if (value < 0 || value >= 0x1fffffffffffff) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"out-of-safe-range\",\n                value: value\n            });\n        }\n        if (value % 1) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"non-integer\",\n                value: value\n            });\n        }\n    }\n    checkArgumentCount(count, expectedCount, message) {\n        if (message) {\n            message = \": \" + message;\n        }\n        else {\n            message = \"\";\n        }\n        if (count < expectedCount) {\n            this.throwError(\"missing argument\" + message, Logger.errors.MISSING_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n        if (count > expectedCount) {\n            this.throwError(\"too many arguments\" + message, Logger.errors.UNEXPECTED_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n    }\n    checkNew(target, kind) {\n        if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n    checkAbstract(target, kind) {\n        if (target === kind) {\n            this.throwError(\"cannot instantiate abstract class \" + JSON.stringify(kind.name) + \" directly; use a sub-class\", Logger.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: \"new\" });\n        }\n        else if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n    static globalLogger() {\n        if (!_globalLogger) {\n            _globalLogger = new Logger(_version__WEBPACK_IMPORTED_MODULE_0__.version);\n        }\n        return _globalLogger;\n    }\n    static setCensorship(censorship, permanent) {\n        if (!censorship && permanent) {\n            this.globalLogger().throwError(\"cannot permanently disable censorship\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n        if (_permanentCensorErrors) {\n            if (!censorship) {\n                return;\n            }\n            this.globalLogger().throwError(\"error censorship permanent\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n        _censorErrors = !!censorship;\n        _permanentCensorErrors = !!permanent;\n    }\n    static setLogLevel(logLevel) {\n        const level = LogLevels[logLevel.toLowerCase()];\n        if (level == null) {\n            Logger.globalLogger().warn(\"invalid log level - \" + logLevel);\n            return;\n        }\n        _logLevel = level;\n    }\n    static from(version) {\n        return new Logger(version);\n    }\n}\nLogger.errors = ErrorCode;\nLogger.levels = LogLevel;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2xvZ2dlci9saWIuZXNtL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBYTtBQUNiO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDRCQUE0QjtBQUN0QjtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0U7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsOEJBQThCO0FBQy9CO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxrQkFBa0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULG9DQUFvQyxLQUFLO0FBQ3pDLHVDQUF1QyxhQUFhO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxpQkFBaUI7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyR0FBMkcseURBQXlELHFDQUFxQztBQUN6TTtBQUNBO0FBQ0Esd0VBQXdFLGlCQUFpQjtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyw2Q0FBTztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xlZGdpdHkteWllbGQtZnJvbnRlbmQvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2xvZ2dlci9saWIuZXNtL2luZGV4LmpzP2Q0YTYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5sZXQgX3Blcm1hbmVudENlbnNvckVycm9ycyA9IGZhbHNlO1xubGV0IF9jZW5zb3JFcnJvcnMgPSBmYWxzZTtcbmNvbnN0IExvZ0xldmVscyA9IHsgZGVidWc6IDEsIFwiZGVmYXVsdFwiOiAyLCBpbmZvOiAyLCB3YXJuaW5nOiAzLCBlcnJvcjogNCwgb2ZmOiA1IH07XG5sZXQgX2xvZ0xldmVsID0gTG9nTGV2ZWxzW1wiZGVmYXVsdFwiXTtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi9fdmVyc2lvblwiO1xubGV0IF9nbG9iYWxMb2dnZXIgPSBudWxsO1xuZnVuY3Rpb24gX2NoZWNrTm9ybWFsaXplKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG1pc3NpbmcgPSBbXTtcbiAgICAgICAgLy8gTWFrZSBzdXJlIGFsbCBmb3JtcyBvZiBub3JtYWxpemF0aW9uIGFyZSBzdXBwb3J0ZWRcbiAgICAgICAgW1wiTkZEXCIsIFwiTkZDXCIsIFwiTkZLRFwiLCBcIk5GS0NcIl0uZm9yRWFjaCgoZm9ybSkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoXCJ0ZXN0XCIubm9ybWFsaXplKGZvcm0pICE9PSBcInRlc3RcIikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJiYWQgbm9ybWFsaXplXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBtaXNzaW5nLnB1c2goZm9ybSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAobWlzc2luZy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgXCIgKyBtaXNzaW5nLmpvaW4oXCIsIFwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFN0cmluZy5mcm9tQ2hhckNvZGUoMHhlOSkubm9ybWFsaXplKFwiTkZEXCIpICE9PSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4NjUsIDB4MDMwMSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImJyb2tlbiBpbXBsZW1lbnRhdGlvblwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yLm1lc3NhZ2U7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuY29uc3QgX25vcm1hbGl6ZUVycm9yID0gX2NoZWNrTm9ybWFsaXplKCk7XG5leHBvcnQgdmFyIExvZ0xldmVsO1xuKGZ1bmN0aW9uIChMb2dMZXZlbCkge1xuICAgIExvZ0xldmVsW1wiREVCVUdcIl0gPSBcIkRFQlVHXCI7XG4gICAgTG9nTGV2ZWxbXCJJTkZPXCJdID0gXCJJTkZPXCI7XG4gICAgTG9nTGV2ZWxbXCJXQVJOSU5HXCJdID0gXCJXQVJOSU5HXCI7XG4gICAgTG9nTGV2ZWxbXCJFUlJPUlwiXSA9IFwiRVJST1JcIjtcbiAgICBMb2dMZXZlbFtcIk9GRlwiXSA9IFwiT0ZGXCI7XG59KShMb2dMZXZlbCB8fCAoTG9nTGV2ZWwgPSB7fSkpO1xuZXhwb3J0IHZhciBFcnJvckNvZGU7XG4oZnVuY3Rpb24gKEVycm9yQ29kZSkge1xuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAvLyBHZW5lcmljIEVycm9yc1xuICAgIC8vIFVua25vd24gRXJyb3JcbiAgICBFcnJvckNvZGVbXCJVTktOT1dOX0VSUk9SXCJdID0gXCJVTktOT1dOX0VSUk9SXCI7XG4gICAgLy8gTm90IEltcGxlbWVudGVkXG4gICAgRXJyb3JDb2RlW1wiTk9UX0lNUExFTUVOVEVEXCJdID0gXCJOT1RfSU1QTEVNRU5URURcIjtcbiAgICAvLyBVbnN1cHBvcnRlZCBPcGVyYXRpb25cbiAgICAvLyAgIC0gb3BlcmF0aW9uXG4gICAgRXJyb3JDb2RlW1wiVU5TVVBQT1JURURfT1BFUkFUSU9OXCJdID0gXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIjtcbiAgICAvLyBOZXR3b3JrIEVycm9yIChpLmUuIEV0aGVyZXVtIE5ldHdvcmssIHN1Y2ggYXMgYW4gaW52YWxpZCBjaGFpbiBJRClcbiAgICAvLyAgIC0gZXZlbnQgKFwibm9OZXR3b3JrXCIgaXMgbm90IHJlLXRocm93biBpbiBwcm92aWRlci5yZWFkeTsgb3RoZXJ3aXNlIHRocm93bilcbiAgICBFcnJvckNvZGVbXCJORVRXT1JLX0VSUk9SXCJdID0gXCJORVRXT1JLX0VSUk9SXCI7XG4gICAgLy8gU29tZSBzb3J0IG9mIGJhZCByZXNwb25zZSBmcm9tIHRoZSBzZXJ2ZXJcbiAgICBFcnJvckNvZGVbXCJTRVJWRVJfRVJST1JcIl0gPSBcIlNFUlZFUl9FUlJPUlwiO1xuICAgIC8vIFRpbWVvdXRcbiAgICBFcnJvckNvZGVbXCJUSU1FT1VUXCJdID0gXCJUSU1FT1VUXCI7XG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vIE9wZXJhdGlvbmFsICBFcnJvcnNcbiAgICAvLyBCdWZmZXIgT3ZlcnJ1blxuICAgIEVycm9yQ29kZVtcIkJVRkZFUl9PVkVSUlVOXCJdID0gXCJCVUZGRVJfT1ZFUlJVTlwiO1xuICAgIC8vIE51bWVyaWMgRmF1bHRcbiAgICAvLyAgIC0gb3BlcmF0aW9uOiB0aGUgb3BlcmF0aW9uIGJlaW5nIGV4ZWN1dGVkXG4gICAgLy8gICAtIGZhdWx0OiB0aGUgcmVhc29uIHRoaXMgZmF1bHRlZFxuICAgIEVycm9yQ29kZVtcIk5VTUVSSUNfRkFVTFRcIl0gPSBcIk5VTUVSSUNfRkFVTFRcIjtcbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8gQXJndW1lbnQgRXJyb3JzXG4gICAgLy8gTWlzc2luZyBuZXcgb3BlcmF0b3IgdG8gYW4gb2JqZWN0XG4gICAgLy8gIC0gbmFtZTogVGhlIG5hbWUgb2YgdGhlIGNsYXNzXG4gICAgRXJyb3JDb2RlW1wiTUlTU0lOR19ORVdcIl0gPSBcIk1JU1NJTkdfTkVXXCI7XG4gICAgLy8gSW52YWxpZCBhcmd1bWVudCAoZS5nLiB2YWx1ZSBpcyBpbmNvbXBhdGlibGUgd2l0aCB0eXBlKSB0byBhIGZ1bmN0aW9uOlxuICAgIC8vICAgLSBhcmd1bWVudDogVGhlIGFyZ3VtZW50IG5hbWUgdGhhdCB3YXMgaW52YWxpZFxuICAgIC8vICAgLSB2YWx1ZTogVGhlIHZhbHVlIG9mIHRoZSBhcmd1bWVudFxuICAgIEVycm9yQ29kZVtcIklOVkFMSURfQVJHVU1FTlRcIl0gPSBcIklOVkFMSURfQVJHVU1FTlRcIjtcbiAgICAvLyBNaXNzaW5nIGFyZ3VtZW50IHRvIGEgZnVuY3Rpb246XG4gICAgLy8gICAtIGNvdW50OiBUaGUgbnVtYmVyIG9mIGFyZ3VtZW50cyByZWNlaXZlZFxuICAgIC8vICAgLSBleHBlY3RlZENvdW50OiBUaGUgbnVtYmVyIG9mIGFyZ3VtZW50cyBleHBlY3RlZFxuICAgIEVycm9yQ29kZVtcIk1JU1NJTkdfQVJHVU1FTlRcIl0gPSBcIk1JU1NJTkdfQVJHVU1FTlRcIjtcbiAgICAvLyBUb28gbWFueSBhcmd1bWVudHNcbiAgICAvLyAgIC0gY291bnQ6IFRoZSBudW1iZXIgb2YgYXJndW1lbnRzIHJlY2VpdmVkXG4gICAgLy8gICAtIGV4cGVjdGVkQ291bnQ6IFRoZSBudW1iZXIgb2YgYXJndW1lbnRzIGV4cGVjdGVkXG4gICAgRXJyb3JDb2RlW1wiVU5FWFBFQ1RFRF9BUkdVTUVOVFwiXSA9IFwiVU5FWFBFQ1RFRF9BUkdVTUVOVFwiO1xuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAvLyBCbG9ja2NoYWluIEVycm9yc1xuICAgIC8vIENhbGwgZXhjZXB0aW9uXG4gICAgLy8gIC0gdHJhbnNhY3Rpb246IHRoZSB0cmFuc2FjdGlvblxuICAgIC8vICAtIGFkZHJlc3M/OiB0aGUgY29udHJhY3QgYWRkcmVzc1xuICAgIC8vICAtIGFyZ3M/OiBUaGUgYXJndW1lbnRzIHBhc3NlZCBpbnRvIHRoZSBmdW5jdGlvblxuICAgIC8vICAtIG1ldGhvZD86IFRoZSBTb2xpZGl0eSBtZXRob2Qgc2lnbmF0dXJlXG4gICAgLy8gIC0gZXJyb3JTaWduYXR1cmU/OiBUaGUgRUlQODQ4IGVycm9yIHNpZ25hdHVyZVxuICAgIC8vICAtIGVycm9yQXJncz86IFRoZSBFSVA4NDggZXJyb3IgcGFyYW1ldGVyc1xuICAgIC8vICAtIHJlYXNvbjogVGhlIHJlYXNvbiAob25seSBmb3IgRUlQODQ4IFwiRXJyb3Ioc3RyaW5nKVwiKVxuICAgIEVycm9yQ29kZVtcIkNBTExfRVhDRVBUSU9OXCJdID0gXCJDQUxMX0VYQ0VQVElPTlwiO1xuICAgIC8vIEluc3VmZmljaWVudCBmdW5kcyAoPCB2YWx1ZSArIGdhc0xpbWl0ICogZ2FzUHJpY2UpXG4gICAgLy8gICAtIHRyYW5zYWN0aW9uOiB0aGUgdHJhbnNhY3Rpb24gYXR0ZW1wdGVkXG4gICAgRXJyb3JDb2RlW1wiSU5TVUZGSUNJRU5UX0ZVTkRTXCJdID0gXCJJTlNVRkZJQ0lFTlRfRlVORFNcIjtcbiAgICAvLyBOb25jZSBoYXMgYWxyZWFkeSBiZWVuIHVzZWRcbiAgICAvLyAgIC0gdHJhbnNhY3Rpb246IHRoZSB0cmFuc2FjdGlvbiBhdHRlbXB0ZWRcbiAgICBFcnJvckNvZGVbXCJOT05DRV9FWFBJUkVEXCJdID0gXCJOT05DRV9FWFBJUkVEXCI7XG4gICAgLy8gVGhlIHJlcGxhY2VtZW50IGZlZSBmb3IgdGhlIHRyYW5zYWN0aW9uIGlzIHRvbyBsb3dcbiAgICAvLyAgIC0gdHJhbnNhY3Rpb246IHRoZSB0cmFuc2FjdGlvbiBhdHRlbXB0ZWRcbiAgICBFcnJvckNvZGVbXCJSRVBMQUNFTUVOVF9VTkRFUlBSSUNFRFwiXSA9IFwiUkVQTEFDRU1FTlRfVU5ERVJQUklDRURcIjtcbiAgICAvLyBUaGUgZ2FzIGxpbWl0IGNvdWxkIG5vdCBiZSBlc3RpbWF0ZWRcbiAgICAvLyAgIC0gdHJhbnNhY3Rpb246IHRoZSB0cmFuc2FjdGlvbiBwYXNzZWQgdG8gZXN0aW1hdGVHYXNcbiAgICBFcnJvckNvZGVbXCJVTlBSRURJQ1RBQkxFX0dBU19MSU1JVFwiXSA9IFwiVU5QUkVESUNUQUJMRV9HQVNfTElNSVRcIjtcbiAgICAvLyBUaGUgdHJhbnNhY3Rpb24gd2FzIHJlcGxhY2VkIGJ5IG9uZSB3aXRoIGEgaGlnaGVyIGdhcyBwcmljZVxuICAgIC8vICAgLSByZWFzb246IFwiY2FuY2VsbGVkXCIsIFwicmVwbGFjZWRcIiBvciBcInJlcHJpY2VkXCJcbiAgICAvLyAgIC0gY2FuY2VsbGVkOiB0cnVlIGlmIHJlYXNvbiA9PSBcImNhbmNlbGxlZFwiIG9yIHJlYXNvbiA9PSBcInJlcGxhY2VkXCIpXG4gICAgLy8gICAtIGhhc2g6IG9yaWdpbmFsIHRyYW5zYWN0aW9uIGhhc2hcbiAgICAvLyAgIC0gcmVwbGFjZW1lbnQ6IHRoZSBmdWxsIFRyYW5zYWN0aW9uc1Jlc3BvbnNlIGZvciB0aGUgcmVwbGFjZW1lbnRcbiAgICAvLyAgIC0gcmVjZWlwdDogdGhlIHJlY2VpcHQgb2YgdGhlIHJlcGxhY2VtZW50XG4gICAgRXJyb3JDb2RlW1wiVFJBTlNBQ1RJT05fUkVQTEFDRURcIl0gPSBcIlRSQU5TQUNUSU9OX1JFUExBQ0VEXCI7XG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vIEludGVyYWN0aW9uIEVycm9yc1xuICAgIC8vIFRoZSB1c2VyIHJlamVjdGVkIHRoZSBhY3Rpb24sIHN1Y2ggYXMgc2lnbmluZyBhIG1lc3NhZ2Ugb3Igc2VuZGluZ1xuICAgIC8vIGEgdHJhbnNhY3Rpb25cbiAgICBFcnJvckNvZGVbXCJBQ1RJT05fUkVKRUNURURcIl0gPSBcIkFDVElPTl9SRUpFQ1RFRFwiO1xufSkoRXJyb3JDb2RlIHx8IChFcnJvckNvZGUgPSB7fSkpO1xuO1xuY29uc3QgSEVYID0gXCIwMTIzNDU2Nzg5YWJjZGVmXCI7XG5leHBvcnQgY2xhc3MgTG9nZ2VyIHtcbiAgICBjb25zdHJ1Y3Rvcih2ZXJzaW9uKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInZlcnNpb25cIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2ZXJzaW9uLFxuICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfbG9nKGxvZ0xldmVsLCBhcmdzKSB7XG4gICAgICAgIGNvbnN0IGxldmVsID0gbG9nTGV2ZWwudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKExvZ0xldmVsc1tsZXZlbF0gPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGxvZyBsZXZlbCBuYW1lXCIsIFwibG9nTGV2ZWxcIiwgbG9nTGV2ZWwpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfbG9nTGV2ZWwgPiBMb2dMZXZlbHNbbGV2ZWxdKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJncyk7XG4gICAgfVxuICAgIGRlYnVnKC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5fbG9nKExvZ2dlci5sZXZlbHMuREVCVUcsIGFyZ3MpO1xuICAgIH1cbiAgICBpbmZvKC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5fbG9nKExvZ2dlci5sZXZlbHMuSU5GTywgYXJncyk7XG4gICAgfVxuICAgIHdhcm4oLi4uYXJncykge1xuICAgICAgICB0aGlzLl9sb2coTG9nZ2VyLmxldmVscy5XQVJOSU5HLCBhcmdzKTtcbiAgICB9XG4gICAgbWFrZUVycm9yKG1lc3NhZ2UsIGNvZGUsIHBhcmFtcykge1xuICAgICAgICAvLyBFcnJvcnMgYXJlIGJlaW5nIGNlbnNvcmVkXG4gICAgICAgIGlmIChfY2Vuc29yRXJyb3JzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYWtlRXJyb3IoXCJjZW5zb3JlZCBlcnJvclwiLCBjb2RlLCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjb2RlKSB7XG4gICAgICAgICAgICBjb2RlID0gTG9nZ2VyLmVycm9ycy5VTktOT1dOX0VSUk9SO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcGFyYW1zKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXNzYWdlRGV0YWlscyA9IFtdO1xuICAgICAgICBPYmplY3Qua2V5cyhwYXJhbXMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgaGV4ID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGV4ICs9IEhFWFt2YWx1ZVtpXSA+PiA0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhleCArPSBIRVhbdmFsdWVbaV0gJiAweDBmXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlRGV0YWlscy5wdXNoKGtleSArIFwiPVVpbnQ4QXJyYXkoMHhcIiArIGhleCArIFwiKVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VEZXRhaWxzLnB1c2goa2V5ICsgXCI9XCIgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2VEZXRhaWxzLnB1c2goa2V5ICsgXCI9XCIgKyBKU09OLnN0cmluZ2lmeShwYXJhbXNba2V5XS50b1N0cmluZygpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBtZXNzYWdlRGV0YWlscy5wdXNoKGBjb2RlPSR7Y29kZX1gKTtcbiAgICAgICAgbWVzc2FnZURldGFpbHMucHVzaChgdmVyc2lvbj0ke3RoaXMudmVyc2lvbn1gKTtcbiAgICAgICAgY29uc3QgcmVhc29uID0gbWVzc2FnZTtcbiAgICAgICAgbGV0IHVybCA9IFwiXCI7XG4gICAgICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICAgICAgY2FzZSBFcnJvckNvZGUuTlVNRVJJQ19GQVVMVDoge1xuICAgICAgICAgICAgICAgIHVybCA9IFwiTlVNRVJJQ19GQVVMVFwiO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZhdWx0ID0gbWVzc2FnZTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGZhdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJvdmVyZmxvd1wiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwidW5kZXJmbG93XCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJkaXZpc2lvbi1ieS16ZXJvXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgKz0gXCItXCIgKyBmYXVsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwibmVnYXRpdmUtcG93ZXJcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm5lZ2F0aXZlLXdpZHRoXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgKz0gXCItdW5zdXBwb3J0ZWRcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwidW5ib3VuZC1iaXR3aXNlLXJlc3VsdFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsICs9IFwiLXVuYm91bmQtcmVzdWx0XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIEVycm9yQ29kZS5DQUxMX0VYQ0VQVElPTjpcbiAgICAgICAgICAgIGNhc2UgRXJyb3JDb2RlLklOU1VGRklDSUVOVF9GVU5EUzpcbiAgICAgICAgICAgIGNhc2UgRXJyb3JDb2RlLk1JU1NJTkdfTkVXOlxuICAgICAgICAgICAgY2FzZSBFcnJvckNvZGUuTk9OQ0VfRVhQSVJFRDpcbiAgICAgICAgICAgIGNhc2UgRXJyb3JDb2RlLlJFUExBQ0VNRU5UX1VOREVSUFJJQ0VEOlxuICAgICAgICAgICAgY2FzZSBFcnJvckNvZGUuVFJBTlNBQ1RJT05fUkVQTEFDRUQ6XG4gICAgICAgICAgICBjYXNlIEVycm9yQ29kZS5VTlBSRURJQ1RBQkxFX0dBU19MSU1JVDpcbiAgICAgICAgICAgICAgICB1cmwgPSBjb2RlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1cmwpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgKz0gXCIgWyBTZWU6IGh0dHBzOi9cXC9saW5rcy5ldGhlcnMub3JnL3Y1LWVycm9ycy1cIiArIHVybCArIFwiIF1cIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZURldGFpbHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBtZXNzYWdlICs9IFwiIChcIiArIG1lc3NhZ2VEZXRhaWxzLmpvaW4oXCIsIFwiKSArIFwiKVwiO1xuICAgICAgICB9XG4gICAgICAgIC8vIEBUT0RPOiBBbnk/P1xuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgZXJyb3IucmVhc29uID0gcmVhc29uO1xuICAgICAgICBlcnJvci5jb2RlID0gY29kZTtcbiAgICAgICAgT2JqZWN0LmtleXMocGFyYW1zKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGVycm9yW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBlcnJvcjtcbiAgICB9XG4gICAgdGhyb3dFcnJvcihtZXNzYWdlLCBjb2RlLCBwYXJhbXMpIHtcbiAgICAgICAgdGhyb3cgdGhpcy5tYWtlRXJyb3IobWVzc2FnZSwgY29kZSwgcGFyYW1zKTtcbiAgICB9XG4gICAgdGhyb3dBcmd1bWVudEVycm9yKG1lc3NhZ2UsIG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRocm93RXJyb3IobWVzc2FnZSwgTG9nZ2VyLmVycm9ycy5JTlZBTElEX0FSR1VNRU5ULCB7XG4gICAgICAgICAgICBhcmd1bWVudDogbmFtZSxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXNzZXJ0KGNvbmRpdGlvbiwgbWVzc2FnZSwgY29kZSwgcGFyYW1zKSB7XG4gICAgICAgIGlmICghIWNvbmRpdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGhyb3dFcnJvcihtZXNzYWdlLCBjb2RlLCBwYXJhbXMpO1xuICAgIH1cbiAgICBhc3NlcnRBcmd1bWVudChjb25kaXRpb24sIG1lc3NhZ2UsIG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIGlmICghIWNvbmRpdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGhyb3dBcmd1bWVudEVycm9yKG1lc3NhZ2UsIG5hbWUsIHZhbHVlKTtcbiAgICB9XG4gICAgY2hlY2tOb3JtYWxpemUobWVzc2FnZSkge1xuICAgICAgICBpZiAobWVzc2FnZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gXCJwbGF0Zm9ybSBtaXNzaW5nIFN0cmluZy5wcm90b3R5cGUubm9ybWFsaXplXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF9ub3JtYWxpemVFcnJvcikge1xuICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKFwicGxhdGZvcm0gbWlzc2luZyBTdHJpbmcucHJvdG90eXBlLm5vcm1hbGl6ZVwiLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJTdHJpbmcucHJvdG90eXBlLm5vcm1hbGl6ZVwiLCBmb3JtOiBfbm9ybWFsaXplRXJyb3JcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNoZWNrU2FmZVVpbnQ1Myh2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICBpZiAodHlwZW9mICh2YWx1ZSkgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gXCJ2YWx1ZSBub3Qgc2FmZVwiO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSA8IDAgfHwgdmFsdWUgPj0gMHgxZmZmZmZmZmZmZmZmZikge1xuICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKG1lc3NhZ2UsIExvZ2dlci5lcnJvcnMuTlVNRVJJQ19GQVVMVCwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJjaGVja1NhZmVJbnRlZ2VyXCIsXG4gICAgICAgICAgICAgICAgZmF1bHQ6IFwib3V0LW9mLXNhZmUtcmFuZ2VcIixcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSAlIDEpIHtcbiAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihtZXNzYWdlLCBMb2dnZXIuZXJyb3JzLk5VTUVSSUNfRkFVTFQsIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwiY2hlY2tTYWZlSW50ZWdlclwiLFxuICAgICAgICAgICAgICAgIGZhdWx0OiBcIm5vbi1pbnRlZ2VyXCIsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjaGVja0FyZ3VtZW50Q291bnQoY291bnQsIGV4cGVjdGVkQ291bnQsIG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBcIjogXCIgKyBtZXNzYWdlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZSA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvdW50IDwgZXhwZWN0ZWRDb3VudCkge1xuICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKFwibWlzc2luZyBhcmd1bWVudFwiICsgbWVzc2FnZSwgTG9nZ2VyLmVycm9ycy5NSVNTSU5HX0FSR1VNRU5ULCB7XG4gICAgICAgICAgICAgICAgY291bnQ6IGNvdW50LFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkQ291bnQ6IGV4cGVjdGVkQ291bnRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb3VudCA+IGV4cGVjdGVkQ291bnQpIHtcbiAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihcInRvbyBtYW55IGFyZ3VtZW50c1wiICsgbWVzc2FnZSwgTG9nZ2VyLmVycm9ycy5VTkVYUEVDVEVEX0FSR1VNRU5ULCB7XG4gICAgICAgICAgICAgICAgY291bnQ6IGNvdW50LFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkQ291bnQ6IGV4cGVjdGVkQ291bnRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNoZWNrTmV3KHRhcmdldCwga2luZCkge1xuICAgICAgICBpZiAodGFyZ2V0ID09PSBPYmplY3QgfHwgdGFyZ2V0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihcIm1pc3NpbmcgbmV3XCIsIExvZ2dlci5lcnJvcnMuTUlTU0lOR19ORVcsIHsgbmFtZToga2luZC5uYW1lIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNoZWNrQWJzdHJhY3QodGFyZ2V0LCBraW5kKSB7XG4gICAgICAgIGlmICh0YXJnZXQgPT09IGtpbmQpIHtcbiAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihcImNhbm5vdCBpbnN0YW50aWF0ZSBhYnN0cmFjdCBjbGFzcyBcIiArIEpTT04uc3RyaW5naWZ5KGtpbmQubmFtZSkgKyBcIiBkaXJlY3RseTsgdXNlIGEgc3ViLWNsYXNzXCIsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7IG5hbWU6IHRhcmdldC5uYW1lLCBvcGVyYXRpb246IFwibmV3XCIgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGFyZ2V0ID09PSBPYmplY3QgfHwgdGFyZ2V0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihcIm1pc3NpbmcgbmV3XCIsIExvZ2dlci5lcnJvcnMuTUlTU0lOR19ORVcsIHsgbmFtZToga2luZC5uYW1lIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBnbG9iYWxMb2dnZXIoKSB7XG4gICAgICAgIGlmICghX2dsb2JhbExvZ2dlcikge1xuICAgICAgICAgICAgX2dsb2JhbExvZ2dlciA9IG5ldyBMb2dnZXIodmVyc2lvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9nbG9iYWxMb2dnZXI7XG4gICAgfVxuICAgIHN0YXRpYyBzZXRDZW5zb3JzaGlwKGNlbnNvcnNoaXAsIHBlcm1hbmVudCkge1xuICAgICAgICBpZiAoIWNlbnNvcnNoaXAgJiYgcGVybWFuZW50KSB7XG4gICAgICAgICAgICB0aGlzLmdsb2JhbExvZ2dlcigpLnRocm93RXJyb3IoXCJjYW5ub3QgcGVybWFuZW50bHkgZGlzYWJsZSBjZW5zb3JzaGlwXCIsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcInNldENlbnNvcnNoaXBcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF9wZXJtYW5lbnRDZW5zb3JFcnJvcnMpIHtcbiAgICAgICAgICAgIGlmICghY2Vuc29yc2hpcCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZ2xvYmFsTG9nZ2VyKCkudGhyb3dFcnJvcihcImVycm9yIGNlbnNvcnNoaXAgcGVybWFuZW50XCIsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcInNldENlbnNvcnNoaXBcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgX2NlbnNvckVycm9ycyA9ICEhY2Vuc29yc2hpcDtcbiAgICAgICAgX3Blcm1hbmVudENlbnNvckVycm9ycyA9ICEhcGVybWFuZW50O1xuICAgIH1cbiAgICBzdGF0aWMgc2V0TG9nTGV2ZWwobG9nTGV2ZWwpIHtcbiAgICAgICAgY29uc3QgbGV2ZWwgPSBMb2dMZXZlbHNbbG9nTGV2ZWwudG9Mb3dlckNhc2UoKV07XG4gICAgICAgIGlmIChsZXZlbCA9PSBudWxsKSB7XG4gICAgICAgICAgICBMb2dnZXIuZ2xvYmFsTG9nZ2VyKCkud2FybihcImludmFsaWQgbG9nIGxldmVsIC0gXCIgKyBsb2dMZXZlbCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgX2xvZ0xldmVsID0gbGV2ZWw7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tKHZlcnNpb24pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMb2dnZXIodmVyc2lvbik7XG4gICAgfVxufVxuTG9nZ2VyLmVycm9ycyA9IEVycm9yQ29kZTtcbkxvZ2dlci5sZXZlbHMgPSBMb2dMZXZlbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ethersproject/logger/lib.esm/index.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@ethersproject/networks/lib.esm/_version.js":
/*!*******************************************************************!*\
  !*** ../node_modules/@ethersproject/networks/lib.esm/_version.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\nconst version = \"networks/5.7.1\";\n//# sourceMappingURL=_version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L25ldHdvcmtzL2xpYi5lc20vX3ZlcnNpb24uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFPO0FBQ1AiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sZWRnaXR5LXlpZWxkLWZyb250ZW5kLy4uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9uZXR3b3Jrcy9saWIuZXNtL192ZXJzaW9uLmpzPzc0NWEiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IHZlcnNpb24gPSBcIm5ldHdvcmtzLzUuNy4xXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdmVyc2lvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ethersproject/networks/lib.esm/_version.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@ethersproject/networks/lib.esm/index.js":
/*!****************************************************************!*\
  !*** ../node_modules/@ethersproject/networks/lib.esm/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getNetwork: () => (/* binding */ getNetwork)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/../node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(ssr)/../node_modules/@ethersproject/networks/lib.esm/_version.js\");\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\n;\nfunction isRenetworkable(value) {\n    return (value && typeof (value.renetwork) === \"function\");\n}\nfunction ethDefaultProvider(network) {\n    const func = function (providers, options) {\n        if (options == null) {\n            options = {};\n        }\n        const providerList = [];\n        if (providers.InfuraProvider && options.infura !== \"-\") {\n            try {\n                providerList.push(new providers.InfuraProvider(network, options.infura));\n            }\n            catch (error) { }\n        }\n        if (providers.EtherscanProvider && options.etherscan !== \"-\") {\n            try {\n                providerList.push(new providers.EtherscanProvider(network, options.etherscan));\n            }\n            catch (error) { }\n        }\n        if (providers.AlchemyProvider && options.alchemy !== \"-\") {\n            try {\n                providerList.push(new providers.AlchemyProvider(network, options.alchemy));\n            }\n            catch (error) { }\n        }\n        if (providers.PocketProvider && options.pocket !== \"-\") {\n            // These networks are currently faulty on Pocket as their\n            // network does not handle the Berlin hardfork, which is\n            // live on these ones.\n            // @TODO: This goes away once Pocket has upgraded their nodes\n            const skip = [\"goerli\", \"ropsten\", \"rinkeby\", \"sepolia\"];\n            try {\n                const provider = new providers.PocketProvider(network, options.pocket);\n                if (provider.network && skip.indexOf(provider.network.name) === -1) {\n                    providerList.push(provider);\n                }\n            }\n            catch (error) { }\n        }\n        if (providers.CloudflareProvider && options.cloudflare !== \"-\") {\n            try {\n                providerList.push(new providers.CloudflareProvider(network));\n            }\n            catch (error) { }\n        }\n        if (providers.AnkrProvider && options.ankr !== \"-\") {\n            try {\n                const skip = [\"ropsten\"];\n                const provider = new providers.AnkrProvider(network, options.ankr);\n                if (provider.network && skip.indexOf(provider.network.name) === -1) {\n                    providerList.push(provider);\n                }\n            }\n            catch (error) { }\n        }\n        if (providerList.length === 0) {\n            return null;\n        }\n        if (providers.FallbackProvider) {\n            let quorum = 1;\n            if (options.quorum != null) {\n                quorum = options.quorum;\n            }\n            else if (network === \"homestead\") {\n                quorum = 2;\n            }\n            return new providers.FallbackProvider(providerList, quorum);\n        }\n        return providerList[0];\n    };\n    func.renetwork = function (network) {\n        return ethDefaultProvider(network);\n    };\n    return func;\n}\nfunction etcDefaultProvider(url, network) {\n    const func = function (providers, options) {\n        if (providers.JsonRpcProvider) {\n            return new providers.JsonRpcProvider(url, network);\n        }\n        return null;\n    };\n    func.renetwork = function (network) {\n        return etcDefaultProvider(url, network);\n    };\n    return func;\n}\nconst homestead = {\n    chainId: 1,\n    ensAddress: \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\",\n    name: \"homestead\",\n    _defaultProvider: ethDefaultProvider(\"homestead\")\n};\nconst ropsten = {\n    chainId: 3,\n    ensAddress: \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\",\n    name: \"ropsten\",\n    _defaultProvider: ethDefaultProvider(\"ropsten\")\n};\nconst classicMordor = {\n    chainId: 63,\n    name: \"classicMordor\",\n    _defaultProvider: etcDefaultProvider(\"https://www.ethercluster.com/mordor\", \"classicMordor\")\n};\n// See: https://chainlist.org\nconst networks = {\n    unspecified: { chainId: 0, name: \"unspecified\" },\n    homestead: homestead,\n    mainnet: homestead,\n    morden: { chainId: 2, name: \"morden\" },\n    ropsten: ropsten,\n    testnet: ropsten,\n    rinkeby: {\n        chainId: 4,\n        ensAddress: \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\",\n        name: \"rinkeby\",\n        _defaultProvider: ethDefaultProvider(\"rinkeby\")\n    },\n    kovan: {\n        chainId: 42,\n        name: \"kovan\",\n        _defaultProvider: ethDefaultProvider(\"kovan\")\n    },\n    goerli: {\n        chainId: 5,\n        ensAddress: \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\",\n        name: \"goerli\",\n        _defaultProvider: ethDefaultProvider(\"goerli\")\n    },\n    kintsugi: { chainId: 1337702, name: \"kintsugi\" },\n    sepolia: {\n        chainId: 11155111,\n        name: \"sepolia\",\n        _defaultProvider: ethDefaultProvider(\"sepolia\")\n    },\n    // ETC (See: #351)\n    classic: {\n        chainId: 61,\n        name: \"classic\",\n        _defaultProvider: etcDefaultProvider(\"https:/\\/www.ethercluster.com/etc\", \"classic\")\n    },\n    classicMorden: { chainId: 62, name: \"classicMorden\" },\n    classicMordor: classicMordor,\n    classicTestnet: classicMordor,\n    classicKotti: {\n        chainId: 6,\n        name: \"classicKotti\",\n        _defaultProvider: etcDefaultProvider(\"https:/\\/www.ethercluster.com/kotti\", \"classicKotti\")\n    },\n    xdai: { chainId: 100, name: \"xdai\" },\n    matic: {\n        chainId: 137,\n        name: \"matic\",\n        _defaultProvider: ethDefaultProvider(\"matic\")\n    },\n    maticmum: { chainId: 80001, name: \"maticmum\" },\n    optimism: {\n        chainId: 10,\n        name: \"optimism\",\n        _defaultProvider: ethDefaultProvider(\"optimism\")\n    },\n    \"optimism-kovan\": { chainId: 69, name: \"optimism-kovan\" },\n    \"optimism-goerli\": { chainId: 420, name: \"optimism-goerli\" },\n    arbitrum: { chainId: 42161, name: \"arbitrum\" },\n    \"arbitrum-rinkeby\": { chainId: 421611, name: \"arbitrum-rinkeby\" },\n    \"arbitrum-goerli\": { chainId: 421613, name: \"arbitrum-goerli\" },\n    bnb: { chainId: 56, name: \"bnb\" },\n    bnbt: { chainId: 97, name: \"bnbt\" },\n};\n/**\n *  getNetwork\n *\n *  Converts a named common networks or chain ID (network ID) to a Network\n *  and verifies a network is a valid Network..\n */\nfunction getNetwork(network) {\n    // No network (null)\n    if (network == null) {\n        return null;\n    }\n    if (typeof (network) === \"number\") {\n        for (const name in networks) {\n            const standard = networks[name];\n            if (standard.chainId === network) {\n                return {\n                    name: standard.name,\n                    chainId: standard.chainId,\n                    ensAddress: (standard.ensAddress || null),\n                    _defaultProvider: (standard._defaultProvider || null)\n                };\n            }\n        }\n        return {\n            chainId: network,\n            name: \"unknown\"\n        };\n    }\n    if (typeof (network) === \"string\") {\n        const standard = networks[network];\n        if (standard == null) {\n            return null;\n        }\n        return {\n            name: standard.name,\n            chainId: standard.chainId,\n            ensAddress: standard.ensAddress,\n            _defaultProvider: (standard._defaultProvider || null)\n        };\n    }\n    const standard = networks[network.name];\n    // Not a standard network; check that it is a valid network in general\n    if (!standard) {\n        if (typeof (network.chainId) !== \"number\") {\n            logger.throwArgumentError(\"invalid network chainId\", \"network\", network);\n        }\n        return network;\n    }\n    // Make sure the chainId matches the expected network chainId (or is 0; disable EIP-155)\n    if (network.chainId !== 0 && network.chainId !== standard.chainId) {\n        logger.throwArgumentError(\"network chainId mismatch\", \"network\", network);\n    }\n    // @TODO: In the next major version add an attach function to a defaultProvider\n    // class and move the _defaultProvider internal to this file (extend Network)\n    let defaultProvider = network._defaultProvider || null;\n    if (defaultProvider == null && standard._defaultProvider) {\n        if (isRenetworkable(standard._defaultProvider)) {\n            defaultProvider = standard._defaultProvider.renetwork(network);\n        }\n        else {\n            defaultProvider = standard._defaultProvider;\n        }\n    }\n    // Standard Network (allow overriding the ENS address)\n    return {\n        name: network.name,\n        chainId: standard.chainId,\n        ensAddress: (network.ensAddress || standard.ensAddress || null),\n        _defaultProvider: defaultProvider\n    };\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L25ldHdvcmtzL2xpYi5lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQWE7QUFDa0M7QUFDVjtBQUNyQyxtQkFBbUIseURBQU0sQ0FBQyw2Q0FBTztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpQ0FBaUM7QUFDcEQ7QUFDQTtBQUNBLGNBQWMsNEJBQTRCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsZ0JBQWdCLG9DQUFvQztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHFCQUFxQixvQ0FBb0M7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLFlBQVksNEJBQTRCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGdCQUFnQixrQ0FBa0M7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsd0JBQXdCLHFDQUFxQztBQUM3RCx5QkFBeUIsdUNBQXVDO0FBQ2hFLGdCQUFnQixrQ0FBa0M7QUFDbEQsMEJBQTBCLDJDQUEyQztBQUNyRSx5QkFBeUIsMENBQTBDO0FBQ25FLFdBQVcsMEJBQTBCO0FBQ3JDLFlBQVksMkJBQTJCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEU7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xlZGdpdHkteWllbGQtZnJvbnRlbmQvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L25ldHdvcmtzL2xpYi5lc20vaW5kZXguanM/OWUzMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi9fdmVyc2lvblwiO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcih2ZXJzaW9uKTtcbjtcbmZ1bmN0aW9uIGlzUmVuZXR3b3JrYWJsZSh2YWx1ZSkge1xuICAgIHJldHVybiAodmFsdWUgJiYgdHlwZW9mICh2YWx1ZS5yZW5ldHdvcmspID09PSBcImZ1bmN0aW9uXCIpO1xufVxuZnVuY3Rpb24gZXRoRGVmYXVsdFByb3ZpZGVyKG5ldHdvcmspIHtcbiAgICBjb25zdCBmdW5jID0gZnVuY3Rpb24gKHByb3ZpZGVycywgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PSBudWxsKSB7XG4gICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJvdmlkZXJMaXN0ID0gW107XG4gICAgICAgIGlmIChwcm92aWRlcnMuSW5mdXJhUHJvdmlkZXIgJiYgb3B0aW9ucy5pbmZ1cmEgIT09IFwiLVwiKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyTGlzdC5wdXNoKG5ldyBwcm92aWRlcnMuSW5mdXJhUHJvdmlkZXIobmV0d29yaywgb3B0aW9ucy5pbmZ1cmEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3ZpZGVycy5FdGhlcnNjYW5Qcm92aWRlciAmJiBvcHRpb25zLmV0aGVyc2NhbiAhPT0gXCItXCIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcHJvdmlkZXJMaXN0LnB1c2gobmV3IHByb3ZpZGVycy5FdGhlcnNjYW5Qcm92aWRlcihuZXR3b3JrLCBvcHRpb25zLmV0aGVyc2NhbikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvdmlkZXJzLkFsY2hlbXlQcm92aWRlciAmJiBvcHRpb25zLmFsY2hlbXkgIT09IFwiLVwiKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyTGlzdC5wdXNoKG5ldyBwcm92aWRlcnMuQWxjaGVteVByb3ZpZGVyKG5ldHdvcmssIG9wdGlvbnMuYWxjaGVteSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvdmlkZXJzLlBvY2tldFByb3ZpZGVyICYmIG9wdGlvbnMucG9ja2V0ICE9PSBcIi1cIikge1xuICAgICAgICAgICAgLy8gVGhlc2UgbmV0d29ya3MgYXJlIGN1cnJlbnRseSBmYXVsdHkgb24gUG9ja2V0IGFzIHRoZWlyXG4gICAgICAgICAgICAvLyBuZXR3b3JrIGRvZXMgbm90IGhhbmRsZSB0aGUgQmVybGluIGhhcmRmb3JrLCB3aGljaCBpc1xuICAgICAgICAgICAgLy8gbGl2ZSBvbiB0aGVzZSBvbmVzLlxuICAgICAgICAgICAgLy8gQFRPRE86IFRoaXMgZ29lcyBhd2F5IG9uY2UgUG9ja2V0IGhhcyB1cGdyYWRlZCB0aGVpciBub2Rlc1xuICAgICAgICAgICAgY29uc3Qgc2tpcCA9IFtcImdvZXJsaVwiLCBcInJvcHN0ZW5cIiwgXCJyaW5rZWJ5XCIsIFwic2Vwb2xpYVwiXTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBuZXcgcHJvdmlkZXJzLlBvY2tldFByb3ZpZGVyKG5ldHdvcmssIG9wdGlvbnMucG9ja2V0KTtcbiAgICAgICAgICAgICAgICBpZiAocHJvdmlkZXIubmV0d29yayAmJiBza2lwLmluZGV4T2YocHJvdmlkZXIubmV0d29yay5uYW1lKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJMaXN0LnB1c2gocHJvdmlkZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3ZpZGVycy5DbG91ZGZsYXJlUHJvdmlkZXIgJiYgb3B0aW9ucy5jbG91ZGZsYXJlICE9PSBcIi1cIikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwcm92aWRlckxpc3QucHVzaChuZXcgcHJvdmlkZXJzLkNsb3VkZmxhcmVQcm92aWRlcihuZXR3b3JrKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwcm92aWRlcnMuQW5rclByb3ZpZGVyICYmIG9wdGlvbnMuYW5rciAhPT0gXCItXCIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2tpcCA9IFtcInJvcHN0ZW5cIl07XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBuZXcgcHJvdmlkZXJzLkFua3JQcm92aWRlcihuZXR3b3JrLCBvcHRpb25zLmFua3IpO1xuICAgICAgICAgICAgICAgIGlmIChwcm92aWRlci5uZXR3b3JrICYmIHNraXAuaW5kZXhPZihwcm92aWRlci5uZXR3b3JrLm5hbWUpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBwcm92aWRlckxpc3QucHVzaChwcm92aWRlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvdmlkZXJMaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3ZpZGVycy5GYWxsYmFja1Byb3ZpZGVyKSB7XG4gICAgICAgICAgICBsZXQgcXVvcnVtID0gMTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnF1b3J1bSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcXVvcnVtID0gb3B0aW9ucy5xdW9ydW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChuZXR3b3JrID09PSBcImhvbWVzdGVhZFwiKSB7XG4gICAgICAgICAgICAgICAgcXVvcnVtID0gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgcHJvdmlkZXJzLkZhbGxiYWNrUHJvdmlkZXIocHJvdmlkZXJMaXN0LCBxdW9ydW0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm92aWRlckxpc3RbMF07XG4gICAgfTtcbiAgICBmdW5jLnJlbmV0d29yayA9IGZ1bmN0aW9uIChuZXR3b3JrKSB7XG4gICAgICAgIHJldHVybiBldGhEZWZhdWx0UHJvdmlkZXIobmV0d29yayk7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuYztcbn1cbmZ1bmN0aW9uIGV0Y0RlZmF1bHRQcm92aWRlcih1cmwsIG5ldHdvcmspIHtcbiAgICBjb25zdCBmdW5jID0gZnVuY3Rpb24gKHByb3ZpZGVycywgb3B0aW9ucykge1xuICAgICAgICBpZiAocHJvdmlkZXJzLkpzb25ScGNQcm92aWRlcikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBwcm92aWRlcnMuSnNvblJwY1Byb3ZpZGVyKHVybCwgbmV0d29yayk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBmdW5jLnJlbmV0d29yayA9IGZ1bmN0aW9uIChuZXR3b3JrKSB7XG4gICAgICAgIHJldHVybiBldGNEZWZhdWx0UHJvdmlkZXIodXJsLCBuZXR3b3JrKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jO1xufVxuY29uc3QgaG9tZXN0ZWFkID0ge1xuICAgIGNoYWluSWQ6IDEsXG4gICAgZW5zQWRkcmVzczogXCIweDAwMDAwMDAwMDAwQzJFMDc0ZUM2OUEwZEZiMjk5N0JBNkM3ZDJlMWVcIixcbiAgICBuYW1lOiBcImhvbWVzdGVhZFwiLFxuICAgIF9kZWZhdWx0UHJvdmlkZXI6IGV0aERlZmF1bHRQcm92aWRlcihcImhvbWVzdGVhZFwiKVxufTtcbmNvbnN0IHJvcHN0ZW4gPSB7XG4gICAgY2hhaW5JZDogMyxcbiAgICBlbnNBZGRyZXNzOiBcIjB4MDAwMDAwMDAwMDBDMkUwNzRlQzY5QTBkRmIyOTk3QkE2QzdkMmUxZVwiLFxuICAgIG5hbWU6IFwicm9wc3RlblwiLFxuICAgIF9kZWZhdWx0UHJvdmlkZXI6IGV0aERlZmF1bHRQcm92aWRlcihcInJvcHN0ZW5cIilcbn07XG5jb25zdCBjbGFzc2ljTW9yZG9yID0ge1xuICAgIGNoYWluSWQ6IDYzLFxuICAgIG5hbWU6IFwiY2xhc3NpY01vcmRvclwiLFxuICAgIF9kZWZhdWx0UHJvdmlkZXI6IGV0Y0RlZmF1bHRQcm92aWRlcihcImh0dHBzOi8vd3d3LmV0aGVyY2x1c3Rlci5jb20vbW9yZG9yXCIsIFwiY2xhc3NpY01vcmRvclwiKVxufTtcbi8vIFNlZTogaHR0cHM6Ly9jaGFpbmxpc3Qub3JnXG5jb25zdCBuZXR3b3JrcyA9IHtcbiAgICB1bnNwZWNpZmllZDogeyBjaGFpbklkOiAwLCBuYW1lOiBcInVuc3BlY2lmaWVkXCIgfSxcbiAgICBob21lc3RlYWQ6IGhvbWVzdGVhZCxcbiAgICBtYWlubmV0OiBob21lc3RlYWQsXG4gICAgbW9yZGVuOiB7IGNoYWluSWQ6IDIsIG5hbWU6IFwibW9yZGVuXCIgfSxcbiAgICByb3BzdGVuOiByb3BzdGVuLFxuICAgIHRlc3RuZXQ6IHJvcHN0ZW4sXG4gICAgcmlua2VieToge1xuICAgICAgICBjaGFpbklkOiA0LFxuICAgICAgICBlbnNBZGRyZXNzOiBcIjB4MDAwMDAwMDAwMDBDMkUwNzRlQzY5QTBkRmIyOTk3QkE2QzdkMmUxZVwiLFxuICAgICAgICBuYW1lOiBcInJpbmtlYnlcIixcbiAgICAgICAgX2RlZmF1bHRQcm92aWRlcjogZXRoRGVmYXVsdFByb3ZpZGVyKFwicmlua2VieVwiKVxuICAgIH0sXG4gICAga292YW46IHtcbiAgICAgICAgY2hhaW5JZDogNDIsXG4gICAgICAgIG5hbWU6IFwia292YW5cIixcbiAgICAgICAgX2RlZmF1bHRQcm92aWRlcjogZXRoRGVmYXVsdFByb3ZpZGVyKFwia292YW5cIilcbiAgICB9LFxuICAgIGdvZXJsaToge1xuICAgICAgICBjaGFpbklkOiA1LFxuICAgICAgICBlbnNBZGRyZXNzOiBcIjB4MDAwMDAwMDAwMDBDMkUwNzRlQzY5QTBkRmIyOTk3QkE2QzdkMmUxZVwiLFxuICAgICAgICBuYW1lOiBcImdvZXJsaVwiLFxuICAgICAgICBfZGVmYXVsdFByb3ZpZGVyOiBldGhEZWZhdWx0UHJvdmlkZXIoXCJnb2VybGlcIilcbiAgICB9LFxuICAgIGtpbnRzdWdpOiB7IGNoYWluSWQ6IDEzMzc3MDIsIG5hbWU6IFwia2ludHN1Z2lcIiB9LFxuICAgIHNlcG9saWE6IHtcbiAgICAgICAgY2hhaW5JZDogMTExNTUxMTEsXG4gICAgICAgIG5hbWU6IFwic2Vwb2xpYVwiLFxuICAgICAgICBfZGVmYXVsdFByb3ZpZGVyOiBldGhEZWZhdWx0UHJvdmlkZXIoXCJzZXBvbGlhXCIpXG4gICAgfSxcbiAgICAvLyBFVEMgKFNlZTogIzM1MSlcbiAgICBjbGFzc2ljOiB7XG4gICAgICAgIGNoYWluSWQ6IDYxLFxuICAgICAgICBuYW1lOiBcImNsYXNzaWNcIixcbiAgICAgICAgX2RlZmF1bHRQcm92aWRlcjogZXRjRGVmYXVsdFByb3ZpZGVyKFwiaHR0cHM6L1xcL3d3dy5ldGhlcmNsdXN0ZXIuY29tL2V0Y1wiLCBcImNsYXNzaWNcIilcbiAgICB9LFxuICAgIGNsYXNzaWNNb3JkZW46IHsgY2hhaW5JZDogNjIsIG5hbWU6IFwiY2xhc3NpY01vcmRlblwiIH0sXG4gICAgY2xhc3NpY01vcmRvcjogY2xhc3NpY01vcmRvcixcbiAgICBjbGFzc2ljVGVzdG5ldDogY2xhc3NpY01vcmRvcixcbiAgICBjbGFzc2ljS290dGk6IHtcbiAgICAgICAgY2hhaW5JZDogNixcbiAgICAgICAgbmFtZTogXCJjbGFzc2ljS290dGlcIixcbiAgICAgICAgX2RlZmF1bHRQcm92aWRlcjogZXRjRGVmYXVsdFByb3ZpZGVyKFwiaHR0cHM6L1xcL3d3dy5ldGhlcmNsdXN0ZXIuY29tL2tvdHRpXCIsIFwiY2xhc3NpY0tvdHRpXCIpXG4gICAgfSxcbiAgICB4ZGFpOiB7IGNoYWluSWQ6IDEwMCwgbmFtZTogXCJ4ZGFpXCIgfSxcbiAgICBtYXRpYzoge1xuICAgICAgICBjaGFpbklkOiAxMzcsXG4gICAgICAgIG5hbWU6IFwibWF0aWNcIixcbiAgICAgICAgX2RlZmF1bHRQcm92aWRlcjogZXRoRGVmYXVsdFByb3ZpZGVyKFwibWF0aWNcIilcbiAgICB9LFxuICAgIG1hdGljbXVtOiB7IGNoYWluSWQ6IDgwMDAxLCBuYW1lOiBcIm1hdGljbXVtXCIgfSxcbiAgICBvcHRpbWlzbToge1xuICAgICAgICBjaGFpbklkOiAxMCxcbiAgICAgICAgbmFtZTogXCJvcHRpbWlzbVwiLFxuICAgICAgICBfZGVmYXVsdFByb3ZpZGVyOiBldGhEZWZhdWx0UHJvdmlkZXIoXCJvcHRpbWlzbVwiKVxuICAgIH0sXG4gICAgXCJvcHRpbWlzbS1rb3ZhblwiOiB7IGNoYWluSWQ6IDY5LCBuYW1lOiBcIm9wdGltaXNtLWtvdmFuXCIgfSxcbiAgICBcIm9wdGltaXNtLWdvZXJsaVwiOiB7IGNoYWluSWQ6IDQyMCwgbmFtZTogXCJvcHRpbWlzbS1nb2VybGlcIiB9LFxuICAgIGFyYml0cnVtOiB7IGNoYWluSWQ6IDQyMTYxLCBuYW1lOiBcImFyYml0cnVtXCIgfSxcbiAgICBcImFyYml0cnVtLXJpbmtlYnlcIjogeyBjaGFpbklkOiA0MjE2MTEsIG5hbWU6IFwiYXJiaXRydW0tcmlua2VieVwiIH0sXG4gICAgXCJhcmJpdHJ1bS1nb2VybGlcIjogeyBjaGFpbklkOiA0MjE2MTMsIG5hbWU6IFwiYXJiaXRydW0tZ29lcmxpXCIgfSxcbiAgICBibmI6IHsgY2hhaW5JZDogNTYsIG5hbWU6IFwiYm5iXCIgfSxcbiAgICBibmJ0OiB7IGNoYWluSWQ6IDk3LCBuYW1lOiBcImJuYnRcIiB9LFxufTtcbi8qKlxuICogIGdldE5ldHdvcmtcbiAqXG4gKiAgQ29udmVydHMgYSBuYW1lZCBjb21tb24gbmV0d29ya3Mgb3IgY2hhaW4gSUQgKG5ldHdvcmsgSUQpIHRvIGEgTmV0d29ya1xuICogIGFuZCB2ZXJpZmllcyBhIG5ldHdvcmsgaXMgYSB2YWxpZCBOZXR3b3JrLi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldE5ldHdvcmsobmV0d29yaykge1xuICAgIC8vIE5vIG5ldHdvcmsgKG51bGwpXG4gICAgaWYgKG5ldHdvcmsgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAobmV0d29yaykgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIGluIG5ldHdvcmtzKSB7XG4gICAgICAgICAgICBjb25zdCBzdGFuZGFyZCA9IG5ldHdvcmtzW25hbWVdO1xuICAgICAgICAgICAgaWYgKHN0YW5kYXJkLmNoYWluSWQgPT09IG5ldHdvcmspIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBzdGFuZGFyZC5uYW1lLFxuICAgICAgICAgICAgICAgICAgICBjaGFpbklkOiBzdGFuZGFyZC5jaGFpbklkLFxuICAgICAgICAgICAgICAgICAgICBlbnNBZGRyZXNzOiAoc3RhbmRhcmQuZW5zQWRkcmVzcyB8fCBudWxsKSxcbiAgICAgICAgICAgICAgICAgICAgX2RlZmF1bHRQcm92aWRlcjogKHN0YW5kYXJkLl9kZWZhdWx0UHJvdmlkZXIgfHwgbnVsbClcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjaGFpbklkOiBuZXR3b3JrLFxuICAgICAgICAgICAgbmFtZTogXCJ1bmtub3duXCJcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAobmV0d29yaykgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgY29uc3Qgc3RhbmRhcmQgPSBuZXR3b3Jrc1tuZXR3b3JrXTtcbiAgICAgICAgaWYgKHN0YW5kYXJkID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lOiBzdGFuZGFyZC5uYW1lLFxuICAgICAgICAgICAgY2hhaW5JZDogc3RhbmRhcmQuY2hhaW5JZCxcbiAgICAgICAgICAgIGVuc0FkZHJlc3M6IHN0YW5kYXJkLmVuc0FkZHJlc3MsXG4gICAgICAgICAgICBfZGVmYXVsdFByb3ZpZGVyOiAoc3RhbmRhcmQuX2RlZmF1bHRQcm92aWRlciB8fCBudWxsKVxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBzdGFuZGFyZCA9IG5ldHdvcmtzW25ldHdvcmsubmFtZV07XG4gICAgLy8gTm90IGEgc3RhbmRhcmQgbmV0d29yazsgY2hlY2sgdGhhdCBpdCBpcyBhIHZhbGlkIG5ldHdvcmsgaW4gZ2VuZXJhbFxuICAgIGlmICghc3RhbmRhcmQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAobmV0d29yay5jaGFpbklkKSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgbmV0d29yayBjaGFpbklkXCIsIFwibmV0d29ya1wiLCBuZXR3b3JrKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV0d29yaztcbiAgICB9XG4gICAgLy8gTWFrZSBzdXJlIHRoZSBjaGFpbklkIG1hdGNoZXMgdGhlIGV4cGVjdGVkIG5ldHdvcmsgY2hhaW5JZCAob3IgaXMgMDsgZGlzYWJsZSBFSVAtMTU1KVxuICAgIGlmIChuZXR3b3JrLmNoYWluSWQgIT09IDAgJiYgbmV0d29yay5jaGFpbklkICE9PSBzdGFuZGFyZC5jaGFpbklkKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJuZXR3b3JrIGNoYWluSWQgbWlzbWF0Y2hcIiwgXCJuZXR3b3JrXCIsIG5ldHdvcmspO1xuICAgIH1cbiAgICAvLyBAVE9ETzogSW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbiBhZGQgYW4gYXR0YWNoIGZ1bmN0aW9uIHRvIGEgZGVmYXVsdFByb3ZpZGVyXG4gICAgLy8gY2xhc3MgYW5kIG1vdmUgdGhlIF9kZWZhdWx0UHJvdmlkZXIgaW50ZXJuYWwgdG8gdGhpcyBmaWxlIChleHRlbmQgTmV0d29yaylcbiAgICBsZXQgZGVmYXVsdFByb3ZpZGVyID0gbmV0d29yay5fZGVmYXVsdFByb3ZpZGVyIHx8IG51bGw7XG4gICAgaWYgKGRlZmF1bHRQcm92aWRlciA9PSBudWxsICYmIHN0YW5kYXJkLl9kZWZhdWx0UHJvdmlkZXIpIHtcbiAgICAgICAgaWYgKGlzUmVuZXR3b3JrYWJsZShzdGFuZGFyZC5fZGVmYXVsdFByb3ZpZGVyKSkge1xuICAgICAgICAgICAgZGVmYXVsdFByb3ZpZGVyID0gc3RhbmRhcmQuX2RlZmF1bHRQcm92aWRlci5yZW5ldHdvcmsobmV0d29yayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWZhdWx0UHJvdmlkZXIgPSBzdGFuZGFyZC5fZGVmYXVsdFByb3ZpZGVyO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFN0YW5kYXJkIE5ldHdvcmsgKGFsbG93IG92ZXJyaWRpbmcgdGhlIEVOUyBhZGRyZXNzKVxuICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IG5ldHdvcmsubmFtZSxcbiAgICAgICAgY2hhaW5JZDogc3RhbmRhcmQuY2hhaW5JZCxcbiAgICAgICAgZW5zQWRkcmVzczogKG5ldHdvcmsuZW5zQWRkcmVzcyB8fCBzdGFuZGFyZC5lbnNBZGRyZXNzIHx8IG51bGwpLFxuICAgICAgICBfZGVmYXVsdFByb3ZpZGVyOiBkZWZhdWx0UHJvdmlkZXJcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ethersproject/networks/lib.esm/index.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@ethersproject/properties/lib.esm/_version.js":
/*!*********************************************************************!*\
  !*** ../node_modules/@ethersproject/properties/lib.esm/_version.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\nconst version = \"properties/5.7.0\";\n//# sourceMappingURL=_version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3Byb3BlcnRpZXMvbGliLmVzbS9fdmVyc2lvbi5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU87QUFDUCIsInNvdXJjZXMiOlsid2VicGFjazovL2xlZGdpdHkteWllbGQtZnJvbnRlbmQvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3Byb3BlcnRpZXMvbGliLmVzbS9fdmVyc2lvbi5qcz9hMDcyIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCB2ZXJzaW9uID0gXCJwcm9wZXJ0aWVzLzUuNy4wXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdmVyc2lvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ethersproject/properties/lib.esm/_version.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@ethersproject/properties/lib.esm/index.js":
/*!******************************************************************!*\
  !*** ../node_modules/@ethersproject/properties/lib.esm/index.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Description: () => (/* binding */ Description),\n/* harmony export */   checkProperties: () => (/* binding */ checkProperties),\n/* harmony export */   deepCopy: () => (/* binding */ deepCopy),\n/* harmony export */   defineReadOnly: () => (/* binding */ defineReadOnly),\n/* harmony export */   getStatic: () => (/* binding */ getStatic),\n/* harmony export */   resolveProperties: () => (/* binding */ resolveProperties),\n/* harmony export */   shallowCopy: () => (/* binding */ shallowCopy)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/../node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(ssr)/../node_modules/@ethersproject/properties/lib.esm/_version.js\");\n\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\nfunction defineReadOnly(object, name, value) {\n    Object.defineProperty(object, name, {\n        enumerable: true,\n        value: value,\n        writable: false,\n    });\n}\n// Crawl up the constructor chain to find a static method\nfunction getStatic(ctor, key) {\n    for (let i = 0; i < 32; i++) {\n        if (ctor[key]) {\n            return ctor[key];\n        }\n        if (!ctor.prototype || typeof (ctor.prototype) !== \"object\") {\n            break;\n        }\n        ctor = Object.getPrototypeOf(ctor.prototype).constructor;\n    }\n    return null;\n}\nfunction resolveProperties(object) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const promises = Object.keys(object).map((key) => {\n            const value = object[key];\n            return Promise.resolve(value).then((v) => ({ key: key, value: v }));\n        });\n        const results = yield Promise.all(promises);\n        return results.reduce((accum, result) => {\n            accum[(result.key)] = result.value;\n            return accum;\n        }, {});\n    });\n}\nfunction checkProperties(object, properties) {\n    if (!object || typeof (object) !== \"object\") {\n        logger.throwArgumentError(\"invalid object\", \"object\", object);\n    }\n    Object.keys(object).forEach((key) => {\n        if (!properties[key]) {\n            logger.throwArgumentError(\"invalid object key - \" + key, \"transaction:\" + key, object);\n        }\n    });\n}\nfunction shallowCopy(object) {\n    const result = {};\n    for (const key in object) {\n        result[key] = object[key];\n    }\n    return result;\n}\nconst opaque = { bigint: true, boolean: true, \"function\": true, number: true, string: true };\nfunction _isFrozen(object) {\n    // Opaque objects are not mutable, so safe to copy by assignment\n    if (object === undefined || object === null || opaque[typeof (object)]) {\n        return true;\n    }\n    if (Array.isArray(object) || typeof (object) === \"object\") {\n        if (!Object.isFrozen(object)) {\n            return false;\n        }\n        const keys = Object.keys(object);\n        for (let i = 0; i < keys.length; i++) {\n            let value = null;\n            try {\n                value = object[keys[i]];\n            }\n            catch (error) {\n                // If accessing a value triggers an error, it is a getter\n                // designed to do so (e.g. Result) and is therefore \"frozen\"\n                continue;\n            }\n            if (!_isFrozen(value)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return logger.throwArgumentError(`Cannot deepCopy ${typeof (object)}`, \"object\", object);\n}\n// Returns a new copy of object, such that no properties may be replaced.\n// New properties may be added only to objects.\nfunction _deepCopy(object) {\n    if (_isFrozen(object)) {\n        return object;\n    }\n    // Arrays are mutable, so we need to create a copy\n    if (Array.isArray(object)) {\n        return Object.freeze(object.map((item) => deepCopy(item)));\n    }\n    if (typeof (object) === \"object\") {\n        const result = {};\n        for (const key in object) {\n            const value = object[key];\n            if (value === undefined) {\n                continue;\n            }\n            defineReadOnly(result, key, deepCopy(value));\n        }\n        return result;\n    }\n    return logger.throwArgumentError(`Cannot deepCopy ${typeof (object)}`, \"object\", object);\n}\nfunction deepCopy(object) {\n    return _deepCopy(object);\n}\nclass Description {\n    constructor(info) {\n        for (const key in info) {\n            this[key] = deepCopy(info[key]);\n        }\n    }\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3Byb3BlcnRpZXMvbGliLmVzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBYTtBQUNiLGlCQUFpQixTQUFJLElBQUksU0FBSTtBQUM3Qiw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUMrQztBQUNWO0FBQ3JDLG1CQUFtQix5REFBTSxDQUFDLDZDQUFPO0FBQzFCO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNPO0FBQ1Asb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxvQkFBb0I7QUFDN0UsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxJQUFJO0FBQ2IsS0FBSztBQUNMO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsZ0JBQWdCO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELGdCQUFnQjtBQUN4RTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sZWRnaXR5LXlpZWxkLWZyb250ZW5kLy4uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm9wZXJ0aWVzL2xpYi5lc20vaW5kZXguanM/YTI2MSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2xvZ2dlclwiO1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gXCIuL192ZXJzaW9uXCI7XG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyKHZlcnNpb24pO1xuZXhwb3J0IGZ1bmN0aW9uIGRlZmluZVJlYWRPbmx5KG9iamVjdCwgbmFtZSwgdmFsdWUpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCBuYW1lLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgIH0pO1xufVxuLy8gQ3Jhd2wgdXAgdGhlIGNvbnN0cnVjdG9yIGNoYWluIHRvIGZpbmQgYSBzdGF0aWMgbWV0aG9kXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3RhdGljKGN0b3IsIGtleSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMzI7IGkrKykge1xuICAgICAgICBpZiAoY3RvcltrZXldKSB7XG4gICAgICAgICAgICByZXR1cm4gY3RvcltrZXldO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY3Rvci5wcm90b3R5cGUgfHwgdHlwZW9mIChjdG9yLnByb3RvdHlwZSkgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGN0b3IgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoY3Rvci5wcm90b3R5cGUpLmNvbnN0cnVjdG9yO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlUHJvcGVydGllcyhvYmplY3QpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBjb25zdCBwcm9taXNlcyA9IE9iamVjdC5rZXlzKG9iamVjdCkubWFwKChrZXkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gb2JqZWN0W2tleV07XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKCh2KSA9PiAoeyBrZXk6IGtleSwgdmFsdWU6IHYgfSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IHlpZWxkIFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdHMucmVkdWNlKChhY2N1bSwgcmVzdWx0KSA9PiB7XG4gICAgICAgICAgICBhY2N1bVsocmVzdWx0LmtleSldID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIGFjY3VtO1xuICAgICAgICB9LCB7fSk7XG4gICAgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gY2hlY2tQcm9wZXJ0aWVzKG9iamVjdCwgcHJvcGVydGllcykge1xuICAgIGlmICghb2JqZWN0IHx8IHR5cGVvZiAob2JqZWN0KSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBvYmplY3RcIiwgXCJvYmplY3RcIiwgb2JqZWN0KTtcbiAgICB9XG4gICAgT2JqZWN0LmtleXMob2JqZWN0KS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgaWYgKCFwcm9wZXJ0aWVzW2tleV0pIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIG9iamVjdCBrZXkgLSBcIiArIGtleSwgXCJ0cmFuc2FjdGlvbjpcIiArIGtleSwgb2JqZWN0KTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNoYWxsb3dDb3B5KG9iamVjdCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIG9iamVjdCkge1xuICAgICAgICByZXN1bHRba2V5XSA9IG9iamVjdFtrZXldO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuY29uc3Qgb3BhcXVlID0geyBiaWdpbnQ6IHRydWUsIGJvb2xlYW46IHRydWUsIFwiZnVuY3Rpb25cIjogdHJ1ZSwgbnVtYmVyOiB0cnVlLCBzdHJpbmc6IHRydWUgfTtcbmZ1bmN0aW9uIF9pc0Zyb3plbihvYmplY3QpIHtcbiAgICAvLyBPcGFxdWUgb2JqZWN0cyBhcmUgbm90IG11dGFibGUsIHNvIHNhZmUgdG8gY29weSBieSBhc3NpZ25tZW50XG4gICAgaWYgKG9iamVjdCA9PT0gdW5kZWZpbmVkIHx8IG9iamVjdCA9PT0gbnVsbCB8fCBvcGFxdWVbdHlwZW9mIChvYmplY3QpXSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob2JqZWN0KSB8fCB0eXBlb2YgKG9iamVjdCkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgaWYgKCFPYmplY3QuaXNGcm96ZW4ob2JqZWN0KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IG51bGw7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gb2JqZWN0W2tleXNbaV1dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgYWNjZXNzaW5nIGEgdmFsdWUgdHJpZ2dlcnMgYW4gZXJyb3IsIGl0IGlzIGEgZ2V0dGVyXG4gICAgICAgICAgICAgICAgLy8gZGVzaWduZWQgdG8gZG8gc28gKGUuZy4gUmVzdWx0KSBhbmQgaXMgdGhlcmVmb3JlIFwiZnJvemVuXCJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghX2lzRnJvemVuKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoYENhbm5vdCBkZWVwQ29weSAke3R5cGVvZiAob2JqZWN0KX1gLCBcIm9iamVjdFwiLCBvYmplY3QpO1xufVxuLy8gUmV0dXJucyBhIG5ldyBjb3B5IG9mIG9iamVjdCwgc3VjaCB0aGF0IG5vIHByb3BlcnRpZXMgbWF5IGJlIHJlcGxhY2VkLlxuLy8gTmV3IHByb3BlcnRpZXMgbWF5IGJlIGFkZGVkIG9ubHkgdG8gb2JqZWN0cy5cbmZ1bmN0aW9uIF9kZWVwQ29weShvYmplY3QpIHtcbiAgICBpZiAoX2lzRnJvemVuKG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG4gICAgLy8gQXJyYXlzIGFyZSBtdXRhYmxlLCBzbyB3ZSBuZWVkIHRvIGNyZWF0ZSBhIGNvcHlcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuZnJlZXplKG9iamVjdC5tYXAoKGl0ZW0pID0+IGRlZXBDb3B5KGl0ZW0pKSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKG9iamVjdCkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIG9iamVjdCkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBvYmplY3Rba2V5XTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZpbmVSZWFkT25seShyZXN1bHQsIGtleSwgZGVlcENvcHkodmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihgQ2Fubm90IGRlZXBDb3B5ICR7dHlwZW9mIChvYmplY3QpfWAsIFwib2JqZWN0XCIsIG9iamVjdCk7XG59XG5leHBvcnQgZnVuY3Rpb24gZGVlcENvcHkob2JqZWN0KSB7XG4gICAgcmV0dXJuIF9kZWVwQ29weShvYmplY3QpO1xufVxuZXhwb3J0IGNsYXNzIERlc2NyaXB0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihpbmZvKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGluZm8pIHtcbiAgICAgICAgICAgIHRoaXNba2V5XSA9IGRlZXBDb3B5KGluZm9ba2V5XSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ethersproject/properties/lib.esm/index.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@ethersproject/providers/lib.esm/_version.js":
/*!********************************************************************!*\
  !*** ../node_modules/@ethersproject/providers/lib.esm/_version.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\nconst version = \"providers/5.7.2\";\n//# sourceMappingURL=_version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3Byb3ZpZGVycy9saWIuZXNtL192ZXJzaW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBTztBQUNQIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGVkZ2l0eS15aWVsZC1mcm9udGVuZC8uLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvcHJvdmlkZXJzL2xpYi5lc20vX3ZlcnNpb24uanM/NTg0MyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgdmVyc2lvbiA9IFwicHJvdmlkZXJzLzUuNy4yXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdmVyc2lvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ethersproject/providers/lib.esm/_version.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@ethersproject/providers/lib.esm/alchemy-provider.js":
/*!****************************************************************************!*\
  !*** ../node_modules/@ethersproject/providers/lib.esm/alchemy-provider.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AlchemyProvider: () => (/* binding */ AlchemyProvider),\n/* harmony export */   AlchemyWebSocketProvider: () => (/* binding */ AlchemyWebSocketProvider)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/../node_modules/@ethersproject/properties/lib.esm/index.js\");\n/* harmony import */ var _formatter__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./formatter */ \"(ssr)/../node_modules/@ethersproject/providers/lib.esm/formatter.js\");\n/* harmony import */ var _websocket_provider__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./websocket-provider */ \"(ssr)/../node_modules/@ethersproject/providers/lib.esm/websocket-provider.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/../node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(ssr)/../node_modules/@ethersproject/providers/lib.esm/_version.js\");\n/* harmony import */ var _url_json_rpc_provider__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./url-json-rpc-provider */ \"(ssr)/../node_modules/@ethersproject/providers/lib.esm/url-json-rpc-provider.js\");\n\n\n\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\n\n// This key was provided to ethers.js by Alchemy to be used by the\n// default provider, but it is recommended that for your own\n// production environments, that you acquire your own API key at:\n//   https://dashboard.alchemyapi.io\nconst defaultApiKey = \"_gg7wSSi0KMBsdKnGVfHDueq6xMB9EkC\";\nclass AlchemyWebSocketProvider extends _websocket_provider__WEBPACK_IMPORTED_MODULE_2__.WebSocketProvider {\n    constructor(network, apiKey) {\n        const provider = new AlchemyProvider(network, apiKey);\n        const url = provider.connection.url.replace(/^http/i, \"ws\")\n            .replace(\".alchemyapi.\", \".ws.alchemyapi.\");\n        super(url, provider.network);\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"apiKey\", provider.apiKey);\n    }\n    isCommunityResource() {\n        return (this.apiKey === defaultApiKey);\n    }\n}\nclass AlchemyProvider extends _url_json_rpc_provider__WEBPACK_IMPORTED_MODULE_4__.UrlJsonRpcProvider {\n    static getWebSocketProvider(network, apiKey) {\n        return new AlchemyWebSocketProvider(network, apiKey);\n    }\n    static getApiKey(apiKey) {\n        if (apiKey == null) {\n            return defaultApiKey;\n        }\n        if (apiKey && typeof (apiKey) !== \"string\") {\n            logger.throwArgumentError(\"invalid apiKey\", \"apiKey\", apiKey);\n        }\n        return apiKey;\n    }\n    static getUrl(network, apiKey) {\n        let host = null;\n        switch (network.name) {\n            case \"homestead\":\n                host = \"eth-mainnet.alchemyapi.io/v2/\";\n                break;\n            case \"goerli\":\n                host = \"eth-goerli.g.alchemy.com/v2/\";\n                break;\n            case \"matic\":\n                host = \"polygon-mainnet.g.alchemy.com/v2/\";\n                break;\n            case \"maticmum\":\n                host = \"polygon-mumbai.g.alchemy.com/v2/\";\n                break;\n            case \"arbitrum\":\n                host = \"arb-mainnet.g.alchemy.com/v2/\";\n                break;\n            case \"arbitrum-goerli\":\n                host = \"arb-goerli.g.alchemy.com/v2/\";\n                break;\n            case \"optimism\":\n                host = \"opt-mainnet.g.alchemy.com/v2/\";\n                break;\n            case \"optimism-goerli\":\n                host = \"opt-goerli.g.alchemy.com/v2/\";\n                break;\n            default:\n                logger.throwArgumentError(\"unsupported network\", \"network\", arguments[0]);\n        }\n        return {\n            allowGzip: true,\n            url: (\"https:/\" + \"/\" + host + apiKey),\n            throttleCallback: (attempt, url) => {\n                if (apiKey === defaultApiKey) {\n                    (0,_formatter__WEBPACK_IMPORTED_MODULE_5__.showThrottleMessage)();\n                }\n                return Promise.resolve(true);\n            }\n        };\n    }\n    isCommunityResource() {\n        return (this.apiKey === defaultApiKey);\n    }\n}\n//# sourceMappingURL=alchemy-provider.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3Byb3ZpZGVycy9saWIuZXNtL2FsY2hlbXktcHJvdmlkZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBYTtBQUM4QztBQUNUO0FBQ087QUFDVjtBQUNWO0FBQ3JDLG1CQUFtQix5REFBTSxDQUFDLDZDQUFPO0FBQzRCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyx1Q0FBdUMsa0VBQWlCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHlFQUFjO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyw4QkFBOEIsc0VBQWtCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsK0RBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGVkZ2l0eS15aWVsZC1mcm9udGVuZC8uLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvcHJvdmlkZXJzL2xpYi5lc20vYWxjaGVteS1wcm92aWRlci5qcz85ZDQ2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuaW1wb3J0IHsgZGVmaW5lUmVhZE9ubHkgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvcHJvcGVydGllc1wiO1xuaW1wb3J0IHsgc2hvd1Rocm90dGxlTWVzc2FnZSB9IGZyb20gXCIuL2Zvcm1hdHRlclwiO1xuaW1wb3J0IHsgV2ViU29ja2V0UHJvdmlkZXIgfSBmcm9tIFwiLi93ZWJzb2NrZXQtcHJvdmlkZXJcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi9fdmVyc2lvblwiO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcih2ZXJzaW9uKTtcbmltcG9ydCB7IFVybEpzb25ScGNQcm92aWRlciB9IGZyb20gXCIuL3VybC1qc29uLXJwYy1wcm92aWRlclwiO1xuLy8gVGhpcyBrZXkgd2FzIHByb3ZpZGVkIHRvIGV0aGVycy5qcyBieSBBbGNoZW15IHRvIGJlIHVzZWQgYnkgdGhlXG4vLyBkZWZhdWx0IHByb3ZpZGVyLCBidXQgaXQgaXMgcmVjb21tZW5kZWQgdGhhdCBmb3IgeW91ciBvd25cbi8vIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRzLCB0aGF0IHlvdSBhY3F1aXJlIHlvdXIgb3duIEFQSSBrZXkgYXQ6XG4vLyAgIGh0dHBzOi8vZGFzaGJvYXJkLmFsY2hlbXlhcGkuaW9cbmNvbnN0IGRlZmF1bHRBcGlLZXkgPSBcIl9nZzd3U1NpMEtNQnNkS25HVmZIRHVlcTZ4TUI5RWtDXCI7XG5leHBvcnQgY2xhc3MgQWxjaGVteVdlYlNvY2tldFByb3ZpZGVyIGV4dGVuZHMgV2ViU29ja2V0UHJvdmlkZXIge1xuICAgIGNvbnN0cnVjdG9yKG5ldHdvcmssIGFwaUtleSkge1xuICAgICAgICBjb25zdCBwcm92aWRlciA9IG5ldyBBbGNoZW15UHJvdmlkZXIobmV0d29yaywgYXBpS2V5KTtcbiAgICAgICAgY29uc3QgdXJsID0gcHJvdmlkZXIuY29ubmVjdGlvbi51cmwucmVwbGFjZSgvXmh0dHAvaSwgXCJ3c1wiKVxuICAgICAgICAgICAgLnJlcGxhY2UoXCIuYWxjaGVteWFwaS5cIiwgXCIud3MuYWxjaGVteWFwaS5cIik7XG4gICAgICAgIHN1cGVyKHVybCwgcHJvdmlkZXIubmV0d29yayk7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiYXBpS2V5XCIsIHByb3ZpZGVyLmFwaUtleSk7XG4gICAgfVxuICAgIGlzQ29tbXVuaXR5UmVzb3VyY2UoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5hcGlLZXkgPT09IGRlZmF1bHRBcGlLZXkpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBBbGNoZW15UHJvdmlkZXIgZXh0ZW5kcyBVcmxKc29uUnBjUHJvdmlkZXIge1xuICAgIHN0YXRpYyBnZXRXZWJTb2NrZXRQcm92aWRlcihuZXR3b3JrLCBhcGlLZXkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBbGNoZW15V2ViU29ja2V0UHJvdmlkZXIobmV0d29yaywgYXBpS2V5KTtcbiAgICB9XG4gICAgc3RhdGljIGdldEFwaUtleShhcGlLZXkpIHtcbiAgICAgICAgaWYgKGFwaUtleSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVmYXVsdEFwaUtleTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXBpS2V5ICYmIHR5cGVvZiAoYXBpS2V5KSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgYXBpS2V5XCIsIFwiYXBpS2V5XCIsIGFwaUtleSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFwaUtleTtcbiAgICB9XG4gICAgc3RhdGljIGdldFVybChuZXR3b3JrLCBhcGlLZXkpIHtcbiAgICAgICAgbGV0IGhvc3QgPSBudWxsO1xuICAgICAgICBzd2l0Y2ggKG5ldHdvcmsubmFtZSkge1xuICAgICAgICAgICAgY2FzZSBcImhvbWVzdGVhZFwiOlxuICAgICAgICAgICAgICAgIGhvc3QgPSBcImV0aC1tYWlubmV0LmFsY2hlbXlhcGkuaW8vdjIvXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZ29lcmxpXCI6XG4gICAgICAgICAgICAgICAgaG9zdCA9IFwiZXRoLWdvZXJsaS5nLmFsY2hlbXkuY29tL3YyL1wiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIm1hdGljXCI6XG4gICAgICAgICAgICAgICAgaG9zdCA9IFwicG9seWdvbi1tYWlubmV0LmcuYWxjaGVteS5jb20vdjIvXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwibWF0aWNtdW1cIjpcbiAgICAgICAgICAgICAgICBob3N0ID0gXCJwb2x5Z29uLW11bWJhaS5nLmFsY2hlbXkuY29tL3YyL1wiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImFyYml0cnVtXCI6XG4gICAgICAgICAgICAgICAgaG9zdCA9IFwiYXJiLW1haW5uZXQuZy5hbGNoZW15LmNvbS92Mi9cIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJhcmJpdHJ1bS1nb2VybGlcIjpcbiAgICAgICAgICAgICAgICBob3N0ID0gXCJhcmItZ29lcmxpLmcuYWxjaGVteS5jb20vdjIvXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwib3B0aW1pc21cIjpcbiAgICAgICAgICAgICAgICBob3N0ID0gXCJvcHQtbWFpbm5ldC5nLmFsY2hlbXkuY29tL3YyL1wiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIm9wdGltaXNtLWdvZXJsaVwiOlxuICAgICAgICAgICAgICAgIGhvc3QgPSBcIm9wdC1nb2VybGkuZy5hbGNoZW15LmNvbS92Mi9cIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInVuc3VwcG9ydGVkIG5ldHdvcmtcIiwgXCJuZXR3b3JrXCIsIGFyZ3VtZW50c1swXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFsbG93R3ppcDogdHJ1ZSxcbiAgICAgICAgICAgIHVybDogKFwiaHR0cHM6L1wiICsgXCIvXCIgKyBob3N0ICsgYXBpS2V5KSxcbiAgICAgICAgICAgIHRocm90dGxlQ2FsbGJhY2s6IChhdHRlbXB0LCB1cmwpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoYXBpS2V5ID09PSBkZWZhdWx0QXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHNob3dUaHJvdHRsZU1lc3NhZ2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgaXNDb21tdW5pdHlSZXNvdXJjZSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmFwaUtleSA9PT0gZGVmYXVsdEFwaUtleSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWxjaGVteS1wcm92aWRlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ethersproject/providers/lib.esm/alchemy-provider.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@ethersproject/providers/lib.esm/ankr-provider.js":
/*!*************************************************************************!*\
  !*** ../node_modules/@ethersproject/providers/lib.esm/ankr-provider.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AnkrProvider: () => (/* binding */ AnkrProvider)\n/* harmony export */ });\n/* harmony import */ var _formatter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./formatter */ \"(ssr)/../node_modules/@ethersproject/providers/lib.esm/formatter.js\");\n/* harmony import */ var _url_json_rpc_provider__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./url-json-rpc-provider */ \"(ssr)/../node_modules/@ethersproject/providers/lib.esm/url-json-rpc-provider.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/../node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(ssr)/../node_modules/@ethersproject/providers/lib.esm/_version.js\");\n\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\nconst defaultApiKey = \"9f7d929b018cdffb338517efa06f58359e86ff1ffd350bc889738523659e7972\";\nfunction getHost(name) {\n    switch (name) {\n        case \"homestead\":\n            return \"rpc.ankr.com/eth/\";\n        case \"ropsten\":\n            return \"rpc.ankr.com/eth_ropsten/\";\n        case \"rinkeby\":\n            return \"rpc.ankr.com/eth_rinkeby/\";\n        case \"goerli\":\n            return \"rpc.ankr.com/eth_goerli/\";\n        case \"matic\":\n            return \"rpc.ankr.com/polygon/\";\n        case \"arbitrum\":\n            return \"rpc.ankr.com/arbitrum/\";\n    }\n    return logger.throwArgumentError(\"unsupported network\", \"name\", name);\n}\nclass AnkrProvider extends _url_json_rpc_provider__WEBPACK_IMPORTED_MODULE_2__.UrlJsonRpcProvider {\n    isCommunityResource() {\n        return (this.apiKey === defaultApiKey);\n    }\n    static getApiKey(apiKey) {\n        if (apiKey == null) {\n            return defaultApiKey;\n        }\n        return apiKey;\n    }\n    static getUrl(network, apiKey) {\n        if (apiKey == null) {\n            apiKey = defaultApiKey;\n        }\n        const connection = {\n            allowGzip: true,\n            url: (\"https:/\\/\" + getHost(network.name) + apiKey),\n            throttleCallback: (attempt, url) => {\n                if (apiKey.apiKey === defaultApiKey) {\n                    (0,_formatter__WEBPACK_IMPORTED_MODULE_3__.showThrottleMessage)();\n                }\n                return Promise.resolve(true);\n            }\n        };\n        if (apiKey.projectSecret != null) {\n            connection.user = \"\";\n            connection.password = apiKey.projectSecret;\n        }\n        return connection;\n    }\n}\n//# sourceMappingURL=ankr-provider.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3Byb3ZpZGVycy9saWIuZXNtL2Fua3ItcHJvdmlkZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBa0Q7QUFDVztBQUNkO0FBQ1Y7QUFDckMsbUJBQW1CLHlEQUFNLENBQUMsNkNBQU87QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sMkJBQTJCLHNFQUFrQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsK0RBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xlZGdpdHkteWllbGQtZnJvbnRlbmQvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3Byb3ZpZGVycy9saWIuZXNtL2Fua3ItcHJvdmlkZXIuanM/NjQwZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzaG93VGhyb3R0bGVNZXNzYWdlIH0gZnJvbSBcIi4vZm9ybWF0dGVyXCI7XG5pbXBvcnQgeyBVcmxKc29uUnBjUHJvdmlkZXIgfSBmcm9tIFwiLi91cmwtanNvbi1ycGMtcHJvdmlkZXJcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi9fdmVyc2lvblwiO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcih2ZXJzaW9uKTtcbmNvbnN0IGRlZmF1bHRBcGlLZXkgPSBcIjlmN2Q5MjliMDE4Y2RmZmIzMzg1MTdlZmEwNmY1ODM1OWU4NmZmMWZmZDM1MGJjODg5NzM4NTIzNjU5ZTc5NzJcIjtcbmZ1bmN0aW9uIGdldEhvc3QobmFtZSkge1xuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgICBjYXNlIFwiaG9tZXN0ZWFkXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJycGMuYW5rci5jb20vZXRoL1wiO1xuICAgICAgICBjYXNlIFwicm9wc3RlblwiOlxuICAgICAgICAgICAgcmV0dXJuIFwicnBjLmFua3IuY29tL2V0aF9yb3BzdGVuL1wiO1xuICAgICAgICBjYXNlIFwicmlua2VieVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwicnBjLmFua3IuY29tL2V0aF9yaW5rZWJ5L1wiO1xuICAgICAgICBjYXNlIFwiZ29lcmxpXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJycGMuYW5rci5jb20vZXRoX2dvZXJsaS9cIjtcbiAgICAgICAgY2FzZSBcIm1hdGljXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJycGMuYW5rci5jb20vcG9seWdvbi9cIjtcbiAgICAgICAgY2FzZSBcImFyYml0cnVtXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJycGMuYW5rci5jb20vYXJiaXRydW0vXCI7XG4gICAgfVxuICAgIHJldHVybiBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwidW5zdXBwb3J0ZWQgbmV0d29ya1wiLCBcIm5hbWVcIiwgbmFtZSk7XG59XG5leHBvcnQgY2xhc3MgQW5rclByb3ZpZGVyIGV4dGVuZHMgVXJsSnNvblJwY1Byb3ZpZGVyIHtcbiAgICBpc0NvbW11bml0eVJlc291cmNlKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuYXBpS2V5ID09PSBkZWZhdWx0QXBpS2V5KTtcbiAgICB9XG4gICAgc3RhdGljIGdldEFwaUtleShhcGlLZXkpIHtcbiAgICAgICAgaWYgKGFwaUtleSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVmYXVsdEFwaUtleTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXBpS2V5O1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0VXJsKG5ldHdvcmssIGFwaUtleSkge1xuICAgICAgICBpZiAoYXBpS2V5ID09IG51bGwpIHtcbiAgICAgICAgICAgIGFwaUtleSA9IGRlZmF1bHRBcGlLZXk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29ubmVjdGlvbiA9IHtcbiAgICAgICAgICAgIGFsbG93R3ppcDogdHJ1ZSxcbiAgICAgICAgICAgIHVybDogKFwiaHR0cHM6L1xcL1wiICsgZ2V0SG9zdChuZXR3b3JrLm5hbWUpICsgYXBpS2V5KSxcbiAgICAgICAgICAgIHRocm90dGxlQ2FsbGJhY2s6IChhdHRlbXB0LCB1cmwpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoYXBpS2V5LmFwaUtleSA9PT0gZGVmYXVsdEFwaUtleSkge1xuICAgICAgICAgICAgICAgICAgICBzaG93VGhyb3R0bGVNZXNzYWdlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGlmIChhcGlLZXkucHJvamVjdFNlY3JldCAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25uZWN0aW9uLnVzZXIgPSBcIlwiO1xuICAgICAgICAgICAgY29ubmVjdGlvbi5wYXNzd29yZCA9IGFwaUtleS5wcm9qZWN0U2VjcmV0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb25uZWN0aW9uO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFua3ItcHJvdmlkZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ethersproject/providers/lib.esm/ankr-provider.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@ethersproject/providers/lib.esm/base-provider.js":
/*!*************************************************************************!*\
  !*** ../node_modules/@ethersproject/providers/lib.esm/base-provider.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseProvider: () => (/* binding */ BaseProvider),\n/* harmony export */   Event: () => (/* binding */ Event),\n/* harmony export */   Resolver: () => (/* binding */ Resolver)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_abstract_provider__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethersproject/abstract-provider */ \"(ssr)/../node_modules/@ethersproject/abstract-provider/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_base64__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @ethersproject/base64 */ \"(ssr)/../node_modules/@ethersproject/base64/lib.esm/base64.js\");\n/* harmony import */ var _ethersproject_basex__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @ethersproject/basex */ \"(ssr)/../node_modules/@ethersproject/basex/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @ethersproject/bignumber */ \"(ssr)/../node_modules/@ethersproject/bignumber/lib.esm/bignumber.js\");\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/../node_modules/@ethersproject/bytes/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_constants__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @ethersproject/constants */ \"(ssr)/../node_modules/@ethersproject/constants/lib.esm/hashes.js\");\n/* harmony import */ var _ethersproject_hash__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @ethersproject/hash */ \"(ssr)/../node_modules/@ethersproject/hash/lib.esm/namehash.js\");\n/* harmony import */ var _ethersproject_networks__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @ethersproject/networks */ \"(ssr)/../node_modules/@ethersproject/networks/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/../node_modules/@ethersproject/properties/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_sha2__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @ethersproject/sha2 */ \"(ssr)/../node_modules/@ethersproject/sha2/lib.esm/sha2.js\");\n/* harmony import */ var _ethersproject_strings__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @ethersproject/strings */ \"(ssr)/../node_modules/@ethersproject/strings/lib.esm/utf8.js\");\n/* harmony import */ var _ethersproject_web__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @ethersproject/web */ \"(ssr)/../node_modules/@ethersproject/web/lib.esm/index.js\");\n/* harmony import */ var bech32__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! bech32 */ \"(ssr)/../node_modules/bech32/index.js\");\n/* harmony import */ var bech32__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(bech32__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/../node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_version */ \"(ssr)/../node_modules/@ethersproject/providers/lib.esm/_version.js\");\n/* harmony import */ var _formatter__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./formatter */ \"(ssr)/../node_modules/@ethersproject/providers/lib.esm/formatter.js\");\n\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger(_version__WEBPACK_IMPORTED_MODULE_2__.version);\n\nconst MAX_CCIP_REDIRECTS = 10;\n//////////////////////////////\n// Event Serializeing\nfunction checkTopic(topic) {\n    if (topic == null) {\n        return \"null\";\n    }\n    if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexDataLength)(topic) !== 32) {\n        logger.throwArgumentError(\"invalid topic\", \"topic\", topic);\n    }\n    return topic.toLowerCase();\n}\nfunction serializeTopics(topics) {\n    // Remove trailing null AND-topics; they are redundant\n    topics = topics.slice();\n    while (topics.length > 0 && topics[topics.length - 1] == null) {\n        topics.pop();\n    }\n    return topics.map((topic) => {\n        if (Array.isArray(topic)) {\n            // Only track unique OR-topics\n            const unique = {};\n            topic.forEach((topic) => {\n                unique[checkTopic(topic)] = true;\n            });\n            // The order of OR-topics does not matter\n            const sorted = Object.keys(unique);\n            sorted.sort();\n            return sorted.join(\"|\");\n        }\n        else {\n            return checkTopic(topic);\n        }\n    }).join(\"&\");\n}\nfunction deserializeTopics(data) {\n    if (data === \"\") {\n        return [];\n    }\n    return data.split(/&/g).map((topic) => {\n        if (topic === \"\") {\n            return [];\n        }\n        const comps = topic.split(\"|\").map((topic) => {\n            return ((topic === \"null\") ? null : topic);\n        });\n        return ((comps.length === 1) ? comps[0] : comps);\n    });\n}\nfunction getEventTag(eventName) {\n    if (typeof (eventName) === \"string\") {\n        eventName = eventName.toLowerCase();\n        if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexDataLength)(eventName) === 32) {\n            return \"tx:\" + eventName;\n        }\n        if (eventName.indexOf(\":\") === -1) {\n            return eventName;\n        }\n    }\n    else if (Array.isArray(eventName)) {\n        return \"filter:*:\" + serializeTopics(eventName);\n    }\n    else if (_ethersproject_abstract_provider__WEBPACK_IMPORTED_MODULE_4__.ForkEvent.isForkEvent(eventName)) {\n        logger.warn(\"not implemented\");\n        throw new Error(\"not implemented\");\n    }\n    else if (eventName && typeof (eventName) === \"object\") {\n        return \"filter:\" + (eventName.address || \"*\") + \":\" + serializeTopics(eventName.topics || []);\n    }\n    throw new Error(\"invalid event - \" + eventName);\n}\n//////////////////////////////\n// Helper Object\nfunction getTime() {\n    return (new Date()).getTime();\n}\nfunction stall(duration) {\n    return new Promise((resolve) => {\n        setTimeout(resolve, duration);\n    });\n}\n//////////////////////////////\n// Provider Object\n/**\n *  EventType\n *   - \"block\"\n *   - \"poll\"\n *   - \"didPoll\"\n *   - \"pending\"\n *   - \"error\"\n *   - \"network\"\n *   - filter\n *   - topics array\n *   - transaction hash\n */\nconst PollableEvents = [\"block\", \"network\", \"pending\", \"poll\"];\nclass Event {\n    constructor(tag, listener, once) {\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.defineReadOnly)(this, \"tag\", tag);\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.defineReadOnly)(this, \"listener\", listener);\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.defineReadOnly)(this, \"once\", once);\n        this._lastBlockNumber = -2;\n        this._inflight = false;\n    }\n    get event() {\n        switch (this.type) {\n            case \"tx\":\n                return this.hash;\n            case \"filter\":\n                return this.filter;\n        }\n        return this.tag;\n    }\n    get type() {\n        return this.tag.split(\":\")[0];\n    }\n    get hash() {\n        const comps = this.tag.split(\":\");\n        if (comps[0] !== \"tx\") {\n            return null;\n        }\n        return comps[1];\n    }\n    get filter() {\n        const comps = this.tag.split(\":\");\n        if (comps[0] !== \"filter\") {\n            return null;\n        }\n        const address = comps[1];\n        const topics = deserializeTopics(comps[2]);\n        const filter = {};\n        if (topics.length > 0) {\n            filter.topics = topics;\n        }\n        if (address && address !== \"*\") {\n            filter.address = address;\n        }\n        return filter;\n    }\n    pollable() {\n        return (this.tag.indexOf(\":\") >= 0 || PollableEvents.indexOf(this.tag) >= 0);\n    }\n}\n;\n// https://github.com/satoshilabs/slips/blob/master/slip-0044.md\nconst coinInfos = {\n    \"0\": { symbol: \"btc\", p2pkh: 0x00, p2sh: 0x05, prefix: \"bc\" },\n    \"2\": { symbol: \"ltc\", p2pkh: 0x30, p2sh: 0x32, prefix: \"ltc\" },\n    \"3\": { symbol: \"doge\", p2pkh: 0x1e, p2sh: 0x16 },\n    \"60\": { symbol: \"eth\", ilk: \"eth\" },\n    \"61\": { symbol: \"etc\", ilk: \"eth\" },\n    \"700\": { symbol: \"xdai\", ilk: \"eth\" },\n};\nfunction bytes32ify(value) {\n    return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexZeroPad)(_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__.BigNumber.from(value).toHexString(), 32);\n}\n// Compute the Base58Check encoded data (checksum is first 4 bytes of sha256d)\nfunction base58Encode(data) {\n    return _ethersproject_basex__WEBPACK_IMPORTED_MODULE_7__.Base58.encode((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.concat)([data, (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexDataSlice)((0,_ethersproject_sha2__WEBPACK_IMPORTED_MODULE_8__.sha256)((0,_ethersproject_sha2__WEBPACK_IMPORTED_MODULE_8__.sha256)(data)), 0, 4)]));\n}\nconst matcherIpfs = new RegExp(\"^(ipfs):/\\/(.*)$\", \"i\");\nconst matchers = [\n    new RegExp(\"^(https):/\\/(.*)$\", \"i\"),\n    new RegExp(\"^(data):(.*)$\", \"i\"),\n    matcherIpfs,\n    new RegExp(\"^eip155:[0-9]+/(erc[0-9]+):(.*)$\", \"i\"),\n];\nfunction _parseString(result, start) {\n    try {\n        return (0,_ethersproject_strings__WEBPACK_IMPORTED_MODULE_9__.toUtf8String)(_parseBytes(result, start));\n    }\n    catch (error) { }\n    return null;\n}\nfunction _parseBytes(result, start) {\n    if (result === \"0x\") {\n        return null;\n    }\n    const offset = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__.BigNumber.from((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexDataSlice)(result, start, start + 32)).toNumber();\n    const length = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__.BigNumber.from((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexDataSlice)(result, offset, offset + 32)).toNumber();\n    return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexDataSlice)(result, offset + 32, offset + 32 + length);\n}\n// Trim off the ipfs:// prefix and return the default gateway URL\nfunction getIpfsLink(link) {\n    if (link.match(/^ipfs:\\/\\/ipfs\\//i)) {\n        link = link.substring(12);\n    }\n    else if (link.match(/^ipfs:\\/\\//i)) {\n        link = link.substring(7);\n    }\n    else {\n        logger.throwArgumentError(\"unsupported IPFS format\", \"link\", link);\n    }\n    return `https:/\\/gateway.ipfs.io/ipfs/${link}`;\n}\nfunction numPad(value) {\n    const result = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.arrayify)(value);\n    if (result.length > 32) {\n        throw new Error(\"internal; should not happen\");\n    }\n    const padded = new Uint8Array(32);\n    padded.set(result, 32 - result.length);\n    return padded;\n}\nfunction bytesPad(value) {\n    if ((value.length % 32) === 0) {\n        return value;\n    }\n    const result = new Uint8Array(Math.ceil(value.length / 32) * 32);\n    result.set(value);\n    return result;\n}\n// ABI Encodes a series of (bytes, bytes, ...)\nfunction encodeBytes(datas) {\n    const result = [];\n    let byteCount = 0;\n    // Add place-holders for pointers as we add items\n    for (let i = 0; i < datas.length; i++) {\n        result.push(null);\n        byteCount += 32;\n    }\n    for (let i = 0; i < datas.length; i++) {\n        const data = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.arrayify)(datas[i]);\n        // Update the bytes offset\n        result[i] = numPad(byteCount);\n        // The length and padded value of data\n        result.push(numPad(data.length));\n        result.push(bytesPad(data));\n        byteCount += 32 + Math.ceil(data.length / 32) * 32;\n    }\n    return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexConcat)(result);\n}\nclass Resolver {\n    // The resolvedAddress is only for creating a ReverseLookup resolver\n    constructor(provider, address, name, resolvedAddress) {\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.defineReadOnly)(this, \"provider\", provider);\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.defineReadOnly)(this, \"name\", name);\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.defineReadOnly)(this, \"address\", provider.formatter.address(address));\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.defineReadOnly)(this, \"_resolvedAddress\", resolvedAddress);\n    }\n    supportsWildcard() {\n        if (!this._supportsEip2544) {\n            // supportsInterface(bytes4 = selector(\"resolve(bytes,bytes)\"))\n            this._supportsEip2544 = this.provider.call({\n                to: this.address,\n                data: \"0x01ffc9a79061b92300000000000000000000000000000000000000000000000000000000\"\n            }).then((result) => {\n                return _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__.BigNumber.from(result).eq(1);\n            }).catch((error) => {\n                if (error.code === _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.CALL_EXCEPTION) {\n                    return false;\n                }\n                // Rethrow the error: link is down, etc. Let future attempts retry.\n                this._supportsEip2544 = null;\n                throw error;\n            });\n        }\n        return this._supportsEip2544;\n    }\n    _fetch(selector, parameters) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // e.g. keccak256(\"addr(bytes32,uint256)\")\n            const tx = {\n                to: this.address,\n                ccipReadEnabled: true,\n                data: (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexConcat)([selector, (0,_ethersproject_hash__WEBPACK_IMPORTED_MODULE_10__.namehash)(this.name), (parameters || \"0x\")])\n            };\n            // Wildcard support; use EIP-2544 to resolve the request\n            let parseBytes = false;\n            if (yield this.supportsWildcard()) {\n                parseBytes = true;\n                // selector(\"resolve(bytes,bytes)\")\n                tx.data = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexConcat)([\"0x9061b923\", encodeBytes([(0,_ethersproject_hash__WEBPACK_IMPORTED_MODULE_10__.dnsEncode)(this.name), tx.data])]);\n            }\n            try {\n                let result = yield this.provider.call(tx);\n                if (((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.arrayify)(result).length % 32) === 4) {\n                    logger.throwError(\"resolver threw error\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.CALL_EXCEPTION, {\n                        transaction: tx, data: result\n                    });\n                }\n                if (parseBytes) {\n                    result = _parseBytes(result, 0);\n                }\n                return result;\n            }\n            catch (error) {\n                if (error.code === _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.CALL_EXCEPTION) {\n                    return null;\n                }\n                throw error;\n            }\n        });\n    }\n    _fetchBytes(selector, parameters) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const result = yield this._fetch(selector, parameters);\n            if (result != null) {\n                return _parseBytes(result, 0);\n            }\n            return null;\n        });\n    }\n    _getAddress(coinType, hexBytes) {\n        const coinInfo = coinInfos[String(coinType)];\n        if (coinInfo == null) {\n            logger.throwError(`unsupported coin type: ${coinType}`, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: `getAddress(${coinType})`\n            });\n        }\n        if (coinInfo.ilk === \"eth\") {\n            return this.provider.formatter.address(hexBytes);\n        }\n        const bytes = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.arrayify)(hexBytes);\n        // P2PKH: OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG\n        if (coinInfo.p2pkh != null) {\n            const p2pkh = hexBytes.match(/^0x76a9([0-9a-f][0-9a-f])([0-9a-f]*)88ac$/);\n            if (p2pkh) {\n                const length = parseInt(p2pkh[1], 16);\n                if (p2pkh[2].length === length * 2 && length >= 1 && length <= 75) {\n                    return base58Encode((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.concat)([[coinInfo.p2pkh], (\"0x\" + p2pkh[2])]));\n                }\n            }\n        }\n        // P2SH: OP_HASH160 <scriptHash> OP_EQUAL\n        if (coinInfo.p2sh != null) {\n            const p2sh = hexBytes.match(/^0xa9([0-9a-f][0-9a-f])([0-9a-f]*)87$/);\n            if (p2sh) {\n                const length = parseInt(p2sh[1], 16);\n                if (p2sh[2].length === length * 2 && length >= 1 && length <= 75) {\n                    return base58Encode((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.concat)([[coinInfo.p2sh], (\"0x\" + p2sh[2])]));\n                }\n            }\n        }\n        // Bech32\n        if (coinInfo.prefix != null) {\n            const length = bytes[1];\n            // https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki#witness-program\n            let version = bytes[0];\n            if (version === 0x00) {\n                if (length !== 20 && length !== 32) {\n                    version = -1;\n                }\n            }\n            else {\n                version = -1;\n            }\n            if (version >= 0 && bytes.length === 2 + length && length >= 1 && length <= 75) {\n                const words = bech32__WEBPACK_IMPORTED_MODULE_0___default().toWords(bytes.slice(2));\n                words.unshift(version);\n                return bech32__WEBPACK_IMPORTED_MODULE_0___default().encode(coinInfo.prefix, words);\n            }\n        }\n        return null;\n    }\n    getAddress(coinType) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (coinType == null) {\n                coinType = 60;\n            }\n            // If Ethereum, use the standard `addr(bytes32)`\n            if (coinType === 60) {\n                try {\n                    // keccak256(\"addr(bytes32)\")\n                    const result = yield this._fetch(\"0x3b3b57de\");\n                    // No address\n                    if (result === \"0x\" || result === _ethersproject_constants__WEBPACK_IMPORTED_MODULE_11__.HashZero) {\n                        return null;\n                    }\n                    return this.provider.formatter.callAddress(result);\n                }\n                catch (error) {\n                    if (error.code === _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.CALL_EXCEPTION) {\n                        return null;\n                    }\n                    throw error;\n                }\n            }\n            // keccak256(\"addr(bytes32,uint256\")\n            const hexBytes = yield this._fetchBytes(\"0xf1cb7e06\", bytes32ify(coinType));\n            // No address\n            if (hexBytes == null || hexBytes === \"0x\") {\n                return null;\n            }\n            // Compute the address\n            const address = this._getAddress(coinType, hexBytes);\n            if (address == null) {\n                logger.throwError(`invalid or unsupported coin data`, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: `getAddress(${coinType})`,\n                    coinType: coinType,\n                    data: hexBytes\n                });\n            }\n            return address;\n        });\n    }\n    getAvatar() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const linkage = [{ type: \"name\", content: this.name }];\n            try {\n                // test data for ricmoo.eth\n                //const avatar = \"eip155:1/erc721:0x265385c7f4132228A0d54EB1A9e7460b91c0cC68/29233\";\n                const avatar = yield this.getText(\"avatar\");\n                if (avatar == null) {\n                    return null;\n                }\n                for (let i = 0; i < matchers.length; i++) {\n                    const match = avatar.match(matchers[i]);\n                    if (match == null) {\n                        continue;\n                    }\n                    const scheme = match[1].toLowerCase();\n                    switch (scheme) {\n                        case \"https\":\n                            linkage.push({ type: \"url\", content: avatar });\n                            return { linkage, url: avatar };\n                        case \"data\":\n                            linkage.push({ type: \"data\", content: avatar });\n                            return { linkage, url: avatar };\n                        case \"ipfs\":\n                            linkage.push({ type: \"ipfs\", content: avatar });\n                            return { linkage, url: getIpfsLink(avatar) };\n                        case \"erc721\":\n                        case \"erc1155\": {\n                            // Depending on the ERC type, use tokenURI(uint256) or url(uint256)\n                            const selector = (scheme === \"erc721\") ? \"0xc87b56dd\" : \"0x0e89341c\";\n                            linkage.push({ type: scheme, content: avatar });\n                            // The owner of this name\n                            const owner = (this._resolvedAddress || (yield this.getAddress()));\n                            const comps = (match[2] || \"\").split(\"/\");\n                            if (comps.length !== 2) {\n                                return null;\n                            }\n                            const addr = yield this.provider.formatter.address(comps[0]);\n                            const tokenId = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexZeroPad)(_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__.BigNumber.from(comps[1]).toHexString(), 32);\n                            // Check that this account owns the token\n                            if (scheme === \"erc721\") {\n                                // ownerOf(uint256 tokenId)\n                                const tokenOwner = this.provider.formatter.callAddress(yield this.provider.call({\n                                    to: addr, data: (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexConcat)([\"0x6352211e\", tokenId])\n                                }));\n                                if (owner !== tokenOwner) {\n                                    return null;\n                                }\n                                linkage.push({ type: \"owner\", content: tokenOwner });\n                            }\n                            else if (scheme === \"erc1155\") {\n                                // balanceOf(address owner, uint256 tokenId)\n                                const balance = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__.BigNumber.from(yield this.provider.call({\n                                    to: addr, data: (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexConcat)([\"0x00fdd58e\", (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexZeroPad)(owner, 32), tokenId])\n                                }));\n                                if (balance.isZero()) {\n                                    return null;\n                                }\n                                linkage.push({ type: \"balance\", content: balance.toString() });\n                            }\n                            // Call the token contract for the metadata URL\n                            const tx = {\n                                to: this.provider.formatter.address(comps[0]),\n                                data: (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexConcat)([selector, tokenId])\n                            };\n                            let metadataUrl = _parseString(yield this.provider.call(tx), 0);\n                            if (metadataUrl == null) {\n                                return null;\n                            }\n                            linkage.push({ type: \"metadata-url-base\", content: metadataUrl });\n                            // ERC-1155 allows a generic {id} in the URL\n                            if (scheme === \"erc1155\") {\n                                metadataUrl = metadataUrl.replace(\"{id}\", tokenId.substring(2));\n                                linkage.push({ type: \"metadata-url-expanded\", content: metadataUrl });\n                            }\n                            // Transform IPFS metadata links\n                            if (metadataUrl.match(/^ipfs:/i)) {\n                                metadataUrl = getIpfsLink(metadataUrl);\n                            }\n                            linkage.push({ type: \"metadata-url\", content: metadataUrl });\n                            // Get the token metadata\n                            const metadata = yield (0,_ethersproject_web__WEBPACK_IMPORTED_MODULE_12__.fetchJson)(metadataUrl);\n                            if (!metadata) {\n                                return null;\n                            }\n                            linkage.push({ type: \"metadata\", content: JSON.stringify(metadata) });\n                            // Pull the image URL out\n                            let imageUrl = metadata.image;\n                            if (typeof (imageUrl) !== \"string\") {\n                                return null;\n                            }\n                            if (imageUrl.match(/^(https:\\/\\/|data:)/i)) {\n                                // Allow\n                            }\n                            else {\n                                // Transform IPFS link to gateway\n                                const ipfs = imageUrl.match(matcherIpfs);\n                                if (ipfs == null) {\n                                    return null;\n                                }\n                                linkage.push({ type: \"url-ipfs\", content: imageUrl });\n                                imageUrl = getIpfsLink(imageUrl);\n                            }\n                            linkage.push({ type: \"url\", content: imageUrl });\n                            return { linkage, url: imageUrl };\n                        }\n                    }\n                }\n            }\n            catch (error) { }\n            return null;\n        });\n    }\n    getContentHash() {\n        return __awaiter(this, void 0, void 0, function* () {\n            // keccak256(\"contenthash()\")\n            const hexBytes = yield this._fetchBytes(\"0xbc1c58d1\");\n            // No contenthash\n            if (hexBytes == null || hexBytes === \"0x\") {\n                return null;\n            }\n            // IPFS (CID: 1, Type: DAG-PB)\n            const ipfs = hexBytes.match(/^0xe3010170(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);\n            if (ipfs) {\n                const length = parseInt(ipfs[3], 16);\n                if (ipfs[4].length === length * 2) {\n                    return \"ipfs:/\\/\" + _ethersproject_basex__WEBPACK_IMPORTED_MODULE_7__.Base58.encode(\"0x\" + ipfs[1]);\n                }\n            }\n            // IPNS (CID: 1, Type: libp2p-key)\n            const ipns = hexBytes.match(/^0xe5010172(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);\n            if (ipns) {\n                const length = parseInt(ipns[3], 16);\n                if (ipns[4].length === length * 2) {\n                    return \"ipns:/\\/\" + _ethersproject_basex__WEBPACK_IMPORTED_MODULE_7__.Base58.encode(\"0x\" + ipns[1]);\n                }\n            }\n            // Swarm (CID: 1, Type: swarm-manifest; hash/length hard-coded to keccak256/32)\n            const swarm = hexBytes.match(/^0xe40101fa011b20([0-9a-f]*)$/);\n            if (swarm) {\n                if (swarm[1].length === (32 * 2)) {\n                    return \"bzz:/\\/\" + swarm[1];\n                }\n            }\n            const skynet = hexBytes.match(/^0x90b2c605([0-9a-f]*)$/);\n            if (skynet) {\n                if (skynet[1].length === (34 * 2)) {\n                    // URL Safe base64; https://datatracker.ietf.org/doc/html/rfc4648#section-5\n                    const urlSafe = { \"=\": \"\", \"+\": \"-\", \"/\": \"_\" };\n                    const hash = (0,_ethersproject_base64__WEBPACK_IMPORTED_MODULE_13__.encode)(\"0x\" + skynet[1]).replace(/[=+\\/]/g, (a) => (urlSafe[a]));\n                    return \"sia:/\\/\" + hash;\n                }\n            }\n            return logger.throwError(`invalid or unsupported content hash data`, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"getContentHash()\",\n                data: hexBytes\n            });\n        });\n    }\n    getText(key) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // The key encoded as parameter to fetchBytes\n            let keyBytes = (0,_ethersproject_strings__WEBPACK_IMPORTED_MODULE_9__.toUtf8Bytes)(key);\n            // The nodehash consumes the first slot, so the string pointer targets\n            // offset 64, with the length at offset 64 and data starting at offset 96\n            keyBytes = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.concat)([bytes32ify(64), bytes32ify(keyBytes.length), keyBytes]);\n            // Pad to word-size (32 bytes)\n            if ((keyBytes.length % 32) !== 0) {\n                keyBytes = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.concat)([keyBytes, (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexZeroPad)(\"0x\", 32 - (key.length % 32))]);\n            }\n            const hexBytes = yield this._fetchBytes(\"0x59d1d43c\", (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexlify)(keyBytes));\n            if (hexBytes == null || hexBytes === \"0x\") {\n                return null;\n            }\n            return (0,_ethersproject_strings__WEBPACK_IMPORTED_MODULE_9__.toUtf8String)(hexBytes);\n        });\n    }\n}\nlet defaultFormatter = null;\nlet nextPollId = 1;\nclass BaseProvider extends _ethersproject_abstract_provider__WEBPACK_IMPORTED_MODULE_4__.Provider {\n    /**\n     *  ready\n     *\n     *  A Promise<Network> that resolves only once the provider is ready.\n     *\n     *  Sub-classes that call the super with a network without a chainId\n     *  MUST set this. Standard named networks have a known chainId.\n     *\n     */\n    constructor(network) {\n        super();\n        // Events being listened to\n        this._events = [];\n        this._emitted = { block: -2 };\n        this.disableCcipRead = false;\n        this.formatter = new.target.getFormatter();\n        // If network is any, this Provider allows the underlying\n        // network to change dynamically, and we auto-detect the\n        // current network\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.defineReadOnly)(this, \"anyNetwork\", (network === \"any\"));\n        if (this.anyNetwork) {\n            network = this.detectNetwork();\n        }\n        if (network instanceof Promise) {\n            this._networkPromise = network;\n            // Squash any \"unhandled promise\" errors; that do not need to be handled\n            network.catch((error) => { });\n            // Trigger initial network setting (async)\n            this._ready().catch((error) => { });\n        }\n        else {\n            const knownNetwork = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.getStatic)(new.target, \"getNetwork\")(network);\n            if (knownNetwork) {\n                (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.defineReadOnly)(this, \"_network\", knownNetwork);\n                this.emit(\"network\", knownNetwork, null);\n            }\n            else {\n                logger.throwArgumentError(\"invalid network\", \"network\", network);\n            }\n        }\n        this._maxInternalBlockNumber = -1024;\n        this._lastBlockNumber = -2;\n        this._maxFilterBlockRange = 10;\n        this._pollingInterval = 4000;\n        this._fastQueryDate = 0;\n    }\n    _ready() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._network == null) {\n                let network = null;\n                if (this._networkPromise) {\n                    try {\n                        network = yield this._networkPromise;\n                    }\n                    catch (error) { }\n                }\n                // Try the Provider's network detection (this MUST throw if it cannot)\n                if (network == null) {\n                    network = yield this.detectNetwork();\n                }\n                // This should never happen; every Provider sub-class should have\n                // suggested a network by here (or have thrown).\n                if (!network) {\n                    logger.throwError(\"no network detected\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.UNKNOWN_ERROR, {});\n                }\n                // Possible this call stacked so do not call defineReadOnly again\n                if (this._network == null) {\n                    if (this.anyNetwork) {\n                        this._network = network;\n                    }\n                    else {\n                        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.defineReadOnly)(this, \"_network\", network);\n                    }\n                    this.emit(\"network\", network, null);\n                }\n            }\n            return this._network;\n        });\n    }\n    // This will always return the most recently established network.\n    // For \"any\", this can change (a \"network\" event is emitted before\n    // any change is reflected); otherwise this cannot change\n    get ready() {\n        return (0,_ethersproject_web__WEBPACK_IMPORTED_MODULE_12__.poll)(() => {\n            return this._ready().then((network) => {\n                return network;\n            }, (error) => {\n                // If the network isn't running yet, we will wait\n                if (error.code === _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.NETWORK_ERROR && error.event === \"noNetwork\") {\n                    return undefined;\n                }\n                throw error;\n            });\n        });\n    }\n    // @TODO: Remove this and just create a singleton formatter\n    static getFormatter() {\n        if (defaultFormatter == null) {\n            defaultFormatter = new _formatter__WEBPACK_IMPORTED_MODULE_14__.Formatter();\n        }\n        return defaultFormatter;\n    }\n    // @TODO: Remove this and just use getNetwork\n    static getNetwork(network) {\n        return (0,_ethersproject_networks__WEBPACK_IMPORTED_MODULE_15__.getNetwork)((network == null) ? \"homestead\" : network);\n    }\n    ccipReadFetch(tx, calldata, urls) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.disableCcipRead || urls.length === 0) {\n                return null;\n            }\n            const sender = tx.to.toLowerCase();\n            const data = calldata.toLowerCase();\n            const errorMessages = [];\n            for (let i = 0; i < urls.length; i++) {\n                const url = urls[i];\n                // URL expansion\n                const href = url.replace(\"{sender}\", sender).replace(\"{data}\", data);\n                // If no {data} is present, use POST; otherwise GET\n                const json = (url.indexOf(\"{data}\") >= 0) ? null : JSON.stringify({ data, sender });\n                const result = yield (0,_ethersproject_web__WEBPACK_IMPORTED_MODULE_12__.fetchJson)({ url: href, errorPassThrough: true }, json, (value, response) => {\n                    value.status = response.statusCode;\n                    return value;\n                });\n                if (result.data) {\n                    return result.data;\n                }\n                const errorMessage = (result.message || \"unknown error\");\n                // 4xx indicates the result is not present; stop\n                if (result.status >= 400 && result.status < 500) {\n                    return logger.throwError(`response not found during CCIP fetch: ${errorMessage}`, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.SERVER_ERROR, { url, errorMessage });\n                }\n                // 5xx indicates server issue; try the next url\n                errorMessages.push(errorMessage);\n            }\n            return logger.throwError(`error encountered during CCIP fetch: ${errorMessages.map((m) => JSON.stringify(m)).join(\", \")}`, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.SERVER_ERROR, {\n                urls, errorMessages\n            });\n        });\n    }\n    // Fetches the blockNumber, but will reuse any result that is less\n    // than maxAge old or has been requested since the last request\n    _getInternalBlockNumber(maxAge) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this._ready();\n            // Allowing stale data up to maxAge old\n            if (maxAge > 0) {\n                // While there are pending internal block requests...\n                while (this._internalBlockNumber) {\n                    // ...\"remember\" which fetch we started with\n                    const internalBlockNumber = this._internalBlockNumber;\n                    try {\n                        // Check the result is not too stale\n                        const result = yield internalBlockNumber;\n                        if ((getTime() - result.respTime) <= maxAge) {\n                            return result.blockNumber;\n                        }\n                        // Too old; fetch a new value\n                        break;\n                    }\n                    catch (error) {\n                        // The fetch rejected; if we are the first to get the\n                        // rejection, drop through so we replace it with a new\n                        // fetch; all others blocked will then get that fetch\n                        // which won't match the one they \"remembered\" and loop\n                        if (this._internalBlockNumber === internalBlockNumber) {\n                            break;\n                        }\n                    }\n                }\n            }\n            const reqTime = getTime();\n            const checkInternalBlockNumber = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.resolveProperties)({\n                blockNumber: this.perform(\"getBlockNumber\", {}),\n                networkError: this.getNetwork().then((network) => (null), (error) => (error))\n            }).then(({ blockNumber, networkError }) => {\n                if (networkError) {\n                    // Unremember this bad internal block number\n                    if (this._internalBlockNumber === checkInternalBlockNumber) {\n                        this._internalBlockNumber = null;\n                    }\n                    throw networkError;\n                }\n                const respTime = getTime();\n                blockNumber = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__.BigNumber.from(blockNumber).toNumber();\n                if (blockNumber < this._maxInternalBlockNumber) {\n                    blockNumber = this._maxInternalBlockNumber;\n                }\n                this._maxInternalBlockNumber = blockNumber;\n                this._setFastBlockNumber(blockNumber); // @TODO: Still need this?\n                return { blockNumber, reqTime, respTime };\n            });\n            this._internalBlockNumber = checkInternalBlockNumber;\n            // Swallow unhandled exceptions; if needed they are handled else where\n            checkInternalBlockNumber.catch((error) => {\n                // Don't null the dead (rejected) fetch, if it has already been updated\n                if (this._internalBlockNumber === checkInternalBlockNumber) {\n                    this._internalBlockNumber = null;\n                }\n            });\n            return (yield checkInternalBlockNumber).blockNumber;\n        });\n    }\n    poll() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const pollId = nextPollId++;\n            // Track all running promises, so we can trigger a post-poll once they are complete\n            const runners = [];\n            let blockNumber = null;\n            try {\n                blockNumber = yield this._getInternalBlockNumber(100 + this.pollingInterval / 2);\n            }\n            catch (error) {\n                this.emit(\"error\", error);\n                return;\n            }\n            this._setFastBlockNumber(blockNumber);\n            // Emit a poll event after we have the latest (fast) block number\n            this.emit(\"poll\", pollId, blockNumber);\n            // If the block has not changed, meh.\n            if (blockNumber === this._lastBlockNumber) {\n                this.emit(\"didPoll\", pollId);\n                return;\n            }\n            // First polling cycle, trigger a \"block\" events\n            if (this._emitted.block === -2) {\n                this._emitted.block = blockNumber - 1;\n            }\n            if (Math.abs((this._emitted.block) - blockNumber) > 1000) {\n                logger.warn(`network block skew detected; skipping block events (emitted=${this._emitted.block} blockNumber${blockNumber})`);\n                this.emit(\"error\", logger.makeError(\"network block skew detected\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.NETWORK_ERROR, {\n                    blockNumber: blockNumber,\n                    event: \"blockSkew\",\n                    previousBlockNumber: this._emitted.block\n                }));\n                this.emit(\"block\", blockNumber);\n            }\n            else {\n                // Notify all listener for each block that has passed\n                for (let i = this._emitted.block + 1; i <= blockNumber; i++) {\n                    this.emit(\"block\", i);\n                }\n            }\n            // The emitted block was updated, check for obsolete events\n            if (this._emitted.block !== blockNumber) {\n                this._emitted.block = blockNumber;\n                Object.keys(this._emitted).forEach((key) => {\n                    // The block event does not expire\n                    if (key === \"block\") {\n                        return;\n                    }\n                    // The block we were at when we emitted this event\n                    const eventBlockNumber = this._emitted[key];\n                    // We cannot garbage collect pending transactions or blocks here\n                    // They should be garbage collected by the Provider when setting\n                    // \"pending\" events\n                    if (eventBlockNumber === \"pending\") {\n                        return;\n                    }\n                    // Evict any transaction hashes or block hashes over 12 blocks\n                    // old, since they should not return null anyways\n                    if (blockNumber - eventBlockNumber > 12) {\n                        delete this._emitted[key];\n                    }\n                });\n            }\n            // First polling cycle\n            if (this._lastBlockNumber === -2) {\n                this._lastBlockNumber = blockNumber - 1;\n            }\n            // Find all transaction hashes we are waiting on\n            this._events.forEach((event) => {\n                switch (event.type) {\n                    case \"tx\": {\n                        const hash = event.hash;\n                        let runner = this.getTransactionReceipt(hash).then((receipt) => {\n                            if (!receipt || receipt.blockNumber == null) {\n                                return null;\n                            }\n                            this._emitted[\"t:\" + hash] = receipt.blockNumber;\n                            this.emit(hash, receipt);\n                            return null;\n                        }).catch((error) => { this.emit(\"error\", error); });\n                        runners.push(runner);\n                        break;\n                    }\n                    case \"filter\": {\n                        // We only allow a single getLogs to be in-flight at a time\n                        if (!event._inflight) {\n                            event._inflight = true;\n                            // This is the first filter for this event, so we want to\n                            // restrict events to events that happened no earlier than now\n                            if (event._lastBlockNumber === -2) {\n                                event._lastBlockNumber = blockNumber - 1;\n                            }\n                            // Filter from the last *known* event; due to load-balancing\n                            // and some nodes returning updated block numbers before\n                            // indexing events, a logs result with 0 entries cannot be\n                            // trusted and we must retry a range which includes it again\n                            const filter = event.filter;\n                            filter.fromBlock = event._lastBlockNumber + 1;\n                            filter.toBlock = blockNumber;\n                            // Prevent fitler ranges from growing too wild, since it is quite\n                            // likely there just haven't been any events to move the lastBlockNumber.\n                            const minFromBlock = filter.toBlock - this._maxFilterBlockRange;\n                            if (minFromBlock > filter.fromBlock) {\n                                filter.fromBlock = minFromBlock;\n                            }\n                            if (filter.fromBlock < 0) {\n                                filter.fromBlock = 0;\n                            }\n                            const runner = this.getLogs(filter).then((logs) => {\n                                // Allow the next getLogs\n                                event._inflight = false;\n                                if (logs.length === 0) {\n                                    return;\n                                }\n                                logs.forEach((log) => {\n                                    // Only when we get an event for a given block number\n                                    // can we trust the events are indexed\n                                    if (log.blockNumber > event._lastBlockNumber) {\n                                        event._lastBlockNumber = log.blockNumber;\n                                    }\n                                    // Make sure we stall requests to fetch blocks and txs\n                                    this._emitted[\"b:\" + log.blockHash] = log.blockNumber;\n                                    this._emitted[\"t:\" + log.transactionHash] = log.blockNumber;\n                                    this.emit(filter, log);\n                                });\n                            }).catch((error) => {\n                                this.emit(\"error\", error);\n                                // Allow another getLogs (the range was not updated)\n                                event._inflight = false;\n                            });\n                            runners.push(runner);\n                        }\n                        break;\n                    }\n                }\n            });\n            this._lastBlockNumber = blockNumber;\n            // Once all events for this loop have been processed, emit \"didPoll\"\n            Promise.all(runners).then(() => {\n                this.emit(\"didPoll\", pollId);\n            }).catch((error) => { this.emit(\"error\", error); });\n            return;\n        });\n    }\n    // Deprecated; do not use this\n    resetEventsBlock(blockNumber) {\n        this._lastBlockNumber = blockNumber - 1;\n        if (this.polling) {\n            this.poll();\n        }\n    }\n    get network() {\n        return this._network;\n    }\n    // This method should query the network if the underlying network\n    // can change, such as when connected to a JSON-RPC backend\n    detectNetwork() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return logger.throwError(\"provider does not support network detection\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"provider.detectNetwork\"\n            });\n        });\n    }\n    getNetwork() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const network = yield this._ready();\n            // Make sure we are still connected to the same network; this is\n            // only an external call for backends which can have the underlying\n            // network change spontaneously\n            const currentNetwork = yield this.detectNetwork();\n            if (network.chainId !== currentNetwork.chainId) {\n                // We are allowing network changes, things can get complex fast;\n                // make sure you know what you are doing if you use \"any\"\n                if (this.anyNetwork) {\n                    this._network = currentNetwork;\n                    // Reset all internal block number guards and caches\n                    this._lastBlockNumber = -2;\n                    this._fastBlockNumber = null;\n                    this._fastBlockNumberPromise = null;\n                    this._fastQueryDate = 0;\n                    this._emitted.block = -2;\n                    this._maxInternalBlockNumber = -1024;\n                    this._internalBlockNumber = null;\n                    // The \"network\" event MUST happen before this method resolves\n                    // so any events have a chance to unregister, so we stall an\n                    // additional event loop before returning from /this/ call\n                    this.emit(\"network\", currentNetwork, network);\n                    yield stall(0);\n                    return this._network;\n                }\n                const error = logger.makeError(\"underlying network changed\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.NETWORK_ERROR, {\n                    event: \"changed\",\n                    network: network,\n                    detectedNetwork: currentNetwork\n                });\n                this.emit(\"error\", error);\n                throw error;\n            }\n            return network;\n        });\n    }\n    get blockNumber() {\n        this._getInternalBlockNumber(100 + this.pollingInterval / 2).then((blockNumber) => {\n            this._setFastBlockNumber(blockNumber);\n        }, (error) => { });\n        return (this._fastBlockNumber != null) ? this._fastBlockNumber : -1;\n    }\n    get polling() {\n        return (this._poller != null);\n    }\n    set polling(value) {\n        if (value && !this._poller) {\n            this._poller = setInterval(() => { this.poll(); }, this.pollingInterval);\n            if (!this._bootstrapPoll) {\n                this._bootstrapPoll = setTimeout(() => {\n                    this.poll();\n                    // We block additional polls until the polling interval\n                    // is done, to prevent overwhelming the poll function\n                    this._bootstrapPoll = setTimeout(() => {\n                        // If polling was disabled, something may require a poke\n                        // since starting the bootstrap poll and it was disabled\n                        if (!this._poller) {\n                            this.poll();\n                        }\n                        // Clear out the bootstrap so we can do another\n                        this._bootstrapPoll = null;\n                    }, this.pollingInterval);\n                }, 0);\n            }\n        }\n        else if (!value && this._poller) {\n            clearInterval(this._poller);\n            this._poller = null;\n        }\n    }\n    get pollingInterval() {\n        return this._pollingInterval;\n    }\n    set pollingInterval(value) {\n        if (typeof (value) !== \"number\" || value <= 0 || parseInt(String(value)) != value) {\n            throw new Error(\"invalid polling interval\");\n        }\n        this._pollingInterval = value;\n        if (this._poller) {\n            clearInterval(this._poller);\n            this._poller = setInterval(() => { this.poll(); }, this._pollingInterval);\n        }\n    }\n    _getFastBlockNumber() {\n        const now = getTime();\n        // Stale block number, request a newer value\n        if ((now - this._fastQueryDate) > 2 * this._pollingInterval) {\n            this._fastQueryDate = now;\n            this._fastBlockNumberPromise = this.getBlockNumber().then((blockNumber) => {\n                if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {\n                    this._fastBlockNumber = blockNumber;\n                }\n                return this._fastBlockNumber;\n            });\n        }\n        return this._fastBlockNumberPromise;\n    }\n    _setFastBlockNumber(blockNumber) {\n        // Older block, maybe a stale request\n        if (this._fastBlockNumber != null && blockNumber < this._fastBlockNumber) {\n            return;\n        }\n        // Update the time we updated the blocknumber\n        this._fastQueryDate = getTime();\n        // Newer block number, use  it\n        if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {\n            this._fastBlockNumber = blockNumber;\n            this._fastBlockNumberPromise = Promise.resolve(blockNumber);\n        }\n    }\n    waitForTransaction(transactionHash, confirmations, timeout) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this._waitForTransaction(transactionHash, (confirmations == null) ? 1 : confirmations, timeout || 0, null);\n        });\n    }\n    _waitForTransaction(transactionHash, confirmations, timeout, replaceable) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const receipt = yield this.getTransactionReceipt(transactionHash);\n            // Receipt is already good\n            if ((receipt ? receipt.confirmations : 0) >= confirmations) {\n                return receipt;\n            }\n            // Poll until the receipt is good...\n            return new Promise((resolve, reject) => {\n                const cancelFuncs = [];\n                let done = false;\n                const alreadyDone = function () {\n                    if (done) {\n                        return true;\n                    }\n                    done = true;\n                    cancelFuncs.forEach((func) => { func(); });\n                    return false;\n                };\n                const minedHandler = (receipt) => {\n                    if (receipt.confirmations < confirmations) {\n                        return;\n                    }\n                    if (alreadyDone()) {\n                        return;\n                    }\n                    resolve(receipt);\n                };\n                this.on(transactionHash, minedHandler);\n                cancelFuncs.push(() => { this.removeListener(transactionHash, minedHandler); });\n                if (replaceable) {\n                    let lastBlockNumber = replaceable.startBlock;\n                    let scannedBlock = null;\n                    const replaceHandler = (blockNumber) => __awaiter(this, void 0, void 0, function* () {\n                        if (done) {\n                            return;\n                        }\n                        // Wait 1 second; this is only used in the case of a fault, so\n                        // we will trade off a little bit of latency for more consistent\n                        // results and fewer JSON-RPC calls\n                        yield stall(1000);\n                        this.getTransactionCount(replaceable.from).then((nonce) => __awaiter(this, void 0, void 0, function* () {\n                            if (done) {\n                                return;\n                            }\n                            if (nonce <= replaceable.nonce) {\n                                lastBlockNumber = blockNumber;\n                            }\n                            else {\n                                // First check if the transaction was mined\n                                {\n                                    const mined = yield this.getTransaction(transactionHash);\n                                    if (mined && mined.blockNumber != null) {\n                                        return;\n                                    }\n                                }\n                                // First time scanning. We start a little earlier for some\n                                // wiggle room here to handle the eventually consistent nature\n                                // of blockchain (e.g. the getTransactionCount was for a\n                                // different block)\n                                if (scannedBlock == null) {\n                                    scannedBlock = lastBlockNumber - 3;\n                                    if (scannedBlock < replaceable.startBlock) {\n                                        scannedBlock = replaceable.startBlock;\n                                    }\n                                }\n                                while (scannedBlock <= blockNumber) {\n                                    if (done) {\n                                        return;\n                                    }\n                                    const block = yield this.getBlockWithTransactions(scannedBlock);\n                                    for (let ti = 0; ti < block.transactions.length; ti++) {\n                                        const tx = block.transactions[ti];\n                                        // Successfully mined!\n                                        if (tx.hash === transactionHash) {\n                                            return;\n                                        }\n                                        // Matches our transaction from and nonce; its a replacement\n                                        if (tx.from === replaceable.from && tx.nonce === replaceable.nonce) {\n                                            if (done) {\n                                                return;\n                                            }\n                                            // Get the receipt of the replacement\n                                            const receipt = yield this.waitForTransaction(tx.hash, confirmations);\n                                            // Already resolved or rejected (prolly a timeout)\n                                            if (alreadyDone()) {\n                                                return;\n                                            }\n                                            // The reason we were replaced\n                                            let reason = \"replaced\";\n                                            if (tx.data === replaceable.data && tx.to === replaceable.to && tx.value.eq(replaceable.value)) {\n                                                reason = \"repriced\";\n                                            }\n                                            else if (tx.data === \"0x\" && tx.from === tx.to && tx.value.isZero()) {\n                                                reason = \"cancelled\";\n                                            }\n                                            // Explain why we were replaced\n                                            reject(logger.makeError(\"transaction was replaced\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.TRANSACTION_REPLACED, {\n                                                cancelled: (reason === \"replaced\" || reason === \"cancelled\"),\n                                                reason,\n                                                replacement: this._wrapTransaction(tx),\n                                                hash: transactionHash,\n                                                receipt\n                                            }));\n                                            return;\n                                        }\n                                    }\n                                    scannedBlock++;\n                                }\n                            }\n                            if (done) {\n                                return;\n                            }\n                            this.once(\"block\", replaceHandler);\n                        }), (error) => {\n                            if (done) {\n                                return;\n                            }\n                            this.once(\"block\", replaceHandler);\n                        });\n                    });\n                    if (done) {\n                        return;\n                    }\n                    this.once(\"block\", replaceHandler);\n                    cancelFuncs.push(() => {\n                        this.removeListener(\"block\", replaceHandler);\n                    });\n                }\n                if (typeof (timeout) === \"number\" && timeout > 0) {\n                    const timer = setTimeout(() => {\n                        if (alreadyDone()) {\n                            return;\n                        }\n                        reject(logger.makeError(\"timeout exceeded\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.TIMEOUT, { timeout: timeout }));\n                    }, timeout);\n                    if (timer.unref) {\n                        timer.unref();\n                    }\n                    cancelFuncs.push(() => { clearTimeout(timer); });\n                }\n            });\n        });\n    }\n    getBlockNumber() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this._getInternalBlockNumber(0);\n        });\n    }\n    getGasPrice() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const result = yield this.perform(\"getGasPrice\", {});\n            try {\n                return _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__.BigNumber.from(result);\n            }\n            catch (error) {\n                return logger.throwError(\"bad result from backend\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.SERVER_ERROR, {\n                    method: \"getGasPrice\",\n                    result, error\n                });\n            }\n        });\n    }\n    getBalance(addressOrName, blockTag) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const params = yield (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.resolveProperties)({\n                address: this._getAddress(addressOrName),\n                blockTag: this._getBlockTag(blockTag)\n            });\n            const result = yield this.perform(\"getBalance\", params);\n            try {\n                return _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__.BigNumber.from(result);\n            }\n            catch (error) {\n                return logger.throwError(\"bad result from backend\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.SERVER_ERROR, {\n                    method: \"getBalance\",\n                    params, result, error\n                });\n            }\n        });\n    }\n    getTransactionCount(addressOrName, blockTag) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const params = yield (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.resolveProperties)({\n                address: this._getAddress(addressOrName),\n                blockTag: this._getBlockTag(blockTag)\n            });\n            const result = yield this.perform(\"getTransactionCount\", params);\n            try {\n                return _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__.BigNumber.from(result).toNumber();\n            }\n            catch (error) {\n                return logger.throwError(\"bad result from backend\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.SERVER_ERROR, {\n                    method: \"getTransactionCount\",\n                    params, result, error\n                });\n            }\n        });\n    }\n    getCode(addressOrName, blockTag) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const params = yield (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.resolveProperties)({\n                address: this._getAddress(addressOrName),\n                blockTag: this._getBlockTag(blockTag)\n            });\n            const result = yield this.perform(\"getCode\", params);\n            try {\n                return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexlify)(result);\n            }\n            catch (error) {\n                return logger.throwError(\"bad result from backend\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.SERVER_ERROR, {\n                    method: \"getCode\",\n                    params, result, error\n                });\n            }\n        });\n    }\n    getStorageAt(addressOrName, position, blockTag) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const params = yield (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.resolveProperties)({\n                address: this._getAddress(addressOrName),\n                blockTag: this._getBlockTag(blockTag),\n                position: Promise.resolve(position).then((p) => (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexValue)(p))\n            });\n            const result = yield this.perform(\"getStorageAt\", params);\n            try {\n                return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexlify)(result);\n            }\n            catch (error) {\n                return logger.throwError(\"bad result from backend\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.SERVER_ERROR, {\n                    method: \"getStorageAt\",\n                    params, result, error\n                });\n            }\n        });\n    }\n    // This should be called by any subclass wrapping a TransactionResponse\n    _wrapTransaction(tx, hash, startBlock) {\n        if (hash != null && (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexDataLength)(hash) !== 32) {\n            throw new Error(\"invalid response - sendTransaction\");\n        }\n        const result = tx;\n        // Check the hash we expect is the same as the hash the server reported\n        if (hash != null && tx.hash !== hash) {\n            logger.throwError(\"Transaction hash mismatch from Provider.sendTransaction.\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.UNKNOWN_ERROR, { expectedHash: tx.hash, returnedHash: hash });\n        }\n        result.wait = (confirms, timeout) => __awaiter(this, void 0, void 0, function* () {\n            if (confirms == null) {\n                confirms = 1;\n            }\n            if (timeout == null) {\n                timeout = 0;\n            }\n            // Get the details to detect replacement\n            let replacement = undefined;\n            if (confirms !== 0 && startBlock != null) {\n                replacement = {\n                    data: tx.data,\n                    from: tx.from,\n                    nonce: tx.nonce,\n                    to: tx.to,\n                    value: tx.value,\n                    startBlock\n                };\n            }\n            const receipt = yield this._waitForTransaction(tx.hash, confirms, timeout, replacement);\n            if (receipt == null && confirms === 0) {\n                return null;\n            }\n            // No longer pending, allow the polling loop to garbage collect this\n            this._emitted[\"t:\" + tx.hash] = receipt.blockNumber;\n            if (receipt.status === 0) {\n                logger.throwError(\"transaction failed\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.CALL_EXCEPTION, {\n                    transactionHash: tx.hash,\n                    transaction: tx,\n                    receipt: receipt\n                });\n            }\n            return receipt;\n        });\n        return result;\n    }\n    sendTransaction(signedTransaction) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const hexTx = yield Promise.resolve(signedTransaction).then(t => (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexlify)(t));\n            const tx = this.formatter.transaction(signedTransaction);\n            if (tx.confirmations == null) {\n                tx.confirmations = 0;\n            }\n            const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n            try {\n                const hash = yield this.perform(\"sendTransaction\", { signedTransaction: hexTx });\n                return this._wrapTransaction(tx, hash, blockNumber);\n            }\n            catch (error) {\n                error.transaction = tx;\n                error.transactionHash = tx.hash;\n                throw error;\n            }\n        });\n    }\n    _getTransactionRequest(transaction) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const values = yield transaction;\n            const tx = {};\n            [\"from\", \"to\"].forEach((key) => {\n                if (values[key] == null) {\n                    return;\n                }\n                tx[key] = Promise.resolve(values[key]).then((v) => (v ? this._getAddress(v) : null));\n            });\n            [\"gasLimit\", \"gasPrice\", \"maxFeePerGas\", \"maxPriorityFeePerGas\", \"value\"].forEach((key) => {\n                if (values[key] == null) {\n                    return;\n                }\n                tx[key] = Promise.resolve(values[key]).then((v) => (v ? _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__.BigNumber.from(v) : null));\n            });\n            [\"type\"].forEach((key) => {\n                if (values[key] == null) {\n                    return;\n                }\n                tx[key] = Promise.resolve(values[key]).then((v) => ((v != null) ? v : null));\n            });\n            if (values.accessList) {\n                tx.accessList = this.formatter.accessList(values.accessList);\n            }\n            [\"data\"].forEach((key) => {\n                if (values[key] == null) {\n                    return;\n                }\n                tx[key] = Promise.resolve(values[key]).then((v) => (v ? (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexlify)(v) : null));\n            });\n            return this.formatter.transactionRequest(yield (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.resolveProperties)(tx));\n        });\n    }\n    _getFilter(filter) {\n        return __awaiter(this, void 0, void 0, function* () {\n            filter = yield filter;\n            const result = {};\n            if (filter.address != null) {\n                result.address = this._getAddress(filter.address);\n            }\n            [\"blockHash\", \"topics\"].forEach((key) => {\n                if (filter[key] == null) {\n                    return;\n                }\n                result[key] = filter[key];\n            });\n            [\"fromBlock\", \"toBlock\"].forEach((key) => {\n                if (filter[key] == null) {\n                    return;\n                }\n                result[key] = this._getBlockTag(filter[key]);\n            });\n            return this.formatter.filter(yield (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.resolveProperties)(result));\n        });\n    }\n    _call(transaction, blockTag, attempt) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (attempt >= MAX_CCIP_REDIRECTS) {\n                logger.throwError(\"CCIP read exceeded maximum redirections\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.SERVER_ERROR, {\n                    redirects: attempt, transaction\n                });\n            }\n            const txSender = transaction.to;\n            const result = yield this.perform(\"call\", { transaction, blockTag });\n            // CCIP Read request via OffchainLookup(address,string[],bytes,bytes4,bytes)\n            if (attempt >= 0 && blockTag === \"latest\" && txSender != null && result.substring(0, 10) === \"0x556f1830\" && ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexDataLength)(result) % 32 === 4)) {\n                try {\n                    const data = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexDataSlice)(result, 4);\n                    // Check the sender of the OffchainLookup matches the transaction\n                    const sender = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexDataSlice)(data, 0, 32);\n                    if (!_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__.BigNumber.from(sender).eq(txSender)) {\n                        logger.throwError(\"CCIP Read sender did not match\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.CALL_EXCEPTION, {\n                            name: \"OffchainLookup\",\n                            signature: \"OffchainLookup(address,string[],bytes,bytes4,bytes)\",\n                            transaction, data: result\n                        });\n                    }\n                    // Read the URLs from the response\n                    const urls = [];\n                    const urlsOffset = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__.BigNumber.from((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexDataSlice)(data, 32, 64)).toNumber();\n                    const urlsLength = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__.BigNumber.from((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexDataSlice)(data, urlsOffset, urlsOffset + 32)).toNumber();\n                    const urlsData = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexDataSlice)(data, urlsOffset + 32);\n                    for (let u = 0; u < urlsLength; u++) {\n                        const url = _parseString(urlsData, u * 32);\n                        if (url == null) {\n                            logger.throwError(\"CCIP Read contained corrupt URL string\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.CALL_EXCEPTION, {\n                                name: \"OffchainLookup\",\n                                signature: \"OffchainLookup(address,string[],bytes,bytes4,bytes)\",\n                                transaction, data: result\n                            });\n                        }\n                        urls.push(url);\n                    }\n                    // Get the CCIP calldata to forward\n                    const calldata = _parseBytes(data, 64);\n                    // Get the callbackSelector (bytes4)\n                    if (!_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__.BigNumber.from((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexDataSlice)(data, 100, 128)).isZero()) {\n                        logger.throwError(\"CCIP Read callback selector included junk\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.CALL_EXCEPTION, {\n                            name: \"OffchainLookup\",\n                            signature: \"OffchainLookup(address,string[],bytes,bytes4,bytes)\",\n                            transaction, data: result\n                        });\n                    }\n                    const callbackSelector = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexDataSlice)(data, 96, 100);\n                    // Get the extra data to send back to the contract as context\n                    const extraData = _parseBytes(data, 128);\n                    const ccipResult = yield this.ccipReadFetch(transaction, calldata, urls);\n                    if (ccipResult == null) {\n                        logger.throwError(\"CCIP Read disabled or provided no URLs\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.CALL_EXCEPTION, {\n                            name: \"OffchainLookup\",\n                            signature: \"OffchainLookup(address,string[],bytes,bytes4,bytes)\",\n                            transaction, data: result\n                        });\n                    }\n                    const tx = {\n                        to: txSender,\n                        data: (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexConcat)([callbackSelector, encodeBytes([ccipResult, extraData])])\n                    };\n                    return this._call(tx, blockTag, attempt + 1);\n                }\n                catch (error) {\n                    if (error.code === _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.SERVER_ERROR) {\n                        throw error;\n                    }\n                }\n            }\n            try {\n                return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexlify)(result);\n            }\n            catch (error) {\n                return logger.throwError(\"bad result from backend\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.SERVER_ERROR, {\n                    method: \"call\",\n                    params: { transaction, blockTag }, result, error\n                });\n            }\n        });\n    }\n    call(transaction, blockTag) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const resolved = yield (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.resolveProperties)({\n                transaction: this._getTransactionRequest(transaction),\n                blockTag: this._getBlockTag(blockTag),\n                ccipReadEnabled: Promise.resolve(transaction.ccipReadEnabled)\n            });\n            return this._call(resolved.transaction, resolved.blockTag, resolved.ccipReadEnabled ? 0 : -1);\n        });\n    }\n    estimateGas(transaction) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const params = yield (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.resolveProperties)({\n                transaction: this._getTransactionRequest(transaction)\n            });\n            const result = yield this.perform(\"estimateGas\", params);\n            try {\n                return _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__.BigNumber.from(result);\n            }\n            catch (error) {\n                return logger.throwError(\"bad result from backend\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.SERVER_ERROR, {\n                    method: \"estimateGas\",\n                    params, result, error\n                });\n            }\n        });\n    }\n    _getAddress(addressOrName) {\n        return __awaiter(this, void 0, void 0, function* () {\n            addressOrName = yield addressOrName;\n            if (typeof (addressOrName) !== \"string\") {\n                logger.throwArgumentError(\"invalid address or ENS name\", \"name\", addressOrName);\n            }\n            const address = yield this.resolveName(addressOrName);\n            if (address == null) {\n                logger.throwError(\"ENS name not configured\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: `resolveName(${JSON.stringify(addressOrName)})`\n                });\n            }\n            return address;\n        });\n    }\n    _getBlock(blockHashOrBlockTag, includeTransactions) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            blockHashOrBlockTag = yield blockHashOrBlockTag;\n            // If blockTag is a number (not \"latest\", etc), this is the block number\n            let blockNumber = -128;\n            const params = {\n                includeTransactions: !!includeTransactions\n            };\n            if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.isHexString)(blockHashOrBlockTag, 32)) {\n                params.blockHash = blockHashOrBlockTag;\n            }\n            else {\n                try {\n                    params.blockTag = yield this._getBlockTag(blockHashOrBlockTag);\n                    if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.isHexString)(params.blockTag)) {\n                        blockNumber = parseInt(params.blockTag.substring(2), 16);\n                    }\n                }\n                catch (error) {\n                    logger.throwArgumentError(\"invalid block hash or block tag\", \"blockHashOrBlockTag\", blockHashOrBlockTag);\n                }\n            }\n            return (0,_ethersproject_web__WEBPACK_IMPORTED_MODULE_12__.poll)(() => __awaiter(this, void 0, void 0, function* () {\n                const block = yield this.perform(\"getBlock\", params);\n                // Block was not found\n                if (block == null) {\n                    // For blockhashes, if we didn't say it existed, that blockhash may\n                    // not exist. If we did see it though, perhaps from a log, we know\n                    // it exists, and this node is just not caught up yet.\n                    if (params.blockHash != null) {\n                        if (this._emitted[\"b:\" + params.blockHash] == null) {\n                            return null;\n                        }\n                    }\n                    // For block tags, if we are asking for a future block, we return null\n                    if (params.blockTag != null) {\n                        if (blockNumber > this._emitted.block) {\n                            return null;\n                        }\n                    }\n                    // Retry on the next block\n                    return undefined;\n                }\n                // Add transactions\n                if (includeTransactions) {\n                    let blockNumber = null;\n                    for (let i = 0; i < block.transactions.length; i++) {\n                        const tx = block.transactions[i];\n                        if (tx.blockNumber == null) {\n                            tx.confirmations = 0;\n                        }\n                        else if (tx.confirmations == null) {\n                            if (blockNumber == null) {\n                                blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n                            }\n                            // Add the confirmations using the fast block number (pessimistic)\n                            let confirmations = (blockNumber - tx.blockNumber) + 1;\n                            if (confirmations <= 0) {\n                                confirmations = 1;\n                            }\n                            tx.confirmations = confirmations;\n                        }\n                    }\n                    const blockWithTxs = this.formatter.blockWithTransactions(block);\n                    blockWithTxs.transactions = blockWithTxs.transactions.map((tx) => this._wrapTransaction(tx));\n                    return blockWithTxs;\n                }\n                return this.formatter.block(block);\n            }), { oncePoll: this });\n        });\n    }\n    getBlock(blockHashOrBlockTag) {\n        return (this._getBlock(blockHashOrBlockTag, false));\n    }\n    getBlockWithTransactions(blockHashOrBlockTag) {\n        return (this._getBlock(blockHashOrBlockTag, true));\n    }\n    getTransaction(transactionHash) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            transactionHash = yield transactionHash;\n            const params = { transactionHash: this.formatter.hash(transactionHash, true) };\n            return (0,_ethersproject_web__WEBPACK_IMPORTED_MODULE_12__.poll)(() => __awaiter(this, void 0, void 0, function* () {\n                const result = yield this.perform(\"getTransaction\", params);\n                if (result == null) {\n                    if (this._emitted[\"t:\" + transactionHash] == null) {\n                        return null;\n                    }\n                    return undefined;\n                }\n                const tx = this.formatter.transactionResponse(result);\n                if (tx.blockNumber == null) {\n                    tx.confirmations = 0;\n                }\n                else if (tx.confirmations == null) {\n                    const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n                    // Add the confirmations using the fast block number (pessimistic)\n                    let confirmations = (blockNumber - tx.blockNumber) + 1;\n                    if (confirmations <= 0) {\n                        confirmations = 1;\n                    }\n                    tx.confirmations = confirmations;\n                }\n                return this._wrapTransaction(tx);\n            }), { oncePoll: this });\n        });\n    }\n    getTransactionReceipt(transactionHash) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            transactionHash = yield transactionHash;\n            const params = { transactionHash: this.formatter.hash(transactionHash, true) };\n            return (0,_ethersproject_web__WEBPACK_IMPORTED_MODULE_12__.poll)(() => __awaiter(this, void 0, void 0, function* () {\n                const result = yield this.perform(\"getTransactionReceipt\", params);\n                if (result == null) {\n                    if (this._emitted[\"t:\" + transactionHash] == null) {\n                        return null;\n                    }\n                    return undefined;\n                }\n                // \"geth-etc\" returns receipts before they are ready\n                if (result.blockHash == null) {\n                    return undefined;\n                }\n                const receipt = this.formatter.receipt(result);\n                if (receipt.blockNumber == null) {\n                    receipt.confirmations = 0;\n                }\n                else if (receipt.confirmations == null) {\n                    const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n                    // Add the confirmations using the fast block number (pessimistic)\n                    let confirmations = (blockNumber - receipt.blockNumber) + 1;\n                    if (confirmations <= 0) {\n                        confirmations = 1;\n                    }\n                    receipt.confirmations = confirmations;\n                }\n                return receipt;\n            }), { oncePoll: this });\n        });\n    }\n    getLogs(filter) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const params = yield (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.resolveProperties)({ filter: this._getFilter(filter) });\n            const logs = yield this.perform(\"getLogs\", params);\n            logs.forEach((log) => {\n                if (log.removed == null) {\n                    log.removed = false;\n                }\n            });\n            return _formatter__WEBPACK_IMPORTED_MODULE_14__.Formatter.arrayOf(this.formatter.filterLog.bind(this.formatter))(logs);\n        });\n    }\n    getEtherPrice() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            return this.perform(\"getEtherPrice\", {});\n        });\n    }\n    _getBlockTag(blockTag) {\n        return __awaiter(this, void 0, void 0, function* () {\n            blockTag = yield blockTag;\n            if (typeof (blockTag) === \"number\" && blockTag < 0) {\n                if (blockTag % 1) {\n                    logger.throwArgumentError(\"invalid BlockTag\", \"blockTag\", blockTag);\n                }\n                let blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n                blockNumber += blockTag;\n                if (blockNumber < 0) {\n                    blockNumber = 0;\n                }\n                return this.formatter.blockTag(blockNumber);\n            }\n            return this.formatter.blockTag(blockTag);\n        });\n    }\n    getResolver(name) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let currentName = name;\n            while (true) {\n                if (currentName === \"\" || currentName === \".\") {\n                    return null;\n                }\n                // Optimization since the eth node cannot change and does\n                // not have a wildcard resolver\n                if (name !== \"eth\" && currentName === \"eth\") {\n                    return null;\n                }\n                // Check the current node for a resolver\n                const addr = yield this._getResolver(currentName, \"getResolver\");\n                // Found a resolver!\n                if (addr != null) {\n                    const resolver = new Resolver(this, addr, name);\n                    // Legacy resolver found, using EIP-2544 so it isn't safe to use\n                    if (currentName !== name && !(yield resolver.supportsWildcard())) {\n                        return null;\n                    }\n                    return resolver;\n                }\n                // Get the parent node\n                currentName = currentName.split(\".\").slice(1).join(\".\");\n            }\n        });\n    }\n    _getResolver(name, operation) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (operation == null) {\n                operation = \"ENS\";\n            }\n            const network = yield this.getNetwork();\n            // No ENS...\n            if (!network.ensAddress) {\n                logger.throwError(\"network does not support ENS\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.UNSUPPORTED_OPERATION, { operation, network: network.name });\n            }\n            try {\n                // keccak256(\"resolver(bytes32)\")\n                const addrData = yield this.call({\n                    to: network.ensAddress,\n                    data: (\"0x0178b8bf\" + (0,_ethersproject_hash__WEBPACK_IMPORTED_MODULE_10__.namehash)(name).substring(2))\n                });\n                return this.formatter.callAddress(addrData);\n            }\n            catch (error) {\n                // ENS registry cannot throw errors on resolver(bytes32)\n            }\n            return null;\n        });\n    }\n    resolveName(name) {\n        return __awaiter(this, void 0, void 0, function* () {\n            name = yield name;\n            // If it is already an address, nothing to resolve\n            try {\n                return Promise.resolve(this.formatter.address(name));\n            }\n            catch (error) {\n                // If is is a hexstring, the address is bad (See #694)\n                if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.isHexString)(name)) {\n                    throw error;\n                }\n            }\n            if (typeof (name) !== \"string\") {\n                logger.throwArgumentError(\"invalid ENS name\", \"name\", name);\n            }\n            // Get the addr from the resolver\n            const resolver = yield this.getResolver(name);\n            if (!resolver) {\n                return null;\n            }\n            return yield resolver.getAddress();\n        });\n    }\n    lookupAddress(address) {\n        return __awaiter(this, void 0, void 0, function* () {\n            address = yield address;\n            address = this.formatter.address(address);\n            const node = address.substring(2).toLowerCase() + \".addr.reverse\";\n            const resolverAddr = yield this._getResolver(node, \"lookupAddress\");\n            if (resolverAddr == null) {\n                return null;\n            }\n            // keccak(\"name(bytes32)\")\n            const name = _parseString(yield this.call({\n                to: resolverAddr,\n                data: (\"0x691f3431\" + (0,_ethersproject_hash__WEBPACK_IMPORTED_MODULE_10__.namehash)(node).substring(2))\n            }), 0);\n            const addr = yield this.resolveName(name);\n            if (addr != address) {\n                return null;\n            }\n            return name;\n        });\n    }\n    getAvatar(nameOrAddress) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let resolver = null;\n            if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.isHexString)(nameOrAddress)) {\n                // Address; reverse lookup\n                const address = this.formatter.address(nameOrAddress);\n                const node = address.substring(2).toLowerCase() + \".addr.reverse\";\n                const resolverAddress = yield this._getResolver(node, \"getAvatar\");\n                if (!resolverAddress) {\n                    return null;\n                }\n                // Try resolving the avatar against the addr.reverse resolver\n                resolver = new Resolver(this, resolverAddress, node);\n                try {\n                    const avatar = yield resolver.getAvatar();\n                    if (avatar) {\n                        return avatar.url;\n                    }\n                }\n                catch (error) {\n                    if (error.code !== _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.CALL_EXCEPTION) {\n                        throw error;\n                    }\n                }\n                // Try getting the name and performing forward lookup; allowing wildcards\n                try {\n                    // keccak(\"name(bytes32)\")\n                    const name = _parseString(yield this.call({\n                        to: resolverAddress,\n                        data: (\"0x691f3431\" + (0,_ethersproject_hash__WEBPACK_IMPORTED_MODULE_10__.namehash)(node).substring(2))\n                    }), 0);\n                    resolver = yield this.getResolver(name);\n                }\n                catch (error) {\n                    if (error.code !== _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.CALL_EXCEPTION) {\n                        throw error;\n                    }\n                    return null;\n                }\n            }\n            else {\n                // ENS name; forward lookup with wildcard\n                resolver = yield this.getResolver(nameOrAddress);\n                if (!resolver) {\n                    return null;\n                }\n            }\n            const avatar = yield resolver.getAvatar();\n            if (avatar == null) {\n                return null;\n            }\n            return avatar.url;\n        });\n    }\n    perform(method, params) {\n        return logger.throwError(method + \" not implemented\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.NOT_IMPLEMENTED, { operation: method });\n    }\n    _startEvent(event) {\n        this.polling = (this._events.filter((e) => e.pollable()).length > 0);\n    }\n    _stopEvent(event) {\n        this.polling = (this._events.filter((e) => e.pollable()).length > 0);\n    }\n    _addEventListener(eventName, listener, once) {\n        const event = new Event(getEventTag(eventName), listener, once);\n        this._events.push(event);\n        this._startEvent(event);\n        return this;\n    }\n    on(eventName, listener) {\n        return this._addEventListener(eventName, listener, false);\n    }\n    once(eventName, listener) {\n        return this._addEventListener(eventName, listener, true);\n    }\n    emit(eventName, ...args) {\n        let result = false;\n        let stopped = [];\n        let eventTag = getEventTag(eventName);\n        this._events = this._events.filter((event) => {\n            if (event.tag !== eventTag) {\n                return true;\n            }\n            setTimeout(() => {\n                event.listener.apply(this, args);\n            }, 0);\n            result = true;\n            if (event.once) {\n                stopped.push(event);\n                return false;\n            }\n            return true;\n        });\n        stopped.forEach((event) => { this._stopEvent(event); });\n        return result;\n    }\n    listenerCount(eventName) {\n        if (!eventName) {\n            return this._events.length;\n        }\n        let eventTag = getEventTag(eventName);\n        return this._events.filter((event) => {\n            return (event.tag === eventTag);\n        }).length;\n    }\n    listeners(eventName) {\n        if (eventName == null) {\n            return this._events.map((event) => event.listener);\n        }\n        let eventTag = getEventTag(eventName);\n        return this._events\n            .filter((event) => (event.tag === eventTag))\n            .map((event) => event.listener);\n    }\n    off(eventName, listener) {\n        if (listener == null) {\n            return this.removeAllListeners(eventName);\n        }\n        const stopped = [];\n        let found = false;\n        let eventTag = getEventTag(eventName);\n        this._events = this._events.filter((event) => {\n            if (event.tag !== eventTag || event.listener != listener) {\n                return true;\n            }\n            if (found) {\n                return true;\n            }\n            found = true;\n            stopped.push(event);\n            return false;\n        });\n        stopped.forEach((event) => { this._stopEvent(event); });\n        return this;\n    }\n    removeAllListeners(eventName) {\n        let stopped = [];\n        if (eventName == null) {\n            stopped = this._events;\n            this._events = [];\n        }\n        else {\n            const eventTag = getEventTag(eventName);\n            this._events = this._events.filter((event) => {\n                if (event.tag !== eventTag) {\n                    return true;\n                }\n                stopped.push(event);\n                return false;\n            });\n        }\n        stopped.forEach((event) => { this._stopEvent(event); });\n        return this;\n    }\n}\n//# sourceMappingURL=base-provider.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3Byb3ZpZGVycy9saWIuZXNtL2Jhc2UtcHJvdmlkZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBYTtBQUNiLGlCQUFpQixTQUFJLElBQUksU0FBSTtBQUM3Qiw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUN1RTtBQUNSO0FBQ2pCO0FBQ087QUFDdUY7QUFDeEY7QUFDTTtBQUNMO0FBQ29DO0FBQzVDO0FBQ3NCO0FBQ2Q7QUFDekI7QUFDbUI7QUFDVjtBQUNyQyxtQkFBbUIseURBQU0sQ0FBQyw2Q0FBTztBQUNPO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxtRUFBYTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbUVBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSx1RUFBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNB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cUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyx5REFBTTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDhEQUE4RCx5REFBTSwyQkFBMkIsbUJBQW1CO0FBQ2xIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULHFDQUFxQyx5QkFBeUI7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxxQ0FBcUMseUJBQXlCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EscUNBQXFDLHlCQUF5QjtBQUM5RDtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xlZGdpdHkteWllbGQtZnJvbnRlbmQvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3Byb3ZpZGVycy9saWIuZXNtL2Jhc2UtcHJvdmlkZXIuanM/OWYwMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuaW1wb3J0IHsgRm9ya0V2ZW50LCBQcm92aWRlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9hYnN0cmFjdC1wcm92aWRlclwiO1xuaW1wb3J0IHsgZW5jb2RlIGFzIGJhc2U2NEVuY29kZSB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9iYXNlNjRcIjtcbmltcG9ydCB7IEJhc2U1OCB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9iYXNleFwiO1xuaW1wb3J0IHsgQmlnTnVtYmVyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2JpZ251bWJlclwiO1xuaW1wb3J0IHsgYXJyYXlpZnksIGNvbmNhdCwgaGV4Q29uY2F0LCBoZXhEYXRhTGVuZ3RoLCBoZXhEYXRhU2xpY2UsIGhleGxpZnksIGhleFZhbHVlLCBoZXhaZXJvUGFkLCBpc0hleFN0cmluZyB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9ieXRlc1wiO1xuaW1wb3J0IHsgSGFzaFplcm8gfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvY29uc3RhbnRzXCI7XG5pbXBvcnQgeyBkbnNFbmNvZGUsIG5hbWVoYXNoIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2hhc2hcIjtcbmltcG9ydCB7IGdldE5ldHdvcmsgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvbmV0d29ya3NcIjtcbmltcG9ydCB7IGRlZmluZVJlYWRPbmx5LCBnZXRTdGF0aWMsIHJlc29sdmVQcm9wZXJ0aWVzIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3Byb3BlcnRpZXNcIjtcbmltcG9ydCB7IHNoYTI1NiB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9zaGEyXCI7XG5pbXBvcnQgeyB0b1V0ZjhCeXRlcywgdG9VdGY4U3RyaW5nIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3N0cmluZ3NcIjtcbmltcG9ydCB7IGZldGNoSnNvbiwgcG9sbCB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC93ZWJcIjtcbmltcG9ydCBiZWNoMzIgZnJvbSBcImJlY2gzMlwiO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2xvZ2dlclwiO1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gXCIuL192ZXJzaW9uXCI7XG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyKHZlcnNpb24pO1xuaW1wb3J0IHsgRm9ybWF0dGVyIH0gZnJvbSBcIi4vZm9ybWF0dGVyXCI7XG5jb25zdCBNQVhfQ0NJUF9SRURJUkVDVFMgPSAxMDtcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gRXZlbnQgU2VyaWFsaXplaW5nXG5mdW5jdGlvbiBjaGVja1RvcGljKHRvcGljKSB7XG4gICAgaWYgKHRvcGljID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFwibnVsbFwiO1xuICAgIH1cbiAgICBpZiAoaGV4RGF0YUxlbmd0aCh0b3BpYykgIT09IDMyKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIHRvcGljXCIsIFwidG9waWNcIiwgdG9waWMpO1xuICAgIH1cbiAgICByZXR1cm4gdG9waWMudG9Mb3dlckNhc2UoKTtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZVRvcGljcyh0b3BpY3MpIHtcbiAgICAvLyBSZW1vdmUgdHJhaWxpbmcgbnVsbCBBTkQtdG9waWNzOyB0aGV5IGFyZSByZWR1bmRhbnRcbiAgICB0b3BpY3MgPSB0b3BpY3Muc2xpY2UoKTtcbiAgICB3aGlsZSAodG9waWNzLmxlbmd0aCA+IDAgJiYgdG9waWNzW3RvcGljcy5sZW5ndGggLSAxXSA9PSBudWxsKSB7XG4gICAgICAgIHRvcGljcy5wb3AoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvcGljcy5tYXAoKHRvcGljKSA9PiB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRvcGljKSkge1xuICAgICAgICAgICAgLy8gT25seSB0cmFjayB1bmlxdWUgT1ItdG9waWNzXG4gICAgICAgICAgICBjb25zdCB1bmlxdWUgPSB7fTtcbiAgICAgICAgICAgIHRvcGljLmZvckVhY2goKHRvcGljKSA9PiB7XG4gICAgICAgICAgICAgICAgdW5pcXVlW2NoZWNrVG9waWModG9waWMpXSA9IHRydWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIFRoZSBvcmRlciBvZiBPUi10b3BpY3MgZG9lcyBub3QgbWF0dGVyXG4gICAgICAgICAgICBjb25zdCBzb3J0ZWQgPSBPYmplY3Qua2V5cyh1bmlxdWUpO1xuICAgICAgICAgICAgc29ydGVkLnNvcnQoKTtcbiAgICAgICAgICAgIHJldHVybiBzb3J0ZWQuam9pbihcInxcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY2hlY2tUb3BpYyh0b3BpYyk7XG4gICAgICAgIH1cbiAgICB9KS5qb2luKFwiJlwiKTtcbn1cbmZ1bmN0aW9uIGRlc2VyaWFsaXplVG9waWNzKGRhdGEpIHtcbiAgICBpZiAoZGF0YSA9PT0gXCJcIikge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHJldHVybiBkYXRhLnNwbGl0KC8mL2cpLm1hcCgodG9waWMpID0+IHtcbiAgICAgICAgaWYgKHRvcGljID09PSBcIlwiKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29tcHMgPSB0b3BpYy5zcGxpdChcInxcIikubWFwKCh0b3BpYykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuICgodG9waWMgPT09IFwibnVsbFwiKSA/IG51bGwgOiB0b3BpYyk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gKChjb21wcy5sZW5ndGggPT09IDEpID8gY29tcHNbMF0gOiBjb21wcyk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBnZXRFdmVudFRhZyhldmVudE5hbWUpIHtcbiAgICBpZiAodHlwZW9mIChldmVudE5hbWUpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGV2ZW50TmFtZSA9IGV2ZW50TmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoaGV4RGF0YUxlbmd0aChldmVudE5hbWUpID09PSAzMikge1xuICAgICAgICAgICAgcmV0dXJuIFwidHg6XCIgKyBldmVudE5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2ZW50TmFtZS5pbmRleE9mKFwiOlwiKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBldmVudE5hbWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShldmVudE5hbWUpKSB7XG4gICAgICAgIHJldHVybiBcImZpbHRlcjoqOlwiICsgc2VyaWFsaXplVG9waWNzKGV2ZW50TmFtZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKEZvcmtFdmVudC5pc0ZvcmtFdmVudChldmVudE5hbWUpKSB7XG4gICAgICAgIGxvZ2dlci53YXJuKFwibm90IGltcGxlbWVudGVkXCIpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub3QgaW1wbGVtZW50ZWRcIik7XG4gICAgfVxuICAgIGVsc2UgaWYgKGV2ZW50TmFtZSAmJiB0eXBlb2YgKGV2ZW50TmFtZSkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgcmV0dXJuIFwiZmlsdGVyOlwiICsgKGV2ZW50TmFtZS5hZGRyZXNzIHx8IFwiKlwiKSArIFwiOlwiICsgc2VyaWFsaXplVG9waWNzKGV2ZW50TmFtZS50b3BpY3MgfHwgW10pO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGV2ZW50IC0gXCIgKyBldmVudE5hbWUpO1xufVxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBIZWxwZXIgT2JqZWN0XG5mdW5jdGlvbiBnZXRUaW1lKCkge1xuICAgIHJldHVybiAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xufVxuZnVuY3Rpb24gc3RhbGwoZHVyYXRpb24pIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgc2V0VGltZW91dChyZXNvbHZlLCBkdXJhdGlvbik7XG4gICAgfSk7XG59XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFByb3ZpZGVyIE9iamVjdFxuLyoqXG4gKiAgRXZlbnRUeXBlXG4gKiAgIC0gXCJibG9ja1wiXG4gKiAgIC0gXCJwb2xsXCJcbiAqICAgLSBcImRpZFBvbGxcIlxuICogICAtIFwicGVuZGluZ1wiXG4gKiAgIC0gXCJlcnJvclwiXG4gKiAgIC0gXCJuZXR3b3JrXCJcbiAqICAgLSBmaWx0ZXJcbiAqICAgLSB0b3BpY3MgYXJyYXlcbiAqICAgLSB0cmFuc2FjdGlvbiBoYXNoXG4gKi9cbmNvbnN0IFBvbGxhYmxlRXZlbnRzID0gW1wiYmxvY2tcIiwgXCJuZXR3b3JrXCIsIFwicGVuZGluZ1wiLCBcInBvbGxcIl07XG5leHBvcnQgY2xhc3MgRXZlbnQge1xuICAgIGNvbnN0cnVjdG9yKHRhZywgbGlzdGVuZXIsIG9uY2UpIHtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJ0YWdcIiwgdGFnKTtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJsaXN0ZW5lclwiLCBsaXN0ZW5lcik7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwib25jZVwiLCBvbmNlKTtcbiAgICAgICAgdGhpcy5fbGFzdEJsb2NrTnVtYmVyID0gLTI7XG4gICAgICAgIHRoaXMuX2luZmxpZ2h0ID0gZmFsc2U7XG4gICAgfVxuICAgIGdldCBldmVudCgpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJ0eFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmhhc2g7XG4gICAgICAgICAgICBjYXNlIFwiZmlsdGVyXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnRhZztcbiAgICB9XG4gICAgZ2V0IHR5cGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRhZy5zcGxpdChcIjpcIilbMF07XG4gICAgfVxuICAgIGdldCBoYXNoKCkge1xuICAgICAgICBjb25zdCBjb21wcyA9IHRoaXMudGFnLnNwbGl0KFwiOlwiKTtcbiAgICAgICAgaWYgKGNvbXBzWzBdICE9PSBcInR4XCIpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb21wc1sxXTtcbiAgICB9XG4gICAgZ2V0IGZpbHRlcigpIHtcbiAgICAgICAgY29uc3QgY29tcHMgPSB0aGlzLnRhZy5zcGxpdChcIjpcIik7XG4gICAgICAgIGlmIChjb21wc1swXSAhPT0gXCJmaWx0ZXJcIikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IGNvbXBzWzFdO1xuICAgICAgICBjb25zdCB0b3BpY3MgPSBkZXNlcmlhbGl6ZVRvcGljcyhjb21wc1syXSk7XG4gICAgICAgIGNvbnN0IGZpbHRlciA9IHt9O1xuICAgICAgICBpZiAodG9waWNzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGZpbHRlci50b3BpY3MgPSB0b3BpY3M7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFkZHJlc3MgJiYgYWRkcmVzcyAhPT0gXCIqXCIpIHtcbiAgICAgICAgICAgIGZpbHRlci5hZGRyZXNzID0gYWRkcmVzcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmlsdGVyO1xuICAgIH1cbiAgICBwb2xsYWJsZSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnRhZy5pbmRleE9mKFwiOlwiKSA+PSAwIHx8IFBvbGxhYmxlRXZlbnRzLmluZGV4T2YodGhpcy50YWcpID49IDApO1xuICAgIH1cbn1cbjtcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zYXRvc2hpbGFicy9zbGlwcy9ibG9iL21hc3Rlci9zbGlwLTAwNDQubWRcbmNvbnN0IGNvaW5JbmZvcyA9IHtcbiAgICBcIjBcIjogeyBzeW1ib2w6IFwiYnRjXCIsIHAycGtoOiAweDAwLCBwMnNoOiAweDA1LCBwcmVmaXg6IFwiYmNcIiB9LFxuICAgIFwiMlwiOiB7IHN5bWJvbDogXCJsdGNcIiwgcDJwa2g6IDB4MzAsIHAyc2g6IDB4MzIsIHByZWZpeDogXCJsdGNcIiB9LFxuICAgIFwiM1wiOiB7IHN5bWJvbDogXCJkb2dlXCIsIHAycGtoOiAweDFlLCBwMnNoOiAweDE2IH0sXG4gICAgXCI2MFwiOiB7IHN5bWJvbDogXCJldGhcIiwgaWxrOiBcImV0aFwiIH0sXG4gICAgXCI2MVwiOiB7IHN5bWJvbDogXCJldGNcIiwgaWxrOiBcImV0aFwiIH0sXG4gICAgXCI3MDBcIjogeyBzeW1ib2w6IFwieGRhaVwiLCBpbGs6IFwiZXRoXCIgfSxcbn07XG5mdW5jdGlvbiBieXRlczMyaWZ5KHZhbHVlKSB7XG4gICAgcmV0dXJuIGhleFplcm9QYWQoQmlnTnVtYmVyLmZyb20odmFsdWUpLnRvSGV4U3RyaW5nKCksIDMyKTtcbn1cbi8vIENvbXB1dGUgdGhlIEJhc2U1OENoZWNrIGVuY29kZWQgZGF0YSAoY2hlY2tzdW0gaXMgZmlyc3QgNCBieXRlcyBvZiBzaGEyNTZkKVxuZnVuY3Rpb24gYmFzZTU4RW5jb2RlKGRhdGEpIHtcbiAgICByZXR1cm4gQmFzZTU4LmVuY29kZShjb25jYXQoW2RhdGEsIGhleERhdGFTbGljZShzaGEyNTYoc2hhMjU2KGRhdGEpKSwgMCwgNCldKSk7XG59XG5jb25zdCBtYXRjaGVySXBmcyA9IG5ldyBSZWdFeHAoXCJeKGlwZnMpOi9cXC8oLiopJFwiLCBcImlcIik7XG5jb25zdCBtYXRjaGVycyA9IFtcbiAgICBuZXcgUmVnRXhwKFwiXihodHRwcyk6L1xcLyguKikkXCIsIFwiaVwiKSxcbiAgICBuZXcgUmVnRXhwKFwiXihkYXRhKTooLiopJFwiLCBcImlcIiksXG4gICAgbWF0Y2hlcklwZnMsXG4gICAgbmV3IFJlZ0V4cChcIl5laXAxNTU6WzAtOV0rLyhlcmNbMC05XSspOiguKikkXCIsIFwiaVwiKSxcbl07XG5mdW5jdGlvbiBfcGFyc2VTdHJpbmcocmVzdWx0LCBzdGFydCkge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB0b1V0ZjhTdHJpbmcoX3BhcnNlQnl0ZXMocmVzdWx0LCBzdGFydCkpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gX3BhcnNlQnl0ZXMocmVzdWx0LCBzdGFydCkge1xuICAgIGlmIChyZXN1bHQgPT09IFwiMHhcIikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3Qgb2Zmc2V0ID0gQmlnTnVtYmVyLmZyb20oaGV4RGF0YVNsaWNlKHJlc3VsdCwgc3RhcnQsIHN0YXJ0ICsgMzIpKS50b051bWJlcigpO1xuICAgIGNvbnN0IGxlbmd0aCA9IEJpZ051bWJlci5mcm9tKGhleERhdGFTbGljZShyZXN1bHQsIG9mZnNldCwgb2Zmc2V0ICsgMzIpKS50b051bWJlcigpO1xuICAgIHJldHVybiBoZXhEYXRhU2xpY2UocmVzdWx0LCBvZmZzZXQgKyAzMiwgb2Zmc2V0ICsgMzIgKyBsZW5ndGgpO1xufVxuLy8gVHJpbSBvZmYgdGhlIGlwZnM6Ly8gcHJlZml4IGFuZCByZXR1cm4gdGhlIGRlZmF1bHQgZ2F0ZXdheSBVUkxcbmZ1bmN0aW9uIGdldElwZnNMaW5rKGxpbmspIHtcbiAgICBpZiAobGluay5tYXRjaCgvXmlwZnM6XFwvXFwvaXBmc1xcLy9pKSkge1xuICAgICAgICBsaW5rID0gbGluay5zdWJzdHJpbmcoMTIpO1xuICAgIH1cbiAgICBlbHNlIGlmIChsaW5rLm1hdGNoKC9eaXBmczpcXC9cXC8vaSkpIHtcbiAgICAgICAgbGluayA9IGxpbmsuc3Vic3RyaW5nKDcpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInVuc3VwcG9ydGVkIElQRlMgZm9ybWF0XCIsIFwibGlua1wiLCBsaW5rKTtcbiAgICB9XG4gICAgcmV0dXJuIGBodHRwczovXFwvZ2F0ZXdheS5pcGZzLmlvL2lwZnMvJHtsaW5rfWA7XG59XG5mdW5jdGlvbiBudW1QYWQodmFsdWUpIHtcbiAgICBjb25zdCByZXN1bHQgPSBhcnJheWlmeSh2YWx1ZSk7XG4gICAgaWYgKHJlc3VsdC5sZW5ndGggPiAzMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnRlcm5hbDsgc2hvdWxkIG5vdCBoYXBwZW5cIik7XG4gICAgfVxuICAgIGNvbnN0IHBhZGRlZCA9IG5ldyBVaW50OEFycmF5KDMyKTtcbiAgICBwYWRkZWQuc2V0KHJlc3VsdCwgMzIgLSByZXN1bHQubGVuZ3RoKTtcbiAgICByZXR1cm4gcGFkZGVkO1xufVxuZnVuY3Rpb24gYnl0ZXNQYWQodmFsdWUpIHtcbiAgICBpZiAoKHZhbHVlLmxlbmd0aCAlIDMyKSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KE1hdGguY2VpbCh2YWx1ZS5sZW5ndGggLyAzMikgKiAzMik7XG4gICAgcmVzdWx0LnNldCh2YWx1ZSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8vIEFCSSBFbmNvZGVzIGEgc2VyaWVzIG9mIChieXRlcywgYnl0ZXMsIC4uLilcbmZ1bmN0aW9uIGVuY29kZUJ5dGVzKGRhdGFzKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgbGV0IGJ5dGVDb3VudCA9IDA7XG4gICAgLy8gQWRkIHBsYWNlLWhvbGRlcnMgZm9yIHBvaW50ZXJzIGFzIHdlIGFkZCBpdGVtc1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0LnB1c2gobnVsbCk7XG4gICAgICAgIGJ5dGVDb3VudCArPSAzMjtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBkYXRhID0gYXJyYXlpZnkoZGF0YXNbaV0pO1xuICAgICAgICAvLyBVcGRhdGUgdGhlIGJ5dGVzIG9mZnNldFxuICAgICAgICByZXN1bHRbaV0gPSBudW1QYWQoYnl0ZUNvdW50KTtcbiAgICAgICAgLy8gVGhlIGxlbmd0aCBhbmQgcGFkZGVkIHZhbHVlIG9mIGRhdGFcbiAgICAgICAgcmVzdWx0LnB1c2gobnVtUGFkKGRhdGEubGVuZ3RoKSk7XG4gICAgICAgIHJlc3VsdC5wdXNoKGJ5dGVzUGFkKGRhdGEpKTtcbiAgICAgICAgYnl0ZUNvdW50ICs9IDMyICsgTWF0aC5jZWlsKGRhdGEubGVuZ3RoIC8gMzIpICogMzI7XG4gICAgfVxuICAgIHJldHVybiBoZXhDb25jYXQocmVzdWx0KTtcbn1cbmV4cG9ydCBjbGFzcyBSZXNvbHZlciB7XG4gICAgLy8gVGhlIHJlc29sdmVkQWRkcmVzcyBpcyBvbmx5IGZvciBjcmVhdGluZyBhIFJldmVyc2VMb29rdXAgcmVzb2x2ZXJcbiAgICBjb25zdHJ1Y3Rvcihwcm92aWRlciwgYWRkcmVzcywgbmFtZSwgcmVzb2x2ZWRBZGRyZXNzKSB7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwicHJvdmlkZXJcIiwgcHJvdmlkZXIpO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcIm5hbWVcIiwgbmFtZSk7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiYWRkcmVzc1wiLCBwcm92aWRlci5mb3JtYXR0ZXIuYWRkcmVzcyhhZGRyZXNzKSk7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiX3Jlc29sdmVkQWRkcmVzc1wiLCByZXNvbHZlZEFkZHJlc3MpO1xuICAgIH1cbiAgICBzdXBwb3J0c1dpbGRjYXJkKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3N1cHBvcnRzRWlwMjU0NCkge1xuICAgICAgICAgICAgLy8gc3VwcG9ydHNJbnRlcmZhY2UoYnl0ZXM0ID0gc2VsZWN0b3IoXCJyZXNvbHZlKGJ5dGVzLGJ5dGVzKVwiKSlcbiAgICAgICAgICAgIHRoaXMuX3N1cHBvcnRzRWlwMjU0NCA9IHRoaXMucHJvdmlkZXIuY2FsbCh7XG4gICAgICAgICAgICAgICAgdG86IHRoaXMuYWRkcmVzcyxcbiAgICAgICAgICAgICAgICBkYXRhOiBcIjB4MDFmZmM5YTc5MDYxYjkyMzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCJcbiAgICAgICAgICAgIH0pLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBCaWdOdW1iZXIuZnJvbShyZXN1bHQpLmVxKDEpO1xuICAgICAgICAgICAgfSkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09IExvZ2dlci5lcnJvcnMuQ0FMTF9FWENFUFRJT04pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBSZXRocm93IHRoZSBlcnJvcjogbGluayBpcyBkb3duLCBldGMuIExldCBmdXR1cmUgYXR0ZW1wdHMgcmV0cnkuXG4gICAgICAgICAgICAgICAgdGhpcy5fc3VwcG9ydHNFaXAyNTQ0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9zdXBwb3J0c0VpcDI1NDQ7XG4gICAgfVxuICAgIF9mZXRjaChzZWxlY3RvciwgcGFyYW1ldGVycykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgLy8gZS5nLiBrZWNjYWsyNTYoXCJhZGRyKGJ5dGVzMzIsdWludDI1NilcIilcbiAgICAgICAgICAgIGNvbnN0IHR4ID0ge1xuICAgICAgICAgICAgICAgIHRvOiB0aGlzLmFkZHJlc3MsXG4gICAgICAgICAgICAgICAgY2NpcFJlYWRFbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgIGRhdGE6IGhleENvbmNhdChbc2VsZWN0b3IsIG5hbWVoYXNoKHRoaXMubmFtZSksIChwYXJhbWV0ZXJzIHx8IFwiMHhcIildKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIFdpbGRjYXJkIHN1cHBvcnQ7IHVzZSBFSVAtMjU0NCB0byByZXNvbHZlIHRoZSByZXF1ZXN0XG4gICAgICAgICAgICBsZXQgcGFyc2VCeXRlcyA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHlpZWxkIHRoaXMuc3VwcG9ydHNXaWxkY2FyZCgpKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VCeXRlcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgLy8gc2VsZWN0b3IoXCJyZXNvbHZlKGJ5dGVzLGJ5dGVzKVwiKVxuICAgICAgICAgICAgICAgIHR4LmRhdGEgPSBoZXhDb25jYXQoW1wiMHg5MDYxYjkyM1wiLCBlbmNvZGVCeXRlcyhbZG5zRW5jb2RlKHRoaXMubmFtZSksIHR4LmRhdGFdKV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0geWllbGQgdGhpcy5wcm92aWRlci5jYWxsKHR4KTtcbiAgICAgICAgICAgICAgICBpZiAoKGFycmF5aWZ5KHJlc3VsdCkubGVuZ3RoICUgMzIpID09PSA0KSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwicmVzb2x2ZXIgdGhyZXcgZXJyb3JcIiwgTG9nZ2VyLmVycm9ycy5DQUxMX0VYQ0VQVElPTiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb246IHR4LCBkYXRhOiByZXN1bHRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwYXJzZUJ5dGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IF9wYXJzZUJ5dGVzKHJlc3VsdCwgMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IuY29kZSA9PT0gTG9nZ2VyLmVycm9ycy5DQUxMX0VYQ0VQVElPTikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfZmV0Y2hCeXRlcyhzZWxlY3RvciwgcGFyYW1ldGVycykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geWllbGQgdGhpcy5fZmV0Y2goc2VsZWN0b3IsIHBhcmFtZXRlcnMpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9wYXJzZUJ5dGVzKHJlc3VsdCwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9nZXRBZGRyZXNzKGNvaW5UeXBlLCBoZXhCeXRlcykge1xuICAgICAgICBjb25zdCBjb2luSW5mbyA9IGNvaW5JbmZvc1tTdHJpbmcoY29pblR5cGUpXTtcbiAgICAgICAgaWYgKGNvaW5JbmZvID09IG51bGwpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKGB1bnN1cHBvcnRlZCBjb2luIHR5cGU6ICR7Y29pblR5cGV9YCwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IGBnZXRBZGRyZXNzKCR7Y29pblR5cGV9KWBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb2luSW5mby5pbGsgPT09IFwiZXRoXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3ZpZGVyLmZvcm1hdHRlci5hZGRyZXNzKGhleEJ5dGVzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBieXRlcyA9IGFycmF5aWZ5KGhleEJ5dGVzKTtcbiAgICAgICAgLy8gUDJQS0g6IE9QX0RVUCBPUF9IQVNIMTYwIDxwdWJLZXlIYXNoPiBPUF9FUVVBTFZFUklGWSBPUF9DSEVDS1NJR1xuICAgICAgICBpZiAoY29pbkluZm8ucDJwa2ggIT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgcDJwa2ggPSBoZXhCeXRlcy5tYXRjaCgvXjB4NzZhOShbMC05YS1mXVswLTlhLWZdKShbMC05YS1mXSopODhhYyQvKTtcbiAgICAgICAgICAgIGlmIChwMnBraCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IHBhcnNlSW50KHAycGtoWzFdLCAxNik7XG4gICAgICAgICAgICAgICAgaWYgKHAycGtoWzJdLmxlbmd0aCA9PT0gbGVuZ3RoICogMiAmJiBsZW5ndGggPj0gMSAmJiBsZW5ndGggPD0gNzUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJhc2U1OEVuY29kZShjb25jYXQoW1tjb2luSW5mby5wMnBraF0sIChcIjB4XCIgKyBwMnBraFsyXSldKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFAyU0g6IE9QX0hBU0gxNjAgPHNjcmlwdEhhc2g+IE9QX0VRVUFMXG4gICAgICAgIGlmIChjb2luSW5mby5wMnNoICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHAyc2ggPSBoZXhCeXRlcy5tYXRjaCgvXjB4YTkoWzAtOWEtZl1bMC05YS1mXSkoWzAtOWEtZl0qKTg3JC8pO1xuICAgICAgICAgICAgaWYgKHAyc2gpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsZW5ndGggPSBwYXJzZUludChwMnNoWzFdLCAxNik7XG4gICAgICAgICAgICAgICAgaWYgKHAyc2hbMl0ubGVuZ3RoID09PSBsZW5ndGggKiAyICYmIGxlbmd0aCA+PSAxICYmIGxlbmd0aCA8PSA3NSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmFzZTU4RW5jb2RlKGNvbmNhdChbW2NvaW5JbmZvLnAyc2hdLCAoXCIweFwiICsgcDJzaFsyXSldKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEJlY2gzMlxuICAgICAgICBpZiAoY29pbkluZm8ucHJlZml4ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IGJ5dGVzWzFdO1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW4vYmlwcy9ibG9iL21hc3Rlci9iaXAtMDE0MS5tZWRpYXdpa2kjd2l0bmVzcy1wcm9ncmFtXG4gICAgICAgICAgICBsZXQgdmVyc2lvbiA9IGJ5dGVzWzBdO1xuICAgICAgICAgICAgaWYgKHZlcnNpb24gPT09IDB4MDApIHtcbiAgICAgICAgICAgICAgICBpZiAobGVuZ3RoICE9PSAyMCAmJiBsZW5ndGggIT09IDMyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZlcnNpb24gPSAtMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2ZXJzaW9uID0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmVyc2lvbiA+PSAwICYmIGJ5dGVzLmxlbmd0aCA9PT0gMiArIGxlbmd0aCAmJiBsZW5ndGggPj0gMSAmJiBsZW5ndGggPD0gNzUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB3b3JkcyA9IGJlY2gzMi50b1dvcmRzKGJ5dGVzLnNsaWNlKDIpKTtcbiAgICAgICAgICAgICAgICB3b3Jkcy51bnNoaWZ0KHZlcnNpb24pO1xuICAgICAgICAgICAgICAgIHJldHVybiBiZWNoMzIuZW5jb2RlKGNvaW5JbmZvLnByZWZpeCwgd29yZHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBnZXRBZGRyZXNzKGNvaW5UeXBlKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAoY29pblR5cGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvaW5UeXBlID0gNjA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiBFdGhlcmV1bSwgdXNlIHRoZSBzdGFuZGFyZCBgYWRkcihieXRlczMyKWBcbiAgICAgICAgICAgIGlmIChjb2luVHlwZSA9PT0gNjApIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAvLyBrZWNjYWsyNTYoXCJhZGRyKGJ5dGVzMzIpXCIpXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHlpZWxkIHRoaXMuX2ZldGNoKFwiMHgzYjNiNTdkZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gTm8gYWRkcmVzc1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0ID09PSBcIjB4XCIgfHwgcmVzdWx0ID09PSBIYXNoWmVybykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXIuZm9ybWF0dGVyLmNhbGxBZGRyZXNzKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IuY29kZSA9PT0gTG9nZ2VyLmVycm9ycy5DQUxMX0VYQ0VQVElPTikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8ga2VjY2FrMjU2KFwiYWRkcihieXRlczMyLHVpbnQyNTZcIilcbiAgICAgICAgICAgIGNvbnN0IGhleEJ5dGVzID0geWllbGQgdGhpcy5fZmV0Y2hCeXRlcyhcIjB4ZjFjYjdlMDZcIiwgYnl0ZXMzMmlmeShjb2luVHlwZSkpO1xuICAgICAgICAgICAgLy8gTm8gYWRkcmVzc1xuICAgICAgICAgICAgaWYgKGhleEJ5dGVzID09IG51bGwgfHwgaGV4Qnl0ZXMgPT09IFwiMHhcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgYWRkcmVzc1xuICAgICAgICAgICAgY29uc3QgYWRkcmVzcyA9IHRoaXMuX2dldEFkZHJlc3MoY29pblR5cGUsIGhleEJ5dGVzKTtcbiAgICAgICAgICAgIGlmIChhZGRyZXNzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihgaW52YWxpZCBvciB1bnN1cHBvcnRlZCBjb2luIGRhdGFgLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IGBnZXRBZGRyZXNzKCR7Y29pblR5cGV9KWAsXG4gICAgICAgICAgICAgICAgICAgIGNvaW5UeXBlOiBjb2luVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogaGV4Qnl0ZXNcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhZGRyZXNzO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0QXZhdGFyKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgbGlua2FnZSA9IFt7IHR5cGU6IFwibmFtZVwiLCBjb250ZW50OiB0aGlzLm5hbWUgfV07XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vIHRlc3QgZGF0YSBmb3IgcmljbW9vLmV0aFxuICAgICAgICAgICAgICAgIC8vY29uc3QgYXZhdGFyID0gXCJlaXAxNTU6MS9lcmM3MjE6MHgyNjUzODVjN2Y0MTMyMjI4QTBkNTRFQjFBOWU3NDYwYjkxYzBjQzY4LzI5MjMzXCI7XG4gICAgICAgICAgICAgICAgY29uc3QgYXZhdGFyID0geWllbGQgdGhpcy5nZXRUZXh0KFwiYXZhdGFyXCIpO1xuICAgICAgICAgICAgICAgIGlmIChhdmF0YXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXRjaGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXRjaCA9IGF2YXRhci5tYXRjaChtYXRjaGVyc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzY2hlbWUgPSBtYXRjaFsxXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHNjaGVtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImh0dHBzXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJ1cmxcIiwgY29udGVudDogYXZhdGFyIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGxpbmthZ2UsIHVybDogYXZhdGFyIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZGF0YVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwiZGF0YVwiLCBjb250ZW50OiBhdmF0YXIgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgbGlua2FnZSwgdXJsOiBhdmF0YXIgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJpcGZzXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJpcGZzXCIsIGNvbnRlbnQ6IGF2YXRhciB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBsaW5rYWdlLCB1cmw6IGdldElwZnNMaW5rKGF2YXRhcikgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlcmM3MjFcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlcmMxMTU1XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEZXBlbmRpbmcgb24gdGhlIEVSQyB0eXBlLCB1c2UgdG9rZW5VUkkodWludDI1Nikgb3IgdXJsKHVpbnQyNTYpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSAoc2NoZW1lID09PSBcImVyYzcyMVwiKSA/IFwiMHhjODdiNTZkZFwiIDogXCIweDBlODkzNDFjXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogc2NoZW1lLCBjb250ZW50OiBhdmF0YXIgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIG93bmVyIG9mIHRoaXMgbmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG93bmVyID0gKHRoaXMuX3Jlc29sdmVkQWRkcmVzcyB8fCAoeWllbGQgdGhpcy5nZXRBZGRyZXNzKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb21wcyA9IChtYXRjaFsyXSB8fCBcIlwiKS5zcGxpdChcIi9cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBzLmxlbmd0aCAhPT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYWRkciA9IHlpZWxkIHRoaXMucHJvdmlkZXIuZm9ybWF0dGVyLmFkZHJlc3MoY29tcHNbMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRva2VuSWQgPSBoZXhaZXJvUGFkKEJpZ051bWJlci5mcm9tKGNvbXBzWzFdKS50b0hleFN0cmluZygpLCAzMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgdGhhdCB0aGlzIGFjY291bnQgb3ducyB0aGUgdG9rZW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2NoZW1lID09PSBcImVyYzcyMVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG93bmVyT2YodWludDI1NiB0b2tlbklkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0b2tlbk93bmVyID0gdGhpcy5wcm92aWRlci5mb3JtYXR0ZXIuY2FsbEFkZHJlc3MoeWllbGQgdGhpcy5wcm92aWRlci5jYWxsKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvOiBhZGRyLCBkYXRhOiBoZXhDb25jYXQoW1wiMHg2MzUyMjExZVwiLCB0b2tlbklkXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3duZXIgIT09IHRva2VuT3duZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwib3duZXJcIiwgY29udGVudDogdG9rZW5Pd25lciB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc2NoZW1lID09PSBcImVyYzExNTVcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBiYWxhbmNlT2YoYWRkcmVzcyBvd25lciwgdWludDI1NiB0b2tlbklkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBiYWxhbmNlID0gQmlnTnVtYmVyLmZyb20oeWllbGQgdGhpcy5wcm92aWRlci5jYWxsKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvOiBhZGRyLCBkYXRhOiBoZXhDb25jYXQoW1wiMHgwMGZkZDU4ZVwiLCBoZXhaZXJvUGFkKG93bmVyLCAzMiksIHRva2VuSWRdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiYWxhbmNlLmlzWmVybygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcImJhbGFuY2VcIiwgY29udGVudDogYmFsYW5jZS50b1N0cmluZygpIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDYWxsIHRoZSB0b2tlbiBjb250cmFjdCBmb3IgdGhlIG1ldGFkYXRhIFVSTFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHR4ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bzogdGhpcy5wcm92aWRlci5mb3JtYXR0ZXIuYWRkcmVzcyhjb21wc1swXSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGhleENvbmNhdChbc2VsZWN0b3IsIHRva2VuSWRdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG1ldGFkYXRhVXJsID0gX3BhcnNlU3RyaW5nKHlpZWxkIHRoaXMucHJvdmlkZXIuY2FsbCh0eCksIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZXRhZGF0YVVybCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcIm1ldGFkYXRhLXVybC1iYXNlXCIsIGNvbnRlbnQ6IG1ldGFkYXRhVXJsIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVSQy0xMTU1IGFsbG93cyBhIGdlbmVyaWMge2lkfSBpbiB0aGUgVVJMXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNjaGVtZSA9PT0gXCJlcmMxMTU1XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGFVcmwgPSBtZXRhZGF0YVVybC5yZXBsYWNlKFwie2lkfVwiLCB0b2tlbklkLnN1YnN0cmluZygyKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwibWV0YWRhdGEtdXJsLWV4cGFuZGVkXCIsIGNvbnRlbnQ6IG1ldGFkYXRhVXJsIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUcmFuc2Zvcm0gSVBGUyBtZXRhZGF0YSBsaW5rc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZXRhZGF0YVVybC5tYXRjaCgvXmlwZnM6L2kpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhVXJsID0gZ2V0SXBmc0xpbmsobWV0YWRhdGFVcmwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcIm1ldGFkYXRhLXVybFwiLCBjb250ZW50OiBtZXRhZGF0YVVybCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIHRva2VuIG1ldGFkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWV0YWRhdGEgPSB5aWVsZCBmZXRjaEpzb24obWV0YWRhdGFVcmwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwibWV0YWRhdGFcIiwgY29udGVudDogSlNPTi5zdHJpbmdpZnkobWV0YWRhdGEpIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFB1bGwgdGhlIGltYWdlIFVSTCBvdXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgaW1hZ2VVcmwgPSBtZXRhZGF0YS5pbWFnZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChpbWFnZVVybCkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbWFnZVVybC5tYXRjaCgvXihodHRwczpcXC9cXC98ZGF0YTopL2kpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFsbG93XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUcmFuc2Zvcm0gSVBGUyBsaW5rIHRvIGdhdGV3YXlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaXBmcyA9IGltYWdlVXJsLm1hdGNoKG1hdGNoZXJJcGZzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlwZnMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJ1cmwtaXBmc1wiLCBjb250ZW50OiBpbWFnZVVybCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2VVcmwgPSBnZXRJcGZzTGluayhpbWFnZVVybCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwidXJsXCIsIGNvbnRlbnQ6IGltYWdlVXJsIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGxpbmthZ2UsIHVybDogaW1hZ2VVcmwgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldENvbnRlbnRIYXNoKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgLy8ga2VjY2FrMjU2KFwiY29udGVudGhhc2goKVwiKVxuICAgICAgICAgICAgY29uc3QgaGV4Qnl0ZXMgPSB5aWVsZCB0aGlzLl9mZXRjaEJ5dGVzKFwiMHhiYzFjNThkMVwiKTtcbiAgICAgICAgICAgIC8vIE5vIGNvbnRlbnRoYXNoXG4gICAgICAgICAgICBpZiAoaGV4Qnl0ZXMgPT0gbnVsbCB8fCBoZXhCeXRlcyA9PT0gXCIweFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJUEZTIChDSUQ6IDEsIFR5cGU6IERBRy1QQilcbiAgICAgICAgICAgIGNvbnN0IGlwZnMgPSBoZXhCeXRlcy5tYXRjaCgvXjB4ZTMwMTAxNzAoKFswLTlhLWZdWzAtOWEtZl0pKFswLTlhLWZdWzAtOWEtZl0pKFswLTlhLWZdKikpJC8pO1xuICAgICAgICAgICAgaWYgKGlwZnMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsZW5ndGggPSBwYXJzZUludChpcGZzWzNdLCAxNik7XG4gICAgICAgICAgICAgICAgaWYgKGlwZnNbNF0ubGVuZ3RoID09PSBsZW5ndGggKiAyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImlwZnM6L1xcL1wiICsgQmFzZTU4LmVuY29kZShcIjB4XCIgKyBpcGZzWzFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJUE5TIChDSUQ6IDEsIFR5cGU6IGxpYnAycC1rZXkpXG4gICAgICAgICAgICBjb25zdCBpcG5zID0gaGV4Qnl0ZXMubWF0Y2goL14weGU1MDEwMTcyKChbMC05YS1mXVswLTlhLWZdKShbMC05YS1mXVswLTlhLWZdKShbMC05YS1mXSopKSQvKTtcbiAgICAgICAgICAgIGlmIChpcG5zKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gcGFyc2VJbnQoaXBuc1szXSwgMTYpO1xuICAgICAgICAgICAgICAgIGlmIChpcG5zWzRdLmxlbmd0aCA9PT0gbGVuZ3RoICogMikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJpcG5zOi9cXC9cIiArIEJhc2U1OC5lbmNvZGUoXCIweFwiICsgaXBuc1sxXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU3dhcm0gKENJRDogMSwgVHlwZTogc3dhcm0tbWFuaWZlc3Q7IGhhc2gvbGVuZ3RoIGhhcmQtY29kZWQgdG8ga2VjY2FrMjU2LzMyKVxuICAgICAgICAgICAgY29uc3Qgc3dhcm0gPSBoZXhCeXRlcy5tYXRjaCgvXjB4ZTQwMTAxZmEwMTFiMjAoWzAtOWEtZl0qKSQvKTtcbiAgICAgICAgICAgIGlmIChzd2FybSkge1xuICAgICAgICAgICAgICAgIGlmIChzd2FybVsxXS5sZW5ndGggPT09ICgzMiAqIDIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImJ6ejovXFwvXCIgKyBzd2FybVsxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBza3luZXQgPSBoZXhCeXRlcy5tYXRjaCgvXjB4OTBiMmM2MDUoWzAtOWEtZl0qKSQvKTtcbiAgICAgICAgICAgIGlmIChza3luZXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2t5bmV0WzFdLmxlbmd0aCA9PT0gKDM0ICogMikpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVVJMIFNhZmUgYmFzZTY0OyBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL3JmYzQ2NDgjc2VjdGlvbi01XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHVybFNhZmUgPSB7IFwiPVwiOiBcIlwiLCBcIitcIjogXCItXCIsIFwiL1wiOiBcIl9cIiB9O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBoYXNoID0gYmFzZTY0RW5jb2RlKFwiMHhcIiArIHNreW5ldFsxXSkucmVwbGFjZSgvWz0rXFwvXS9nLCAoYSkgPT4gKHVybFNhZmVbYV0pKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwic2lhOi9cXC9cIiArIGhhc2g7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0Vycm9yKGBpbnZhbGlkIG9yIHVuc3VwcG9ydGVkIGNvbnRlbnQgaGFzaCBkYXRhYCwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwiZ2V0Q29udGVudEhhc2goKVwiLFxuICAgICAgICAgICAgICAgIGRhdGE6IGhleEJ5dGVzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldFRleHQoa2V5KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAvLyBUaGUga2V5IGVuY29kZWQgYXMgcGFyYW1ldGVyIHRvIGZldGNoQnl0ZXNcbiAgICAgICAgICAgIGxldCBrZXlCeXRlcyA9IHRvVXRmOEJ5dGVzKGtleSk7XG4gICAgICAgICAgICAvLyBUaGUgbm9kZWhhc2ggY29uc3VtZXMgdGhlIGZpcnN0IHNsb3QsIHNvIHRoZSBzdHJpbmcgcG9pbnRlciB0YXJnZXRzXG4gICAgICAgICAgICAvLyBvZmZzZXQgNjQsIHdpdGggdGhlIGxlbmd0aCBhdCBvZmZzZXQgNjQgYW5kIGRhdGEgc3RhcnRpbmcgYXQgb2Zmc2V0IDk2XG4gICAgICAgICAgICBrZXlCeXRlcyA9IGNvbmNhdChbYnl0ZXMzMmlmeSg2NCksIGJ5dGVzMzJpZnkoa2V5Qnl0ZXMubGVuZ3RoKSwga2V5Qnl0ZXNdKTtcbiAgICAgICAgICAgIC8vIFBhZCB0byB3b3JkLXNpemUgKDMyIGJ5dGVzKVxuICAgICAgICAgICAgaWYgKChrZXlCeXRlcy5sZW5ndGggJSAzMikgIT09IDApIHtcbiAgICAgICAgICAgICAgICBrZXlCeXRlcyA9IGNvbmNhdChba2V5Qnl0ZXMsIGhleFplcm9QYWQoXCIweFwiLCAzMiAtIChrZXkubGVuZ3RoICUgMzIpKV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaGV4Qnl0ZXMgPSB5aWVsZCB0aGlzLl9mZXRjaEJ5dGVzKFwiMHg1OWQxZDQzY1wiLCBoZXhsaWZ5KGtleUJ5dGVzKSk7XG4gICAgICAgICAgICBpZiAoaGV4Qnl0ZXMgPT0gbnVsbCB8fCBoZXhCeXRlcyA9PT0gXCIweFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdG9VdGY4U3RyaW5nKGhleEJ5dGVzKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxubGV0IGRlZmF1bHRGb3JtYXR0ZXIgPSBudWxsO1xubGV0IG5leHRQb2xsSWQgPSAxO1xuZXhwb3J0IGNsYXNzIEJhc2VQcm92aWRlciBleHRlbmRzIFByb3ZpZGVyIHtcbiAgICAvKipcbiAgICAgKiAgcmVhZHlcbiAgICAgKlxuICAgICAqICBBIFByb21pc2U8TmV0d29yaz4gdGhhdCByZXNvbHZlcyBvbmx5IG9uY2UgdGhlIHByb3ZpZGVyIGlzIHJlYWR5LlxuICAgICAqXG4gICAgICogIFN1Yi1jbGFzc2VzIHRoYXQgY2FsbCB0aGUgc3VwZXIgd2l0aCBhIG5ldHdvcmsgd2l0aG91dCBhIGNoYWluSWRcbiAgICAgKiAgTVVTVCBzZXQgdGhpcy4gU3RhbmRhcmQgbmFtZWQgbmV0d29ya3MgaGF2ZSBhIGtub3duIGNoYWluSWQuXG4gICAgICpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihuZXR3b3JrKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8vIEV2ZW50cyBiZWluZyBsaXN0ZW5lZCB0b1xuICAgICAgICB0aGlzLl9ldmVudHMgPSBbXTtcbiAgICAgICAgdGhpcy5fZW1pdHRlZCA9IHsgYmxvY2s6IC0yIH07XG4gICAgICAgIHRoaXMuZGlzYWJsZUNjaXBSZWFkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZm9ybWF0dGVyID0gbmV3LnRhcmdldC5nZXRGb3JtYXR0ZXIoKTtcbiAgICAgICAgLy8gSWYgbmV0d29yayBpcyBhbnksIHRoaXMgUHJvdmlkZXIgYWxsb3dzIHRoZSB1bmRlcmx5aW5nXG4gICAgICAgIC8vIG5ldHdvcmsgdG8gY2hhbmdlIGR5bmFtaWNhbGx5LCBhbmQgd2UgYXV0by1kZXRlY3QgdGhlXG4gICAgICAgIC8vIGN1cnJlbnQgbmV0d29ya1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcImFueU5ldHdvcmtcIiwgKG5ldHdvcmsgPT09IFwiYW55XCIpKTtcbiAgICAgICAgaWYgKHRoaXMuYW55TmV0d29yaykge1xuICAgICAgICAgICAgbmV0d29yayA9IHRoaXMuZGV0ZWN0TmV0d29yaygpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXR3b3JrIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgdGhpcy5fbmV0d29ya1Byb21pc2UgPSBuZXR3b3JrO1xuICAgICAgICAgICAgLy8gU3F1YXNoIGFueSBcInVuaGFuZGxlZCBwcm9taXNlXCIgZXJyb3JzOyB0aGF0IGRvIG5vdCBuZWVkIHRvIGJlIGhhbmRsZWRcbiAgICAgICAgICAgIG5ldHdvcmsuY2F0Y2goKGVycm9yKSA9PiB7IH0pO1xuICAgICAgICAgICAgLy8gVHJpZ2dlciBpbml0aWFsIG5ldHdvcmsgc2V0dGluZyAoYXN5bmMpXG4gICAgICAgICAgICB0aGlzLl9yZWFkeSgpLmNhdGNoKChlcnJvcikgPT4geyB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGtub3duTmV0d29yayA9IGdldFN0YXRpYyhuZXcudGFyZ2V0LCBcImdldE5ldHdvcmtcIikobmV0d29yayk7XG4gICAgICAgICAgICBpZiAoa25vd25OZXR3b3JrKSB7XG4gICAgICAgICAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJfbmV0d29ya1wiLCBrbm93bk5ldHdvcmspO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcIm5ldHdvcmtcIiwga25vd25OZXR3b3JrLCBudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIG5ldHdvcmtcIiwgXCJuZXR3b3JrXCIsIG5ldHdvcmspO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX21heEludGVybmFsQmxvY2tOdW1iZXIgPSAtMTAyNDtcbiAgICAgICAgdGhpcy5fbGFzdEJsb2NrTnVtYmVyID0gLTI7XG4gICAgICAgIHRoaXMuX21heEZpbHRlckJsb2NrUmFuZ2UgPSAxMDtcbiAgICAgICAgdGhpcy5fcG9sbGluZ0ludGVydmFsID0gNDAwMDtcbiAgICAgICAgdGhpcy5fZmFzdFF1ZXJ5RGF0ZSA9IDA7XG4gICAgfVxuICAgIF9yZWFkeSgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9uZXR3b3JrID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV0d29yayA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX25ldHdvcmtQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXR3b3JrID0geWllbGQgdGhpcy5fbmV0d29ya1Byb21pc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVHJ5IHRoZSBQcm92aWRlcidzIG5ldHdvcmsgZGV0ZWN0aW9uICh0aGlzIE1VU1QgdGhyb3cgaWYgaXQgY2Fubm90KVxuICAgICAgICAgICAgICAgIGlmIChuZXR3b3JrID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV0d29yayA9IHlpZWxkIHRoaXMuZGV0ZWN0TmV0d29yaygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBUaGlzIHNob3VsZCBuZXZlciBoYXBwZW47IGV2ZXJ5IFByb3ZpZGVyIHN1Yi1jbGFzcyBzaG91bGQgaGF2ZVxuICAgICAgICAgICAgICAgIC8vIHN1Z2dlc3RlZCBhIG5ldHdvcmsgYnkgaGVyZSAob3IgaGF2ZSB0aHJvd24pLlxuICAgICAgICAgICAgICAgIGlmICghbmV0d29yaykge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcIm5vIG5ldHdvcmsgZGV0ZWN0ZWRcIiwgTG9nZ2VyLmVycm9ycy5VTktOT1dOX0VSUk9SLCB7fSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFBvc3NpYmxlIHRoaXMgY2FsbCBzdGFja2VkIHNvIGRvIG5vdCBjYWxsIGRlZmluZVJlYWRPbmx5IGFnYWluXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX25ldHdvcmsgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5hbnlOZXR3b3JrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9uZXR3b3JrID0gbmV0d29yaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiX25ldHdvcmtcIiwgbmV0d29yayk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwibmV0d29ya1wiLCBuZXR3b3JrLCBudWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbmV0d29yaztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIFRoaXMgd2lsbCBhbHdheXMgcmV0dXJuIHRoZSBtb3N0IHJlY2VudGx5IGVzdGFibGlzaGVkIG5ldHdvcmsuXG4gICAgLy8gRm9yIFwiYW55XCIsIHRoaXMgY2FuIGNoYW5nZSAoYSBcIm5ldHdvcmtcIiBldmVudCBpcyBlbWl0dGVkIGJlZm9yZVxuICAgIC8vIGFueSBjaGFuZ2UgaXMgcmVmbGVjdGVkKTsgb3RoZXJ3aXNlIHRoaXMgY2Fubm90IGNoYW5nZVxuICAgIGdldCByZWFkeSgpIHtcbiAgICAgICAgcmV0dXJuIHBvbGwoKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWR5KCkudGhlbigobmV0d29yaykgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXR3b3JrO1xuICAgICAgICAgICAgfSwgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIG5ldHdvcmsgaXNuJ3QgcnVubmluZyB5ZXQsIHdlIHdpbGwgd2FpdFxuICAgICAgICAgICAgICAgIGlmIChlcnJvci5jb2RlID09PSBMb2dnZXIuZXJyb3JzLk5FVFdPUktfRVJST1IgJiYgZXJyb3IuZXZlbnQgPT09IFwibm9OZXR3b3JrXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIEBUT0RPOiBSZW1vdmUgdGhpcyBhbmQganVzdCBjcmVhdGUgYSBzaW5nbGV0b24gZm9ybWF0dGVyXG4gICAgc3RhdGljIGdldEZvcm1hdHRlcigpIHtcbiAgICAgICAgaWYgKGRlZmF1bHRGb3JtYXR0ZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgZGVmYXVsdEZvcm1hdHRlciA9IG5ldyBGb3JtYXR0ZXIoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVmYXVsdEZvcm1hdHRlcjtcbiAgICB9XG4gICAgLy8gQFRPRE86IFJlbW92ZSB0aGlzIGFuZCBqdXN0IHVzZSBnZXROZXR3b3JrXG4gICAgc3RhdGljIGdldE5ldHdvcmsobmV0d29yaykge1xuICAgICAgICByZXR1cm4gZ2V0TmV0d29yaygobmV0d29yayA9PSBudWxsKSA/IFwiaG9tZXN0ZWFkXCIgOiBuZXR3b3JrKTtcbiAgICB9XG4gICAgY2NpcFJlYWRGZXRjaCh0eCwgY2FsbGRhdGEsIHVybHMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRpc2FibGVDY2lwUmVhZCB8fCB1cmxzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc2VuZGVyID0gdHgudG8udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBjYWxsZGF0YS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB1cmxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdXJsID0gdXJsc1tpXTtcbiAgICAgICAgICAgICAgICAvLyBVUkwgZXhwYW5zaW9uXG4gICAgICAgICAgICAgICAgY29uc3QgaHJlZiA9IHVybC5yZXBsYWNlKFwie3NlbmRlcn1cIiwgc2VuZGVyKS5yZXBsYWNlKFwie2RhdGF9XCIsIGRhdGEpO1xuICAgICAgICAgICAgICAgIC8vIElmIG5vIHtkYXRhfSBpcyBwcmVzZW50LCB1c2UgUE9TVDsgb3RoZXJ3aXNlIEdFVFxuICAgICAgICAgICAgICAgIGNvbnN0IGpzb24gPSAodXJsLmluZGV4T2YoXCJ7ZGF0YX1cIikgPj0gMCkgPyBudWxsIDogSlNPTi5zdHJpbmdpZnkoeyBkYXRhLCBzZW5kZXIgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geWllbGQgZmV0Y2hKc29uKHsgdXJsOiBocmVmLCBlcnJvclBhc3NUaHJvdWdoOiB0cnVlIH0sIGpzb24sICh2YWx1ZSwgcmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUuc3RhdHVzID0gcmVzcG9uc2Uuc3RhdHVzQ29kZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0LmRhdGE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IChyZXN1bHQubWVzc2FnZSB8fCBcInVua25vd24gZXJyb3JcIik7XG4gICAgICAgICAgICAgICAgLy8gNHh4IGluZGljYXRlcyB0aGUgcmVzdWx0IGlzIG5vdCBwcmVzZW50OyBzdG9wXG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5zdGF0dXMgPj0gNDAwICYmIHJlc3VsdC5zdGF0dXMgPCA1MDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0Vycm9yKGByZXNwb25zZSBub3QgZm91bmQgZHVyaW5nIENDSVAgZmV0Y2g6ICR7ZXJyb3JNZXNzYWdlfWAsIExvZ2dlci5lcnJvcnMuU0VSVkVSX0VSUk9SLCB7IHVybCwgZXJyb3JNZXNzYWdlIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyA1eHggaW5kaWNhdGVzIHNlcnZlciBpc3N1ZTsgdHJ5IHRoZSBuZXh0IHVybFxuICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZXMucHVzaChlcnJvck1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0Vycm9yKGBlcnJvciBlbmNvdW50ZXJlZCBkdXJpbmcgQ0NJUCBmZXRjaDogJHtlcnJvck1lc3NhZ2VzLm1hcCgobSkgPT4gSlNPTi5zdHJpbmdpZnkobSkpLmpvaW4oXCIsIFwiKX1gLCBMb2dnZXIuZXJyb3JzLlNFUlZFUl9FUlJPUiwge1xuICAgICAgICAgICAgICAgIHVybHMsIGVycm9yTWVzc2FnZXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gRmV0Y2hlcyB0aGUgYmxvY2tOdW1iZXIsIGJ1dCB3aWxsIHJldXNlIGFueSByZXN1bHQgdGhhdCBpcyBsZXNzXG4gICAgLy8gdGhhbiBtYXhBZ2Ugb2xkIG9yIGhhcyBiZWVuIHJlcXVlc3RlZCBzaW5jZSB0aGUgbGFzdCByZXF1ZXN0XG4gICAgX2dldEludGVybmFsQmxvY2tOdW1iZXIobWF4QWdlKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLl9yZWFkeSgpO1xuICAgICAgICAgICAgLy8gQWxsb3dpbmcgc3RhbGUgZGF0YSB1cCB0byBtYXhBZ2Ugb2xkXG4gICAgICAgICAgICBpZiAobWF4QWdlID4gMCkge1xuICAgICAgICAgICAgICAgIC8vIFdoaWxlIHRoZXJlIGFyZSBwZW5kaW5nIGludGVybmFsIGJsb2NrIHJlcXVlc3RzLi4uXG4gICAgICAgICAgICAgICAgd2hpbGUgKHRoaXMuX2ludGVybmFsQmxvY2tOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gLi4uXCJyZW1lbWJlclwiIHdoaWNoIGZldGNoIHdlIHN0YXJ0ZWQgd2l0aFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbnRlcm5hbEJsb2NrTnVtYmVyID0gdGhpcy5faW50ZXJuYWxCbG9ja051bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIHRoZSByZXN1bHQgaXMgbm90IHRvbyBzdGFsZVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geWllbGQgaW50ZXJuYWxCbG9ja051bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoZ2V0VGltZSgpIC0gcmVzdWx0LnJlc3BUaW1lKSA8PSBtYXhBZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0LmJsb2NrTnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVG9vIG9sZDsgZmV0Y2ggYSBuZXcgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGZldGNoIHJlamVjdGVkOyBpZiB3ZSBhcmUgdGhlIGZpcnN0IHRvIGdldCB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlamVjdGlvbiwgZHJvcCB0aHJvdWdoIHNvIHdlIHJlcGxhY2UgaXQgd2l0aCBhIG5ld1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZmV0Y2g7IGFsbCBvdGhlcnMgYmxvY2tlZCB3aWxsIHRoZW4gZ2V0IHRoYXQgZmV0Y2hcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdoaWNoIHdvbid0IG1hdGNoIHRoZSBvbmUgdGhleSBcInJlbWVtYmVyZWRcIiBhbmQgbG9vcFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2ludGVybmFsQmxvY2tOdW1iZXIgPT09IGludGVybmFsQmxvY2tOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlcVRpbWUgPSBnZXRUaW1lKCk7XG4gICAgICAgICAgICBjb25zdCBjaGVja0ludGVybmFsQmxvY2tOdW1iZXIgPSByZXNvbHZlUHJvcGVydGllcyh7XG4gICAgICAgICAgICAgICAgYmxvY2tOdW1iZXI6IHRoaXMucGVyZm9ybShcImdldEJsb2NrTnVtYmVyXCIsIHt9KSxcbiAgICAgICAgICAgICAgICBuZXR3b3JrRXJyb3I6IHRoaXMuZ2V0TmV0d29yaygpLnRoZW4oKG5ldHdvcmspID0+IChudWxsKSwgKGVycm9yKSA9PiAoZXJyb3IpKVxuICAgICAgICAgICAgfSkudGhlbigoeyBibG9ja051bWJlciwgbmV0d29ya0Vycm9yIH0pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAobmV0d29ya0Vycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFVucmVtZW1iZXIgdGhpcyBiYWQgaW50ZXJuYWwgYmxvY2sgbnVtYmVyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pbnRlcm5hbEJsb2NrTnVtYmVyID09PSBjaGVja0ludGVybmFsQmxvY2tOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2ludGVybmFsQmxvY2tOdW1iZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldHdvcmtFcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcFRpbWUgPSBnZXRUaW1lKCk7XG4gICAgICAgICAgICAgICAgYmxvY2tOdW1iZXIgPSBCaWdOdW1iZXIuZnJvbShibG9ja051bWJlcikudG9OdW1iZXIoKTtcbiAgICAgICAgICAgICAgICBpZiAoYmxvY2tOdW1iZXIgPCB0aGlzLl9tYXhJbnRlcm5hbEJsb2NrTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyID0gdGhpcy5fbWF4SW50ZXJuYWxCbG9ja051bWJlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fbWF4SW50ZXJuYWxCbG9ja051bWJlciA9IGJsb2NrTnVtYmVyO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldEZhc3RCbG9ja051bWJlcihibG9ja051bWJlcik7IC8vIEBUT0RPOiBTdGlsbCBuZWVkIHRoaXM/XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgYmxvY2tOdW1iZXIsIHJlcVRpbWUsIHJlc3BUaW1lIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuX2ludGVybmFsQmxvY2tOdW1iZXIgPSBjaGVja0ludGVybmFsQmxvY2tOdW1iZXI7XG4gICAgICAgICAgICAvLyBTd2FsbG93IHVuaGFuZGxlZCBleGNlcHRpb25zOyBpZiBuZWVkZWQgdGhleSBhcmUgaGFuZGxlZCBlbHNlIHdoZXJlXG4gICAgICAgICAgICBjaGVja0ludGVybmFsQmxvY2tOdW1iZXIuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gRG9uJ3QgbnVsbCB0aGUgZGVhZCAocmVqZWN0ZWQpIGZldGNoLCBpZiBpdCBoYXMgYWxyZWFkeSBiZWVuIHVwZGF0ZWRcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faW50ZXJuYWxCbG9ja051bWJlciA9PT0gY2hlY2tJbnRlcm5hbEJsb2NrTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2ludGVybmFsQmxvY2tOdW1iZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuICh5aWVsZCBjaGVja0ludGVybmFsQmxvY2tOdW1iZXIpLmJsb2NrTnVtYmVyO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcG9sbCgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHBvbGxJZCA9IG5leHRQb2xsSWQrKztcbiAgICAgICAgICAgIC8vIFRyYWNrIGFsbCBydW5uaW5nIHByb21pc2VzLCBzbyB3ZSBjYW4gdHJpZ2dlciBhIHBvc3QtcG9sbCBvbmNlIHRoZXkgYXJlIGNvbXBsZXRlXG4gICAgICAgICAgICBjb25zdCBydW5uZXJzID0gW107XG4gICAgICAgICAgICBsZXQgYmxvY2tOdW1iZXIgPSBudWxsO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBibG9ja051bWJlciA9IHlpZWxkIHRoaXMuX2dldEludGVybmFsQmxvY2tOdW1iZXIoMTAwICsgdGhpcy5wb2xsaW5nSW50ZXJ2YWwgLyAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImVycm9yXCIsIGVycm9yKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9zZXRGYXN0QmxvY2tOdW1iZXIoYmxvY2tOdW1iZXIpO1xuICAgICAgICAgICAgLy8gRW1pdCBhIHBvbGwgZXZlbnQgYWZ0ZXIgd2UgaGF2ZSB0aGUgbGF0ZXN0IChmYXN0KSBibG9jayBudW1iZXJcbiAgICAgICAgICAgIHRoaXMuZW1pdChcInBvbGxcIiwgcG9sbElkLCBibG9ja051bWJlcik7XG4gICAgICAgICAgICAvLyBJZiB0aGUgYmxvY2sgaGFzIG5vdCBjaGFuZ2VkLCBtZWguXG4gICAgICAgICAgICBpZiAoYmxvY2tOdW1iZXIgPT09IHRoaXMuX2xhc3RCbG9ja051bWJlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRpZFBvbGxcIiwgcG9sbElkKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGaXJzdCBwb2xsaW5nIGN5Y2xlLCB0cmlnZ2VyIGEgXCJibG9ja1wiIGV2ZW50c1xuICAgICAgICAgICAgaWYgKHRoaXMuX2VtaXR0ZWQuYmxvY2sgPT09IC0yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZW1pdHRlZC5ibG9jayA9IGJsb2NrTnVtYmVyIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChNYXRoLmFicygodGhpcy5fZW1pdHRlZC5ibG9jaykgLSBibG9ja051bWJlcikgPiAxMDAwKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oYG5ldHdvcmsgYmxvY2sgc2tldyBkZXRlY3RlZDsgc2tpcHBpbmcgYmxvY2sgZXZlbnRzIChlbWl0dGVkPSR7dGhpcy5fZW1pdHRlZC5ibG9ja30gYmxvY2tOdW1iZXIke2Jsb2NrTnVtYmVyfSlgKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJlcnJvclwiLCBsb2dnZXIubWFrZUVycm9yKFwibmV0d29yayBibG9jayBza2V3IGRldGVjdGVkXCIsIExvZ2dlci5lcnJvcnMuTkVUV09SS19FUlJPUiwge1xuICAgICAgICAgICAgICAgICAgICBibG9ja051bWJlcjogYmxvY2tOdW1iZXIsXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50OiBcImJsb2NrU2tld1wiLFxuICAgICAgICAgICAgICAgICAgICBwcmV2aW91c0Jsb2NrTnVtYmVyOiB0aGlzLl9lbWl0dGVkLmJsb2NrXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImJsb2NrXCIsIGJsb2NrTnVtYmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIE5vdGlmeSBhbGwgbGlzdGVuZXIgZm9yIGVhY2ggYmxvY2sgdGhhdCBoYXMgcGFzc2VkXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuX2VtaXR0ZWQuYmxvY2sgKyAxOyBpIDw9IGJsb2NrTnVtYmVyOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiYmxvY2tcIiwgaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVGhlIGVtaXR0ZWQgYmxvY2sgd2FzIHVwZGF0ZWQsIGNoZWNrIGZvciBvYnNvbGV0ZSBldmVudHNcbiAgICAgICAgICAgIGlmICh0aGlzLl9lbWl0dGVkLmJsb2NrICE9PSBibG9ja051bWJlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2VtaXR0ZWQuYmxvY2sgPSBibG9ja051bWJlcjtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyh0aGlzLl9lbWl0dGVkKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGJsb2NrIGV2ZW50IGRvZXMgbm90IGV4cGlyZVxuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSBcImJsb2NrXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgYmxvY2sgd2Ugd2VyZSBhdCB3aGVuIHdlIGVtaXR0ZWQgdGhpcyBldmVudFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBldmVudEJsb2NrTnVtYmVyID0gdGhpcy5fZW1pdHRlZFtrZXldO1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBjYW5ub3QgZ2FyYmFnZSBjb2xsZWN0IHBlbmRpbmcgdHJhbnNhY3Rpb25zIG9yIGJsb2NrcyBoZXJlXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZXkgc2hvdWxkIGJlIGdhcmJhZ2UgY29sbGVjdGVkIGJ5IHRoZSBQcm92aWRlciB3aGVuIHNldHRpbmdcbiAgICAgICAgICAgICAgICAgICAgLy8gXCJwZW5kaW5nXCIgZXZlbnRzXG4gICAgICAgICAgICAgICAgICAgIGlmIChldmVudEJsb2NrTnVtYmVyID09PSBcInBlbmRpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEV2aWN0IGFueSB0cmFuc2FjdGlvbiBoYXNoZXMgb3IgYmxvY2sgaGFzaGVzIG92ZXIgMTIgYmxvY2tzXG4gICAgICAgICAgICAgICAgICAgIC8vIG9sZCwgc2luY2UgdGhleSBzaG91bGQgbm90IHJldHVybiBudWxsIGFueXdheXNcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJsb2NrTnVtYmVyIC0gZXZlbnRCbG9ja051bWJlciA+IDEyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fZW1pdHRlZFtrZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGaXJzdCBwb2xsaW5nIGN5Y2xlXG4gICAgICAgICAgICBpZiAodGhpcy5fbGFzdEJsb2NrTnVtYmVyID09PSAtMikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xhc3RCbG9ja051bWJlciA9IGJsb2NrTnVtYmVyIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZpbmQgYWxsIHRyYW5zYWN0aW9uIGhhc2hlcyB3ZSBhcmUgd2FpdGluZyBvblxuICAgICAgICAgICAgdGhpcy5fZXZlbnRzLmZvckVhY2goKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChldmVudC50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ0eFwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBoYXNoID0gZXZlbnQuaGFzaDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBydW5uZXIgPSB0aGlzLmdldFRyYW5zYWN0aW9uUmVjZWlwdChoYXNoKS50aGVuKChyZWNlaXB0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyZWNlaXB0IHx8IHJlY2VpcHQuYmxvY2tOdW1iZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZW1pdHRlZFtcInQ6XCIgKyBoYXNoXSA9IHJlY2VpcHQuYmxvY2tOdW1iZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KGhhc2gsIHJlY2VpcHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2goKGVycm9yKSA9PiB7IHRoaXMuZW1pdChcImVycm9yXCIsIGVycm9yKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBydW5uZXJzLnB1c2gocnVubmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJmaWx0ZXJcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2Ugb25seSBhbGxvdyBhIHNpbmdsZSBnZXRMb2dzIHRvIGJlIGluLWZsaWdodCBhdCBhIHRpbWVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZXZlbnQuX2luZmxpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuX2luZmxpZ2h0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBmaXJzdCBmaWx0ZXIgZm9yIHRoaXMgZXZlbnQsIHNvIHdlIHdhbnQgdG9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZXN0cmljdCBldmVudHMgdG8gZXZlbnRzIHRoYXQgaGFwcGVuZWQgbm8gZWFybGllciB0aGFuIG5vd1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChldmVudC5fbGFzdEJsb2NrTnVtYmVyID09PSAtMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudC5fbGFzdEJsb2NrTnVtYmVyID0gYmxvY2tOdW1iZXIgLSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGaWx0ZXIgZnJvbSB0aGUgbGFzdCAqa25vd24qIGV2ZW50OyBkdWUgdG8gbG9hZC1iYWxhbmNpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmQgc29tZSBub2RlcyByZXR1cm5pbmcgdXBkYXRlZCBibG9jayBudW1iZXJzIGJlZm9yZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluZGV4aW5nIGV2ZW50cywgYSBsb2dzIHJlc3VsdCB3aXRoIDAgZW50cmllcyBjYW5ub3QgYmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0cnVzdGVkIGFuZCB3ZSBtdXN0IHJldHJ5IGEgcmFuZ2Ugd2hpY2ggaW5jbHVkZXMgaXQgYWdhaW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmaWx0ZXIgPSBldmVudC5maWx0ZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyLmZyb21CbG9jayA9IGV2ZW50Ll9sYXN0QmxvY2tOdW1iZXIgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlci50b0Jsb2NrID0gYmxvY2tOdW1iZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHJldmVudCBmaXRsZXIgcmFuZ2VzIGZyb20gZ3Jvd2luZyB0b28gd2lsZCwgc2luY2UgaXQgaXMgcXVpdGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBsaWtlbHkgdGhlcmUganVzdCBoYXZlbid0IGJlZW4gYW55IGV2ZW50cyB0byBtb3ZlIHRoZSBsYXN0QmxvY2tOdW1iZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWluRnJvbUJsb2NrID0gZmlsdGVyLnRvQmxvY2sgLSB0aGlzLl9tYXhGaWx0ZXJCbG9ja1JhbmdlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtaW5Gcm9tQmxvY2sgPiBmaWx0ZXIuZnJvbUJsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlci5mcm9tQmxvY2sgPSBtaW5Gcm9tQmxvY2s7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaWx0ZXIuZnJvbUJsb2NrIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXIuZnJvbUJsb2NrID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcnVubmVyID0gdGhpcy5nZXRMb2dzKGZpbHRlcikudGhlbigobG9ncykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBbGxvdyB0aGUgbmV4dCBnZXRMb2dzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50Ll9pbmZsaWdodCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobG9ncy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dzLmZvckVhY2goKGxvZykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT25seSB3aGVuIHdlIGdldCBhbiBldmVudCBmb3IgYSBnaXZlbiBibG9jayBudW1iZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhbiB3ZSB0cnVzdCB0aGUgZXZlbnRzIGFyZSBpbmRleGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobG9nLmJsb2NrTnVtYmVyID4gZXZlbnQuX2xhc3RCbG9ja051bWJlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50Ll9sYXN0QmxvY2tOdW1iZXIgPSBsb2cuYmxvY2tOdW1iZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgd2Ugc3RhbGwgcmVxdWVzdHMgdG8gZmV0Y2ggYmxvY2tzIGFuZCB0eHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2VtaXR0ZWRbXCJiOlwiICsgbG9nLmJsb2NrSGFzaF0gPSBsb2cuYmxvY2tOdW1iZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9lbWl0dGVkW1widDpcIiArIGxvZy50cmFuc2FjdGlvbkhhc2hdID0gbG9nLmJsb2NrTnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KGZpbHRlciwgbG9nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImVycm9yXCIsIGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWxsb3cgYW5vdGhlciBnZXRMb2dzICh0aGUgcmFuZ2Ugd2FzIG5vdCB1cGRhdGVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudC5faW5mbGlnaHQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBydW5uZXJzLnB1c2gocnVubmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLl9sYXN0QmxvY2tOdW1iZXIgPSBibG9ja051bWJlcjtcbiAgICAgICAgICAgIC8vIE9uY2UgYWxsIGV2ZW50cyBmb3IgdGhpcyBsb29wIGhhdmUgYmVlbiBwcm9jZXNzZWQsIGVtaXQgXCJkaWRQb2xsXCJcbiAgICAgICAgICAgIFByb21pc2UuYWxsKHJ1bm5lcnMpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRpZFBvbGxcIiwgcG9sbElkKTtcbiAgICAgICAgICAgIH0pLmNhdGNoKChlcnJvcikgPT4geyB0aGlzLmVtaXQoXCJlcnJvclwiLCBlcnJvcik7IH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gRGVwcmVjYXRlZDsgZG8gbm90IHVzZSB0aGlzXG4gICAgcmVzZXRFdmVudHNCbG9jayhibG9ja051bWJlcikge1xuICAgICAgICB0aGlzLl9sYXN0QmxvY2tOdW1iZXIgPSBibG9ja051bWJlciAtIDE7XG4gICAgICAgIGlmICh0aGlzLnBvbGxpbmcpIHtcbiAgICAgICAgICAgIHRoaXMucG9sbCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBuZXR3b3JrKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmV0d29yaztcbiAgICB9XG4gICAgLy8gVGhpcyBtZXRob2Qgc2hvdWxkIHF1ZXJ5IHRoZSBuZXR3b3JrIGlmIHRoZSB1bmRlcmx5aW5nIG5ldHdvcmtcbiAgICAvLyBjYW4gY2hhbmdlLCBzdWNoIGFzIHdoZW4gY29ubmVjdGVkIHRvIGEgSlNPTi1SUEMgYmFja2VuZFxuICAgIGRldGVjdE5ldHdvcmsoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93RXJyb3IoXCJwcm92aWRlciBkb2VzIG5vdCBzdXBwb3J0IG5ldHdvcmsgZGV0ZWN0aW9uXCIsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcInByb3ZpZGVyLmRldGVjdE5ldHdvcmtcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXROZXR3b3JrKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgbmV0d29yayA9IHlpZWxkIHRoaXMuX3JlYWR5KCk7XG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgd2UgYXJlIHN0aWxsIGNvbm5lY3RlZCB0byB0aGUgc2FtZSBuZXR3b3JrOyB0aGlzIGlzXG4gICAgICAgICAgICAvLyBvbmx5IGFuIGV4dGVybmFsIGNhbGwgZm9yIGJhY2tlbmRzIHdoaWNoIGNhbiBoYXZlIHRoZSB1bmRlcmx5aW5nXG4gICAgICAgICAgICAvLyBuZXR3b3JrIGNoYW5nZSBzcG9udGFuZW91c2x5XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50TmV0d29yayA9IHlpZWxkIHRoaXMuZGV0ZWN0TmV0d29yaygpO1xuICAgICAgICAgICAgaWYgKG5ldHdvcmsuY2hhaW5JZCAhPT0gY3VycmVudE5ldHdvcmsuY2hhaW5JZCkge1xuICAgICAgICAgICAgICAgIC8vIFdlIGFyZSBhbGxvd2luZyBuZXR3b3JrIGNoYW5nZXMsIHRoaW5ncyBjYW4gZ2V0IGNvbXBsZXggZmFzdDtcbiAgICAgICAgICAgICAgICAvLyBtYWtlIHN1cmUgeW91IGtub3cgd2hhdCB5b3UgYXJlIGRvaW5nIGlmIHlvdSB1c2UgXCJhbnlcIlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmFueU5ldHdvcmspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbmV0d29yayA9IGN1cnJlbnROZXR3b3JrO1xuICAgICAgICAgICAgICAgICAgICAvLyBSZXNldCBhbGwgaW50ZXJuYWwgYmxvY2sgbnVtYmVyIGd1YXJkcyBhbmQgY2FjaGVzXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xhc3RCbG9ja051bWJlciA9IC0yO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9mYXN0QmxvY2tOdW1iZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9mYXN0QmxvY2tOdW1iZXJQcm9taXNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZmFzdFF1ZXJ5RGF0ZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2VtaXR0ZWQuYmxvY2sgPSAtMjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWF4SW50ZXJuYWxCbG9ja051bWJlciA9IC0xMDI0O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbnRlcm5hbEJsb2NrTnVtYmVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIFwibmV0d29ya1wiIGV2ZW50IE1VU1QgaGFwcGVuIGJlZm9yZSB0aGlzIG1ldGhvZCByZXNvbHZlc1xuICAgICAgICAgICAgICAgICAgICAvLyBzbyBhbnkgZXZlbnRzIGhhdmUgYSBjaGFuY2UgdG8gdW5yZWdpc3Rlciwgc28gd2Ugc3RhbGwgYW5cbiAgICAgICAgICAgICAgICAgICAgLy8gYWRkaXRpb25hbCBldmVudCBsb29wIGJlZm9yZSByZXR1cm5pbmcgZnJvbSAvdGhpcy8gY2FsbFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJuZXR3b3JrXCIsIGN1cnJlbnROZXR3b3JrLCBuZXR3b3JrKTtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgc3RhbGwoMCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9uZXR3b3JrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IGxvZ2dlci5tYWtlRXJyb3IoXCJ1bmRlcmx5aW5nIG5ldHdvcmsgY2hhbmdlZFwiLCBMb2dnZXIuZXJyb3JzLk5FVFdPUktfRVJST1IsIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IFwiY2hhbmdlZFwiLFxuICAgICAgICAgICAgICAgICAgICBuZXR3b3JrOiBuZXR3b3JrLFxuICAgICAgICAgICAgICAgICAgICBkZXRlY3RlZE5ldHdvcms6IGN1cnJlbnROZXR3b3JrXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZXJyb3JcIiwgZXJyb3IpO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldHdvcms7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQgYmxvY2tOdW1iZXIoKSB7XG4gICAgICAgIHRoaXMuX2dldEludGVybmFsQmxvY2tOdW1iZXIoMTAwICsgdGhpcy5wb2xsaW5nSW50ZXJ2YWwgLyAyKS50aGVuKChibG9ja051bWJlcikgPT4ge1xuICAgICAgICAgICAgdGhpcy5fc2V0RmFzdEJsb2NrTnVtYmVyKGJsb2NrTnVtYmVyKTtcbiAgICAgICAgfSwgKGVycm9yKSA9PiB7IH0pO1xuICAgICAgICByZXR1cm4gKHRoaXMuX2Zhc3RCbG9ja051bWJlciAhPSBudWxsKSA/IHRoaXMuX2Zhc3RCbG9ja051bWJlciA6IC0xO1xuICAgIH1cbiAgICBnZXQgcG9sbGluZygpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9wb2xsZXIgIT0gbnVsbCk7XG4gICAgfVxuICAgIHNldCBwb2xsaW5nKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSAmJiAhdGhpcy5fcG9sbGVyKSB7XG4gICAgICAgICAgICB0aGlzLl9wb2xsZXIgPSBzZXRJbnRlcnZhbCgoKSA9PiB7IHRoaXMucG9sbCgpOyB9LCB0aGlzLnBvbGxpbmdJbnRlcnZhbCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2Jvb3RzdHJhcFBvbGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9ib290c3RyYXBQb2xsID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG9sbCgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBibG9jayBhZGRpdGlvbmFsIHBvbGxzIHVudGlsIHRoZSBwb2xsaW5nIGludGVydmFsXG4gICAgICAgICAgICAgICAgICAgIC8vIGlzIGRvbmUsIHRvIHByZXZlbnQgb3ZlcndoZWxtaW5nIHRoZSBwb2xsIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Jvb3RzdHJhcFBvbGwgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHBvbGxpbmcgd2FzIGRpc2FibGVkLCBzb21ldGhpbmcgbWF5IHJlcXVpcmUgYSBwb2tlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzaW5jZSBzdGFydGluZyB0aGUgYm9vdHN0cmFwIHBvbGwgYW5kIGl0IHdhcyBkaXNhYmxlZFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9wb2xsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBvbGwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENsZWFyIG91dCB0aGUgYm9vdHN0cmFwIHNvIHdlIGNhbiBkbyBhbm90aGVyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9ib290c3RyYXBQb2xsID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfSwgdGhpcy5wb2xsaW5nSW50ZXJ2YWwpO1xuICAgICAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCF2YWx1ZSAmJiB0aGlzLl9wb2xsZXIpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5fcG9sbGVyKTtcbiAgICAgICAgICAgIHRoaXMuX3BvbGxlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IHBvbGxpbmdJbnRlcnZhbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BvbGxpbmdJbnRlcnZhbDtcbiAgICB9XG4gICAgc2V0IHBvbGxpbmdJbnRlcnZhbCh2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mICh2YWx1ZSkgIT09IFwibnVtYmVyXCIgfHwgdmFsdWUgPD0gMCB8fCBwYXJzZUludChTdHJpbmcodmFsdWUpKSAhPSB2YWx1ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBwb2xsaW5nIGludGVydmFsXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3BvbGxpbmdJbnRlcnZhbCA9IHZhbHVlO1xuICAgICAgICBpZiAodGhpcy5fcG9sbGVyKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMuX3BvbGxlcik7XG4gICAgICAgICAgICB0aGlzLl9wb2xsZXIgPSBzZXRJbnRlcnZhbCgoKSA9PiB7IHRoaXMucG9sbCgpOyB9LCB0aGlzLl9wb2xsaW5nSW50ZXJ2YWwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9nZXRGYXN0QmxvY2tOdW1iZXIoKSB7XG4gICAgICAgIGNvbnN0IG5vdyA9IGdldFRpbWUoKTtcbiAgICAgICAgLy8gU3RhbGUgYmxvY2sgbnVtYmVyLCByZXF1ZXN0IGEgbmV3ZXIgdmFsdWVcbiAgICAgICAgaWYgKChub3cgLSB0aGlzLl9mYXN0UXVlcnlEYXRlKSA+IDIgKiB0aGlzLl9wb2xsaW5nSW50ZXJ2YWwpIHtcbiAgICAgICAgICAgIHRoaXMuX2Zhc3RRdWVyeURhdGUgPSBub3c7XG4gICAgICAgICAgICB0aGlzLl9mYXN0QmxvY2tOdW1iZXJQcm9taXNlID0gdGhpcy5nZXRCbG9ja051bWJlcigpLnRoZW4oKGJsb2NrTnVtYmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2Zhc3RCbG9ja051bWJlciA9PSBudWxsIHx8IGJsb2NrTnVtYmVyID4gdGhpcy5fZmFzdEJsb2NrTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Zhc3RCbG9ja051bWJlciA9IGJsb2NrTnVtYmVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZmFzdEJsb2NrTnVtYmVyO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2Zhc3RCbG9ja051bWJlclByb21pc2U7XG4gICAgfVxuICAgIF9zZXRGYXN0QmxvY2tOdW1iZXIoYmxvY2tOdW1iZXIpIHtcbiAgICAgICAgLy8gT2xkZXIgYmxvY2ssIG1heWJlIGEgc3RhbGUgcmVxdWVzdFxuICAgICAgICBpZiAodGhpcy5fZmFzdEJsb2NrTnVtYmVyICE9IG51bGwgJiYgYmxvY2tOdW1iZXIgPCB0aGlzLl9mYXN0QmxvY2tOdW1iZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBVcGRhdGUgdGhlIHRpbWUgd2UgdXBkYXRlZCB0aGUgYmxvY2tudW1iZXJcbiAgICAgICAgdGhpcy5fZmFzdFF1ZXJ5RGF0ZSA9IGdldFRpbWUoKTtcbiAgICAgICAgLy8gTmV3ZXIgYmxvY2sgbnVtYmVyLCB1c2UgIGl0XG4gICAgICAgIGlmICh0aGlzLl9mYXN0QmxvY2tOdW1iZXIgPT0gbnVsbCB8fCBibG9ja051bWJlciA+IHRoaXMuX2Zhc3RCbG9ja051bWJlcikge1xuICAgICAgICAgICAgdGhpcy5fZmFzdEJsb2NrTnVtYmVyID0gYmxvY2tOdW1iZXI7XG4gICAgICAgICAgICB0aGlzLl9mYXN0QmxvY2tOdW1iZXJQcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKGJsb2NrTnVtYmVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB3YWl0Rm9yVHJhbnNhY3Rpb24odHJhbnNhY3Rpb25IYXNoLCBjb25maXJtYXRpb25zLCB0aW1lb3V0KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2FpdEZvclRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uSGFzaCwgKGNvbmZpcm1hdGlvbnMgPT0gbnVsbCkgPyAxIDogY29uZmlybWF0aW9ucywgdGltZW91dCB8fCAwLCBudWxsKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF93YWl0Rm9yVHJhbnNhY3Rpb24odHJhbnNhY3Rpb25IYXNoLCBjb25maXJtYXRpb25zLCB0aW1lb3V0LCByZXBsYWNlYWJsZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVjZWlwdCA9IHlpZWxkIHRoaXMuZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KHRyYW5zYWN0aW9uSGFzaCk7XG4gICAgICAgICAgICAvLyBSZWNlaXB0IGlzIGFscmVhZHkgZ29vZFxuICAgICAgICAgICAgaWYgKChyZWNlaXB0ID8gcmVjZWlwdC5jb25maXJtYXRpb25zIDogMCkgPj0gY29uZmlybWF0aW9ucykge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWNlaXB0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUG9sbCB1bnRpbCB0aGUgcmVjZWlwdCBpcyBnb29kLi4uXG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhbmNlbEZ1bmNzID0gW107XG4gICAgICAgICAgICAgICAgbGV0IGRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBjb25zdCBhbHJlYWR5RG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBjYW5jZWxGdW5jcy5mb3JFYWNoKChmdW5jKSA9PiB7IGZ1bmMoKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNvbnN0IG1pbmVkSGFuZGxlciA9IChyZWNlaXB0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWNlaXB0LmNvbmZpcm1hdGlvbnMgPCBjb25maXJtYXRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGFscmVhZHlEb25lKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlY2VpcHQpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpcy5vbih0cmFuc2FjdGlvbkhhc2gsIG1pbmVkSGFuZGxlcik7XG4gICAgICAgICAgICAgICAgY2FuY2VsRnVuY3MucHVzaCgoKSA9PiB7IHRoaXMucmVtb3ZlTGlzdGVuZXIodHJhbnNhY3Rpb25IYXNoLCBtaW5lZEhhbmRsZXIpOyB9KTtcbiAgICAgICAgICAgICAgICBpZiAocmVwbGFjZWFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxhc3RCbG9ja051bWJlciA9IHJlcGxhY2VhYmxlLnN0YXJ0QmxvY2s7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzY2FubmVkQmxvY2sgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXBsYWNlSGFuZGxlciA9IChibG9ja051bWJlcikgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXYWl0IDEgc2Vjb25kOyB0aGlzIGlzIG9ubHkgdXNlZCBpbiB0aGUgY2FzZSBvZiBhIGZhdWx0LCBzb1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2Ugd2lsbCB0cmFkZSBvZmYgYSBsaXR0bGUgYml0IG9mIGxhdGVuY3kgZm9yIG1vcmUgY29uc2lzdGVudFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVzdWx0cyBhbmQgZmV3ZXIgSlNPTi1SUEMgY2FsbHNcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIHN0YWxsKDEwMDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRUcmFuc2FjdGlvbkNvdW50KHJlcGxhY2VhYmxlLmZyb20pLnRoZW4oKG5vbmNlKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9uY2UgPD0gcmVwbGFjZWFibGUubm9uY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdEJsb2NrTnVtYmVyID0gYmxvY2tOdW1iZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGaXJzdCBjaGVjayBpZiB0aGUgdHJhbnNhY3Rpb24gd2FzIG1pbmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1pbmVkID0geWllbGQgdGhpcy5nZXRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbkhhc2gpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1pbmVkICYmIG1pbmVkLmJsb2NrTnVtYmVyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmlyc3QgdGltZSBzY2FubmluZy4gV2Ugc3RhcnQgYSBsaXR0bGUgZWFybGllciBmb3Igc29tZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3aWdnbGUgcm9vbSBoZXJlIHRvIGhhbmRsZSB0aGUgZXZlbnR1YWxseSBjb25zaXN0ZW50IG5hdHVyZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvZiBibG9ja2NoYWluIChlLmcuIHRoZSBnZXRUcmFuc2FjdGlvbkNvdW50IHdhcyBmb3IgYVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkaWZmZXJlbnQgYmxvY2spXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzY2FubmVkQmxvY2sgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Nhbm5lZEJsb2NrID0gbGFzdEJsb2NrTnVtYmVyIC0gMztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzY2FubmVkQmxvY2sgPCByZXBsYWNlYWJsZS5zdGFydEJsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Nhbm5lZEJsb2NrID0gcmVwbGFjZWFibGUuc3RhcnRCbG9jaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc2Nhbm5lZEJsb2NrIDw9IGJsb2NrTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJsb2NrID0geWllbGQgdGhpcy5nZXRCbG9ja1dpdGhUcmFuc2FjdGlvbnMoc2Nhbm5lZEJsb2NrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHRpID0gMDsgdGkgPCBibG9jay50cmFuc2FjdGlvbnMubGVuZ3RoOyB0aSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdHggPSBibG9jay50cmFuc2FjdGlvbnNbdGldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1Y2Nlc3NmdWxseSBtaW5lZCFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHguaGFzaCA9PT0gdHJhbnNhY3Rpb25IYXNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWF0Y2hlcyBvdXIgdHJhbnNhY3Rpb24gZnJvbSBhbmQgbm9uY2U7IGl0cyBhIHJlcGxhY2VtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR4LmZyb20gPT09IHJlcGxhY2VhYmxlLmZyb20gJiYgdHgubm9uY2UgPT09IHJlcGxhY2VhYmxlLm5vbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSByZWNlaXB0IG9mIHRoZSByZXBsYWNlbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZWNlaXB0ID0geWllbGQgdGhpcy53YWl0Rm9yVHJhbnNhY3Rpb24odHguaGFzaCwgY29uZmlybWF0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFscmVhZHkgcmVzb2x2ZWQgb3IgcmVqZWN0ZWQgKHByb2xseSBhIHRpbWVvdXQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhbHJlYWR5RG9uZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHJlYXNvbiB3ZSB3ZXJlIHJlcGxhY2VkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZWFzb24gPSBcInJlcGxhY2VkXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eC5kYXRhID09PSByZXBsYWNlYWJsZS5kYXRhICYmIHR4LnRvID09PSByZXBsYWNlYWJsZS50byAmJiB0eC52YWx1ZS5lcShyZXBsYWNlYWJsZS52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYXNvbiA9IFwicmVwcmljZWRcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eC5kYXRhID09PSBcIjB4XCIgJiYgdHguZnJvbSA9PT0gdHgudG8gJiYgdHgudmFsdWUuaXNaZXJvKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYXNvbiA9IFwiY2FuY2VsbGVkXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXhwbGFpbiB3aHkgd2Ugd2VyZSByZXBsYWNlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobG9nZ2VyLm1ha2VFcnJvcihcInRyYW5zYWN0aW9uIHdhcyByZXBsYWNlZFwiLCBMb2dnZXIuZXJyb3JzLlRSQU5TQUNUSU9OX1JFUExBQ0VELCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5jZWxsZWQ6IChyZWFzb24gPT09IFwicmVwbGFjZWRcIiB8fCByZWFzb24gPT09IFwiY2FuY2VsbGVkXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhc29uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwbGFjZW1lbnQ6IHRoaXMuX3dyYXBUcmFuc2FjdGlvbih0eCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNoOiB0cmFuc2FjdGlvbkhhc2gsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWNlaXB0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjYW5uZWRCbG9jaysrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vbmNlKFwiYmxvY2tcIiwgcmVwbGFjZUhhbmRsZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSksIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vbmNlKFwiYmxvY2tcIiwgcmVwbGFjZUhhbmRsZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25jZShcImJsb2NrXCIsIHJlcGxhY2VIYW5kbGVyKTtcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsRnVuY3MucHVzaCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKFwiYmxvY2tcIiwgcmVwbGFjZUhhbmRsZXIpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAodGltZW91dCkgPT09IFwibnVtYmVyXCIgJiYgdGltZW91dCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhbHJlYWR5RG9uZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGxvZ2dlci5tYWtlRXJyb3IoXCJ0aW1lb3V0IGV4Y2VlZGVkXCIsIExvZ2dlci5lcnJvcnMuVElNRU9VVCwgeyB0aW1lb3V0OiB0aW1lb3V0IH0pKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgdGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aW1lci51bnJlZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGltZXIudW5yZWYoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYW5jZWxGdW5jcy5wdXNoKCgpID0+IHsgY2xlYXJUaW1lb3V0KHRpbWVyKTsgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRCbG9ja051bWJlcigpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRJbnRlcm5hbEJsb2NrTnVtYmVyKDApO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0R2FzUHJpY2UoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLmdldE5ldHdvcmsoKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHlpZWxkIHRoaXMucGVyZm9ybShcImdldEdhc1ByaWNlXCIsIHt9KTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEJpZ051bWJlci5mcm9tKHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93RXJyb3IoXCJiYWQgcmVzdWx0IGZyb20gYmFja2VuZFwiLCBMb2dnZXIuZXJyb3JzLlNFUlZFUl9FUlJPUiwge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwiZ2V0R2FzUHJpY2VcIixcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LCBlcnJvclxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0QmFsYW5jZShhZGRyZXNzT3JOYW1lLCBibG9ja1RhZykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgeWllbGQgdGhpcy5nZXROZXR3b3JrKCk7XG4gICAgICAgICAgICBjb25zdCBwYXJhbXMgPSB5aWVsZCByZXNvbHZlUHJvcGVydGllcyh7XG4gICAgICAgICAgICAgICAgYWRkcmVzczogdGhpcy5fZ2V0QWRkcmVzcyhhZGRyZXNzT3JOYW1lKSxcbiAgICAgICAgICAgICAgICBibG9ja1RhZzogdGhpcy5fZ2V0QmxvY2tUYWcoYmxvY2tUYWcpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHlpZWxkIHRoaXMucGVyZm9ybShcImdldEJhbGFuY2VcIiwgcGFyYW1zKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEJpZ051bWJlci5mcm9tKHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93RXJyb3IoXCJiYWQgcmVzdWx0IGZyb20gYmFja2VuZFwiLCBMb2dnZXIuZXJyb3JzLlNFUlZFUl9FUlJPUiwge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwiZ2V0QmFsYW5jZVwiLFxuICAgICAgICAgICAgICAgICAgICBwYXJhbXMsIHJlc3VsdCwgZXJyb3JcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldFRyYW5zYWN0aW9uQ291bnQoYWRkcmVzc09yTmFtZSwgYmxvY2tUYWcpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuZ2V0TmV0d29yaygpO1xuICAgICAgICAgICAgY29uc3QgcGFyYW1zID0geWllbGQgcmVzb2x2ZVByb3BlcnRpZXMoe1xuICAgICAgICAgICAgICAgIGFkZHJlc3M6IHRoaXMuX2dldEFkZHJlc3MoYWRkcmVzc09yTmFtZSksXG4gICAgICAgICAgICAgICAgYmxvY2tUYWc6IHRoaXMuX2dldEJsb2NrVGFnKGJsb2NrVGFnKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB5aWVsZCB0aGlzLnBlcmZvcm0oXCJnZXRUcmFuc2FjdGlvbkNvdW50XCIsIHBhcmFtcyk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBCaWdOdW1iZXIuZnJvbShyZXN1bHQpLnRvTnVtYmVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93RXJyb3IoXCJiYWQgcmVzdWx0IGZyb20gYmFja2VuZFwiLCBMb2dnZXIuZXJyb3JzLlNFUlZFUl9FUlJPUiwge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwiZ2V0VHJhbnNhY3Rpb25Db3VudFwiLFxuICAgICAgICAgICAgICAgICAgICBwYXJhbXMsIHJlc3VsdCwgZXJyb3JcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldENvZGUoYWRkcmVzc09yTmFtZSwgYmxvY2tUYWcpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuZ2V0TmV0d29yaygpO1xuICAgICAgICAgICAgY29uc3QgcGFyYW1zID0geWllbGQgcmVzb2x2ZVByb3BlcnRpZXMoe1xuICAgICAgICAgICAgICAgIGFkZHJlc3M6IHRoaXMuX2dldEFkZHJlc3MoYWRkcmVzc09yTmFtZSksXG4gICAgICAgICAgICAgICAgYmxvY2tUYWc6IHRoaXMuX2dldEJsb2NrVGFnKGJsb2NrVGFnKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB5aWVsZCB0aGlzLnBlcmZvcm0oXCJnZXRDb2RlXCIsIHBhcmFtcyk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBoZXhsaWZ5KHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93RXJyb3IoXCJiYWQgcmVzdWx0IGZyb20gYmFja2VuZFwiLCBMb2dnZXIuZXJyb3JzLlNFUlZFUl9FUlJPUiwge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwiZ2V0Q29kZVwiLFxuICAgICAgICAgICAgICAgICAgICBwYXJhbXMsIHJlc3VsdCwgZXJyb3JcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldFN0b3JhZ2VBdChhZGRyZXNzT3JOYW1lLCBwb3NpdGlvbiwgYmxvY2tUYWcpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuZ2V0TmV0d29yaygpO1xuICAgICAgICAgICAgY29uc3QgcGFyYW1zID0geWllbGQgcmVzb2x2ZVByb3BlcnRpZXMoe1xuICAgICAgICAgICAgICAgIGFkZHJlc3M6IHRoaXMuX2dldEFkZHJlc3MoYWRkcmVzc09yTmFtZSksXG4gICAgICAgICAgICAgICAgYmxvY2tUYWc6IHRoaXMuX2dldEJsb2NrVGFnKGJsb2NrVGFnKSxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogUHJvbWlzZS5yZXNvbHZlKHBvc2l0aW9uKS50aGVuKChwKSA9PiBoZXhWYWx1ZShwKSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geWllbGQgdGhpcy5wZXJmb3JtKFwiZ2V0U3RvcmFnZUF0XCIsIHBhcmFtcyk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBoZXhsaWZ5KHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93RXJyb3IoXCJiYWQgcmVzdWx0IGZyb20gYmFja2VuZFwiLCBMb2dnZXIuZXJyb3JzLlNFUlZFUl9FUlJPUiwge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwiZ2V0U3RvcmFnZUF0XCIsXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcywgcmVzdWx0LCBlcnJvclxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gVGhpcyBzaG91bGQgYmUgY2FsbGVkIGJ5IGFueSBzdWJjbGFzcyB3cmFwcGluZyBhIFRyYW5zYWN0aW9uUmVzcG9uc2VcbiAgICBfd3JhcFRyYW5zYWN0aW9uKHR4LCBoYXNoLCBzdGFydEJsb2NrKSB7XG4gICAgICAgIGlmIChoYXNoICE9IG51bGwgJiYgaGV4RGF0YUxlbmd0aChoYXNoKSAhPT0gMzIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgcmVzcG9uc2UgLSBzZW5kVHJhbnNhY3Rpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdHg7XG4gICAgICAgIC8vIENoZWNrIHRoZSBoYXNoIHdlIGV4cGVjdCBpcyB0aGUgc2FtZSBhcyB0aGUgaGFzaCB0aGUgc2VydmVyIHJlcG9ydGVkXG4gICAgICAgIGlmIChoYXNoICE9IG51bGwgJiYgdHguaGFzaCAhPT0gaGFzaCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJUcmFuc2FjdGlvbiBoYXNoIG1pc21hdGNoIGZyb20gUHJvdmlkZXIuc2VuZFRyYW5zYWN0aW9uLlwiLCBMb2dnZXIuZXJyb3JzLlVOS05PV05fRVJST1IsIHsgZXhwZWN0ZWRIYXNoOiB0eC5oYXNoLCByZXR1cm5lZEhhc2g6IGhhc2ggfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LndhaXQgPSAoY29uZmlybXMsIHRpbWVvdXQpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChjb25maXJtcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uZmlybXMgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRpbWVvdXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRpbWVvdXQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gR2V0IHRoZSBkZXRhaWxzIHRvIGRldGVjdCByZXBsYWNlbWVudFxuICAgICAgICAgICAgbGV0IHJlcGxhY2VtZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKGNvbmZpcm1zICE9PSAwICYmIHN0YXJ0QmxvY2sgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50ID0ge1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiB0eC5kYXRhLFxuICAgICAgICAgICAgICAgICAgICBmcm9tOiB0eC5mcm9tLFxuICAgICAgICAgICAgICAgICAgICBub25jZTogdHgubm9uY2UsXG4gICAgICAgICAgICAgICAgICAgIHRvOiB0eC50byxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHR4LnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBzdGFydEJsb2NrXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlY2VpcHQgPSB5aWVsZCB0aGlzLl93YWl0Rm9yVHJhbnNhY3Rpb24odHguaGFzaCwgY29uZmlybXMsIHRpbWVvdXQsIHJlcGxhY2VtZW50KTtcbiAgICAgICAgICAgIGlmIChyZWNlaXB0ID09IG51bGwgJiYgY29uZmlybXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5vIGxvbmdlciBwZW5kaW5nLCBhbGxvdyB0aGUgcG9sbGluZyBsb29wIHRvIGdhcmJhZ2UgY29sbGVjdCB0aGlzXG4gICAgICAgICAgICB0aGlzLl9lbWl0dGVkW1widDpcIiArIHR4Lmhhc2hdID0gcmVjZWlwdC5ibG9ja051bWJlcjtcbiAgICAgICAgICAgIGlmIChyZWNlaXB0LnN0YXR1cyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwidHJhbnNhY3Rpb24gZmFpbGVkXCIsIExvZ2dlci5lcnJvcnMuQ0FMTF9FWENFUFRJT04sIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25IYXNoOiB0eC5oYXNoLFxuICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbjogdHgsXG4gICAgICAgICAgICAgICAgICAgIHJlY2VpcHQ6IHJlY2VpcHRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZWNlaXB0O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgc2VuZFRyYW5zYWN0aW9uKHNpZ25lZFRyYW5zYWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLmdldE5ldHdvcmsoKTtcbiAgICAgICAgICAgIGNvbnN0IGhleFR4ID0geWllbGQgUHJvbWlzZS5yZXNvbHZlKHNpZ25lZFRyYW5zYWN0aW9uKS50aGVuKHQgPT4gaGV4bGlmeSh0KSk7XG4gICAgICAgICAgICBjb25zdCB0eCA9IHRoaXMuZm9ybWF0dGVyLnRyYW5zYWN0aW9uKHNpZ25lZFRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgIGlmICh0eC5jb25maXJtYXRpb25zID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0eC5jb25maXJtYXRpb25zID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGJsb2NrTnVtYmVyID0geWllbGQgdGhpcy5fZ2V0SW50ZXJuYWxCbG9ja051bWJlcigxMDAgKyAyICogdGhpcy5wb2xsaW5nSW50ZXJ2YWwpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBoYXNoID0geWllbGQgdGhpcy5wZXJmb3JtKFwic2VuZFRyYW5zYWN0aW9uXCIsIHsgc2lnbmVkVHJhbnNhY3Rpb246IGhleFR4IH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93cmFwVHJhbnNhY3Rpb24odHgsIGhhc2gsIGJsb2NrTnVtYmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGVycm9yLnRyYW5zYWN0aW9uID0gdHg7XG4gICAgICAgICAgICAgICAgZXJyb3IudHJhbnNhY3Rpb25IYXNoID0gdHguaGFzaDtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9nZXRUcmFuc2FjdGlvblJlcXVlc3QodHJhbnNhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlcyA9IHlpZWxkIHRyYW5zYWN0aW9uO1xuICAgICAgICAgICAgY29uc3QgdHggPSB7fTtcbiAgICAgICAgICAgIFtcImZyb21cIiwgXCJ0b1wiXS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWVzW2tleV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHR4W2tleV0gPSBQcm9taXNlLnJlc29sdmUodmFsdWVzW2tleV0pLnRoZW4oKHYpID0+ICh2ID8gdGhpcy5fZ2V0QWRkcmVzcyh2KSA6IG51bGwpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgW1wiZ2FzTGltaXRcIiwgXCJnYXNQcmljZVwiLCBcIm1heEZlZVBlckdhc1wiLCBcIm1heFByaW9yaXR5RmVlUGVyR2FzXCIsIFwidmFsdWVcIl0uZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlc1trZXldID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0eFtrZXldID0gUHJvbWlzZS5yZXNvbHZlKHZhbHVlc1trZXldKS50aGVuKCh2KSA9PiAodiA/IEJpZ051bWJlci5mcm9tKHYpIDogbnVsbCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBbXCJ0eXBlXCJdLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZXNba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHhba2V5XSA9IFByb21pc2UucmVzb2x2ZSh2YWx1ZXNba2V5XSkudGhlbigodikgPT4gKCh2ICE9IG51bGwpID8gdiA6IG51bGwpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHZhbHVlcy5hY2Nlc3NMaXN0KSB7XG4gICAgICAgICAgICAgICAgdHguYWNjZXNzTGlzdCA9IHRoaXMuZm9ybWF0dGVyLmFjY2Vzc0xpc3QodmFsdWVzLmFjY2Vzc0xpc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgW1wiZGF0YVwiXS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWVzW2tleV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHR4W2tleV0gPSBQcm9taXNlLnJlc29sdmUodmFsdWVzW2tleV0pLnRoZW4oKHYpID0+ICh2ID8gaGV4bGlmeSh2KSA6IG51bGwpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0dGVyLnRyYW5zYWN0aW9uUmVxdWVzdCh5aWVsZCByZXNvbHZlUHJvcGVydGllcyh0eCkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2dldEZpbHRlcihmaWx0ZXIpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGZpbHRlciA9IHlpZWxkIGZpbHRlcjtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgICAgICAgICAgaWYgKGZpbHRlci5hZGRyZXNzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuYWRkcmVzcyA9IHRoaXMuX2dldEFkZHJlc3MoZmlsdGVyLmFkZHJlc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgW1wiYmxvY2tIYXNoXCIsIFwidG9waWNzXCJdLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChmaWx0ZXJba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBmaWx0ZXJba2V5XTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgW1wiZnJvbUJsb2NrXCIsIFwidG9CbG9ja1wiXS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZmlsdGVyW2tleV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gdGhpcy5fZ2V0QmxvY2tUYWcoZmlsdGVyW2tleV0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXR0ZXIuZmlsdGVyKHlpZWxkIHJlc29sdmVQcm9wZXJ0aWVzKHJlc3VsdCkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2NhbGwodHJhbnNhY3Rpb24sIGJsb2NrVGFnLCBhdHRlbXB0KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAoYXR0ZW1wdCA+PSBNQVhfQ0NJUF9SRURJUkVDVFMpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcIkNDSVAgcmVhZCBleGNlZWRlZCBtYXhpbXVtIHJlZGlyZWN0aW9uc1wiLCBMb2dnZXIuZXJyb3JzLlNFUlZFUl9FUlJPUiwge1xuICAgICAgICAgICAgICAgICAgICByZWRpcmVjdHM6IGF0dGVtcHQsIHRyYW5zYWN0aW9uXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0eFNlbmRlciA9IHRyYW5zYWN0aW9uLnRvO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geWllbGQgdGhpcy5wZXJmb3JtKFwiY2FsbFwiLCB7IHRyYW5zYWN0aW9uLCBibG9ja1RhZyB9KTtcbiAgICAgICAgICAgIC8vIENDSVAgUmVhZCByZXF1ZXN0IHZpYSBPZmZjaGFpbkxvb2t1cChhZGRyZXNzLHN0cmluZ1tdLGJ5dGVzLGJ5dGVzNCxieXRlcylcbiAgICAgICAgICAgIGlmIChhdHRlbXB0ID49IDAgJiYgYmxvY2tUYWcgPT09IFwibGF0ZXN0XCIgJiYgdHhTZW5kZXIgIT0gbnVsbCAmJiByZXN1bHQuc3Vic3RyaW5nKDAsIDEwKSA9PT0gXCIweDU1NmYxODMwXCIgJiYgKGhleERhdGFMZW5ndGgocmVzdWx0KSAlIDMyID09PSA0KSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBoZXhEYXRhU2xpY2UocmVzdWx0LCA0KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgdGhlIHNlbmRlciBvZiB0aGUgT2ZmY2hhaW5Mb29rdXAgbWF0Y2hlcyB0aGUgdHJhbnNhY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VuZGVyID0gaGV4RGF0YVNsaWNlKGRhdGEsIDAsIDMyKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFCaWdOdW1iZXIuZnJvbShzZW5kZXIpLmVxKHR4U2VuZGVyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJDQ0lQIFJlYWQgc2VuZGVyIGRpZCBub3QgbWF0Y2hcIiwgTG9nZ2VyLmVycm9ycy5DQUxMX0VYQ0VQVElPTiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiT2ZmY2hhaW5Mb29rdXBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmU6IFwiT2ZmY2hhaW5Mb29rdXAoYWRkcmVzcyxzdHJpbmdbXSxieXRlcyxieXRlczQsYnl0ZXMpXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24sIGRhdGE6IHJlc3VsdFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gUmVhZCB0aGUgVVJMcyBmcm9tIHRoZSByZXNwb25zZVxuICAgICAgICAgICAgICAgICAgICBjb25zdCB1cmxzID0gW107XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHVybHNPZmZzZXQgPSBCaWdOdW1iZXIuZnJvbShoZXhEYXRhU2xpY2UoZGF0YSwgMzIsIDY0KSkudG9OdW1iZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdXJsc0xlbmd0aCA9IEJpZ051bWJlci5mcm9tKGhleERhdGFTbGljZShkYXRhLCB1cmxzT2Zmc2V0LCB1cmxzT2Zmc2V0ICsgMzIpKS50b051bWJlcigpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB1cmxzRGF0YSA9IGhleERhdGFTbGljZShkYXRhLCB1cmxzT2Zmc2V0ICsgMzIpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCB1ID0gMDsgdSA8IHVybHNMZW5ndGg7IHUrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdXJsID0gX3BhcnNlU3RyaW5nKHVybHNEYXRhLCB1ICogMzIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVybCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJDQ0lQIFJlYWQgY29udGFpbmVkIGNvcnJ1cHQgVVJMIHN0cmluZ1wiLCBMb2dnZXIuZXJyb3JzLkNBTExfRVhDRVBUSU9OLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiT2ZmY2hhaW5Mb29rdXBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlOiBcIk9mZmNoYWluTG9va3VwKGFkZHJlc3Msc3RyaW5nW10sYnl0ZXMsYnl0ZXM0LGJ5dGVzKVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbiwgZGF0YTogcmVzdWx0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB1cmxzLnB1c2godXJsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIENDSVAgY2FsbGRhdGEgdG8gZm9yd2FyZFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjYWxsZGF0YSA9IF9wYXJzZUJ5dGVzKGRhdGEsIDY0KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBjYWxsYmFja1NlbGVjdG9yIChieXRlczQpXG4gICAgICAgICAgICAgICAgICAgIGlmICghQmlnTnVtYmVyLmZyb20oaGV4RGF0YVNsaWNlKGRhdGEsIDEwMCwgMTI4KSkuaXNaZXJvKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiQ0NJUCBSZWFkIGNhbGxiYWNrIHNlbGVjdG9yIGluY2x1ZGVkIGp1bmtcIiwgTG9nZ2VyLmVycm9ycy5DQUxMX0VYQ0VQVElPTiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiT2ZmY2hhaW5Mb29rdXBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmU6IFwiT2ZmY2hhaW5Mb29rdXAoYWRkcmVzcyxzdHJpbmdbXSxieXRlcyxieXRlczQsYnl0ZXMpXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24sIGRhdGE6IHJlc3VsdFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FsbGJhY2tTZWxlY3RvciA9IGhleERhdGFTbGljZShkYXRhLCA5NiwgMTAwKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBleHRyYSBkYXRhIHRvIHNlbmQgYmFjayB0byB0aGUgY29udHJhY3QgYXMgY29udGV4dFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBleHRyYURhdGEgPSBfcGFyc2VCeXRlcyhkYXRhLCAxMjgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjY2lwUmVzdWx0ID0geWllbGQgdGhpcy5jY2lwUmVhZEZldGNoKHRyYW5zYWN0aW9uLCBjYWxsZGF0YSwgdXJscyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjY2lwUmVzdWx0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiQ0NJUCBSZWFkIGRpc2FibGVkIG9yIHByb3ZpZGVkIG5vIFVSTHNcIiwgTG9nZ2VyLmVycm9ycy5DQUxMX0VYQ0VQVElPTiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiT2ZmY2hhaW5Mb29rdXBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmU6IFwiT2ZmY2hhaW5Mb29rdXAoYWRkcmVzcyxzdHJpbmdbXSxieXRlcyxieXRlczQsYnl0ZXMpXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24sIGRhdGE6IHJlc3VsdFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdHggPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0bzogdHhTZW5kZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBoZXhDb25jYXQoW2NhbGxiYWNrU2VsZWN0b3IsIGVuY29kZUJ5dGVzKFtjY2lwUmVzdWx0LCBleHRyYURhdGFdKV0pXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYWxsKHR4LCBibG9ja1RhZywgYXR0ZW1wdCArIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09IExvZ2dlci5lcnJvcnMuU0VSVkVSX0VSUk9SKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhleGxpZnkocmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dFcnJvcihcImJhZCByZXN1bHQgZnJvbSBiYWNrZW5kXCIsIExvZ2dlci5lcnJvcnMuU0VSVkVSX0VSUk9SLCB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJjYWxsXCIsXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtczogeyB0cmFuc2FjdGlvbiwgYmxvY2tUYWcgfSwgcmVzdWx0LCBlcnJvclxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2FsbCh0cmFuc2FjdGlvbiwgYmxvY2tUYWcpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuZ2V0TmV0d29yaygpO1xuICAgICAgICAgICAgY29uc3QgcmVzb2x2ZWQgPSB5aWVsZCByZXNvbHZlUHJvcGVydGllcyh7XG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb246IHRoaXMuX2dldFRyYW5zYWN0aW9uUmVxdWVzdCh0cmFuc2FjdGlvbiksXG4gICAgICAgICAgICAgICAgYmxvY2tUYWc6IHRoaXMuX2dldEJsb2NrVGFnKGJsb2NrVGFnKSxcbiAgICAgICAgICAgICAgICBjY2lwUmVhZEVuYWJsZWQ6IFByb21pc2UucmVzb2x2ZSh0cmFuc2FjdGlvbi5jY2lwUmVhZEVuYWJsZWQpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYWxsKHJlc29sdmVkLnRyYW5zYWN0aW9uLCByZXNvbHZlZC5ibG9ja1RhZywgcmVzb2x2ZWQuY2NpcFJlYWRFbmFibGVkID8gMCA6IC0xKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVzdGltYXRlR2FzKHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLmdldE5ldHdvcmsoKTtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IHlpZWxkIHJlc29sdmVQcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbjogdGhpcy5fZ2V0VHJhbnNhY3Rpb25SZXF1ZXN0KHRyYW5zYWN0aW9uKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB5aWVsZCB0aGlzLnBlcmZvcm0oXCJlc3RpbWF0ZUdhc1wiLCBwYXJhbXMpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQmlnTnVtYmVyLmZyb20ocmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dFcnJvcihcImJhZCByZXN1bHQgZnJvbSBiYWNrZW5kXCIsIExvZ2dlci5lcnJvcnMuU0VSVkVSX0VSUk9SLCB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJlc3RpbWF0ZUdhc1wiLFxuICAgICAgICAgICAgICAgICAgICBwYXJhbXMsIHJlc3VsdCwgZXJyb3JcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9nZXRBZGRyZXNzKGFkZHJlc3NPck5hbWUpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGFkZHJlc3NPck5hbWUgPSB5aWVsZCBhZGRyZXNzT3JOYW1lO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiAoYWRkcmVzc09yTmFtZSkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBhZGRyZXNzIG9yIEVOUyBuYW1lXCIsIFwibmFtZVwiLCBhZGRyZXNzT3JOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFkZHJlc3MgPSB5aWVsZCB0aGlzLnJlc29sdmVOYW1lKGFkZHJlc3NPck5hbWUpO1xuICAgICAgICAgICAgaWYgKGFkZHJlc3MgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiRU5TIG5hbWUgbm90IGNvbmZpZ3VyZWRcIiwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBgcmVzb2x2ZU5hbWUoJHtKU09OLnN0cmluZ2lmeShhZGRyZXNzT3JOYW1lKX0pYFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFkZHJlc3M7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfZ2V0QmxvY2soYmxvY2tIYXNoT3JCbG9ja1RhZywgaW5jbHVkZVRyYW5zYWN0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgeWllbGQgdGhpcy5nZXROZXR3b3JrKCk7XG4gICAgICAgICAgICBibG9ja0hhc2hPckJsb2NrVGFnID0geWllbGQgYmxvY2tIYXNoT3JCbG9ja1RhZztcbiAgICAgICAgICAgIC8vIElmIGJsb2NrVGFnIGlzIGEgbnVtYmVyIChub3QgXCJsYXRlc3RcIiwgZXRjKSwgdGhpcyBpcyB0aGUgYmxvY2sgbnVtYmVyXG4gICAgICAgICAgICBsZXQgYmxvY2tOdW1iZXIgPSAtMTI4O1xuICAgICAgICAgICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIGluY2x1ZGVUcmFuc2FjdGlvbnM6ICEhaW5jbHVkZVRyYW5zYWN0aW9uc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChpc0hleFN0cmluZyhibG9ja0hhc2hPckJsb2NrVGFnLCAzMikpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMuYmxvY2tIYXNoID0gYmxvY2tIYXNoT3JCbG9ja1RhZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcy5ibG9ja1RhZyA9IHlpZWxkIHRoaXMuX2dldEJsb2NrVGFnKGJsb2NrSGFzaE9yQmxvY2tUYWcpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNIZXhTdHJpbmcocGFyYW1zLmJsb2NrVGFnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tOdW1iZXIgPSBwYXJzZUludChwYXJhbXMuYmxvY2tUYWcuc3Vic3RyaW5nKDIpLCAxNik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGJsb2NrIGhhc2ggb3IgYmxvY2sgdGFnXCIsIFwiYmxvY2tIYXNoT3JCbG9ja1RhZ1wiLCBibG9ja0hhc2hPckJsb2NrVGFnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcG9sbCgoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYmxvY2sgPSB5aWVsZCB0aGlzLnBlcmZvcm0oXCJnZXRCbG9ja1wiLCBwYXJhbXMpO1xuICAgICAgICAgICAgICAgIC8vIEJsb2NrIHdhcyBub3QgZm91bmRcbiAgICAgICAgICAgICAgICBpZiAoYmxvY2sgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBGb3IgYmxvY2toYXNoZXMsIGlmIHdlIGRpZG4ndCBzYXkgaXQgZXhpc3RlZCwgdGhhdCBibG9ja2hhc2ggbWF5XG4gICAgICAgICAgICAgICAgICAgIC8vIG5vdCBleGlzdC4gSWYgd2UgZGlkIHNlZSBpdCB0aG91Z2gsIHBlcmhhcHMgZnJvbSBhIGxvZywgd2Uga25vd1xuICAgICAgICAgICAgICAgICAgICAvLyBpdCBleGlzdHMsIGFuZCB0aGlzIG5vZGUgaXMganVzdCBub3QgY2F1Z2h0IHVwIHlldC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5ibG9ja0hhc2ggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2VtaXR0ZWRbXCJiOlwiICsgcGFyYW1zLmJsb2NrSGFzaF0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEZvciBibG9jayB0YWdzLCBpZiB3ZSBhcmUgYXNraW5nIGZvciBhIGZ1dHVyZSBibG9jaywgd2UgcmV0dXJuIG51bGxcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5ibG9ja1RhZyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmxvY2tOdW1iZXIgPiB0aGlzLl9lbWl0dGVkLmJsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gUmV0cnkgb24gdGhlIG5leHQgYmxvY2tcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQWRkIHRyYW5zYWN0aW9uc1xuICAgICAgICAgICAgICAgIGlmIChpbmNsdWRlVHJhbnNhY3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBibG9ja051bWJlciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmxvY2sudHJhbnNhY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0eCA9IGJsb2NrLnRyYW5zYWN0aW9uc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eC5ibG9ja051bWJlciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHguY29uZmlybWF0aW9ucyA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eC5jb25maXJtYXRpb25zID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmxvY2tOdW1iZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja051bWJlciA9IHlpZWxkIHRoaXMuX2dldEludGVybmFsQmxvY2tOdW1iZXIoMTAwICsgMiAqIHRoaXMucG9sbGluZ0ludGVydmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHRoZSBjb25maXJtYXRpb25zIHVzaW5nIHRoZSBmYXN0IGJsb2NrIG51bWJlciAocGVzc2ltaXN0aWMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNvbmZpcm1hdGlvbnMgPSAoYmxvY2tOdW1iZXIgLSB0eC5ibG9ja051bWJlcikgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb25maXJtYXRpb25zIDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlybWF0aW9ucyA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR4LmNvbmZpcm1hdGlvbnMgPSBjb25maXJtYXRpb25zO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJsb2NrV2l0aFR4cyA9IHRoaXMuZm9ybWF0dGVyLmJsb2NrV2l0aFRyYW5zYWN0aW9ucyhibG9jayk7XG4gICAgICAgICAgICAgICAgICAgIGJsb2NrV2l0aFR4cy50cmFuc2FjdGlvbnMgPSBibG9ja1dpdGhUeHMudHJhbnNhY3Rpb25zLm1hcCgodHgpID0+IHRoaXMuX3dyYXBUcmFuc2FjdGlvbih0eCkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmxvY2tXaXRoVHhzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXR0ZXIuYmxvY2soYmxvY2spO1xuICAgICAgICAgICAgfSksIHsgb25jZVBvbGw6IHRoaXMgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRCbG9jayhibG9ja0hhc2hPckJsb2NrVGFnKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5fZ2V0QmxvY2soYmxvY2tIYXNoT3JCbG9ja1RhZywgZmFsc2UpKTtcbiAgICB9XG4gICAgZ2V0QmxvY2tXaXRoVHJhbnNhY3Rpb25zKGJsb2NrSGFzaE9yQmxvY2tUYWcpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9nZXRCbG9jayhibG9ja0hhc2hPckJsb2NrVGFnLCB0cnVlKSk7XG4gICAgfVxuICAgIGdldFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uSGFzaCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgeWllbGQgdGhpcy5nZXROZXR3b3JrKCk7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbkhhc2ggPSB5aWVsZCB0cmFuc2FjdGlvbkhhc2g7XG4gICAgICAgICAgICBjb25zdCBwYXJhbXMgPSB7IHRyYW5zYWN0aW9uSGFzaDogdGhpcy5mb3JtYXR0ZXIuaGFzaCh0cmFuc2FjdGlvbkhhc2gsIHRydWUpIH07XG4gICAgICAgICAgICByZXR1cm4gcG9sbCgoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geWllbGQgdGhpcy5wZXJmb3JtKFwiZ2V0VHJhbnNhY3Rpb25cIiwgcGFyYW1zKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2VtaXR0ZWRbXCJ0OlwiICsgdHJhbnNhY3Rpb25IYXNoXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB0eCA9IHRoaXMuZm9ybWF0dGVyLnRyYW5zYWN0aW9uUmVzcG9uc2UocmVzdWx0KTtcbiAgICAgICAgICAgICAgICBpZiAodHguYmxvY2tOdW1iZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0eC5jb25maXJtYXRpb25zID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHguY29uZmlybWF0aW9ucyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJsb2NrTnVtYmVyID0geWllbGQgdGhpcy5fZ2V0SW50ZXJuYWxCbG9ja051bWJlcigxMDAgKyAyICogdGhpcy5wb2xsaW5nSW50ZXJ2YWwpO1xuICAgICAgICAgICAgICAgICAgICAvLyBBZGQgdGhlIGNvbmZpcm1hdGlvbnMgdXNpbmcgdGhlIGZhc3QgYmxvY2sgbnVtYmVyIChwZXNzaW1pc3RpYylcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvbmZpcm1hdGlvbnMgPSAoYmxvY2tOdW1iZXIgLSB0eC5ibG9ja051bWJlcikgKyAxO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29uZmlybWF0aW9ucyA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maXJtYXRpb25zID0gMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0eC5jb25maXJtYXRpb25zID0gY29uZmlybWF0aW9ucztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dyYXBUcmFuc2FjdGlvbih0eCk7XG4gICAgICAgICAgICB9KSwgeyBvbmNlUG9sbDogdGhpcyB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldFRyYW5zYWN0aW9uUmVjZWlwdCh0cmFuc2FjdGlvbkhhc2gpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuZ2V0TmV0d29yaygpO1xuICAgICAgICAgICAgdHJhbnNhY3Rpb25IYXNoID0geWllbGQgdHJhbnNhY3Rpb25IYXNoO1xuICAgICAgICAgICAgY29uc3QgcGFyYW1zID0geyB0cmFuc2FjdGlvbkhhc2g6IHRoaXMuZm9ybWF0dGVyLmhhc2godHJhbnNhY3Rpb25IYXNoLCB0cnVlKSB9O1xuICAgICAgICAgICAgcmV0dXJuIHBvbGwoKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHlpZWxkIHRoaXMucGVyZm9ybShcImdldFRyYW5zYWN0aW9uUmVjZWlwdFwiLCBwYXJhbXMpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fZW1pdHRlZFtcInQ6XCIgKyB0cmFuc2FjdGlvbkhhc2hdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFwiZ2V0aC1ldGNcIiByZXR1cm5zIHJlY2VpcHRzIGJlZm9yZSB0aGV5IGFyZSByZWFkeVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuYmxvY2tIYXNoID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcmVjZWlwdCA9IHRoaXMuZm9ybWF0dGVyLnJlY2VpcHQocmVzdWx0KTtcbiAgICAgICAgICAgICAgICBpZiAocmVjZWlwdC5ibG9ja051bWJlciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlY2VpcHQuY29uZmlybWF0aW9ucyA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlY2VpcHQuY29uZmlybWF0aW9ucyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJsb2NrTnVtYmVyID0geWllbGQgdGhpcy5fZ2V0SW50ZXJuYWxCbG9ja051bWJlcigxMDAgKyAyICogdGhpcy5wb2xsaW5nSW50ZXJ2YWwpO1xuICAgICAgICAgICAgICAgICAgICAvLyBBZGQgdGhlIGNvbmZpcm1hdGlvbnMgdXNpbmcgdGhlIGZhc3QgYmxvY2sgbnVtYmVyIChwZXNzaW1pc3RpYylcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvbmZpcm1hdGlvbnMgPSAoYmxvY2tOdW1iZXIgLSByZWNlaXB0LmJsb2NrTnVtYmVyKSArIDE7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb25maXJtYXRpb25zIDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpcm1hdGlvbnMgPSAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlY2VpcHQuY29uZmlybWF0aW9ucyA9IGNvbmZpcm1hdGlvbnM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZWNlaXB0O1xuICAgICAgICAgICAgfSksIHsgb25jZVBvbGw6IHRoaXMgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRMb2dzKGZpbHRlcikge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgeWllbGQgdGhpcy5nZXROZXR3b3JrKCk7XG4gICAgICAgICAgICBjb25zdCBwYXJhbXMgPSB5aWVsZCByZXNvbHZlUHJvcGVydGllcyh7IGZpbHRlcjogdGhpcy5fZ2V0RmlsdGVyKGZpbHRlcikgfSk7XG4gICAgICAgICAgICBjb25zdCBsb2dzID0geWllbGQgdGhpcy5wZXJmb3JtKFwiZ2V0TG9nc1wiLCBwYXJhbXMpO1xuICAgICAgICAgICAgbG9ncy5mb3JFYWNoKChsb2cpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAobG9nLnJlbW92ZWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBsb2cucmVtb3ZlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIEZvcm1hdHRlci5hcnJheU9mKHRoaXMuZm9ybWF0dGVyLmZpbHRlckxvZy5iaW5kKHRoaXMuZm9ybWF0dGVyKSkobG9ncyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRFdGhlclByaWNlKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgeWllbGQgdGhpcy5nZXROZXR3b3JrKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wZXJmb3JtKFwiZ2V0RXRoZXJQcmljZVwiLCB7fSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfZ2V0QmxvY2tUYWcoYmxvY2tUYWcpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGJsb2NrVGFnID0geWllbGQgYmxvY2tUYWc7XG4gICAgICAgICAgICBpZiAodHlwZW9mIChibG9ja1RhZykgPT09IFwibnVtYmVyXCIgJiYgYmxvY2tUYWcgPCAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJsb2NrVGFnICUgMSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBCbG9ja1RhZ1wiLCBcImJsb2NrVGFnXCIsIGJsb2NrVGFnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGJsb2NrTnVtYmVyID0geWllbGQgdGhpcy5fZ2V0SW50ZXJuYWxCbG9ja051bWJlcigxMDAgKyAyICogdGhpcy5wb2xsaW5nSW50ZXJ2YWwpO1xuICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyICs9IGJsb2NrVGFnO1xuICAgICAgICAgICAgICAgIGlmIChibG9ja051bWJlciA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tOdW1iZXIgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXR0ZXIuYmxvY2tUYWcoYmxvY2tOdW1iZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0dGVyLmJsb2NrVGFnKGJsb2NrVGFnKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldFJlc29sdmVyKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGxldCBjdXJyZW50TmFtZSA9IG5hbWU7XG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50TmFtZSA9PT0gXCJcIiB8fCBjdXJyZW50TmFtZSA9PT0gXCIuXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIE9wdGltaXphdGlvbiBzaW5jZSB0aGUgZXRoIG5vZGUgY2Fubm90IGNoYW5nZSBhbmQgZG9lc1xuICAgICAgICAgICAgICAgIC8vIG5vdCBoYXZlIGEgd2lsZGNhcmQgcmVzb2x2ZXJcbiAgICAgICAgICAgICAgICBpZiAobmFtZSAhPT0gXCJldGhcIiAmJiBjdXJyZW50TmFtZSA9PT0gXCJldGhcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgdGhlIGN1cnJlbnQgbm9kZSBmb3IgYSByZXNvbHZlclxuICAgICAgICAgICAgICAgIGNvbnN0IGFkZHIgPSB5aWVsZCB0aGlzLl9nZXRSZXNvbHZlcihjdXJyZW50TmFtZSwgXCJnZXRSZXNvbHZlclwiKTtcbiAgICAgICAgICAgICAgICAvLyBGb3VuZCBhIHJlc29sdmVyIVxuICAgICAgICAgICAgICAgIGlmIChhZGRyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzb2x2ZXIgPSBuZXcgUmVzb2x2ZXIodGhpcywgYWRkciwgbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIExlZ2FjeSByZXNvbHZlciBmb3VuZCwgdXNpbmcgRUlQLTI1NDQgc28gaXQgaXNuJ3Qgc2FmZSB0byB1c2VcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnROYW1lICE9PSBuYW1lICYmICEoeWllbGQgcmVzb2x2ZXIuc3VwcG9ydHNXaWxkY2FyZCgpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIHBhcmVudCBub2RlXG4gICAgICAgICAgICAgICAgY3VycmVudE5hbWUgPSBjdXJyZW50TmFtZS5zcGxpdChcIi5cIikuc2xpY2UoMSkuam9pbihcIi5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfZ2V0UmVzb2x2ZXIobmFtZSwgb3BlcmF0aW9uKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAob3BlcmF0aW9uID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb24gPSBcIkVOU1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbmV0d29yayA9IHlpZWxkIHRoaXMuZ2V0TmV0d29yaygpO1xuICAgICAgICAgICAgLy8gTm8gRU5TLi4uXG4gICAgICAgICAgICBpZiAoIW5ldHdvcmsuZW5zQWRkcmVzcykge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwibmV0d29yayBkb2VzIG5vdCBzdXBwb3J0IEVOU1wiLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwgeyBvcGVyYXRpb24sIG5ldHdvcms6IG5ldHdvcmsubmFtZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLy8ga2VjY2FrMjU2KFwicmVzb2x2ZXIoYnl0ZXMzMilcIilcbiAgICAgICAgICAgICAgICBjb25zdCBhZGRyRGF0YSA9IHlpZWxkIHRoaXMuY2FsbCh7XG4gICAgICAgICAgICAgICAgICAgIHRvOiBuZXR3b3JrLmVuc0FkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IChcIjB4MDE3OGI4YmZcIiArIG5hbWVoYXNoKG5hbWUpLnN1YnN0cmluZygyKSlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXR0ZXIuY2FsbEFkZHJlc3MoYWRkckRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgLy8gRU5TIHJlZ2lzdHJ5IGNhbm5vdCB0aHJvdyBlcnJvcnMgb24gcmVzb2x2ZXIoYnl0ZXMzMilcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVzb2x2ZU5hbWUobmFtZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgbmFtZSA9IHlpZWxkIG5hbWU7XG4gICAgICAgICAgICAvLyBJZiBpdCBpcyBhbHJlYWR5IGFuIGFkZHJlc3MsIG5vdGhpbmcgdG8gcmVzb2x2ZVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuZm9ybWF0dGVyLmFkZHJlc3MobmFtZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgaXMgaXMgYSBoZXhzdHJpbmcsIHRoZSBhZGRyZXNzIGlzIGJhZCAoU2VlICM2OTQpXG4gICAgICAgICAgICAgICAgaWYgKGlzSGV4U3RyaW5nKG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgKG5hbWUpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgRU5TIG5hbWVcIiwgXCJuYW1lXCIsIG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gR2V0IHRoZSBhZGRyIGZyb20gdGhlIHJlc29sdmVyXG4gICAgICAgICAgICBjb25zdCByZXNvbHZlciA9IHlpZWxkIHRoaXMuZ2V0UmVzb2x2ZXIobmFtZSk7XG4gICAgICAgICAgICBpZiAoIXJlc29sdmVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzb2x2ZXIuZ2V0QWRkcmVzcygpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgbG9va3VwQWRkcmVzcyhhZGRyZXNzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBhZGRyZXNzID0geWllbGQgYWRkcmVzcztcbiAgICAgICAgICAgIGFkZHJlc3MgPSB0aGlzLmZvcm1hdHRlci5hZGRyZXNzKGFkZHJlc3MpO1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IGFkZHJlc3Muc3Vic3RyaW5nKDIpLnRvTG93ZXJDYXNlKCkgKyBcIi5hZGRyLnJldmVyc2VcIjtcbiAgICAgICAgICAgIGNvbnN0IHJlc29sdmVyQWRkciA9IHlpZWxkIHRoaXMuX2dldFJlc29sdmVyKG5vZGUsIFwibG9va3VwQWRkcmVzc1wiKTtcbiAgICAgICAgICAgIGlmIChyZXNvbHZlckFkZHIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8ga2VjY2FrKFwibmFtZShieXRlczMyKVwiKVxuICAgICAgICAgICAgY29uc3QgbmFtZSA9IF9wYXJzZVN0cmluZyh5aWVsZCB0aGlzLmNhbGwoe1xuICAgICAgICAgICAgICAgIHRvOiByZXNvbHZlckFkZHIsXG4gICAgICAgICAgICAgICAgZGF0YTogKFwiMHg2OTFmMzQzMVwiICsgbmFtZWhhc2gobm9kZSkuc3Vic3RyaW5nKDIpKVxuICAgICAgICAgICAgfSksIDApO1xuICAgICAgICAgICAgY29uc3QgYWRkciA9IHlpZWxkIHRoaXMucmVzb2x2ZU5hbWUobmFtZSk7XG4gICAgICAgICAgICBpZiAoYWRkciAhPSBhZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldEF2YXRhcihuYW1lT3JBZGRyZXNzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBsZXQgcmVzb2x2ZXIgPSBudWxsO1xuICAgICAgICAgICAgaWYgKGlzSGV4U3RyaW5nKG5hbWVPckFkZHJlc3MpKSB7XG4gICAgICAgICAgICAgICAgLy8gQWRkcmVzczsgcmV2ZXJzZSBsb29rdXBcbiAgICAgICAgICAgICAgICBjb25zdCBhZGRyZXNzID0gdGhpcy5mb3JtYXR0ZXIuYWRkcmVzcyhuYW1lT3JBZGRyZXNzKTtcbiAgICAgICAgICAgICAgICBjb25zdCBub2RlID0gYWRkcmVzcy5zdWJzdHJpbmcoMikudG9Mb3dlckNhc2UoKSArIFwiLmFkZHIucmV2ZXJzZVwiO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc29sdmVyQWRkcmVzcyA9IHlpZWxkIHRoaXMuX2dldFJlc29sdmVyKG5vZGUsIFwiZ2V0QXZhdGFyXCIpO1xuICAgICAgICAgICAgICAgIGlmICghcmVzb2x2ZXJBZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBUcnkgcmVzb2x2aW5nIHRoZSBhdmF0YXIgYWdhaW5zdCB0aGUgYWRkci5yZXZlcnNlIHJlc29sdmVyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZXIgPSBuZXcgUmVzb2x2ZXIodGhpcywgcmVzb2x2ZXJBZGRyZXNzLCBub2RlKTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhdmF0YXIgPSB5aWVsZCByZXNvbHZlci5nZXRBdmF0YXIoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGF2YXRhcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF2YXRhci51cmw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvci5jb2RlICE9PSBMb2dnZXIuZXJyb3JzLkNBTExfRVhDRVBUSU9OKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBUcnkgZ2V0dGluZyB0aGUgbmFtZSBhbmQgcGVyZm9ybWluZyBmb3J3YXJkIGxvb2t1cDsgYWxsb3dpbmcgd2lsZGNhcmRzXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgLy8ga2VjY2FrKFwibmFtZShieXRlczMyKVwiKVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBuYW1lID0gX3BhcnNlU3RyaW5nKHlpZWxkIHRoaXMuY2FsbCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0bzogcmVzb2x2ZXJBZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogKFwiMHg2OTFmMzQzMVwiICsgbmFtZWhhc2gobm9kZSkuc3Vic3RyaW5nKDIpKVxuICAgICAgICAgICAgICAgICAgICB9KSwgMCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmVyID0geWllbGQgdGhpcy5nZXRSZXNvbHZlcihuYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvci5jb2RlICE9PSBMb2dnZXIuZXJyb3JzLkNBTExfRVhDRVBUSU9OKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBFTlMgbmFtZTsgZm9yd2FyZCBsb29rdXAgd2l0aCB3aWxkY2FyZFxuICAgICAgICAgICAgICAgIHJlc29sdmVyID0geWllbGQgdGhpcy5nZXRSZXNvbHZlcihuYW1lT3JBZGRyZXNzKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc29sdmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGF2YXRhciA9IHlpZWxkIHJlc29sdmVyLmdldEF2YXRhcigpO1xuICAgICAgICAgICAgaWYgKGF2YXRhciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXZhdGFyLnVybDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHBlcmZvcm0obWV0aG9kLCBwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0Vycm9yKG1ldGhvZCArIFwiIG5vdCBpbXBsZW1lbnRlZFwiLCBMb2dnZXIuZXJyb3JzLk5PVF9JTVBMRU1FTlRFRCwgeyBvcGVyYXRpb246IG1ldGhvZCB9KTtcbiAgICB9XG4gICAgX3N0YXJ0RXZlbnQoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5wb2xsaW5nID0gKHRoaXMuX2V2ZW50cy5maWx0ZXIoKGUpID0+IGUucG9sbGFibGUoKSkubGVuZ3RoID4gMCk7XG4gICAgfVxuICAgIF9zdG9wRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5wb2xsaW5nID0gKHRoaXMuX2V2ZW50cy5maWx0ZXIoKGUpID0+IGUucG9sbGFibGUoKSkubGVuZ3RoID4gMCk7XG4gICAgfVxuICAgIF9hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIsIG9uY2UpIHtcbiAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgRXZlbnQoZ2V0RXZlbnRUYWcoZXZlbnROYW1lKSwgbGlzdGVuZXIsIG9uY2UpO1xuICAgICAgICB0aGlzLl9ldmVudHMucHVzaChldmVudCk7XG4gICAgICAgIHRoaXMuX3N0YXJ0RXZlbnQoZXZlbnQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgb24oZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyLCBmYWxzZSk7XG4gICAgfVxuICAgIG9uY2UoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyLCB0cnVlKTtcbiAgICB9XG4gICAgZW1pdChldmVudE5hbWUsIC4uLmFyZ3MpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICBsZXQgc3RvcHBlZCA9IFtdO1xuICAgICAgICBsZXQgZXZlbnRUYWcgPSBnZXRFdmVudFRhZyhldmVudE5hbWUpO1xuICAgICAgICB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMuZmlsdGVyKChldmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnRhZyAhPT0gZXZlbnRUYWcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGV2ZW50Lmxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICByZXN1bHQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKGV2ZW50Lm9uY2UpIHtcbiAgICAgICAgICAgICAgICBzdG9wcGVkLnB1c2goZXZlbnQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgICAgc3RvcHBlZC5mb3JFYWNoKChldmVudCkgPT4geyB0aGlzLl9zdG9wRXZlbnQoZXZlbnQpOyB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgbGlzdGVuZXJDb3VudChldmVudE5hbWUpIHtcbiAgICAgICAgaWYgKCFldmVudE5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9ldmVudHMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGxldCBldmVudFRhZyA9IGdldEV2ZW50VGFnKGV2ZW50TmFtZSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9ldmVudHMuZmlsdGVyKChldmVudCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIChldmVudC50YWcgPT09IGV2ZW50VGFnKTtcbiAgICAgICAgfSkubGVuZ3RoO1xuICAgIH1cbiAgICBsaXN0ZW5lcnMoZXZlbnROYW1lKSB7XG4gICAgICAgIGlmIChldmVudE5hbWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2V2ZW50cy5tYXAoKGV2ZW50KSA9PiBldmVudC5saXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGV2ZW50VGFnID0gZ2V0RXZlbnRUYWcoZXZlbnROYW1lKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2V2ZW50c1xuICAgICAgICAgICAgLmZpbHRlcigoZXZlbnQpID0+IChldmVudC50YWcgPT09IGV2ZW50VGFnKSlcbiAgICAgICAgICAgIC5tYXAoKGV2ZW50KSA9PiBldmVudC5saXN0ZW5lcik7XG4gICAgfVxuICAgIG9mZihldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgICAgIGlmIChsaXN0ZW5lciA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnROYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdG9wcGVkID0gW107XG4gICAgICAgIGxldCBmb3VuZCA9IGZhbHNlO1xuICAgICAgICBsZXQgZXZlbnRUYWcgPSBnZXRFdmVudFRhZyhldmVudE5hbWUpO1xuICAgICAgICB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMuZmlsdGVyKChldmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnRhZyAhPT0gZXZlbnRUYWcgfHwgZXZlbnQubGlzdGVuZXIgIT0gbGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmb3VuZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgc3RvcHBlZC5wdXNoKGV2ZW50KTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHN0b3BwZWQuZm9yRWFjaCgoZXZlbnQpID0+IHsgdGhpcy5fc3RvcEV2ZW50KGV2ZW50KTsgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnROYW1lKSB7XG4gICAgICAgIGxldCBzdG9wcGVkID0gW107XG4gICAgICAgIGlmIChldmVudE5hbWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgc3RvcHBlZCA9IHRoaXMuX2V2ZW50cztcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZXZlbnRUYWcgPSBnZXRFdmVudFRhZyhldmVudE5hbWUpO1xuICAgICAgICAgICAgdGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzLmZpbHRlcigoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQudGFnICE9PSBldmVudFRhZykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RvcHBlZC5wdXNoKGV2ZW50KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzdG9wcGVkLmZvckVhY2goKGV2ZW50KSA9PiB7IHRoaXMuX3N0b3BFdmVudChldmVudCk7IH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYXNlLXByb3ZpZGVyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ethersproject/providers/lib.esm/base-provider.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@ethersproject/providers/lib.esm/cloudflare-provider.js":
/*!*******************************************************************************!*\
  !*** ../node_modules/@ethersproject/providers/lib.esm/cloudflare-provider.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CloudflareProvider: () => (/* binding */ CloudflareProvider)\n/* harmony export */ });\n/* harmony import */ var _url_json_rpc_provider__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./url-json-rpc-provider */ \"(ssr)/../node_modules/@ethersproject/providers/lib.esm/url-json-rpc-provider.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/../node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(ssr)/../node_modules/@ethersproject/providers/lib.esm/_version.js\");\n\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\nclass CloudflareProvider extends _url_json_rpc_provider__WEBPACK_IMPORTED_MODULE_2__.UrlJsonRpcProvider {\n    static getApiKey(apiKey) {\n        if (apiKey != null) {\n            logger.throwArgumentError(\"apiKey not supported for cloudflare\", \"apiKey\", apiKey);\n        }\n        return null;\n    }\n    static getUrl(network, apiKey) {\n        let host = null;\n        switch (network.name) {\n            case \"homestead\":\n                host = \"https://cloudflare-eth.com/\";\n                break;\n            default:\n                logger.throwArgumentError(\"unsupported network\", \"network\", arguments[0]);\n        }\n        return host;\n    }\n    perform(method, params) {\n        const _super = Object.create(null, {\n            perform: { get: () => super.perform }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            // The Cloudflare provider does not support eth_blockNumber,\n            // so we get the latest block and pull it from that\n            if (method === \"getBlockNumber\") {\n                const block = yield _super.perform.call(this, \"getBlock\", { blockTag: \"latest\" });\n                return block.number;\n            }\n            return _super.perform.call(this, method, params);\n        });\n    }\n}\n//# sourceMappingURL=cloudflare-provider.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3Byb3ZpZGVycy9saWIuZXNtL2Nsb3VkZmxhcmUtcHJvdmlkZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFhO0FBQ2IsaUJBQWlCLFNBQUksSUFBSSxTQUFJO0FBQzdCLDRCQUE0QiwrREFBK0QsaUJBQWlCO0FBQzVHO0FBQ0Esb0NBQW9DLE1BQU0sK0JBQStCLFlBQVk7QUFDckYsbUNBQW1DLE1BQU0sbUNBQW1DLFlBQVk7QUFDeEYsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMO0FBQzZEO0FBQ2Q7QUFDVjtBQUNyQyxtQkFBbUIseURBQU0sQ0FBQyw2Q0FBTztBQUMxQixpQ0FBaUMsc0VBQWtCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSxvQkFBb0I7QUFDaEc7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xlZGdpdHkteWllbGQtZnJvbnRlbmQvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3Byb3ZpZGVycy9saWIuZXNtL2Nsb3VkZmxhcmUtcHJvdmlkZXIuanM/ZjUxNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuaW1wb3J0IHsgVXJsSnNvblJwY1Byb3ZpZGVyIH0gZnJvbSBcIi4vdXJsLWpzb24tcnBjLXByb3ZpZGVyXCI7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvbG9nZ2VyXCI7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4vX3ZlcnNpb25cIjtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIodmVyc2lvbik7XG5leHBvcnQgY2xhc3MgQ2xvdWRmbGFyZVByb3ZpZGVyIGV4dGVuZHMgVXJsSnNvblJwY1Byb3ZpZGVyIHtcbiAgICBzdGF0aWMgZ2V0QXBpS2V5KGFwaUtleSkge1xuICAgICAgICBpZiAoYXBpS2V5ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJhcGlLZXkgbm90IHN1cHBvcnRlZCBmb3IgY2xvdWRmbGFyZVwiLCBcImFwaUtleVwiLCBhcGlLZXkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0VXJsKG5ldHdvcmssIGFwaUtleSkge1xuICAgICAgICBsZXQgaG9zdCA9IG51bGw7XG4gICAgICAgIHN3aXRjaCAobmV0d29yay5uYW1lKSB7XG4gICAgICAgICAgICBjYXNlIFwiaG9tZXN0ZWFkXCI6XG4gICAgICAgICAgICAgICAgaG9zdCA9IFwiaHR0cHM6Ly9jbG91ZGZsYXJlLWV0aC5jb20vXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ1bnN1cHBvcnRlZCBuZXR3b3JrXCIsIFwibmV0d29ya1wiLCBhcmd1bWVudHNbMF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBob3N0O1xuICAgIH1cbiAgICBwZXJmb3JtKG1ldGhvZCwgcGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IF9zdXBlciA9IE9iamVjdC5jcmVhdGUobnVsbCwge1xuICAgICAgICAgICAgcGVyZm9ybTogeyBnZXQ6ICgpID0+IHN1cGVyLnBlcmZvcm0gfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIC8vIFRoZSBDbG91ZGZsYXJlIHByb3ZpZGVyIGRvZXMgbm90IHN1cHBvcnQgZXRoX2Jsb2NrTnVtYmVyLFxuICAgICAgICAgICAgLy8gc28gd2UgZ2V0IHRoZSBsYXRlc3QgYmxvY2sgYW5kIHB1bGwgaXQgZnJvbSB0aGF0XG4gICAgICAgICAgICBpZiAobWV0aG9kID09PSBcImdldEJsb2NrTnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBibG9jayA9IHlpZWxkIF9zdXBlci5wZXJmb3JtLmNhbGwodGhpcywgXCJnZXRCbG9ja1wiLCB7IGJsb2NrVGFnOiBcImxhdGVzdFwiIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBibG9jay5udW1iZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX3N1cGVyLnBlcmZvcm0uY2FsbCh0aGlzLCBtZXRob2QsIHBhcmFtcyk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNsb3VkZmxhcmUtcHJvdmlkZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ethersproject/providers/lib.esm/cloudflare-provider.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@ethersproject/providers/lib.esm/etherscan-provider.js":
/*!******************************************************************************!*\
  !*** ../node_modules/@ethersproject/providers/lib.esm/etherscan-provider.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EtherscanProvider: () => (/* binding */ EtherscanProvider)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/../node_modules/@ethersproject/bytes/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/../node_modules/@ethersproject/properties/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_transactions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/transactions */ \"(ssr)/../node_modules/@ethersproject/transactions/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_web__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @ethersproject/web */ \"(ssr)/../node_modules/@ethersproject/web/lib.esm/index.js\");\n/* harmony import */ var _formatter__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./formatter */ \"(ssr)/../node_modules/@ethersproject/providers/lib.esm/formatter.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/../node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(ssr)/../node_modules/@ethersproject/providers/lib.esm/_version.js\");\n/* harmony import */ var _base_provider__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./base-provider */ \"(ssr)/../node_modules/@ethersproject/providers/lib.esm/base-provider.js\");\n\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\n\n// The transaction has already been sanitized by the calls in Provider\nfunction getTransactionPostData(transaction) {\n    const result = {};\n    for (let key in transaction) {\n        if (transaction[key] == null) {\n            continue;\n        }\n        let value = transaction[key];\n        if (key === \"type\" && value === 0) {\n            continue;\n        }\n        // Quantity-types require no leading zero, unless 0\n        if ({ type: true, gasLimit: true, gasPrice: true, maxFeePerGs: true, maxPriorityFeePerGas: true, nonce: true, value: true }[key]) {\n            value = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.hexValue)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.hexlify)(value));\n        }\n        else if (key === \"accessList\") {\n            value = \"[\" + (0,_ethersproject_transactions__WEBPACK_IMPORTED_MODULE_3__.accessListify)(value).map((set) => {\n                return `{address:\"${set.address}\",storageKeys:[\"${set.storageKeys.join('\",\"')}\"]}`;\n            }).join(\",\") + \"]\";\n        }\n        else {\n            value = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.hexlify)(value);\n        }\n        result[key] = value;\n    }\n    return result;\n}\nfunction getResult(result) {\n    // getLogs, getHistory have weird success responses\n    if (result.status == 0 && (result.message === \"No records found\" || result.message === \"No transactions found\")) {\n        return result.result;\n    }\n    if (result.status != 1 || typeof (result.message) !== \"string\" || !result.message.match(/^OK/)) {\n        const error = new Error(\"invalid response\");\n        error.result = JSON.stringify(result);\n        if ((result.result || \"\").toLowerCase().indexOf(\"rate limit\") >= 0) {\n            error.throttleRetry = true;\n        }\n        throw error;\n    }\n    return result.result;\n}\nfunction getJsonResult(result) {\n    // This response indicates we are being throttled\n    if (result && result.status == 0 && result.message == \"NOTOK\" && (result.result || \"\").toLowerCase().indexOf(\"rate limit\") >= 0) {\n        const error = new Error(\"throttled response\");\n        error.result = JSON.stringify(result);\n        error.throttleRetry = true;\n        throw error;\n    }\n    if (result.jsonrpc != \"2.0\") {\n        // @TODO: not any\n        const error = new Error(\"invalid response\");\n        error.result = JSON.stringify(result);\n        throw error;\n    }\n    if (result.error) {\n        // @TODO: not any\n        const error = new Error(result.error.message || \"unknown error\");\n        if (result.error.code) {\n            error.code = result.error.code;\n        }\n        if (result.error.data) {\n            error.data = result.error.data;\n        }\n        throw error;\n    }\n    return result.result;\n}\n// The blockTag was normalized as a string by the Provider pre-perform operations\nfunction checkLogTag(blockTag) {\n    if (blockTag === \"pending\") {\n        throw new Error(\"pending not supported\");\n    }\n    if (blockTag === \"latest\") {\n        return blockTag;\n    }\n    return parseInt(blockTag.substring(2), 16);\n}\nfunction checkError(method, error, transaction) {\n    // Undo the \"convenience\" some nodes are attempting to prevent backwards\n    // incompatibility; maybe for v6 consider forwarding reverts as errors\n    if (method === \"call\" && error.code === _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.SERVER_ERROR) {\n        const e = error.error;\n        // Etherscan keeps changing their string\n        if (e && (e.message.match(/reverted/i) || e.message.match(/VM execution error/i))) {\n            // Etherscan prefixes the data like \"Reverted 0x1234\"\n            let data = e.data;\n            if (data) {\n                data = \"0x\" + data.replace(/^.*0x/i, \"\");\n            }\n            if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.isHexString)(data)) {\n                return data;\n            }\n            logger.throwError(\"missing revert data in call exception\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.CALL_EXCEPTION, {\n                error, data: \"0x\"\n            });\n        }\n    }\n    // Get the message from any nested error structure\n    let message = error.message;\n    if (error.code === _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.SERVER_ERROR) {\n        if (error.error && typeof (error.error.message) === \"string\") {\n            message = error.error.message;\n        }\n        else if (typeof (error.body) === \"string\") {\n            message = error.body;\n        }\n        else if (typeof (error.responseText) === \"string\") {\n            message = error.responseText;\n        }\n    }\n    message = (message || \"\").toLowerCase();\n    // \"Insufficient funds. The account you tried to send transaction from does not have enough funds. Required 21464000000000 and got: 0\"\n    if (message.match(/insufficient funds/)) {\n        logger.throwError(\"insufficient funds for intrinsic transaction cost\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.INSUFFICIENT_FUNDS, {\n            error, method, transaction\n        });\n    }\n    // \"Transaction with the same hash was already imported.\"\n    if (message.match(/same hash was already imported|transaction nonce is too low|nonce too low/)) {\n        logger.throwError(\"nonce has already been used\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.NONCE_EXPIRED, {\n            error, method, transaction\n        });\n    }\n    // \"Transaction gas price is too low. There is another transaction with same nonce in the queue. Try increasing the gas price or incrementing the nonce.\"\n    if (message.match(/another transaction with same nonce/)) {\n        logger.throwError(\"replacement fee too low\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.REPLACEMENT_UNDERPRICED, {\n            error, method, transaction\n        });\n    }\n    if (message.match(/execution failed due to an exception|execution reverted/)) {\n        logger.throwError(\"cannot estimate gas; transaction may fail or may require manual gas limit\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNPREDICTABLE_GAS_LIMIT, {\n            error, method, transaction\n        });\n    }\n    throw error;\n}\nclass EtherscanProvider extends _base_provider__WEBPACK_IMPORTED_MODULE_4__.BaseProvider {\n    constructor(network, apiKey) {\n        super(network);\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.defineReadOnly)(this, \"baseUrl\", this.getBaseUrl());\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.defineReadOnly)(this, \"apiKey\", apiKey || null);\n    }\n    getBaseUrl() {\n        switch (this.network ? this.network.name : \"invalid\") {\n            case \"homestead\":\n                return \"https:/\\/api.etherscan.io\";\n            case \"goerli\":\n                return \"https:/\\/api-goerli.etherscan.io\";\n            case \"sepolia\":\n                return \"https:/\\/api-sepolia.etherscan.io\";\n            case \"matic\":\n                return \"https:/\\/api.polygonscan.com\";\n            case \"maticmum\":\n                return \"https:/\\/api-testnet.polygonscan.com\";\n            case \"arbitrum\":\n                return \"https:/\\/api.arbiscan.io\";\n            case \"arbitrum-goerli\":\n                return \"https:/\\/api-goerli.arbiscan.io\";\n            case \"optimism\":\n                return \"https:/\\/api-optimistic.etherscan.io\";\n            case \"optimism-goerli\":\n                return \"https:/\\/api-goerli-optimistic.etherscan.io\";\n            default:\n        }\n        return logger.throwArgumentError(\"unsupported network\", \"network\", this.network.name);\n    }\n    getUrl(module, params) {\n        const query = Object.keys(params).reduce((accum, key) => {\n            const value = params[key];\n            if (value != null) {\n                accum += `&${key}=${value}`;\n            }\n            return accum;\n        }, \"\");\n        const apiKey = ((this.apiKey) ? `&apikey=${this.apiKey}` : \"\");\n        return `${this.baseUrl}/api?module=${module}${query}${apiKey}`;\n    }\n    getPostUrl() {\n        return `${this.baseUrl}/api`;\n    }\n    getPostData(module, params) {\n        params.module = module;\n        params.apikey = this.apiKey;\n        return params;\n    }\n    fetch(module, params, post) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const url = (post ? this.getPostUrl() : this.getUrl(module, params));\n            const payload = (post ? this.getPostData(module, params) : null);\n            const procFunc = (module === \"proxy\") ? getJsonResult : getResult;\n            this.emit(\"debug\", {\n                action: \"request\",\n                request: url,\n                provider: this\n            });\n            const connection = {\n                url: url,\n                throttleSlotInterval: 1000,\n                throttleCallback: (attempt, url) => {\n                    if (this.isCommunityResource()) {\n                        (0,_formatter__WEBPACK_IMPORTED_MODULE_6__.showThrottleMessage)();\n                    }\n                    return Promise.resolve(true);\n                }\n            };\n            let payloadStr = null;\n            if (payload) {\n                connection.headers = { \"content-type\": \"application/x-www-form-urlencoded; charset=UTF-8\" };\n                payloadStr = Object.keys(payload).map((key) => {\n                    return `${key}=${payload[key]}`;\n                }).join(\"&\");\n            }\n            const result = yield (0,_ethersproject_web__WEBPACK_IMPORTED_MODULE_7__.fetchJson)(connection, payloadStr, procFunc || getJsonResult);\n            this.emit(\"debug\", {\n                action: \"response\",\n                request: url,\n                response: (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.deepCopy)(result),\n                provider: this\n            });\n            return result;\n        });\n    }\n    detectNetwork() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.network;\n        });\n    }\n    perform(method, params) {\n        const _super = Object.create(null, {\n            perform: { get: () => super.perform }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            switch (method) {\n                case \"getBlockNumber\":\n                    return this.fetch(\"proxy\", { action: \"eth_blockNumber\" });\n                case \"getGasPrice\":\n                    return this.fetch(\"proxy\", { action: \"eth_gasPrice\" });\n                case \"getBalance\":\n                    // Returns base-10 result\n                    return this.fetch(\"account\", {\n                        action: \"balance\",\n                        address: params.address,\n                        tag: params.blockTag\n                    });\n                case \"getTransactionCount\":\n                    return this.fetch(\"proxy\", {\n                        action: \"eth_getTransactionCount\",\n                        address: params.address,\n                        tag: params.blockTag\n                    });\n                case \"getCode\":\n                    return this.fetch(\"proxy\", {\n                        action: \"eth_getCode\",\n                        address: params.address,\n                        tag: params.blockTag\n                    });\n                case \"getStorageAt\":\n                    return this.fetch(\"proxy\", {\n                        action: \"eth_getStorageAt\",\n                        address: params.address,\n                        position: params.position,\n                        tag: params.blockTag\n                    });\n                case \"sendTransaction\":\n                    return this.fetch(\"proxy\", {\n                        action: \"eth_sendRawTransaction\",\n                        hex: params.signedTransaction\n                    }, true).catch((error) => {\n                        return checkError(\"sendTransaction\", error, params.signedTransaction);\n                    });\n                case \"getBlock\":\n                    if (params.blockTag) {\n                        return this.fetch(\"proxy\", {\n                            action: \"eth_getBlockByNumber\",\n                            tag: params.blockTag,\n                            boolean: (params.includeTransactions ? \"true\" : \"false\")\n                        });\n                    }\n                    throw new Error(\"getBlock by blockHash not implemented\");\n                case \"getTransaction\":\n                    return this.fetch(\"proxy\", {\n                        action: \"eth_getTransactionByHash\",\n                        txhash: params.transactionHash\n                    });\n                case \"getTransactionReceipt\":\n                    return this.fetch(\"proxy\", {\n                        action: \"eth_getTransactionReceipt\",\n                        txhash: params.transactionHash\n                    });\n                case \"call\": {\n                    if (params.blockTag !== \"latest\") {\n                        throw new Error(\"EtherscanProvider does not support blockTag for call\");\n                    }\n                    const postData = getTransactionPostData(params.transaction);\n                    postData.module = \"proxy\";\n                    postData.action = \"eth_call\";\n                    try {\n                        return yield this.fetch(\"proxy\", postData, true);\n                    }\n                    catch (error) {\n                        return checkError(\"call\", error, params.transaction);\n                    }\n                }\n                case \"estimateGas\": {\n                    const postData = getTransactionPostData(params.transaction);\n                    postData.module = \"proxy\";\n                    postData.action = \"eth_estimateGas\";\n                    try {\n                        return yield this.fetch(\"proxy\", postData, true);\n                    }\n                    catch (error) {\n                        return checkError(\"estimateGas\", error, params.transaction);\n                    }\n                }\n                case \"getLogs\": {\n                    const args = { action: \"getLogs\" };\n                    if (params.filter.fromBlock) {\n                        args.fromBlock = checkLogTag(params.filter.fromBlock);\n                    }\n                    if (params.filter.toBlock) {\n                        args.toBlock = checkLogTag(params.filter.toBlock);\n                    }\n                    if (params.filter.address) {\n                        args.address = params.filter.address;\n                    }\n                    // @TODO: We can handle slightly more complicated logs using the logs API\n                    if (params.filter.topics && params.filter.topics.length > 0) {\n                        if (params.filter.topics.length > 1) {\n                            logger.throwError(\"unsupported topic count\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, { topics: params.filter.topics });\n                        }\n                        if (params.filter.topics.length === 1) {\n                            const topic0 = params.filter.topics[0];\n                            if (typeof (topic0) !== \"string\" || topic0.length !== 66) {\n                                logger.throwError(\"unsupported topic format\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, { topic0: topic0 });\n                            }\n                            args.topic0 = topic0;\n                        }\n                    }\n                    const logs = yield this.fetch(\"logs\", args);\n                    // Cache txHash => blockHash\n                    let blocks = {};\n                    // Add any missing blockHash to the logs\n                    for (let i = 0; i < logs.length; i++) {\n                        const log = logs[i];\n                        if (log.blockHash != null) {\n                            continue;\n                        }\n                        if (blocks[log.blockNumber] == null) {\n                            const block = yield this.getBlock(log.blockNumber);\n                            if (block) {\n                                blocks[log.blockNumber] = block.hash;\n                            }\n                        }\n                        log.blockHash = blocks[log.blockNumber];\n                    }\n                    return logs;\n                }\n                case \"getEtherPrice\":\n                    if (this.network.name !== \"homestead\") {\n                        return 0.0;\n                    }\n                    return parseFloat((yield this.fetch(\"stats\", { action: \"ethprice\" })).ethusd);\n                default:\n                    break;\n            }\n            return _super.perform.call(this, method, params);\n        });\n    }\n    // Note: The `page` page parameter only allows pagination within the\n    //       10,000 window available without a page and offset parameter\n    //       Error: Result window is too large, PageNo x Offset size must\n    //              be less than or equal to 10000\n    getHistory(addressOrName, startBlock, endBlock) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const params = {\n                action: \"txlist\",\n                address: (yield this.resolveName(addressOrName)),\n                startblock: ((startBlock == null) ? 0 : startBlock),\n                endblock: ((endBlock == null) ? 99999999 : endBlock),\n                sort: \"asc\"\n            };\n            const result = yield this.fetch(\"account\", params);\n            return result.map((tx) => {\n                [\"contractAddress\", \"to\"].forEach(function (key) {\n                    if (tx[key] == \"\") {\n                        delete tx[key];\n                    }\n                });\n                if (tx.creates == null && tx.contractAddress != null) {\n                    tx.creates = tx.contractAddress;\n                }\n                const item = this.formatter.transactionResponse(tx);\n                if (tx.timeStamp) {\n                    item.timestamp = parseInt(tx.timeStamp);\n                }\n                return item;\n            });\n        });\n    }\n    isCommunityResource() {\n        return (this.apiKey == null);\n    }\n}\n//# sourceMappingURL=etherscan-provider.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3Byb3ZpZGVycy9saWIuZXNtL2V0aGVyc2Nhbi1wcm92aWRlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBYTtBQUNiLGlCQUFpQixTQUFJLElBQUksU0FBSTtBQUM3Qiw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNzRTtBQUNEO0FBQ1Q7QUFDYjtBQUNHO0FBQ0g7QUFDVjtBQUNyQyxtQkFBbUIseURBQU0sQ0FBQyw2Q0FBTztBQUNjO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMscUhBQXFIO0FBQ25JLG9CQUFvQiw4REFBUSxDQUFDLDZEQUFPO0FBQ3BDO0FBQ0E7QUFDQSwwQkFBMEIsMEVBQWE7QUFDdkMseUJBQXlCLFdBQVcsWUFBWSxrQkFBa0IsNEJBQTRCLEdBQUc7QUFDakcsYUFBYTtBQUNiO0FBQ0E7QUFDQSxvQkFBb0IsNkRBQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4Qiw0Q0FBNEMseURBQU07QUFD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LGlDQUFpQyxnQkFBZ0I7QUFDckk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxpQkFBaUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLG9CQUFvQjtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xlZGdpdHkteWllbGQtZnJvbnRlbmQvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3Byb3ZpZGVycy9saWIuZXNtL2V0aGVyc2Nhbi1wcm92aWRlci5qcz9kYjE4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5pbXBvcnQgeyBoZXhsaWZ5LCBoZXhWYWx1ZSwgaXNIZXhTdHJpbmcgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYnl0ZXNcIjtcbmltcG9ydCB7IGRlZXBDb3B5LCBkZWZpbmVSZWFkT25seSB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9wcm9wZXJ0aWVzXCI7XG5pbXBvcnQgeyBhY2Nlc3NMaXN0aWZ5IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3RyYW5zYWN0aW9uc1wiO1xuaW1wb3J0IHsgZmV0Y2hKc29uIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3dlYlwiO1xuaW1wb3J0IHsgc2hvd1Rocm90dGxlTWVzc2FnZSB9IGZyb20gXCIuL2Zvcm1hdHRlclwiO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2xvZ2dlclwiO1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gXCIuL192ZXJzaW9uXCI7XG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyKHZlcnNpb24pO1xuaW1wb3J0IHsgQmFzZVByb3ZpZGVyIH0gZnJvbSBcIi4vYmFzZS1wcm92aWRlclwiO1xuLy8gVGhlIHRyYW5zYWN0aW9uIGhhcyBhbHJlYWR5IGJlZW4gc2FuaXRpemVkIGJ5IHRoZSBjYWxscyBpbiBQcm92aWRlclxuZnVuY3Rpb24gZ2V0VHJhbnNhY3Rpb25Qb3N0RGF0YSh0cmFuc2FjdGlvbikge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGZvciAobGV0IGtleSBpbiB0cmFuc2FjdGlvbikge1xuICAgICAgICBpZiAodHJhbnNhY3Rpb25ba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdmFsdWUgPSB0cmFuc2FjdGlvbltrZXldO1xuICAgICAgICBpZiAoa2V5ID09PSBcInR5cGVcIiAmJiB2YWx1ZSA9PT0gMCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUXVhbnRpdHktdHlwZXMgcmVxdWlyZSBubyBsZWFkaW5nIHplcm8sIHVubGVzcyAwXG4gICAgICAgIGlmICh7IHR5cGU6IHRydWUsIGdhc0xpbWl0OiB0cnVlLCBnYXNQcmljZTogdHJ1ZSwgbWF4RmVlUGVyR3M6IHRydWUsIG1heFByaW9yaXR5RmVlUGVyR2FzOiB0cnVlLCBub25jZTogdHJ1ZSwgdmFsdWU6IHRydWUgfVtrZXldKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGhleFZhbHVlKGhleGxpZnkodmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChrZXkgPT09IFwiYWNjZXNzTGlzdFwiKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IFwiW1wiICsgYWNjZXNzTGlzdGlmeSh2YWx1ZSkubWFwKChzZXQpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYHthZGRyZXNzOlwiJHtzZXQuYWRkcmVzc31cIixzdG9yYWdlS2V5czpbXCIke3NldC5zdG9yYWdlS2V5cy5qb2luKCdcIixcIicpfVwiXX1gO1xuICAgICAgICAgICAgfSkuam9pbihcIixcIikgKyBcIl1cIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlID0gaGV4bGlmeSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGdldFJlc3VsdChyZXN1bHQpIHtcbiAgICAvLyBnZXRMb2dzLCBnZXRIaXN0b3J5IGhhdmUgd2VpcmQgc3VjY2VzcyByZXNwb25zZXNcbiAgICBpZiAocmVzdWx0LnN0YXR1cyA9PSAwICYmIChyZXN1bHQubWVzc2FnZSA9PT0gXCJObyByZWNvcmRzIGZvdW5kXCIgfHwgcmVzdWx0Lm1lc3NhZ2UgPT09IFwiTm8gdHJhbnNhY3Rpb25zIGZvdW5kXCIpKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQucmVzdWx0O1xuICAgIH1cbiAgICBpZiAocmVzdWx0LnN0YXR1cyAhPSAxIHx8IHR5cGVvZiAocmVzdWx0Lm1lc3NhZ2UpICE9PSBcInN0cmluZ1wiIHx8ICFyZXN1bHQubWVzc2FnZS5tYXRjaCgvXk9LLykpIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoXCJpbnZhbGlkIHJlc3BvbnNlXCIpO1xuICAgICAgICBlcnJvci5yZXN1bHQgPSBKU09OLnN0cmluZ2lmeShyZXN1bHQpO1xuICAgICAgICBpZiAoKHJlc3VsdC5yZXN1bHQgfHwgXCJcIikudG9Mb3dlckNhc2UoKS5pbmRleE9mKFwicmF0ZSBsaW1pdFwiKSA+PSAwKSB7XG4gICAgICAgICAgICBlcnJvci50aHJvdHRsZVJldHJ5ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdC5yZXN1bHQ7XG59XG5mdW5jdGlvbiBnZXRKc29uUmVzdWx0KHJlc3VsdCkge1xuICAgIC8vIFRoaXMgcmVzcG9uc2UgaW5kaWNhdGVzIHdlIGFyZSBiZWluZyB0aHJvdHRsZWRcbiAgICBpZiAocmVzdWx0ICYmIHJlc3VsdC5zdGF0dXMgPT0gMCAmJiByZXN1bHQubWVzc2FnZSA9PSBcIk5PVE9LXCIgJiYgKHJlc3VsdC5yZXN1bHQgfHwgXCJcIikudG9Mb3dlckNhc2UoKS5pbmRleE9mKFwicmF0ZSBsaW1pdFwiKSA+PSAwKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKFwidGhyb3R0bGVkIHJlc3BvbnNlXCIpO1xuICAgICAgICBlcnJvci5yZXN1bHQgPSBKU09OLnN0cmluZ2lmeShyZXN1bHQpO1xuICAgICAgICBlcnJvci50aHJvdHRsZVJldHJ5ID0gdHJ1ZTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIGlmIChyZXN1bHQuanNvbnJwYyAhPSBcIjIuMFwiKSB7XG4gICAgICAgIC8vIEBUT0RPOiBub3QgYW55XG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKFwiaW52YWxpZCByZXNwb25zZVwiKTtcbiAgICAgICAgZXJyb3IucmVzdWx0ID0gSlNPTi5zdHJpbmdpZnkocmVzdWx0KTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIGlmIChyZXN1bHQuZXJyb3IpIHtcbiAgICAgICAgLy8gQFRPRE86IG5vdCBhbnlcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IocmVzdWx0LmVycm9yLm1lc3NhZ2UgfHwgXCJ1bmtub3duIGVycm9yXCIpO1xuICAgICAgICBpZiAocmVzdWx0LmVycm9yLmNvZGUpIHtcbiAgICAgICAgICAgIGVycm9yLmNvZGUgPSByZXN1bHQuZXJyb3IuY29kZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0LmVycm9yLmRhdGEpIHtcbiAgICAgICAgICAgIGVycm9yLmRhdGEgPSByZXN1bHQuZXJyb3IuZGF0YTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdC5yZXN1bHQ7XG59XG4vLyBUaGUgYmxvY2tUYWcgd2FzIG5vcm1hbGl6ZWQgYXMgYSBzdHJpbmcgYnkgdGhlIFByb3ZpZGVyIHByZS1wZXJmb3JtIG9wZXJhdGlvbnNcbmZ1bmN0aW9uIGNoZWNrTG9nVGFnKGJsb2NrVGFnKSB7XG4gICAgaWYgKGJsb2NrVGFnID09PSBcInBlbmRpbmdcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJwZW5kaW5nIG5vdCBzdXBwb3J0ZWRcIik7XG4gICAgfVxuICAgIGlmIChibG9ja1RhZyA9PT0gXCJsYXRlc3RcIikge1xuICAgICAgICByZXR1cm4gYmxvY2tUYWc7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZUludChibG9ja1RhZy5zdWJzdHJpbmcoMiksIDE2KTtcbn1cbmZ1bmN0aW9uIGNoZWNrRXJyb3IobWV0aG9kLCBlcnJvciwgdHJhbnNhY3Rpb24pIHtcbiAgICAvLyBVbmRvIHRoZSBcImNvbnZlbmllbmNlXCIgc29tZSBub2RlcyBhcmUgYXR0ZW1wdGluZyB0byBwcmV2ZW50IGJhY2t3YXJkc1xuICAgIC8vIGluY29tcGF0aWJpbGl0eTsgbWF5YmUgZm9yIHY2IGNvbnNpZGVyIGZvcndhcmRpbmcgcmV2ZXJ0cyBhcyBlcnJvcnNcbiAgICBpZiAobWV0aG9kID09PSBcImNhbGxcIiAmJiBlcnJvci5jb2RlID09PSBMb2dnZXIuZXJyb3JzLlNFUlZFUl9FUlJPUikge1xuICAgICAgICBjb25zdCBlID0gZXJyb3IuZXJyb3I7XG4gICAgICAgIC8vIEV0aGVyc2NhbiBrZWVwcyBjaGFuZ2luZyB0aGVpciBzdHJpbmdcbiAgICAgICAgaWYgKGUgJiYgKGUubWVzc2FnZS5tYXRjaCgvcmV2ZXJ0ZWQvaSkgfHwgZS5tZXNzYWdlLm1hdGNoKC9WTSBleGVjdXRpb24gZXJyb3IvaSkpKSB7XG4gICAgICAgICAgICAvLyBFdGhlcnNjYW4gcHJlZml4ZXMgdGhlIGRhdGEgbGlrZSBcIlJldmVydGVkIDB4MTIzNFwiXG4gICAgICAgICAgICBsZXQgZGF0YSA9IGUuZGF0YTtcbiAgICAgICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IFwiMHhcIiArIGRhdGEucmVwbGFjZSgvXi4qMHgvaSwgXCJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNIZXhTdHJpbmcoZGF0YSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwibWlzc2luZyByZXZlcnQgZGF0YSBpbiBjYWxsIGV4Y2VwdGlvblwiLCBMb2dnZXIuZXJyb3JzLkNBTExfRVhDRVBUSU9OLCB7XG4gICAgICAgICAgICAgICAgZXJyb3IsIGRhdGE6IFwiMHhcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gR2V0IHRoZSBtZXNzYWdlIGZyb20gYW55IG5lc3RlZCBlcnJvciBzdHJ1Y3R1cmVcbiAgICBsZXQgbWVzc2FnZSA9IGVycm9yLm1lc3NhZ2U7XG4gICAgaWYgKGVycm9yLmNvZGUgPT09IExvZ2dlci5lcnJvcnMuU0VSVkVSX0VSUk9SKSB7XG4gICAgICAgIGlmIChlcnJvci5lcnJvciAmJiB0eXBlb2YgKGVycm9yLmVycm9yLm1lc3NhZ2UpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gZXJyb3IuZXJyb3IubWVzc2FnZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgKGVycm9yLmJvZHkpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gZXJyb3IuYm9keTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgKGVycm9yLnJlc3BvbnNlVGV4dCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBlcnJvci5yZXNwb25zZVRleHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbWVzc2FnZSA9IChtZXNzYWdlIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCk7XG4gICAgLy8gXCJJbnN1ZmZpY2llbnQgZnVuZHMuIFRoZSBhY2NvdW50IHlvdSB0cmllZCB0byBzZW5kIHRyYW5zYWN0aW9uIGZyb20gZG9lcyBub3QgaGF2ZSBlbm91Z2ggZnVuZHMuIFJlcXVpcmVkIDIxNDY0MDAwMDAwMDAwIGFuZCBnb3Q6IDBcIlxuICAgIGlmIChtZXNzYWdlLm1hdGNoKC9pbnN1ZmZpY2llbnQgZnVuZHMvKSkge1xuICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImluc3VmZmljaWVudCBmdW5kcyBmb3IgaW50cmluc2ljIHRyYW5zYWN0aW9uIGNvc3RcIiwgTG9nZ2VyLmVycm9ycy5JTlNVRkZJQ0lFTlRfRlVORFMsIHtcbiAgICAgICAgICAgIGVycm9yLCBtZXRob2QsIHRyYW5zYWN0aW9uXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBcIlRyYW5zYWN0aW9uIHdpdGggdGhlIHNhbWUgaGFzaCB3YXMgYWxyZWFkeSBpbXBvcnRlZC5cIlxuICAgIGlmIChtZXNzYWdlLm1hdGNoKC9zYW1lIGhhc2ggd2FzIGFscmVhZHkgaW1wb3J0ZWR8dHJhbnNhY3Rpb24gbm9uY2UgaXMgdG9vIGxvd3xub25jZSB0b28gbG93LykpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJub25jZSBoYXMgYWxyZWFkeSBiZWVuIHVzZWRcIiwgTG9nZ2VyLmVycm9ycy5OT05DRV9FWFBJUkVELCB7XG4gICAgICAgICAgICBlcnJvciwgbWV0aG9kLCB0cmFuc2FjdGlvblxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gXCJUcmFuc2FjdGlvbiBnYXMgcHJpY2UgaXMgdG9vIGxvdy4gVGhlcmUgaXMgYW5vdGhlciB0cmFuc2FjdGlvbiB3aXRoIHNhbWUgbm9uY2UgaW4gdGhlIHF1ZXVlLiBUcnkgaW5jcmVhc2luZyB0aGUgZ2FzIHByaWNlIG9yIGluY3JlbWVudGluZyB0aGUgbm9uY2UuXCJcbiAgICBpZiAobWVzc2FnZS5tYXRjaCgvYW5vdGhlciB0cmFuc2FjdGlvbiB3aXRoIHNhbWUgbm9uY2UvKSkge1xuICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcInJlcGxhY2VtZW50IGZlZSB0b28gbG93XCIsIExvZ2dlci5lcnJvcnMuUkVQTEFDRU1FTlRfVU5ERVJQUklDRUQsIHtcbiAgICAgICAgICAgIGVycm9yLCBtZXRob2QsIHRyYW5zYWN0aW9uXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAobWVzc2FnZS5tYXRjaCgvZXhlY3V0aW9uIGZhaWxlZCBkdWUgdG8gYW4gZXhjZXB0aW9ufGV4ZWN1dGlvbiByZXZlcnRlZC8pKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiY2Fubm90IGVzdGltYXRlIGdhczsgdHJhbnNhY3Rpb24gbWF5IGZhaWwgb3IgbWF5IHJlcXVpcmUgbWFudWFsIGdhcyBsaW1pdFwiLCBMb2dnZXIuZXJyb3JzLlVOUFJFRElDVEFCTEVfR0FTX0xJTUlULCB7XG4gICAgICAgICAgICBlcnJvciwgbWV0aG9kLCB0cmFuc2FjdGlvblxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdGhyb3cgZXJyb3I7XG59XG5leHBvcnQgY2xhc3MgRXRoZXJzY2FuUHJvdmlkZXIgZXh0ZW5kcyBCYXNlUHJvdmlkZXIge1xuICAgIGNvbnN0cnVjdG9yKG5ldHdvcmssIGFwaUtleSkge1xuICAgICAgICBzdXBlcihuZXR3b3JrKTtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJiYXNlVXJsXCIsIHRoaXMuZ2V0QmFzZVVybCgpKTtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJhcGlLZXlcIiwgYXBpS2V5IHx8IG51bGwpO1xuICAgIH1cbiAgICBnZXRCYXNlVXJsKCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMubmV0d29yayA/IHRoaXMubmV0d29yay5uYW1lIDogXCJpbnZhbGlkXCIpIHtcbiAgICAgICAgICAgIGNhc2UgXCJob21lc3RlYWRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJodHRwczovXFwvYXBpLmV0aGVyc2Nhbi5pb1wiO1xuICAgICAgICAgICAgY2FzZSBcImdvZXJsaVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBcImh0dHBzOi9cXC9hcGktZ29lcmxpLmV0aGVyc2Nhbi5pb1wiO1xuICAgICAgICAgICAgY2FzZSBcInNlcG9saWFcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJodHRwczovXFwvYXBpLXNlcG9saWEuZXRoZXJzY2FuLmlvXCI7XG4gICAgICAgICAgICBjYXNlIFwibWF0aWNcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJodHRwczovXFwvYXBpLnBvbHlnb25zY2FuLmNvbVwiO1xuICAgICAgICAgICAgY2FzZSBcIm1hdGljbXVtXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiaHR0cHM6L1xcL2FwaS10ZXN0bmV0LnBvbHlnb25zY2FuLmNvbVwiO1xuICAgICAgICAgICAgY2FzZSBcImFyYml0cnVtXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiaHR0cHM6L1xcL2FwaS5hcmJpc2Nhbi5pb1wiO1xuICAgICAgICAgICAgY2FzZSBcImFyYml0cnVtLWdvZXJsaVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBcImh0dHBzOi9cXC9hcGktZ29lcmxpLmFyYmlzY2FuLmlvXCI7XG4gICAgICAgICAgICBjYXNlIFwib3B0aW1pc21cIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJodHRwczovXFwvYXBpLW9wdGltaXN0aWMuZXRoZXJzY2FuLmlvXCI7XG4gICAgICAgICAgICBjYXNlIFwib3B0aW1pc20tZ29lcmxpXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiaHR0cHM6L1xcL2FwaS1nb2VybGktb3B0aW1pc3RpYy5ldGhlcnNjYW4uaW9cIjtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ1bnN1cHBvcnRlZCBuZXR3b3JrXCIsIFwibmV0d29ya1wiLCB0aGlzLm5ldHdvcmsubmFtZSk7XG4gICAgfVxuICAgIGdldFVybChtb2R1bGUsIHBhcmFtcykge1xuICAgICAgICBjb25zdCBxdWVyeSA9IE9iamVjdC5rZXlzKHBhcmFtcykucmVkdWNlKChhY2N1bSwga2V5KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBhY2N1bSArPSBgJiR7a2V5fT0ke3ZhbHVlfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYWNjdW07XG4gICAgICAgIH0sIFwiXCIpO1xuICAgICAgICBjb25zdCBhcGlLZXkgPSAoKHRoaXMuYXBpS2V5KSA/IGAmYXBpa2V5PSR7dGhpcy5hcGlLZXl9YCA6IFwiXCIpO1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5iYXNlVXJsfS9hcGk/bW9kdWxlPSR7bW9kdWxlfSR7cXVlcnl9JHthcGlLZXl9YDtcbiAgICB9XG4gICAgZ2V0UG9zdFVybCgpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuYmFzZVVybH0vYXBpYDtcbiAgICB9XG4gICAgZ2V0UG9zdERhdGEobW9kdWxlLCBwYXJhbXMpIHtcbiAgICAgICAgcGFyYW1zLm1vZHVsZSA9IG1vZHVsZTtcbiAgICAgICAgcGFyYW1zLmFwaWtleSA9IHRoaXMuYXBpS2V5O1xuICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH1cbiAgICBmZXRjaChtb2R1bGUsIHBhcmFtcywgcG9zdCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgdXJsID0gKHBvc3QgPyB0aGlzLmdldFBvc3RVcmwoKSA6IHRoaXMuZ2V0VXJsKG1vZHVsZSwgcGFyYW1zKSk7XG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gKHBvc3QgPyB0aGlzLmdldFBvc3REYXRhKG1vZHVsZSwgcGFyYW1zKSA6IG51bGwpO1xuICAgICAgICAgICAgY29uc3QgcHJvY0Z1bmMgPSAobW9kdWxlID09PSBcInByb3h5XCIpID8gZ2V0SnNvblJlc3VsdCA6IGdldFJlc3VsdDtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHtcbiAgICAgICAgICAgICAgICBhY3Rpb246IFwicmVxdWVzdFwiLFxuICAgICAgICAgICAgICAgIHJlcXVlc3Q6IHVybCxcbiAgICAgICAgICAgICAgICBwcm92aWRlcjogdGhpc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBjb25uZWN0aW9uID0ge1xuICAgICAgICAgICAgICAgIHVybDogdXJsLFxuICAgICAgICAgICAgICAgIHRocm90dGxlU2xvdEludGVydmFsOiAxMDAwLFxuICAgICAgICAgICAgICAgIHRocm90dGxlQ2FsbGJhY2s6IChhdHRlbXB0LCB1cmwpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNDb21tdW5pdHlSZXNvdXJjZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaG93VGhyb3R0bGVNZXNzYWdlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbGV0IHBheWxvYWRTdHIgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHBheWxvYWQpIHtcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uLmhlYWRlcnMgPSB7IFwiY29udGVudC10eXBlXCI6IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkOyBjaGFyc2V0PVVURi04XCIgfTtcbiAgICAgICAgICAgICAgICBwYXlsb2FkU3RyID0gT2JqZWN0LmtleXMocGF5bG9hZCkubWFwKChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGAke2tleX09JHtwYXlsb2FkW2tleV19YDtcbiAgICAgICAgICAgICAgICB9KS5qb2luKFwiJlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHlpZWxkIGZldGNoSnNvbihjb25uZWN0aW9uLCBwYXlsb2FkU3RyLCBwcm9jRnVuYyB8fCBnZXRKc29uUmVzdWx0KTtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHtcbiAgICAgICAgICAgICAgICBhY3Rpb246IFwicmVzcG9uc2VcIixcbiAgICAgICAgICAgICAgICByZXF1ZXN0OiB1cmwsXG4gICAgICAgICAgICAgICAgcmVzcG9uc2U6IGRlZXBDb3B5KHJlc3VsdCksXG4gICAgICAgICAgICAgICAgcHJvdmlkZXI6IHRoaXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRldGVjdE5ldHdvcmsoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5uZXR3b3JrO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcGVyZm9ybShtZXRob2QsIHBhcmFtcykge1xuICAgICAgICBjb25zdCBfc3VwZXIgPSBPYmplY3QuY3JlYXRlKG51bGwsIHtcbiAgICAgICAgICAgIHBlcmZvcm06IHsgZ2V0OiAoKSA9PiBzdXBlci5wZXJmb3JtIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKG1ldGhvZCkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJnZXRCbG9ja051bWJlclwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mZXRjaChcInByb3h5XCIsIHsgYWN0aW9uOiBcImV0aF9ibG9ja051bWJlclwiIH0pO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJnZXRHYXNQcmljZVwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mZXRjaChcInByb3h5XCIsIHsgYWN0aW9uOiBcImV0aF9nYXNQcmljZVwiIH0pO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJnZXRCYWxhbmNlXCI6XG4gICAgICAgICAgICAgICAgICAgIC8vIFJldHVybnMgYmFzZS0xMCByZXN1bHRcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2goXCJhY2NvdW50XCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJiYWxhbmNlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzOiBwYXJhbXMuYWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZzogcGFyYW1zLmJsb2NrVGFnXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJnZXRUcmFuc2FjdGlvbkNvdW50XCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZldGNoKFwicHJveHlcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcImV0aF9nZXRUcmFuc2FjdGlvbkNvdW50XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzOiBwYXJhbXMuYWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZzogcGFyYW1zLmJsb2NrVGFnXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJnZXRDb2RlXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZldGNoKFwicHJveHlcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcImV0aF9nZXRDb2RlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzOiBwYXJhbXMuYWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZzogcGFyYW1zLmJsb2NrVGFnXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJnZXRTdG9yYWdlQXRcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2goXCJwcm94eVwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwiZXRoX2dldFN0b3JhZ2VBdFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzczogcGFyYW1zLmFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogcGFyYW1zLnBvc2l0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFnOiBwYXJhbXMuYmxvY2tUYWdcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY2FzZSBcInNlbmRUcmFuc2FjdGlvblwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mZXRjaChcInByb3h5XCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJldGhfc2VuZFJhd1RyYW5zYWN0aW9uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZXg6IHBhcmFtcy5zaWduZWRUcmFuc2FjdGlvblxuICAgICAgICAgICAgICAgICAgICB9LCB0cnVlKS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGVja0Vycm9yKFwic2VuZFRyYW5zYWN0aW9uXCIsIGVycm9yLCBwYXJhbXMuc2lnbmVkVHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZ2V0QmxvY2tcIjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5ibG9ja1RhZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2goXCJwcm94eVwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcImV0aF9nZXRCbG9ja0J5TnVtYmVyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFnOiBwYXJhbXMuYmxvY2tUYWcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9vbGVhbjogKHBhcmFtcy5pbmNsdWRlVHJhbnNhY3Rpb25zID8gXCJ0cnVlXCIgOiBcImZhbHNlXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJnZXRCbG9jayBieSBibG9ja0hhc2ggbm90IGltcGxlbWVudGVkXCIpO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJnZXRUcmFuc2FjdGlvblwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mZXRjaChcInByb3h5XCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJldGhfZ2V0VHJhbnNhY3Rpb25CeUhhc2hcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHR4aGFzaDogcGFyYW1zLnRyYW5zYWN0aW9uSGFzaFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZ2V0VHJhbnNhY3Rpb25SZWNlaXB0XCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZldGNoKFwicHJveHlcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcImV0aF9nZXRUcmFuc2FjdGlvblJlY2VpcHRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHR4aGFzaDogcGFyYW1zLnRyYW5zYWN0aW9uSGFzaFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjYXNlIFwiY2FsbFwiOiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuYmxvY2tUYWcgIT09IFwibGF0ZXN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV0aGVyc2NhblByb3ZpZGVyIGRvZXMgbm90IHN1cHBvcnQgYmxvY2tUYWcgZm9yIGNhbGxcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9zdERhdGEgPSBnZXRUcmFuc2FjdGlvblBvc3REYXRhKHBhcmFtcy50cmFuc2FjdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIHBvc3REYXRhLm1vZHVsZSA9IFwicHJveHlcIjtcbiAgICAgICAgICAgICAgICAgICAgcG9zdERhdGEuYWN0aW9uID0gXCJldGhfY2FsbFwiO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMuZmV0Y2goXCJwcm94eVwiLCBwb3N0RGF0YSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hlY2tFcnJvcihcImNhbGxcIiwgZXJyb3IsIHBhcmFtcy50cmFuc2FjdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBcImVzdGltYXRlR2FzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9zdERhdGEgPSBnZXRUcmFuc2FjdGlvblBvc3REYXRhKHBhcmFtcy50cmFuc2FjdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIHBvc3REYXRhLm1vZHVsZSA9IFwicHJveHlcIjtcbiAgICAgICAgICAgICAgICAgICAgcG9zdERhdGEuYWN0aW9uID0gXCJldGhfZXN0aW1hdGVHYXNcIjtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLmZldGNoKFwicHJveHlcIiwgcG9zdERhdGEsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoZWNrRXJyb3IoXCJlc3RpbWF0ZUdhc1wiLCBlcnJvciwgcGFyYW1zLnRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFwiZ2V0TG9nc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFyZ3MgPSB7IGFjdGlvbjogXCJnZXRMb2dzXCIgfTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5maWx0ZXIuZnJvbUJsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzLmZyb21CbG9jayA9IGNoZWNrTG9nVGFnKHBhcmFtcy5maWx0ZXIuZnJvbUJsb2NrKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmZpbHRlci50b0Jsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzLnRvQmxvY2sgPSBjaGVja0xvZ1RhZyhwYXJhbXMuZmlsdGVyLnRvQmxvY2spO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuZmlsdGVyLmFkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MuYWRkcmVzcyA9IHBhcmFtcy5maWx0ZXIuYWRkcmVzcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBAVE9ETzogV2UgY2FuIGhhbmRsZSBzbGlnaHRseSBtb3JlIGNvbXBsaWNhdGVkIGxvZ3MgdXNpbmcgdGhlIGxvZ3MgQVBJXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuZmlsdGVyLnRvcGljcyAmJiBwYXJhbXMuZmlsdGVyLnRvcGljcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmZpbHRlci50b3BpY3MubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwidW5zdXBwb3J0ZWQgdG9waWMgY291bnRcIiwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHsgdG9waWNzOiBwYXJhbXMuZmlsdGVyLnRvcGljcyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuZmlsdGVyLnRvcGljcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0b3BpYzAgPSBwYXJhbXMuZmlsdGVyLnRvcGljc1swXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mICh0b3BpYzApICE9PSBcInN0cmluZ1wiIHx8IHRvcGljMC5sZW5ndGggIT09IDY2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwidW5zdXBwb3J0ZWQgdG9waWMgZm9ybWF0XCIsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7IHRvcGljMDogdG9waWMwIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzLnRvcGljMCA9IHRvcGljMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2dzID0geWllbGQgdGhpcy5mZXRjaChcImxvZ3NcIiwgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIENhY2hlIHR4SGFzaCA9PiBibG9ja0hhc2hcbiAgICAgICAgICAgICAgICAgICAgbGV0IGJsb2NrcyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAvLyBBZGQgYW55IG1pc3NpbmcgYmxvY2tIYXNoIHRvIHRoZSBsb2dzXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbG9ncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9nID0gbG9nc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsb2cuYmxvY2tIYXNoICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChibG9ja3NbbG9nLmJsb2NrTnVtYmVyXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYmxvY2sgPSB5aWVsZCB0aGlzLmdldEJsb2NrKGxvZy5ibG9ja051bWJlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1tsb2cuYmxvY2tOdW1iZXJdID0gYmxvY2suaGFzaDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2cuYmxvY2tIYXNoID0gYmxvY2tzW2xvZy5ibG9ja051bWJlcl07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxvZ3M7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgXCJnZXRFdGhlclByaWNlXCI6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm5ldHdvcmsubmFtZSAhPT0gXCJob21lc3RlYWRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDAuMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdCgoeWllbGQgdGhpcy5mZXRjaChcInN0YXRzXCIsIHsgYWN0aW9uOiBcImV0aHByaWNlXCIgfSkpLmV0aHVzZCk7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX3N1cGVyLnBlcmZvcm0uY2FsbCh0aGlzLCBtZXRob2QsIHBhcmFtcyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBOb3RlOiBUaGUgYHBhZ2VgIHBhZ2UgcGFyYW1ldGVyIG9ubHkgYWxsb3dzIHBhZ2luYXRpb24gd2l0aGluIHRoZVxuICAgIC8vICAgICAgIDEwLDAwMCB3aW5kb3cgYXZhaWxhYmxlIHdpdGhvdXQgYSBwYWdlIGFuZCBvZmZzZXQgcGFyYW1ldGVyXG4gICAgLy8gICAgICAgRXJyb3I6IFJlc3VsdCB3aW5kb3cgaXMgdG9vIGxhcmdlLCBQYWdlTm8geCBPZmZzZXQgc2l6ZSBtdXN0XG4gICAgLy8gICAgICAgICAgICAgIGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byAxMDAwMFxuICAgIGdldEhpc3RvcnkoYWRkcmVzc09yTmFtZSwgc3RhcnRCbG9jaywgZW5kQmxvY2spIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBhY3Rpb246IFwidHhsaXN0XCIsXG4gICAgICAgICAgICAgICAgYWRkcmVzczogKHlpZWxkIHRoaXMucmVzb2x2ZU5hbWUoYWRkcmVzc09yTmFtZSkpLFxuICAgICAgICAgICAgICAgIHN0YXJ0YmxvY2s6ICgoc3RhcnRCbG9jayA9PSBudWxsKSA/IDAgOiBzdGFydEJsb2NrKSxcbiAgICAgICAgICAgICAgICBlbmRibG9jazogKChlbmRCbG9jayA9PSBudWxsKSA/IDk5OTk5OTk5IDogZW5kQmxvY2spLFxuICAgICAgICAgICAgICAgIHNvcnQ6IFwiYXNjXCJcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB5aWVsZCB0aGlzLmZldGNoKFwiYWNjb3VudFwiLCBwYXJhbXMpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5tYXAoKHR4KSA9PiB7XG4gICAgICAgICAgICAgICAgW1wiY29udHJhY3RBZGRyZXNzXCIsIFwidG9cIl0uZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eFtrZXldID09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0eFtrZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHR4LmNyZWF0ZXMgPT0gbnVsbCAmJiB0eC5jb250cmFjdEFkZHJlc3MgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0eC5jcmVhdGVzID0gdHguY29udHJhY3RBZGRyZXNzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5mb3JtYXR0ZXIudHJhbnNhY3Rpb25SZXNwb25zZSh0eCk7XG4gICAgICAgICAgICAgICAgaWYgKHR4LnRpbWVTdGFtcCkge1xuICAgICAgICAgICAgICAgICAgICBpdGVtLnRpbWVzdGFtcCA9IHBhcnNlSW50KHR4LnRpbWVTdGFtcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpc0NvbW11bml0eVJlc291cmNlKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuYXBpS2V5ID09IG51bGwpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV0aGVyc2Nhbi1wcm92aWRlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ethersproject/providers/lib.esm/etherscan-provider.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@ethersproject/providers/lib.esm/fallback-provider.js":
/*!*****************************************************************************!*\
  !*** ../node_modules/@ethersproject/providers/lib.esm/fallback-provider.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FallbackProvider: () => (/* binding */ FallbackProvider)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_abstract_provider__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @ethersproject/abstract-provider */ \"(ssr)/../node_modules/@ethersproject/abstract-provider/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/bignumber */ \"(ssr)/../node_modules/@ethersproject/bignumber/lib.esm/bignumber.js\");\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/../node_modules/@ethersproject/bytes/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/../node_modules/@ethersproject/properties/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_random__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @ethersproject/random */ \"(ssr)/../node_modules/@ethersproject/random/lib.esm/shuffle.js\");\n/* harmony import */ var _ethersproject_web__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethersproject/web */ \"(ssr)/../node_modules/@ethersproject/web/lib.esm/index.js\");\n/* harmony import */ var _base_provider__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./base-provider */ \"(ssr)/../node_modules/@ethersproject/providers/lib.esm/base-provider.js\");\n/* harmony import */ var _formatter__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./formatter */ \"(ssr)/../node_modules/@ethersproject/providers/lib.esm/formatter.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/../node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(ssr)/../node_modules/@ethersproject/providers/lib.esm/_version.js\");\n\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\n\n\n\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\nfunction now() { return (new Date()).getTime(); }\n// Returns to network as long as all agree, or null if any is null.\n// Throws an error if any two networks do not match.\nfunction checkNetworks(networks) {\n    let result = null;\n    for (let i = 0; i < networks.length; i++) {\n        const network = networks[i];\n        // Null! We do not know our network; bail.\n        if (network == null) {\n            return null;\n        }\n        if (result) {\n            // Make sure the network matches the previous networks\n            if (!(result.name === network.name && result.chainId === network.chainId &&\n                ((result.ensAddress === network.ensAddress) || (result.ensAddress == null && network.ensAddress == null)))) {\n                logger.throwArgumentError(\"provider mismatch\", \"networks\", networks);\n            }\n        }\n        else {\n            result = network;\n        }\n    }\n    return result;\n}\nfunction median(values, maxDelta) {\n    values = values.slice().sort();\n    const middle = Math.floor(values.length / 2);\n    // Odd length; take the middle\n    if (values.length % 2) {\n        return values[middle];\n    }\n    // Even length; take the average of the two middle\n    const a = values[middle - 1], b = values[middle];\n    if (maxDelta != null && Math.abs(a - b) > maxDelta) {\n        return null;\n    }\n    return (a + b) / 2;\n}\nfunction serialize(value) {\n    if (value === null) {\n        return \"null\";\n    }\n    else if (typeof (value) === \"number\" || typeof (value) === \"boolean\") {\n        return JSON.stringify(value);\n    }\n    else if (typeof (value) === \"string\") {\n        return value;\n    }\n    else if (_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_2__.BigNumber.isBigNumber(value)) {\n        return value.toString();\n    }\n    else if (Array.isArray(value)) {\n        return JSON.stringify(value.map((i) => serialize(i)));\n    }\n    else if (typeof (value) === \"object\") {\n        const keys = Object.keys(value);\n        keys.sort();\n        return \"{\" + keys.map((key) => {\n            let v = value[key];\n            if (typeof (v) === \"function\") {\n                v = \"[function]\";\n            }\n            else {\n                v = serialize(v);\n            }\n            return JSON.stringify(key) + \":\" + v;\n        }).join(\",\") + \"}\";\n    }\n    throw new Error(\"unknown value type: \" + typeof (value));\n}\n// Next request ID to use for emitting debug info\nlet nextRid = 1;\n;\nfunction stall(duration) {\n    let cancel = null;\n    let timer = null;\n    let promise = (new Promise((resolve) => {\n        cancel = function () {\n            if (timer) {\n                clearTimeout(timer);\n                timer = null;\n            }\n            resolve();\n        };\n        timer = setTimeout(cancel, duration);\n    }));\n    const wait = (func) => {\n        promise = promise.then(func);\n        return promise;\n    };\n    function getPromise() {\n        return promise;\n    }\n    return { cancel, getPromise, wait };\n}\nconst ForwardErrors = [\n    _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.CALL_EXCEPTION,\n    _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.INSUFFICIENT_FUNDS,\n    _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.NONCE_EXPIRED,\n    _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.REPLACEMENT_UNDERPRICED,\n    _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNPREDICTABLE_GAS_LIMIT\n];\nconst ForwardProperties = [\n    \"address\",\n    \"args\",\n    \"errorArgs\",\n    \"errorSignature\",\n    \"method\",\n    \"transaction\",\n];\n;\nfunction exposeDebugConfig(config, now) {\n    const result = {\n        weight: config.weight\n    };\n    Object.defineProperty(result, \"provider\", { get: () => config.provider });\n    if (config.start) {\n        result.start = config.start;\n    }\n    if (now) {\n        result.duration = (now - config.start);\n    }\n    if (config.done) {\n        if (config.error) {\n            result.error = config.error;\n        }\n        else {\n            result.result = config.result || null;\n        }\n    }\n    return result;\n}\nfunction normalizedTally(normalize, quorum) {\n    return function (configs) {\n        // Count the votes for each result\n        const tally = {};\n        configs.forEach((c) => {\n            const value = normalize(c.result);\n            if (!tally[value]) {\n                tally[value] = { count: 0, result: c.result };\n            }\n            tally[value].count++;\n        });\n        // Check for a quorum on any given result\n        const keys = Object.keys(tally);\n        for (let i = 0; i < keys.length; i++) {\n            const check = tally[keys[i]];\n            if (check.count >= quorum) {\n                return check.result;\n            }\n        }\n        // No quroum\n        return undefined;\n    };\n}\nfunction getProcessFunc(provider, method, params) {\n    let normalize = serialize;\n    switch (method) {\n        case \"getBlockNumber\":\n            // Return the median value, unless there is (median + 1) is also\n            // present, in which case that is probably true and the median\n            // is going to be stale soon. In the event of a malicious node,\n            // the lie will be true soon enough.\n            return function (configs) {\n                const values = configs.map((c) => c.result);\n                // Get the median block number\n                let blockNumber = median(configs.map((c) => c.result), 2);\n                if (blockNumber == null) {\n                    return undefined;\n                }\n                blockNumber = Math.ceil(blockNumber);\n                // If the next block height is present, its prolly safe to use\n                if (values.indexOf(blockNumber + 1) >= 0) {\n                    blockNumber++;\n                }\n                // Don't ever roll back the blockNumber\n                if (blockNumber >= provider._highestBlockNumber) {\n                    provider._highestBlockNumber = blockNumber;\n                }\n                return provider._highestBlockNumber;\n            };\n        case \"getGasPrice\":\n            // Return the middle (round index up) value, similar to median\n            // but do not average even entries and choose the higher.\n            // Malicious actors must compromise 50% of the nodes to lie.\n            return function (configs) {\n                const values = configs.map((c) => c.result);\n                values.sort();\n                return values[Math.floor(values.length / 2)];\n            };\n        case \"getEtherPrice\":\n            // Returns the median price. Malicious actors must compromise at\n            // least 50% of the nodes to lie (in a meaningful way).\n            return function (configs) {\n                return median(configs.map((c) => c.result));\n            };\n        // No additional normalizing required; serialize is enough\n        case \"getBalance\":\n        case \"getTransactionCount\":\n        case \"getCode\":\n        case \"getStorageAt\":\n        case \"call\":\n        case \"estimateGas\":\n        case \"getLogs\":\n            break;\n        // We drop the confirmations from transactions as it is approximate\n        case \"getTransaction\":\n        case \"getTransactionReceipt\":\n            normalize = function (tx) {\n                if (tx == null) {\n                    return null;\n                }\n                tx = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.shallowCopy)(tx);\n                tx.confirmations = -1;\n                return serialize(tx);\n            };\n            break;\n        // We drop the confirmations from transactions as it is approximate\n        case \"getBlock\":\n            // We drop the confirmations from transactions as it is approximate\n            if (params.includeTransactions) {\n                normalize = function (block) {\n                    if (block == null) {\n                        return null;\n                    }\n                    block = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.shallowCopy)(block);\n                    block.transactions = block.transactions.map((tx) => {\n                        tx = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.shallowCopy)(tx);\n                        tx.confirmations = -1;\n                        return tx;\n                    });\n                    return serialize(block);\n                };\n            }\n            else {\n                normalize = function (block) {\n                    if (block == null) {\n                        return null;\n                    }\n                    return serialize(block);\n                };\n            }\n            break;\n        default:\n            throw new Error(\"unknown method: \" + method);\n    }\n    // Return the result if and only if the expected quorum is\n    // satisfied and agreed upon for the final result.\n    return normalizedTally(normalize, provider.quorum);\n}\n// If we are doing a blockTag query, we need to make sure the backend is\n// caught up to the FallbackProvider, before sending a request to it.\nfunction waitForSync(config, blockNumber) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const provider = (config.provider);\n        if ((provider.blockNumber != null && provider.blockNumber >= blockNumber) || blockNumber === -1) {\n            return provider;\n        }\n        return (0,_ethersproject_web__WEBPACK_IMPORTED_MODULE_4__.poll)(() => {\n            return new Promise((resolve, reject) => {\n                setTimeout(function () {\n                    // We are synced\n                    if (provider.blockNumber >= blockNumber) {\n                        return resolve(provider);\n                    }\n                    // We're done; just quit\n                    if (config.cancelled) {\n                        return resolve(null);\n                    }\n                    // Try again, next block\n                    return resolve(undefined);\n                }, 0);\n            });\n        }, { oncePoll: provider });\n    });\n}\nfunction getRunner(config, currentBlockNumber, method, params) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let provider = config.provider;\n        switch (method) {\n            case \"getBlockNumber\":\n            case \"getGasPrice\":\n                return provider[method]();\n            case \"getEtherPrice\":\n                if (provider.getEtherPrice) {\n                    return provider.getEtherPrice();\n                }\n                break;\n            case \"getBalance\":\n            case \"getTransactionCount\":\n            case \"getCode\":\n                if (params.blockTag && (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__.isHexString)(params.blockTag)) {\n                    provider = yield waitForSync(config, currentBlockNumber);\n                }\n                return provider[method](params.address, params.blockTag || \"latest\");\n            case \"getStorageAt\":\n                if (params.blockTag && (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__.isHexString)(params.blockTag)) {\n                    provider = yield waitForSync(config, currentBlockNumber);\n                }\n                return provider.getStorageAt(params.address, params.position, params.blockTag || \"latest\");\n            case \"getBlock\":\n                if (params.blockTag && (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__.isHexString)(params.blockTag)) {\n                    provider = yield waitForSync(config, currentBlockNumber);\n                }\n                return provider[(params.includeTransactions ? \"getBlockWithTransactions\" : \"getBlock\")](params.blockTag || params.blockHash);\n            case \"call\":\n            case \"estimateGas\":\n                if (params.blockTag && (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__.isHexString)(params.blockTag)) {\n                    provider = yield waitForSync(config, currentBlockNumber);\n                }\n                if (method === \"call\" && params.blockTag) {\n                    return provider[method](params.transaction, params.blockTag);\n                }\n                return provider[method](params.transaction);\n            case \"getTransaction\":\n            case \"getTransactionReceipt\":\n                return provider[method](params.transactionHash);\n            case \"getLogs\": {\n                let filter = params.filter;\n                if ((filter.fromBlock && (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__.isHexString)(filter.fromBlock)) || (filter.toBlock && (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__.isHexString)(filter.toBlock))) {\n                    provider = yield waitForSync(config, currentBlockNumber);\n                }\n                return provider.getLogs(filter);\n            }\n        }\n        return logger.throwError(\"unknown method error\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNKNOWN_ERROR, {\n            method: method,\n            params: params\n        });\n    });\n}\nclass FallbackProvider extends _base_provider__WEBPACK_IMPORTED_MODULE_6__.BaseProvider {\n    constructor(providers, quorum) {\n        if (providers.length === 0) {\n            logger.throwArgumentError(\"missing providers\", \"providers\", providers);\n        }\n        const providerConfigs = providers.map((configOrProvider, index) => {\n            if (_ethersproject_abstract_provider__WEBPACK_IMPORTED_MODULE_7__.Provider.isProvider(configOrProvider)) {\n                const stallTimeout = (0,_formatter__WEBPACK_IMPORTED_MODULE_8__.isCommunityResource)(configOrProvider) ? 2000 : 750;\n                const priority = 1;\n                return Object.freeze({ provider: configOrProvider, weight: 1, stallTimeout, priority });\n            }\n            const config = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.shallowCopy)(configOrProvider);\n            if (config.priority == null) {\n                config.priority = 1;\n            }\n            if (config.stallTimeout == null) {\n                config.stallTimeout = (0,_formatter__WEBPACK_IMPORTED_MODULE_8__.isCommunityResource)(configOrProvider) ? 2000 : 750;\n            }\n            if (config.weight == null) {\n                config.weight = 1;\n            }\n            const weight = config.weight;\n            if (weight % 1 || weight > 512 || weight < 1) {\n                logger.throwArgumentError(\"invalid weight; must be integer in [1, 512]\", `providers[${index}].weight`, weight);\n            }\n            return Object.freeze(config);\n        });\n        const total = providerConfigs.reduce((accum, c) => (accum + c.weight), 0);\n        if (quorum == null) {\n            quorum = total / 2;\n        }\n        else if (quorum > total) {\n            logger.throwArgumentError(\"quorum will always fail; larger than total weight\", \"quorum\", quorum);\n        }\n        // Are all providers' networks are known\n        let networkOrReady = checkNetworks(providerConfigs.map((c) => (c.provider).network));\n        // Not all networks are known; we must stall\n        if (networkOrReady == null) {\n            networkOrReady = new Promise((resolve, reject) => {\n                setTimeout(() => {\n                    this.detectNetwork().then(resolve, reject);\n                }, 0);\n            });\n        }\n        super(networkOrReady);\n        // Preserve a copy, so we do not get mutated\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"providerConfigs\", Object.freeze(providerConfigs));\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"quorum\", quorum);\n        this._highestBlockNumber = -1;\n    }\n    detectNetwork() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const networks = yield Promise.all(this.providerConfigs.map((c) => c.provider.getNetwork()));\n            return checkNetworks(networks);\n        });\n    }\n    perform(method, params) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Sending transactions is special; always broadcast it to all backends\n            if (method === \"sendTransaction\") {\n                const results = yield Promise.all(this.providerConfigs.map((c) => {\n                    return c.provider.sendTransaction(params.signedTransaction).then((result) => {\n                        return result.hash;\n                    }, (error) => {\n                        return error;\n                    });\n                }));\n                // Any success is good enough (other errors are likely \"already seen\" errors\n                for (let i = 0; i < results.length; i++) {\n                    const result = results[i];\n                    if (typeof (result) === \"string\") {\n                        return result;\n                    }\n                }\n                // They were all an error; pick the first error\n                throw results[0];\n            }\n            // We need to make sure we are in sync with our backends, so we need\n            // to know this before we can make a lot of calls\n            if (this._highestBlockNumber === -1 && method !== \"getBlockNumber\") {\n                yield this.getBlockNumber();\n            }\n            const processFunc = getProcessFunc(this, method, params);\n            // Shuffle the providers and then sort them by their priority; we\n            // shallowCopy them since we will store the result in them too\n            const configs = (0,_ethersproject_random__WEBPACK_IMPORTED_MODULE_9__.shuffled)(this.providerConfigs.map(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.shallowCopy));\n            configs.sort((a, b) => (a.priority - b.priority));\n            const currentBlockNumber = this._highestBlockNumber;\n            let i = 0;\n            let first = true;\n            while (true) {\n                const t0 = now();\n                // Compute the inflight weight (exclude anything past)\n                let inflightWeight = configs.filter((c) => (c.runner && ((t0 - c.start) < c.stallTimeout)))\n                    .reduce((accum, c) => (accum + c.weight), 0);\n                // Start running enough to meet quorum\n                while (inflightWeight < this.quorum && i < configs.length) {\n                    const config = configs[i++];\n                    const rid = nextRid++;\n                    config.start = now();\n                    config.staller = stall(config.stallTimeout);\n                    config.staller.wait(() => { config.staller = null; });\n                    config.runner = getRunner(config, currentBlockNumber, method, params).then((result) => {\n                        config.done = true;\n                        config.result = result;\n                        if (this.listenerCount(\"debug\")) {\n                            this.emit(\"debug\", {\n                                action: \"request\",\n                                rid: rid,\n                                backend: exposeDebugConfig(config, now()),\n                                request: { method: method, params: (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.deepCopy)(params) },\n                                provider: this\n                            });\n                        }\n                    }, (error) => {\n                        config.done = true;\n                        config.error = error;\n                        if (this.listenerCount(\"debug\")) {\n                            this.emit(\"debug\", {\n                                action: \"request\",\n                                rid: rid,\n                                backend: exposeDebugConfig(config, now()),\n                                request: { method: method, params: (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.deepCopy)(params) },\n                                provider: this\n                            });\n                        }\n                    });\n                    if (this.listenerCount(\"debug\")) {\n                        this.emit(\"debug\", {\n                            action: \"request\",\n                            rid: rid,\n                            backend: exposeDebugConfig(config, null),\n                            request: { method: method, params: (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.deepCopy)(params) },\n                            provider: this\n                        });\n                    }\n                    inflightWeight += config.weight;\n                }\n                // Wait for anything meaningful to finish or stall out\n                const waiting = [];\n                configs.forEach((c) => {\n                    if (c.done || !c.runner) {\n                        return;\n                    }\n                    waiting.push(c.runner);\n                    if (c.staller) {\n                        waiting.push(c.staller.getPromise());\n                    }\n                });\n                if (waiting.length) {\n                    yield Promise.race(waiting);\n                }\n                // Check the quorum and process the results; the process function\n                // may additionally decide the quorum is not met\n                const results = configs.filter((c) => (c.done && c.error == null));\n                if (results.length >= this.quorum) {\n                    const result = processFunc(results);\n                    if (result !== undefined) {\n                        // Shut down any stallers\n                        configs.forEach(c => {\n                            if (c.staller) {\n                                c.staller.cancel();\n                            }\n                            c.cancelled = true;\n                        });\n                        return result;\n                    }\n                    if (!first) {\n                        yield stall(100).getPromise();\n                    }\n                    first = false;\n                }\n                // No result, check for errors that should be forwarded\n                const errors = configs.reduce((accum, c) => {\n                    if (!c.done || c.error == null) {\n                        return accum;\n                    }\n                    const code = (c.error).code;\n                    if (ForwardErrors.indexOf(code) >= 0) {\n                        if (!accum[code]) {\n                            accum[code] = { error: c.error, weight: 0 };\n                        }\n                        accum[code].weight += c.weight;\n                    }\n                    return accum;\n                }, ({}));\n                Object.keys(errors).forEach((errorCode) => {\n                    const tally = errors[errorCode];\n                    if (tally.weight < this.quorum) {\n                        return;\n                    }\n                    // Shut down any stallers\n                    configs.forEach(c => {\n                        if (c.staller) {\n                            c.staller.cancel();\n                        }\n                        c.cancelled = true;\n                    });\n                    const e = (tally.error);\n                    const props = {};\n                    ForwardProperties.forEach((name) => {\n                        if (e[name] == null) {\n                            return;\n                        }\n                        props[name] = e[name];\n                    });\n                    logger.throwError(e.reason || e.message, errorCode, props);\n                });\n                // All configs have run to completion; we will never get more data\n                if (configs.filter((c) => !c.done).length === 0) {\n                    break;\n                }\n            }\n            // Shut down any stallers; shouldn't be any\n            configs.forEach(c => {\n                if (c.staller) {\n                    c.staller.cancel();\n                }\n                c.cancelled = true;\n            });\n            return logger.throwError(\"failed to meet quorum\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.SERVER_ERROR, {\n                method: method,\n                params: params,\n                //results: configs.map((c) => c.result),\n                //errors: configs.map((c) => c.error),\n                results: configs.map((c) => exposeDebugConfig(c)),\n                provider: this\n            });\n        });\n    }\n}\n//# sourceMappingURL=fallback-provider.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3Byb3ZpZGVycy9saWIuZXNtL2ZhbGxiYWNrLXByb3ZpZGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQWE7QUFDYixpQkFBaUIsU0FBSSxJQUFJLFNBQUk7QUFDN0IsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDNEQ7QUFDUDtBQUNGO0FBQytCO0FBQ2pDO0FBQ1A7QUFDSztBQUNHO0FBQ0g7QUFDVjtBQUNyQyxtQkFBbUIseURBQU0sQ0FBQyw2Q0FBTztBQUNqQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsK0RBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxnQkFBZ0I7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNB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NkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsS0FBSztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsaUJBQWlCO0FBQ2pCLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLDhEQUE4RCx5REFBTTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xlZGdpdHkteWllbGQtZnJvbnRlbmQvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3Byb3ZpZGVycy9saWIuZXNtL2ZhbGxiYWNrLXByb3ZpZGVyLmpzP2UzZjEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbmltcG9ydCB7IFByb3ZpZGVyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2Fic3RyYWN0LXByb3ZpZGVyXCI7XG5pbXBvcnQgeyBCaWdOdW1iZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYmlnbnVtYmVyXCI7XG5pbXBvcnQgeyBpc0hleFN0cmluZyB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9ieXRlc1wiO1xuaW1wb3J0IHsgZGVlcENvcHksIGRlZmluZVJlYWRPbmx5LCBzaGFsbG93Q29weSB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9wcm9wZXJ0aWVzXCI7XG5pbXBvcnQgeyBzaHVmZmxlZCB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9yYW5kb21cIjtcbmltcG9ydCB7IHBvbGwgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3Qvd2ViXCI7XG5pbXBvcnQgeyBCYXNlUHJvdmlkZXIgfSBmcm9tIFwiLi9iYXNlLXByb3ZpZGVyXCI7XG5pbXBvcnQgeyBpc0NvbW11bml0eVJlc291cmNlIH0gZnJvbSBcIi4vZm9ybWF0dGVyXCI7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvbG9nZ2VyXCI7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4vX3ZlcnNpb25cIjtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIodmVyc2lvbik7XG5mdW5jdGlvbiBub3coKSB7IHJldHVybiAobmV3IERhdGUoKSkuZ2V0VGltZSgpOyB9XG4vLyBSZXR1cm5zIHRvIG5ldHdvcmsgYXMgbG9uZyBhcyBhbGwgYWdyZWUsIG9yIG51bGwgaWYgYW55IGlzIG51bGwuXG4vLyBUaHJvd3MgYW4gZXJyb3IgaWYgYW55IHR3byBuZXR3b3JrcyBkbyBub3QgbWF0Y2guXG5mdW5jdGlvbiBjaGVja05ldHdvcmtzKG5ldHdvcmtzKSB7XG4gICAgbGV0IHJlc3VsdCA9IG51bGw7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXR3b3Jrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBuZXR3b3JrID0gbmV0d29ya3NbaV07XG4gICAgICAgIC8vIE51bGwhIFdlIGRvIG5vdCBrbm93IG91ciBuZXR3b3JrOyBiYWlsLlxuICAgICAgICBpZiAobmV0d29yayA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIG5ldHdvcmsgbWF0Y2hlcyB0aGUgcHJldmlvdXMgbmV0d29ya3NcbiAgICAgICAgICAgIGlmICghKHJlc3VsdC5uYW1lID09PSBuZXR3b3JrLm5hbWUgJiYgcmVzdWx0LmNoYWluSWQgPT09IG5ldHdvcmsuY2hhaW5JZCAmJlxuICAgICAgICAgICAgICAgICgocmVzdWx0LmVuc0FkZHJlc3MgPT09IG5ldHdvcmsuZW5zQWRkcmVzcykgfHwgKHJlc3VsdC5lbnNBZGRyZXNzID09IG51bGwgJiYgbmV0d29yay5lbnNBZGRyZXNzID09IG51bGwpKSkpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwicHJvdmlkZXIgbWlzbWF0Y2hcIiwgXCJuZXR3b3Jrc1wiLCBuZXR3b3Jrcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSBuZXR3b3JrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBtZWRpYW4odmFsdWVzLCBtYXhEZWx0YSkge1xuICAgIHZhbHVlcyA9IHZhbHVlcy5zbGljZSgpLnNvcnQoKTtcbiAgICBjb25zdCBtaWRkbGUgPSBNYXRoLmZsb29yKHZhbHVlcy5sZW5ndGggLyAyKTtcbiAgICAvLyBPZGQgbGVuZ3RoOyB0YWtlIHRoZSBtaWRkbGVcbiAgICBpZiAodmFsdWVzLmxlbmd0aCAlIDIpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlc1ttaWRkbGVdO1xuICAgIH1cbiAgICAvLyBFdmVuIGxlbmd0aDsgdGFrZSB0aGUgYXZlcmFnZSBvZiB0aGUgdHdvIG1pZGRsZVxuICAgIGNvbnN0IGEgPSB2YWx1ZXNbbWlkZGxlIC0gMV0sIGIgPSB2YWx1ZXNbbWlkZGxlXTtcbiAgICBpZiAobWF4RGVsdGEgIT0gbnVsbCAmJiBNYXRoLmFicyhhIC0gYikgPiBtYXhEZWx0YSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIChhICsgYikgLyAyO1xufVxuZnVuY3Rpb24gc2VyaWFsaXplKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBcIm51bGxcIjtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwibnVtYmVyXCIgfHwgdHlwZW9mICh2YWx1ZSkgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoQmlnTnVtYmVyLmlzQmlnTnVtYmVyKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlLm1hcCgoaSkgPT4gc2VyaWFsaXplKGkpKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XG4gICAgICAgIGtleXMuc29ydCgpO1xuICAgICAgICByZXR1cm4gXCJ7XCIgKyBrZXlzLm1hcCgoa2V5KSA9PiB7XG4gICAgICAgICAgICBsZXQgdiA9IHZhbHVlW2tleV07XG4gICAgICAgICAgICBpZiAodHlwZW9mICh2KSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgdiA9IFwiW2Z1bmN0aW9uXVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdiA9IHNlcmlhbGl6ZSh2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShrZXkpICsgXCI6XCIgKyB2O1xuICAgICAgICB9KS5qb2luKFwiLFwiKSArIFwifVwiO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIHZhbHVlIHR5cGU6IFwiICsgdHlwZW9mICh2YWx1ZSkpO1xufVxuLy8gTmV4dCByZXF1ZXN0IElEIHRvIHVzZSBmb3IgZW1pdHRpbmcgZGVidWcgaW5mb1xubGV0IG5leHRSaWQgPSAxO1xuO1xuZnVuY3Rpb24gc3RhbGwoZHVyYXRpb24pIHtcbiAgICBsZXQgY2FuY2VsID0gbnVsbDtcbiAgICBsZXQgdGltZXIgPSBudWxsO1xuICAgIGxldCBwcm9taXNlID0gKG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIGNhbmNlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aW1lcikge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgICAgICAgICAgdGltZXIgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9O1xuICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQoY2FuY2VsLCBkdXJhdGlvbik7XG4gICAgfSkpO1xuICAgIGNvbnN0IHdhaXQgPSAoZnVuYykgPT4ge1xuICAgICAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmMpO1xuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGdldFByb21pc2UoKSB7XG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbiAgICByZXR1cm4geyBjYW5jZWwsIGdldFByb21pc2UsIHdhaXQgfTtcbn1cbmNvbnN0IEZvcndhcmRFcnJvcnMgPSBbXG4gICAgTG9nZ2VyLmVycm9ycy5DQUxMX0VYQ0VQVElPTixcbiAgICBMb2dnZXIuZXJyb3JzLklOU1VGRklDSUVOVF9GVU5EUyxcbiAgICBMb2dnZXIuZXJyb3JzLk5PTkNFX0VYUElSRUQsXG4gICAgTG9nZ2VyLmVycm9ycy5SRVBMQUNFTUVOVF9VTkRFUlBSSUNFRCxcbiAgICBMb2dnZXIuZXJyb3JzLlVOUFJFRElDVEFCTEVfR0FTX0xJTUlUXG5dO1xuY29uc3QgRm9yd2FyZFByb3BlcnRpZXMgPSBbXG4gICAgXCJhZGRyZXNzXCIsXG4gICAgXCJhcmdzXCIsXG4gICAgXCJlcnJvckFyZ3NcIixcbiAgICBcImVycm9yU2lnbmF0dXJlXCIsXG4gICAgXCJtZXRob2RcIixcbiAgICBcInRyYW5zYWN0aW9uXCIsXG5dO1xuO1xuZnVuY3Rpb24gZXhwb3NlRGVidWdDb25maWcoY29uZmlnLCBub3cpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgIHdlaWdodDogY29uZmlnLndlaWdodFxuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlc3VsdCwgXCJwcm92aWRlclwiLCB7IGdldDogKCkgPT4gY29uZmlnLnByb3ZpZGVyIH0pO1xuICAgIGlmIChjb25maWcuc3RhcnQpIHtcbiAgICAgICAgcmVzdWx0LnN0YXJ0ID0gY29uZmlnLnN0YXJ0O1xuICAgIH1cbiAgICBpZiAobm93KSB7XG4gICAgICAgIHJlc3VsdC5kdXJhdGlvbiA9IChub3cgLSBjb25maWcuc3RhcnQpO1xuICAgIH1cbiAgICBpZiAoY29uZmlnLmRvbmUpIHtcbiAgICAgICAgaWYgKGNvbmZpZy5lcnJvcikge1xuICAgICAgICAgICAgcmVzdWx0LmVycm9yID0gY29uZmlnLmVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0LnJlc3VsdCA9IGNvbmZpZy5yZXN1bHQgfHwgbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gbm9ybWFsaXplZFRhbGx5KG5vcm1hbGl6ZSwgcXVvcnVtKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChjb25maWdzKSB7XG4gICAgICAgIC8vIENvdW50IHRoZSB2b3RlcyBmb3IgZWFjaCByZXN1bHRcbiAgICAgICAgY29uc3QgdGFsbHkgPSB7fTtcbiAgICAgICAgY29uZmlncy5mb3JFYWNoKChjKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IG5vcm1hbGl6ZShjLnJlc3VsdCk7XG4gICAgICAgICAgICBpZiAoIXRhbGx5W3ZhbHVlXSkge1xuICAgICAgICAgICAgICAgIHRhbGx5W3ZhbHVlXSA9IHsgY291bnQ6IDAsIHJlc3VsdDogYy5yZXN1bHQgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRhbGx5W3ZhbHVlXS5jb3VudCsrO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gQ2hlY2sgZm9yIGEgcXVvcnVtIG9uIGFueSBnaXZlbiByZXN1bHRcbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHRhbGx5KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBjaGVjayA9IHRhbGx5W2tleXNbaV1dO1xuICAgICAgICAgICAgaWYgKGNoZWNrLmNvdW50ID49IHF1b3J1bSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjaGVjay5yZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm8gcXVyb3VtXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldFByb2Nlc3NGdW5jKHByb3ZpZGVyLCBtZXRob2QsIHBhcmFtcykge1xuICAgIGxldCBub3JtYWxpemUgPSBzZXJpYWxpemU7XG4gICAgc3dpdGNoIChtZXRob2QpIHtcbiAgICAgICAgY2FzZSBcImdldEJsb2NrTnVtYmVyXCI6XG4gICAgICAgICAgICAvLyBSZXR1cm4gdGhlIG1lZGlhbiB2YWx1ZSwgdW5sZXNzIHRoZXJlIGlzIChtZWRpYW4gKyAxKSBpcyBhbHNvXG4gICAgICAgICAgICAvLyBwcmVzZW50LCBpbiB3aGljaCBjYXNlIHRoYXQgaXMgcHJvYmFibHkgdHJ1ZSBhbmQgdGhlIG1lZGlhblxuICAgICAgICAgICAgLy8gaXMgZ29pbmcgdG8gYmUgc3RhbGUgc29vbi4gSW4gdGhlIGV2ZW50IG9mIGEgbWFsaWNpb3VzIG5vZGUsXG4gICAgICAgICAgICAvLyB0aGUgbGllIHdpbGwgYmUgdHJ1ZSBzb29uIGVub3VnaC5cbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoY29uZmlncykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlcyA9IGNvbmZpZ3MubWFwKChjKSA9PiBjLnJlc3VsdCk7XG4gICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBtZWRpYW4gYmxvY2sgbnVtYmVyXG4gICAgICAgICAgICAgICAgbGV0IGJsb2NrTnVtYmVyID0gbWVkaWFuKGNvbmZpZ3MubWFwKChjKSA9PiBjLnJlc3VsdCksIDIpO1xuICAgICAgICAgICAgICAgIGlmIChibG9ja051bWJlciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyID0gTWF0aC5jZWlsKGJsb2NrTnVtYmVyKTtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgbmV4dCBibG9jayBoZWlnaHQgaXMgcHJlc2VudCwgaXRzIHByb2xseSBzYWZlIHRvIHVzZVxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZXMuaW5kZXhPZihibG9ja051bWJlciArIDEpID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tOdW1iZXIrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gRG9uJ3QgZXZlciByb2xsIGJhY2sgdGhlIGJsb2NrTnVtYmVyXG4gICAgICAgICAgICAgICAgaWYgKGJsb2NrTnVtYmVyID49IHByb3ZpZGVyLl9oaWdoZXN0QmxvY2tOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXIuX2hpZ2hlc3RCbG9ja051bWJlciA9IGJsb2NrTnVtYmVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvdmlkZXIuX2hpZ2hlc3RCbG9ja051bWJlcjtcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgXCJnZXRHYXNQcmljZVwiOlxuICAgICAgICAgICAgLy8gUmV0dXJuIHRoZSBtaWRkbGUgKHJvdW5kIGluZGV4IHVwKSB2YWx1ZSwgc2ltaWxhciB0byBtZWRpYW5cbiAgICAgICAgICAgIC8vIGJ1dCBkbyBub3QgYXZlcmFnZSBldmVuIGVudHJpZXMgYW5kIGNob29zZSB0aGUgaGlnaGVyLlxuICAgICAgICAgICAgLy8gTWFsaWNpb3VzIGFjdG9ycyBtdXN0IGNvbXByb21pc2UgNTAlIG9mIHRoZSBub2RlcyB0byBsaWUuXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGNvbmZpZ3MpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZXMgPSBjb25maWdzLm1hcCgoYykgPT4gYy5yZXN1bHQpO1xuICAgICAgICAgICAgICAgIHZhbHVlcy5zb3J0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlc1tNYXRoLmZsb29yKHZhbHVlcy5sZW5ndGggLyAyKV07XG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlIFwiZ2V0RXRoZXJQcmljZVwiOlxuICAgICAgICAgICAgLy8gUmV0dXJucyB0aGUgbWVkaWFuIHByaWNlLiBNYWxpY2lvdXMgYWN0b3JzIG11c3QgY29tcHJvbWlzZSBhdFxuICAgICAgICAgICAgLy8gbGVhc3QgNTAlIG9mIHRoZSBub2RlcyB0byBsaWUgKGluIGEgbWVhbmluZ2Z1bCB3YXkpLlxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChjb25maWdzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1lZGlhbihjb25maWdzLm1hcCgoYykgPT4gYy5yZXN1bHQpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIC8vIE5vIGFkZGl0aW9uYWwgbm9ybWFsaXppbmcgcmVxdWlyZWQ7IHNlcmlhbGl6ZSBpcyBlbm91Z2hcbiAgICAgICAgY2FzZSBcImdldEJhbGFuY2VcIjpcbiAgICAgICAgY2FzZSBcImdldFRyYW5zYWN0aW9uQ291bnRcIjpcbiAgICAgICAgY2FzZSBcImdldENvZGVcIjpcbiAgICAgICAgY2FzZSBcImdldFN0b3JhZ2VBdFwiOlxuICAgICAgICBjYXNlIFwiY2FsbFwiOlxuICAgICAgICBjYXNlIFwiZXN0aW1hdGVHYXNcIjpcbiAgICAgICAgY2FzZSBcImdldExvZ3NcIjpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBXZSBkcm9wIHRoZSBjb25maXJtYXRpb25zIGZyb20gdHJhbnNhY3Rpb25zIGFzIGl0IGlzIGFwcHJveGltYXRlXG4gICAgICAgIGNhc2UgXCJnZXRUcmFuc2FjdGlvblwiOlxuICAgICAgICBjYXNlIFwiZ2V0VHJhbnNhY3Rpb25SZWNlaXB0XCI6XG4gICAgICAgICAgICBub3JtYWxpemUgPSBmdW5jdGlvbiAodHgpIHtcbiAgICAgICAgICAgICAgICBpZiAodHggPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHggPSBzaGFsbG93Q29weSh0eCk7XG4gICAgICAgICAgICAgICAgdHguY29uZmlybWF0aW9ucyA9IC0xO1xuICAgICAgICAgICAgICAgIHJldHVybiBzZXJpYWxpemUodHgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBXZSBkcm9wIHRoZSBjb25maXJtYXRpb25zIGZyb20gdHJhbnNhY3Rpb25zIGFzIGl0IGlzIGFwcHJveGltYXRlXG4gICAgICAgIGNhc2UgXCJnZXRCbG9ja1wiOlxuICAgICAgICAgICAgLy8gV2UgZHJvcCB0aGUgY29uZmlybWF0aW9ucyBmcm9tIHRyYW5zYWN0aW9ucyBhcyBpdCBpcyBhcHByb3hpbWF0ZVxuICAgICAgICAgICAgaWYgKHBhcmFtcy5pbmNsdWRlVHJhbnNhY3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgbm9ybWFsaXplID0gZnVuY3Rpb24gKGJsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChibG9jayA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBibG9jayA9IHNoYWxsb3dDb3B5KGJsb2NrKTtcbiAgICAgICAgICAgICAgICAgICAgYmxvY2sudHJhbnNhY3Rpb25zID0gYmxvY2sudHJhbnNhY3Rpb25zLm1hcCgodHgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR4ID0gc2hhbGxvd0NvcHkodHgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHguY29uZmlybWF0aW9ucyA9IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHR4O1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZShibG9jayk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZSA9IGZ1bmN0aW9uIChibG9jaykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYmxvY2sgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZShibG9jayk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biBtZXRob2Q6IFwiICsgbWV0aG9kKTtcbiAgICB9XG4gICAgLy8gUmV0dXJuIHRoZSByZXN1bHQgaWYgYW5kIG9ubHkgaWYgdGhlIGV4cGVjdGVkIHF1b3J1bSBpc1xuICAgIC8vIHNhdGlzZmllZCBhbmQgYWdyZWVkIHVwb24gZm9yIHRoZSBmaW5hbCByZXN1bHQuXG4gICAgcmV0dXJuIG5vcm1hbGl6ZWRUYWxseShub3JtYWxpemUsIHByb3ZpZGVyLnF1b3J1bSk7XG59XG4vLyBJZiB3ZSBhcmUgZG9pbmcgYSBibG9ja1RhZyBxdWVyeSwgd2UgbmVlZCB0byBtYWtlIHN1cmUgdGhlIGJhY2tlbmQgaXNcbi8vIGNhdWdodCB1cCB0byB0aGUgRmFsbGJhY2tQcm92aWRlciwgYmVmb3JlIHNlbmRpbmcgYSByZXF1ZXN0IHRvIGl0LlxuZnVuY3Rpb24gd2FpdEZvclN5bmMoY29uZmlnLCBibG9ja051bWJlcikge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gKGNvbmZpZy5wcm92aWRlcik7XG4gICAgICAgIGlmICgocHJvdmlkZXIuYmxvY2tOdW1iZXIgIT0gbnVsbCAmJiBwcm92aWRlci5ibG9ja051bWJlciA+PSBibG9ja051bWJlcikgfHwgYmxvY2tOdW1iZXIgPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvdmlkZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvbGwoKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgYXJlIHN5bmNlZFxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvdmlkZXIuYmxvY2tOdW1iZXIgPj0gYmxvY2tOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHByb3ZpZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBXZSdyZSBkb25lOyBqdXN0IHF1aXRcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpZy5jYW5jZWxsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFRyeSBhZ2FpbiwgbmV4dCBibG9ja1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSh1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIHsgb25jZVBvbGw6IHByb3ZpZGVyIH0pO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZ2V0UnVubmVyKGNvbmZpZywgY3VycmVudEJsb2NrTnVtYmVyLCBtZXRob2QsIHBhcmFtcykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGxldCBwcm92aWRlciA9IGNvbmZpZy5wcm92aWRlcjtcbiAgICAgICAgc3dpdGNoIChtZXRob2QpIHtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRCbG9ja051bWJlclwiOlxuICAgICAgICAgICAgY2FzZSBcImdldEdhc1ByaWNlXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVyW21ldGhvZF0oKTtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRFdGhlclByaWNlXCI6XG4gICAgICAgICAgICAgICAgaWYgKHByb3ZpZGVyLmdldEV0aGVyUHJpY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVyLmdldEV0aGVyUHJpY2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZ2V0QmFsYW5jZVwiOlxuICAgICAgICAgICAgY2FzZSBcImdldFRyYW5zYWN0aW9uQ291bnRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJnZXRDb2RlXCI6XG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5ibG9ja1RhZyAmJiBpc0hleFN0cmluZyhwYXJhbXMuYmxvY2tUYWcpKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyID0geWllbGQgd2FpdEZvclN5bmMoY29uZmlnLCBjdXJyZW50QmxvY2tOdW1iZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvdmlkZXJbbWV0aG9kXShwYXJhbXMuYWRkcmVzcywgcGFyYW1zLmJsb2NrVGFnIHx8IFwibGF0ZXN0XCIpO1xuICAgICAgICAgICAgY2FzZSBcImdldFN0b3JhZ2VBdFwiOlxuICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuYmxvY2tUYWcgJiYgaXNIZXhTdHJpbmcocGFyYW1zLmJsb2NrVGFnKSkge1xuICAgICAgICAgICAgICAgICAgICBwcm92aWRlciA9IHlpZWxkIHdhaXRGb3JTeW5jKGNvbmZpZywgY3VycmVudEJsb2NrTnVtYmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVyLmdldFN0b3JhZ2VBdChwYXJhbXMuYWRkcmVzcywgcGFyYW1zLnBvc2l0aW9uLCBwYXJhbXMuYmxvY2tUYWcgfHwgXCJsYXRlc3RcIik7XG4gICAgICAgICAgICBjYXNlIFwiZ2V0QmxvY2tcIjpcbiAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmJsb2NrVGFnICYmIGlzSGV4U3RyaW5nKHBhcmFtcy5ibG9ja1RhZykpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXIgPSB5aWVsZCB3YWl0Rm9yU3luYyhjb25maWcsIGN1cnJlbnRCbG9ja051bWJlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBwcm92aWRlclsocGFyYW1zLmluY2x1ZGVUcmFuc2FjdGlvbnMgPyBcImdldEJsb2NrV2l0aFRyYW5zYWN0aW9uc1wiIDogXCJnZXRCbG9ja1wiKV0ocGFyYW1zLmJsb2NrVGFnIHx8IHBhcmFtcy5ibG9ja0hhc2gpO1xuICAgICAgICAgICAgY2FzZSBcImNhbGxcIjpcbiAgICAgICAgICAgIGNhc2UgXCJlc3RpbWF0ZUdhc1wiOlxuICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuYmxvY2tUYWcgJiYgaXNIZXhTdHJpbmcocGFyYW1zLmJsb2NrVGFnKSkge1xuICAgICAgICAgICAgICAgICAgICBwcm92aWRlciA9IHlpZWxkIHdhaXRGb3JTeW5jKGNvbmZpZywgY3VycmVudEJsb2NrTnVtYmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJjYWxsXCIgJiYgcGFyYW1zLmJsb2NrVGFnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm92aWRlclttZXRob2RdKHBhcmFtcy50cmFuc2FjdGlvbiwgcGFyYW1zLmJsb2NrVGFnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVyW21ldGhvZF0ocGFyYW1zLnRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRUcmFuc2FjdGlvblwiOlxuICAgICAgICAgICAgY2FzZSBcImdldFRyYW5zYWN0aW9uUmVjZWlwdFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBwcm92aWRlclttZXRob2RdKHBhcmFtcy50cmFuc2FjdGlvbkhhc2gpO1xuICAgICAgICAgICAgY2FzZSBcImdldExvZ3NcIjoge1xuICAgICAgICAgICAgICAgIGxldCBmaWx0ZXIgPSBwYXJhbXMuZmlsdGVyO1xuICAgICAgICAgICAgICAgIGlmICgoZmlsdGVyLmZyb21CbG9jayAmJiBpc0hleFN0cmluZyhmaWx0ZXIuZnJvbUJsb2NrKSkgfHwgKGZpbHRlci50b0Jsb2NrICYmIGlzSGV4U3RyaW5nKGZpbHRlci50b0Jsb2NrKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXIgPSB5aWVsZCB3YWl0Rm9yU3luYyhjb25maWcsIGN1cnJlbnRCbG9ja051bWJlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBwcm92aWRlci5nZXRMb2dzKGZpbHRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0Vycm9yKFwidW5rbm93biBtZXRob2QgZXJyb3JcIiwgTG9nZ2VyLmVycm9ycy5VTktOT1dOX0VSUk9SLCB7XG4gICAgICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgICAgIHBhcmFtczogcGFyYW1zXG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuZXhwb3J0IGNsYXNzIEZhbGxiYWNrUHJvdmlkZXIgZXh0ZW5kcyBCYXNlUHJvdmlkZXIge1xuICAgIGNvbnN0cnVjdG9yKHByb3ZpZGVycywgcXVvcnVtKSB7XG4gICAgICAgIGlmIChwcm92aWRlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwibWlzc2luZyBwcm92aWRlcnNcIiwgXCJwcm92aWRlcnNcIiwgcHJvdmlkZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcm92aWRlckNvbmZpZ3MgPSBwcm92aWRlcnMubWFwKChjb25maWdPclByb3ZpZGVyLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgaWYgKFByb3ZpZGVyLmlzUHJvdmlkZXIoY29uZmlnT3JQcm92aWRlcikpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGFsbFRpbWVvdXQgPSBpc0NvbW11bml0eVJlc291cmNlKGNvbmZpZ09yUHJvdmlkZXIpID8gMjAwMCA6IDc1MDtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmlvcml0eSA9IDE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5mcmVlemUoeyBwcm92aWRlcjogY29uZmlnT3JQcm92aWRlciwgd2VpZ2h0OiAxLCBzdGFsbFRpbWVvdXQsIHByaW9yaXR5IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY29uZmlnID0gc2hhbGxvd0NvcHkoY29uZmlnT3JQcm92aWRlcik7XG4gICAgICAgICAgICBpZiAoY29uZmlnLnByaW9yaXR5ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25maWcucHJpb3JpdHkgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbmZpZy5zdGFsbFRpbWVvdXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5zdGFsbFRpbWVvdXQgPSBpc0NvbW11bml0eVJlc291cmNlKGNvbmZpZ09yUHJvdmlkZXIpID8gMjAwMCA6IDc1MDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb25maWcud2VpZ2h0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25maWcud2VpZ2h0ID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHdlaWdodCA9IGNvbmZpZy53ZWlnaHQ7XG4gICAgICAgICAgICBpZiAod2VpZ2h0ICUgMSB8fCB3ZWlnaHQgPiA1MTIgfHwgd2VpZ2h0IDwgMSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIHdlaWdodDsgbXVzdCBiZSBpbnRlZ2VyIGluIFsxLCA1MTJdXCIsIGBwcm92aWRlcnNbJHtpbmRleH1dLndlaWdodGAsIHdlaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZShjb25maWcpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgdG90YWwgPSBwcm92aWRlckNvbmZpZ3MucmVkdWNlKChhY2N1bSwgYykgPT4gKGFjY3VtICsgYy53ZWlnaHQpLCAwKTtcbiAgICAgICAgaWYgKHF1b3J1bSA9PSBudWxsKSB7XG4gICAgICAgICAgICBxdW9ydW0gPSB0b3RhbCAvIDI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocXVvcnVtID4gdG90YWwpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJxdW9ydW0gd2lsbCBhbHdheXMgZmFpbDsgbGFyZ2VyIHRoYW4gdG90YWwgd2VpZ2h0XCIsIFwicXVvcnVtXCIsIHF1b3J1bSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXJlIGFsbCBwcm92aWRlcnMnIG5ldHdvcmtzIGFyZSBrbm93blxuICAgICAgICBsZXQgbmV0d29ya09yUmVhZHkgPSBjaGVja05ldHdvcmtzKHByb3ZpZGVyQ29uZmlncy5tYXAoKGMpID0+IChjLnByb3ZpZGVyKS5uZXR3b3JrKSk7XG4gICAgICAgIC8vIE5vdCBhbGwgbmV0d29ya3MgYXJlIGtub3duOyB3ZSBtdXN0IHN0YWxsXG4gICAgICAgIGlmIChuZXR3b3JrT3JSZWFkeSA9PSBudWxsKSB7XG4gICAgICAgICAgICBuZXR3b3JrT3JSZWFkeSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZXRlY3ROZXR3b3JrKCkudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIobmV0d29ya09yUmVhZHkpO1xuICAgICAgICAvLyBQcmVzZXJ2ZSBhIGNvcHksIHNvIHdlIGRvIG5vdCBnZXQgbXV0YXRlZFxuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcInByb3ZpZGVyQ29uZmlnc1wiLCBPYmplY3QuZnJlZXplKHByb3ZpZGVyQ29uZmlncykpO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcInF1b3J1bVwiLCBxdW9ydW0pO1xuICAgICAgICB0aGlzLl9oaWdoZXN0QmxvY2tOdW1iZXIgPSAtMTtcbiAgICB9XG4gICAgZGV0ZWN0TmV0d29yaygpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ldHdvcmtzID0geWllbGQgUHJvbWlzZS5hbGwodGhpcy5wcm92aWRlckNvbmZpZ3MubWFwKChjKSA9PiBjLnByb3ZpZGVyLmdldE5ldHdvcmsoKSkpO1xuICAgICAgICAgICAgcmV0dXJuIGNoZWNrTmV0d29ya3MobmV0d29ya3MpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcGVyZm9ybShtZXRob2QsIHBhcmFtcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgLy8gU2VuZGluZyB0cmFuc2FjdGlvbnMgaXMgc3BlY2lhbDsgYWx3YXlzIGJyb2FkY2FzdCBpdCB0byBhbGwgYmFja2VuZHNcbiAgICAgICAgICAgIGlmIChtZXRob2QgPT09IFwic2VuZFRyYW5zYWN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHRzID0geWllbGQgUHJvbWlzZS5hbGwodGhpcy5wcm92aWRlckNvbmZpZ3MubWFwKChjKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjLnByb3ZpZGVyLnNlbmRUcmFuc2FjdGlvbihwYXJhbXMuc2lnbmVkVHJhbnNhY3Rpb24pLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5oYXNoO1xuICAgICAgICAgICAgICAgICAgICB9LCAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIC8vIEFueSBzdWNjZXNzIGlzIGdvb2QgZW5vdWdoIChvdGhlciBlcnJvcnMgYXJlIGxpa2VseSBcImFscmVhZHkgc2VlblwiIGVycm9yc1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzdWx0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSByZXN1bHRzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChyZXN1bHQpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFRoZXkgd2VyZSBhbGwgYW4gZXJyb3I7IHBpY2sgdGhlIGZpcnN0IGVycm9yXG4gICAgICAgICAgICAgICAgdGhyb3cgcmVzdWx0c1swXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gbWFrZSBzdXJlIHdlIGFyZSBpbiBzeW5jIHdpdGggb3VyIGJhY2tlbmRzLCBzbyB3ZSBuZWVkXG4gICAgICAgICAgICAvLyB0byBrbm93IHRoaXMgYmVmb3JlIHdlIGNhbiBtYWtlIGEgbG90IG9mIGNhbGxzXG4gICAgICAgICAgICBpZiAodGhpcy5faGlnaGVzdEJsb2NrTnVtYmVyID09PSAtMSAmJiBtZXRob2QgIT09IFwiZ2V0QmxvY2tOdW1iZXJcIikge1xuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuZ2V0QmxvY2tOdW1iZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHByb2Nlc3NGdW5jID0gZ2V0UHJvY2Vzc0Z1bmModGhpcywgbWV0aG9kLCBwYXJhbXMpO1xuICAgICAgICAgICAgLy8gU2h1ZmZsZSB0aGUgcHJvdmlkZXJzIGFuZCB0aGVuIHNvcnQgdGhlbSBieSB0aGVpciBwcmlvcml0eTsgd2VcbiAgICAgICAgICAgIC8vIHNoYWxsb3dDb3B5IHRoZW0gc2luY2Ugd2Ugd2lsbCBzdG9yZSB0aGUgcmVzdWx0IGluIHRoZW0gdG9vXG4gICAgICAgICAgICBjb25zdCBjb25maWdzID0gc2h1ZmZsZWQodGhpcy5wcm92aWRlckNvbmZpZ3MubWFwKHNoYWxsb3dDb3B5KSk7XG4gICAgICAgICAgICBjb25maWdzLnNvcnQoKGEsIGIpID0+IChhLnByaW9yaXR5IC0gYi5wcmlvcml0eSkpO1xuICAgICAgICAgICAgY29uc3QgY3VycmVudEJsb2NrTnVtYmVyID0gdGhpcy5faGlnaGVzdEJsb2NrTnVtYmVyO1xuICAgICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgICAgbGV0IGZpcnN0ID0gdHJ1ZTtcbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdDAgPSBub3coKTtcbiAgICAgICAgICAgICAgICAvLyBDb21wdXRlIHRoZSBpbmZsaWdodCB3ZWlnaHQgKGV4Y2x1ZGUgYW55dGhpbmcgcGFzdClcbiAgICAgICAgICAgICAgICBsZXQgaW5mbGlnaHRXZWlnaHQgPSBjb25maWdzLmZpbHRlcigoYykgPT4gKGMucnVubmVyICYmICgodDAgLSBjLnN0YXJ0KSA8IGMuc3RhbGxUaW1lb3V0KSkpXG4gICAgICAgICAgICAgICAgICAgIC5yZWR1Y2UoKGFjY3VtLCBjKSA9PiAoYWNjdW0gKyBjLndlaWdodCksIDApO1xuICAgICAgICAgICAgICAgIC8vIFN0YXJ0IHJ1bm5pbmcgZW5vdWdoIHRvIG1lZXQgcXVvcnVtXG4gICAgICAgICAgICAgICAgd2hpbGUgKGluZmxpZ2h0V2VpZ2h0IDwgdGhpcy5xdW9ydW0gJiYgaSA8IGNvbmZpZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbmZpZyA9IGNvbmZpZ3NbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmlkID0gbmV4dFJpZCsrO1xuICAgICAgICAgICAgICAgICAgICBjb25maWcuc3RhcnQgPSBub3coKTtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLnN0YWxsZXIgPSBzdGFsbChjb25maWcuc3RhbGxUaW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLnN0YWxsZXIud2FpdCgoKSA9PiB7IGNvbmZpZy5zdGFsbGVyID0gbnVsbDsgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5ydW5uZXIgPSBnZXRSdW5uZXIoY29uZmlnLCBjdXJyZW50QmxvY2tOdW1iZXIsIG1ldGhvZCwgcGFyYW1zKS50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy5kb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy5yZXN1bHQgPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5saXN0ZW5lckNvdW50KFwiZGVidWdcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJyZXF1ZXN0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZDogcmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYWNrZW5kOiBleHBvc2VEZWJ1Z0NvbmZpZyhjb25maWcsIG5vdygpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdDogeyBtZXRob2Q6IG1ldGhvZCwgcGFyYW1zOiBkZWVwQ29weShwYXJhbXMpIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyOiB0aGlzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLmRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLmVycm9yID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5saXN0ZW5lckNvdW50KFwiZGVidWdcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJyZXF1ZXN0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZDogcmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYWNrZW5kOiBleHBvc2VEZWJ1Z0NvbmZpZyhjb25maWcsIG5vdygpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdDogeyBtZXRob2Q6IG1ldGhvZCwgcGFyYW1zOiBkZWVwQ29weShwYXJhbXMpIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyOiB0aGlzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5saXN0ZW5lckNvdW50KFwiZGVidWdcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwicmVxdWVzdFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZDogcmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tlbmQ6IGV4cG9zZURlYnVnQ29uZmlnKGNvbmZpZywgbnVsbCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdDogeyBtZXRob2Q6IG1ldGhvZCwgcGFyYW1zOiBkZWVwQ29weShwYXJhbXMpIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXI6IHRoaXNcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGluZmxpZ2h0V2VpZ2h0ICs9IGNvbmZpZy53ZWlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFdhaXQgZm9yIGFueXRoaW5nIG1lYW5pbmdmdWwgdG8gZmluaXNoIG9yIHN0YWxsIG91dFxuICAgICAgICAgICAgICAgIGNvbnN0IHdhaXRpbmcgPSBbXTtcbiAgICAgICAgICAgICAgICBjb25maWdzLmZvckVhY2goKGMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMuZG9uZSB8fCAhYy5ydW5uZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB3YWl0aW5nLnB1c2goYy5ydW5uZXIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYy5zdGFsbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3YWl0aW5nLnB1c2goYy5zdGFsbGVyLmdldFByb21pc2UoKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAod2FpdGluZy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgUHJvbWlzZS5yYWNlKHdhaXRpbmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBDaGVjayB0aGUgcXVvcnVtIGFuZCBwcm9jZXNzIHRoZSByZXN1bHRzOyB0aGUgcHJvY2VzcyBmdW5jdGlvblxuICAgICAgICAgICAgICAgIC8vIG1heSBhZGRpdGlvbmFsbHkgZGVjaWRlIHRoZSBxdW9ydW0gaXMgbm90IG1ldFxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdHMgPSBjb25maWdzLmZpbHRlcigoYykgPT4gKGMuZG9uZSAmJiBjLmVycm9yID09IG51bGwpKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0cy5sZW5ndGggPj0gdGhpcy5xdW9ydW0pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gcHJvY2Vzc0Z1bmMocmVzdWx0cyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2h1dCBkb3duIGFueSBzdGFsbGVyc1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlncy5mb3JFYWNoKGMgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjLnN0YWxsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5zdGFsbGVyLmNhbmNlbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmaXJzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgc3RhbGwoMTAwKS5nZXRQcm9taXNlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gTm8gcmVzdWx0LCBjaGVjayBmb3IgZXJyb3JzIHRoYXQgc2hvdWxkIGJlIGZvcndhcmRlZFxuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9ycyA9IGNvbmZpZ3MucmVkdWNlKChhY2N1bSwgYykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWMuZG9uZSB8fCBjLmVycm9yID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhY2N1bTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb2RlID0gKGMuZXJyb3IpLmNvZGU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChGb3J3YXJkRXJyb3JzLmluZGV4T2YoY29kZSkgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhY2N1bVtjb2RlXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjY3VtW2NvZGVdID0geyBlcnJvcjogYy5lcnJvciwgd2VpZ2h0OiAwIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBhY2N1bVtjb2RlXS53ZWlnaHQgKz0gYy53ZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFjY3VtO1xuICAgICAgICAgICAgICAgIH0sICh7fSkpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKGVycm9ycykuZm9yRWFjaCgoZXJyb3JDb2RlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhbGx5ID0gZXJyb3JzW2Vycm9yQ29kZV07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWxseS53ZWlnaHQgPCB0aGlzLnF1b3J1bSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFNodXQgZG93biBhbnkgc3RhbGxlcnNcbiAgICAgICAgICAgICAgICAgICAgY29uZmlncy5mb3JFYWNoKGMgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGMuc3RhbGxlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuc3RhbGxlci5jYW5jZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGMuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGUgPSAodGFsbHkuZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9wcyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBGb3J3YXJkUHJvcGVydGllcy5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZVtuYW1lXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHNbbmFtZV0gPSBlW25hbWVdO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoZS5yZWFzb24gfHwgZS5tZXNzYWdlLCBlcnJvckNvZGUsIHByb3BzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyBBbGwgY29uZmlncyBoYXZlIHJ1biB0byBjb21wbGV0aW9uOyB3ZSB3aWxsIG5ldmVyIGdldCBtb3JlIGRhdGFcbiAgICAgICAgICAgICAgICBpZiAoY29uZmlncy5maWx0ZXIoKGMpID0+ICFjLmRvbmUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTaHV0IGRvd24gYW55IHN0YWxsZXJzOyBzaG91bGRuJ3QgYmUgYW55XG4gICAgICAgICAgICBjb25maWdzLmZvckVhY2goYyA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGMuc3RhbGxlcikge1xuICAgICAgICAgICAgICAgICAgICBjLnN0YWxsZXIuY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGMuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0Vycm9yKFwiZmFpbGVkIHRvIG1lZXQgcXVvcnVtXCIsIExvZ2dlci5lcnJvcnMuU0VSVkVSX0VSUk9SLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICAgICAgICAgICAgcGFyYW1zOiBwYXJhbXMsXG4gICAgICAgICAgICAgICAgLy9yZXN1bHRzOiBjb25maWdzLm1hcCgoYykgPT4gYy5yZXN1bHQpLFxuICAgICAgICAgICAgICAgIC8vZXJyb3JzOiBjb25maWdzLm1hcCgoYykgPT4gYy5lcnJvciksXG4gICAgICAgICAgICAgICAgcmVzdWx0czogY29uZmlncy5tYXAoKGMpID0+IGV4cG9zZURlYnVnQ29uZmlnKGMpKSxcbiAgICAgICAgICAgICAgICBwcm92aWRlcjogdGhpc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZhbGxiYWNrLXByb3ZpZGVyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ethersproject/providers/lib.esm/fallback-provider.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@ethersproject/providers/lib.esm/formatter.js":
/*!*********************************************************************!*\
  !*** ../node_modules/@ethersproject/providers/lib.esm/formatter.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Formatter: () => (/* binding */ Formatter),\n/* harmony export */   isCommunityResourcable: () => (/* binding */ isCommunityResourcable),\n/* harmony export */   isCommunityResource: () => (/* binding */ isCommunityResource),\n/* harmony export */   showThrottleMessage: () => (/* binding */ showThrottleMessage)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_address__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @ethersproject/address */ \"(ssr)/../node_modules/@ethersproject/address/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethersproject/bignumber */ \"(ssr)/../node_modules/@ethersproject/bignumber/lib.esm/bignumber.js\");\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/../node_modules/@ethersproject/bytes/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_constants__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @ethersproject/constants */ \"(ssr)/../node_modules/@ethersproject/constants/lib.esm/addresses.js\");\n/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/../node_modules/@ethersproject/properties/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_transactions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/transactions */ \"(ssr)/../node_modules/@ethersproject/transactions/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/../node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(ssr)/../node_modules/@ethersproject/providers/lib.esm/_version.js\");\n\n\n\n\n\n\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\nclass Formatter {\n    constructor() {\n        this.formats = this.getDefaultFormats();\n    }\n    getDefaultFormats() {\n        const formats = ({});\n        const address = this.address.bind(this);\n        const bigNumber = this.bigNumber.bind(this);\n        const blockTag = this.blockTag.bind(this);\n        const data = this.data.bind(this);\n        const hash = this.hash.bind(this);\n        const hex = this.hex.bind(this);\n        const number = this.number.bind(this);\n        const type = this.type.bind(this);\n        const strictData = (v) => { return this.data(v, true); };\n        formats.transaction = {\n            hash: hash,\n            type: type,\n            accessList: Formatter.allowNull(this.accessList.bind(this), null),\n            blockHash: Formatter.allowNull(hash, null),\n            blockNumber: Formatter.allowNull(number, null),\n            transactionIndex: Formatter.allowNull(number, null),\n            confirmations: Formatter.allowNull(number, null),\n            from: address,\n            // either (gasPrice) or (maxPriorityFeePerGas + maxFeePerGas)\n            // must be set\n            gasPrice: Formatter.allowNull(bigNumber),\n            maxPriorityFeePerGas: Formatter.allowNull(bigNumber),\n            maxFeePerGas: Formatter.allowNull(bigNumber),\n            gasLimit: bigNumber,\n            to: Formatter.allowNull(address, null),\n            value: bigNumber,\n            nonce: number,\n            data: data,\n            r: Formatter.allowNull(this.uint256),\n            s: Formatter.allowNull(this.uint256),\n            v: Formatter.allowNull(number),\n            creates: Formatter.allowNull(address, null),\n            raw: Formatter.allowNull(data),\n        };\n        formats.transactionRequest = {\n            from: Formatter.allowNull(address),\n            nonce: Formatter.allowNull(number),\n            gasLimit: Formatter.allowNull(bigNumber),\n            gasPrice: Formatter.allowNull(bigNumber),\n            maxPriorityFeePerGas: Formatter.allowNull(bigNumber),\n            maxFeePerGas: Formatter.allowNull(bigNumber),\n            to: Formatter.allowNull(address),\n            value: Formatter.allowNull(bigNumber),\n            data: Formatter.allowNull(strictData),\n            type: Formatter.allowNull(number),\n            accessList: Formatter.allowNull(this.accessList.bind(this), null),\n        };\n        formats.receiptLog = {\n            transactionIndex: number,\n            blockNumber: number,\n            transactionHash: hash,\n            address: address,\n            topics: Formatter.arrayOf(hash),\n            data: data,\n            logIndex: number,\n            blockHash: hash,\n        };\n        formats.receipt = {\n            to: Formatter.allowNull(this.address, null),\n            from: Formatter.allowNull(this.address, null),\n            contractAddress: Formatter.allowNull(address, null),\n            transactionIndex: number,\n            // should be allowNull(hash), but broken-EIP-658 support is handled in receipt\n            root: Formatter.allowNull(hex),\n            gasUsed: bigNumber,\n            logsBloom: Formatter.allowNull(data),\n            blockHash: hash,\n            transactionHash: hash,\n            logs: Formatter.arrayOf(this.receiptLog.bind(this)),\n            blockNumber: number,\n            confirmations: Formatter.allowNull(number, null),\n            cumulativeGasUsed: bigNumber,\n            effectiveGasPrice: Formatter.allowNull(bigNumber),\n            status: Formatter.allowNull(number),\n            type: type\n        };\n        formats.block = {\n            hash: Formatter.allowNull(hash),\n            parentHash: hash,\n            number: number,\n            timestamp: number,\n            nonce: Formatter.allowNull(hex),\n            difficulty: this.difficulty.bind(this),\n            gasLimit: bigNumber,\n            gasUsed: bigNumber,\n            miner: Formatter.allowNull(address),\n            extraData: data,\n            transactions: Formatter.allowNull(Formatter.arrayOf(hash)),\n            baseFeePerGas: Formatter.allowNull(bigNumber)\n        };\n        formats.blockWithTransactions = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.shallowCopy)(formats.block);\n        formats.blockWithTransactions.transactions = Formatter.allowNull(Formatter.arrayOf(this.transactionResponse.bind(this)));\n        formats.filter = {\n            fromBlock: Formatter.allowNull(blockTag, undefined),\n            toBlock: Formatter.allowNull(blockTag, undefined),\n            blockHash: Formatter.allowNull(hash, undefined),\n            address: Formatter.allowNull(address, undefined),\n            topics: Formatter.allowNull(this.topics.bind(this), undefined),\n        };\n        formats.filterLog = {\n            blockNumber: Formatter.allowNull(number),\n            blockHash: Formatter.allowNull(hash),\n            transactionIndex: number,\n            removed: Formatter.allowNull(this.boolean.bind(this)),\n            address: address,\n            data: Formatter.allowFalsish(data, \"0x\"),\n            topics: Formatter.arrayOf(hash),\n            transactionHash: hash,\n            logIndex: number,\n        };\n        return formats;\n    }\n    accessList(accessList) {\n        return (0,_ethersproject_transactions__WEBPACK_IMPORTED_MODULE_3__.accessListify)(accessList || []);\n    }\n    // Requires a BigNumberish that is within the IEEE754 safe integer range; returns a number\n    // Strict! Used on input.\n    number(number) {\n        if (number === \"0x\") {\n            return 0;\n        }\n        return _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(number).toNumber();\n    }\n    type(number) {\n        if (number === \"0x\" || number == null) {\n            return 0;\n        }\n        return _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(number).toNumber();\n    }\n    // Strict! Used on input.\n    bigNumber(value) {\n        return _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(value);\n    }\n    // Requires a boolean, \"true\" or  \"false\"; returns a boolean\n    boolean(value) {\n        if (typeof (value) === \"boolean\") {\n            return value;\n        }\n        if (typeof (value) === \"string\") {\n            value = value.toLowerCase();\n            if (value === \"true\") {\n                return true;\n            }\n            if (value === \"false\") {\n                return false;\n            }\n        }\n        throw new Error(\"invalid boolean - \" + value);\n    }\n    hex(value, strict) {\n        if (typeof (value) === \"string\") {\n            if (!strict && value.substring(0, 2) !== \"0x\") {\n                value = \"0x\" + value;\n            }\n            if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__.isHexString)(value)) {\n                return value.toLowerCase();\n            }\n        }\n        return logger.throwArgumentError(\"invalid hash\", \"value\", value);\n    }\n    data(value, strict) {\n        const result = this.hex(value, strict);\n        if ((result.length % 2) !== 0) {\n            throw new Error(\"invalid data; odd-length - \" + value);\n        }\n        return result;\n    }\n    // Requires an address\n    // Strict! Used on input.\n    address(value) {\n        return (0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_6__.getAddress)(value);\n    }\n    callAddress(value) {\n        if (!(0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__.isHexString)(value, 32)) {\n            return null;\n        }\n        const address = (0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_6__.getAddress)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__.hexDataSlice)(value, 12));\n        return (address === _ethersproject_constants__WEBPACK_IMPORTED_MODULE_7__.AddressZero) ? null : address;\n    }\n    contractAddress(value) {\n        return (0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_6__.getContractAddress)(value);\n    }\n    // Strict! Used on input.\n    blockTag(blockTag) {\n        if (blockTag == null) {\n            return \"latest\";\n        }\n        if (blockTag === \"earliest\") {\n            return \"0x0\";\n        }\n        switch (blockTag) {\n            case \"earliest\": return \"0x0\";\n            case \"latest\":\n            case \"pending\":\n            case \"safe\":\n            case \"finalized\":\n                return blockTag;\n        }\n        if (typeof (blockTag) === \"number\" || (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__.isHexString)(blockTag)) {\n            return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__.hexValue)(blockTag);\n        }\n        throw new Error(\"invalid blockTag\");\n    }\n    // Requires a hash, optionally requires 0x prefix; returns prefixed lowercase hash.\n    hash(value, strict) {\n        const result = this.hex(value, strict);\n        if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__.hexDataLength)(result) !== 32) {\n            return logger.throwArgumentError(\"invalid hash\", \"value\", value);\n        }\n        return result;\n    }\n    // Returns the difficulty as a number, or if too large (i.e. PoA network) null\n    difficulty(value) {\n        if (value == null) {\n            return null;\n        }\n        const v = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(value);\n        try {\n            return v.toNumber();\n        }\n        catch (error) { }\n        return null;\n    }\n    uint256(value) {\n        if (!(0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__.isHexString)(value)) {\n            throw new Error(\"invalid uint256\");\n        }\n        return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__.hexZeroPad)(value, 32);\n    }\n    _block(value, format) {\n        if (value.author != null && value.miner == null) {\n            value.miner = value.author;\n        }\n        // The difficulty may need to come from _difficulty in recursed blocks\n        const difficulty = (value._difficulty != null) ? value._difficulty : value.difficulty;\n        const result = Formatter.check(format, value);\n        result._difficulty = ((difficulty == null) ? null : _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(difficulty));\n        return result;\n    }\n    block(value) {\n        return this._block(value, this.formats.block);\n    }\n    blockWithTransactions(value) {\n        return this._block(value, this.formats.blockWithTransactions);\n    }\n    // Strict! Used on input.\n    transactionRequest(value) {\n        return Formatter.check(this.formats.transactionRequest, value);\n    }\n    transactionResponse(transaction) {\n        // Rename gas to gasLimit\n        if (transaction.gas != null && transaction.gasLimit == null) {\n            transaction.gasLimit = transaction.gas;\n        }\n        // Some clients (TestRPC) do strange things like return 0x0 for the\n        // 0 address; correct this to be a real address\n        if (transaction.to && _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(transaction.to).isZero()) {\n            transaction.to = \"0x0000000000000000000000000000000000000000\";\n        }\n        // Rename input to data\n        if (transaction.input != null && transaction.data == null) {\n            transaction.data = transaction.input;\n        }\n        // If to and creates are empty, populate the creates from the transaction\n        if (transaction.to == null && transaction.creates == null) {\n            transaction.creates = this.contractAddress(transaction);\n        }\n        if ((transaction.type === 1 || transaction.type === 2) && transaction.accessList == null) {\n            transaction.accessList = [];\n        }\n        const result = Formatter.check(this.formats.transaction, transaction);\n        if (transaction.chainId != null) {\n            let chainId = transaction.chainId;\n            if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__.isHexString)(chainId)) {\n                chainId = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(chainId).toNumber();\n            }\n            result.chainId = chainId;\n        }\n        else {\n            let chainId = transaction.networkId;\n            // geth-etc returns chainId\n            if (chainId == null && result.v == null) {\n                chainId = transaction.chainId;\n            }\n            if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__.isHexString)(chainId)) {\n                chainId = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(chainId).toNumber();\n            }\n            if (typeof (chainId) !== \"number\" && result.v != null) {\n                chainId = (result.v - 35) / 2;\n                if (chainId < 0) {\n                    chainId = 0;\n                }\n                chainId = parseInt(chainId);\n            }\n            if (typeof (chainId) !== \"number\") {\n                chainId = 0;\n            }\n            result.chainId = chainId;\n        }\n        // 0x0000... should actually be null\n        if (result.blockHash && result.blockHash.replace(/0/g, \"\") === \"x\") {\n            result.blockHash = null;\n        }\n        return result;\n    }\n    transaction(value) {\n        return (0,_ethersproject_transactions__WEBPACK_IMPORTED_MODULE_3__.parse)(value);\n    }\n    receiptLog(value) {\n        return Formatter.check(this.formats.receiptLog, value);\n    }\n    receipt(value) {\n        const result = Formatter.check(this.formats.receipt, value);\n        // RSK incorrectly implemented EIP-658, so we munge things a bit here for it\n        if (result.root != null) {\n            if (result.root.length <= 4) {\n                // Could be 0x00, 0x0, 0x01 or 0x1\n                const value = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(result.root).toNumber();\n                if (value === 0 || value === 1) {\n                    // Make sure if both are specified, they match\n                    if (result.status != null && (result.status !== value)) {\n                        logger.throwArgumentError(\"alt-root-status/status mismatch\", \"value\", { root: result.root, status: result.status });\n                    }\n                    result.status = value;\n                    delete result.root;\n                }\n                else {\n                    logger.throwArgumentError(\"invalid alt-root-status\", \"value.root\", result.root);\n                }\n            }\n            else if (result.root.length !== 66) {\n                // Must be a valid bytes32\n                logger.throwArgumentError(\"invalid root hash\", \"value.root\", result.root);\n            }\n        }\n        if (result.status != null) {\n            result.byzantium = true;\n        }\n        return result;\n    }\n    topics(value) {\n        if (Array.isArray(value)) {\n            return value.map((v) => this.topics(v));\n        }\n        else if (value != null) {\n            return this.hash(value, true);\n        }\n        return null;\n    }\n    filter(value) {\n        return Formatter.check(this.formats.filter, value);\n    }\n    filterLog(value) {\n        return Formatter.check(this.formats.filterLog, value);\n    }\n    static check(format, object) {\n        const result = {};\n        for (const key in format) {\n            try {\n                const value = format[key](object[key]);\n                if (value !== undefined) {\n                    result[key] = value;\n                }\n            }\n            catch (error) {\n                error.checkKey = key;\n                error.checkValue = object[key];\n                throw error;\n            }\n        }\n        return result;\n    }\n    // if value is null-ish, nullValue is returned\n    static allowNull(format, nullValue) {\n        return (function (value) {\n            if (value == null) {\n                return nullValue;\n            }\n            return format(value);\n        });\n    }\n    // If value is false-ish, replaceValue is returned\n    static allowFalsish(format, replaceValue) {\n        return (function (value) {\n            if (!value) {\n                return replaceValue;\n            }\n            return format(value);\n        });\n    }\n    // Requires an Array satisfying check\n    static arrayOf(format) {\n        return (function (array) {\n            if (!Array.isArray(array)) {\n                throw new Error(\"not an array\");\n            }\n            const result = [];\n            array.forEach(function (value) {\n                result.push(format(value));\n            });\n            return result;\n        });\n    }\n}\nfunction isCommunityResourcable(value) {\n    return (value && typeof (value.isCommunityResource) === \"function\");\n}\nfunction isCommunityResource(value) {\n    return (isCommunityResourcable(value) && value.isCommunityResource());\n}\n// Show the throttle message only once\nlet throttleMessage = false;\nfunction showThrottleMessage() {\n    if (throttleMessage) {\n        return;\n    }\n    throttleMessage = true;\n    console.log(\"========= NOTICE =========\");\n    console.log(\"Request-Rate Exceeded  (this message will not be repeated)\");\n    console.log(\"\");\n    console.log(\"The default API keys for each service are provided as a highly-throttled,\");\n    console.log(\"community resource for low-traffic projects and early prototyping.\");\n    console.log(\"\");\n    console.log(\"While your application will continue to function, we highly recommended\");\n    console.log(\"signing up for your own API keys to improve performance, increase your\");\n    console.log(\"request rate/limit and enable other perks, such as metrics and advanced APIs.\");\n    console.log(\"\");\n    console.log(\"For more details: https:/\\/docs.ethers.io/api-keys/\");\n    console.log(\"==========================\");\n}\n//# sourceMappingURL=formatter.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3Byb3ZpZGVycy9saWIuZXNtL2Zvcm1hdHRlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBYTtBQUMyRDtBQUNuQjtBQUNpRDtBQUMvQztBQUNDO0FBQytCO0FBQ3hDO0FBQ1Y7QUFDckMsbUJBQW1CLHlEQUFNLENBQUMsNkNBQU87QUFDMUI7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxzRUFBVztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMEVBQWE7QUFDNUI7QUFDQSw4RUFBOEU7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsK0RBQVM7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O0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xlZGdpdHkteWllbGQtZnJvbnRlbmQvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3Byb3ZpZGVycy9saWIuZXNtL2Zvcm1hdHRlci5qcz9lNWE4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuaW1wb3J0IHsgZ2V0QWRkcmVzcywgZ2V0Q29udHJhY3RBZGRyZXNzIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2FkZHJlc3NcIjtcbmltcG9ydCB7IEJpZ051bWJlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9iaWdudW1iZXJcIjtcbmltcG9ydCB7IGhleERhdGFMZW5ndGgsIGhleERhdGFTbGljZSwgaGV4VmFsdWUsIGhleFplcm9QYWQsIGlzSGV4U3RyaW5nIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2J5dGVzXCI7XG5pbXBvcnQgeyBBZGRyZXNzWmVybyB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9jb25zdGFudHNcIjtcbmltcG9ydCB7IHNoYWxsb3dDb3B5IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3Byb3BlcnRpZXNcIjtcbmltcG9ydCB7IGFjY2Vzc0xpc3RpZnksIHBhcnNlIGFzIHBhcnNlVHJhbnNhY3Rpb24gfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvdHJhbnNhY3Rpb25zXCI7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvbG9nZ2VyXCI7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4vX3ZlcnNpb25cIjtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIodmVyc2lvbik7XG5leHBvcnQgY2xhc3MgRm9ybWF0dGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5mb3JtYXRzID0gdGhpcy5nZXREZWZhdWx0Rm9ybWF0cygpO1xuICAgIH1cbiAgICBnZXREZWZhdWx0Rm9ybWF0cygpIHtcbiAgICAgICAgY29uc3QgZm9ybWF0cyA9ICh7fSk7XG4gICAgICAgIGNvbnN0IGFkZHJlc3MgPSB0aGlzLmFkZHJlc3MuYmluZCh0aGlzKTtcbiAgICAgICAgY29uc3QgYmlnTnVtYmVyID0gdGhpcy5iaWdOdW1iZXIuYmluZCh0aGlzKTtcbiAgICAgICAgY29uc3QgYmxvY2tUYWcgPSB0aGlzLmJsb2NrVGFnLmJpbmQodGhpcyk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLmRhdGEuYmluZCh0aGlzKTtcbiAgICAgICAgY29uc3QgaGFzaCA9IHRoaXMuaGFzaC5iaW5kKHRoaXMpO1xuICAgICAgICBjb25zdCBoZXggPSB0aGlzLmhleC5iaW5kKHRoaXMpO1xuICAgICAgICBjb25zdCBudW1iZXIgPSB0aGlzLm51bWJlci5iaW5kKHRoaXMpO1xuICAgICAgICBjb25zdCB0eXBlID0gdGhpcy50eXBlLmJpbmQodGhpcyk7XG4gICAgICAgIGNvbnN0IHN0cmljdERhdGEgPSAodikgPT4geyByZXR1cm4gdGhpcy5kYXRhKHYsIHRydWUpOyB9O1xuICAgICAgICBmb3JtYXRzLnRyYW5zYWN0aW9uID0ge1xuICAgICAgICAgICAgaGFzaDogaGFzaCxcbiAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICBhY2Nlc3NMaXN0OiBGb3JtYXR0ZXIuYWxsb3dOdWxsKHRoaXMuYWNjZXNzTGlzdC5iaW5kKHRoaXMpLCBudWxsKSxcbiAgICAgICAgICAgIGJsb2NrSGFzaDogRm9ybWF0dGVyLmFsbG93TnVsbChoYXNoLCBudWxsKSxcbiAgICAgICAgICAgIGJsb2NrTnVtYmVyOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKG51bWJlciwgbnVsbCksXG4gICAgICAgICAgICB0cmFuc2FjdGlvbkluZGV4OiBGb3JtYXR0ZXIuYWxsb3dOdWxsKG51bWJlciwgbnVsbCksXG4gICAgICAgICAgICBjb25maXJtYXRpb25zOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKG51bWJlciwgbnVsbCksXG4gICAgICAgICAgICBmcm9tOiBhZGRyZXNzLFxuICAgICAgICAgICAgLy8gZWl0aGVyIChnYXNQcmljZSkgb3IgKG1heFByaW9yaXR5RmVlUGVyR2FzICsgbWF4RmVlUGVyR2FzKVxuICAgICAgICAgICAgLy8gbXVzdCBiZSBzZXRcbiAgICAgICAgICAgIGdhc1ByaWNlOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGJpZ051bWJlciksXG4gICAgICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhczogRm9ybWF0dGVyLmFsbG93TnVsbChiaWdOdW1iZXIpLFxuICAgICAgICAgICAgbWF4RmVlUGVyR2FzOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGJpZ051bWJlciksXG4gICAgICAgICAgICBnYXNMaW1pdDogYmlnTnVtYmVyLFxuICAgICAgICAgICAgdG86IEZvcm1hdHRlci5hbGxvd051bGwoYWRkcmVzcywgbnVsbCksXG4gICAgICAgICAgICB2YWx1ZTogYmlnTnVtYmVyLFxuICAgICAgICAgICAgbm9uY2U6IG51bWJlcixcbiAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgICByOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKHRoaXMudWludDI1NiksXG4gICAgICAgICAgICBzOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKHRoaXMudWludDI1NiksXG4gICAgICAgICAgICB2OiBGb3JtYXR0ZXIuYWxsb3dOdWxsKG51bWJlciksXG4gICAgICAgICAgICBjcmVhdGVzOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGFkZHJlc3MsIG51bGwpLFxuICAgICAgICAgICAgcmF3OiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGRhdGEpLFxuICAgICAgICB9O1xuICAgICAgICBmb3JtYXRzLnRyYW5zYWN0aW9uUmVxdWVzdCA9IHtcbiAgICAgICAgICAgIGZyb206IEZvcm1hdHRlci5hbGxvd051bGwoYWRkcmVzcyksXG4gICAgICAgICAgICBub25jZTogRm9ybWF0dGVyLmFsbG93TnVsbChudW1iZXIpLFxuICAgICAgICAgICAgZ2FzTGltaXQ6IEZvcm1hdHRlci5hbGxvd051bGwoYmlnTnVtYmVyKSxcbiAgICAgICAgICAgIGdhc1ByaWNlOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGJpZ051bWJlciksXG4gICAgICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhczogRm9ybWF0dGVyLmFsbG93TnVsbChiaWdOdW1iZXIpLFxuICAgICAgICAgICAgbWF4RmVlUGVyR2FzOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGJpZ051bWJlciksXG4gICAgICAgICAgICB0bzogRm9ybWF0dGVyLmFsbG93TnVsbChhZGRyZXNzKSxcbiAgICAgICAgICAgIHZhbHVlOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGJpZ051bWJlciksXG4gICAgICAgICAgICBkYXRhOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKHN0cmljdERhdGEpLFxuICAgICAgICAgICAgdHlwZTogRm9ybWF0dGVyLmFsbG93TnVsbChudW1iZXIpLFxuICAgICAgICAgICAgYWNjZXNzTGlzdDogRm9ybWF0dGVyLmFsbG93TnVsbCh0aGlzLmFjY2Vzc0xpc3QuYmluZCh0aGlzKSwgbnVsbCksXG4gICAgICAgIH07XG4gICAgICAgIGZvcm1hdHMucmVjZWlwdExvZyA9IHtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uSW5kZXg6IG51bWJlcixcbiAgICAgICAgICAgIGJsb2NrTnVtYmVyOiBudW1iZXIsXG4gICAgICAgICAgICB0cmFuc2FjdGlvbkhhc2g6IGhhc2gsXG4gICAgICAgICAgICBhZGRyZXNzOiBhZGRyZXNzLFxuICAgICAgICAgICAgdG9waWNzOiBGb3JtYXR0ZXIuYXJyYXlPZihoYXNoKSxcbiAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgICBsb2dJbmRleDogbnVtYmVyLFxuICAgICAgICAgICAgYmxvY2tIYXNoOiBoYXNoLFxuICAgICAgICB9O1xuICAgICAgICBmb3JtYXRzLnJlY2VpcHQgPSB7XG4gICAgICAgICAgICB0bzogRm9ybWF0dGVyLmFsbG93TnVsbCh0aGlzLmFkZHJlc3MsIG51bGwpLFxuICAgICAgICAgICAgZnJvbTogRm9ybWF0dGVyLmFsbG93TnVsbCh0aGlzLmFkZHJlc3MsIG51bGwpLFxuICAgICAgICAgICAgY29udHJhY3RBZGRyZXNzOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGFkZHJlc3MsIG51bGwpLFxuICAgICAgICAgICAgdHJhbnNhY3Rpb25JbmRleDogbnVtYmVyLFxuICAgICAgICAgICAgLy8gc2hvdWxkIGJlIGFsbG93TnVsbChoYXNoKSwgYnV0IGJyb2tlbi1FSVAtNjU4IHN1cHBvcnQgaXMgaGFuZGxlZCBpbiByZWNlaXB0XG4gICAgICAgICAgICByb290OiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGhleCksXG4gICAgICAgICAgICBnYXNVc2VkOiBiaWdOdW1iZXIsXG4gICAgICAgICAgICBsb2dzQmxvb206IEZvcm1hdHRlci5hbGxvd051bGwoZGF0YSksXG4gICAgICAgICAgICBibG9ja0hhc2g6IGhhc2gsXG4gICAgICAgICAgICB0cmFuc2FjdGlvbkhhc2g6IGhhc2gsXG4gICAgICAgICAgICBsb2dzOiBGb3JtYXR0ZXIuYXJyYXlPZih0aGlzLnJlY2VpcHRMb2cuYmluZCh0aGlzKSksXG4gICAgICAgICAgICBibG9ja051bWJlcjogbnVtYmVyLFxuICAgICAgICAgICAgY29uZmlybWF0aW9uczogRm9ybWF0dGVyLmFsbG93TnVsbChudW1iZXIsIG51bGwpLFxuICAgICAgICAgICAgY3VtdWxhdGl2ZUdhc1VzZWQ6IGJpZ051bWJlcixcbiAgICAgICAgICAgIGVmZmVjdGl2ZUdhc1ByaWNlOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGJpZ051bWJlciksXG4gICAgICAgICAgICBzdGF0dXM6IEZvcm1hdHRlci5hbGxvd051bGwobnVtYmVyKSxcbiAgICAgICAgICAgIHR5cGU6IHR5cGVcbiAgICAgICAgfTtcbiAgICAgICAgZm9ybWF0cy5ibG9jayA9IHtcbiAgICAgICAgICAgIGhhc2g6IEZvcm1hdHRlci5hbGxvd051bGwoaGFzaCksXG4gICAgICAgICAgICBwYXJlbnRIYXNoOiBoYXNoLFxuICAgICAgICAgICAgbnVtYmVyOiBudW1iZXIsXG4gICAgICAgICAgICB0aW1lc3RhbXA6IG51bWJlcixcbiAgICAgICAgICAgIG5vbmNlOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGhleCksXG4gICAgICAgICAgICBkaWZmaWN1bHR5OiB0aGlzLmRpZmZpY3VsdHkuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGdhc0xpbWl0OiBiaWdOdW1iZXIsXG4gICAgICAgICAgICBnYXNVc2VkOiBiaWdOdW1iZXIsXG4gICAgICAgICAgICBtaW5lcjogRm9ybWF0dGVyLmFsbG93TnVsbChhZGRyZXNzKSxcbiAgICAgICAgICAgIGV4dHJhRGF0YTogZGF0YSxcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uczogRm9ybWF0dGVyLmFsbG93TnVsbChGb3JtYXR0ZXIuYXJyYXlPZihoYXNoKSksXG4gICAgICAgICAgICBiYXNlRmVlUGVyR2FzOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGJpZ051bWJlcilcbiAgICAgICAgfTtcbiAgICAgICAgZm9ybWF0cy5ibG9ja1dpdGhUcmFuc2FjdGlvbnMgPSBzaGFsbG93Q29weShmb3JtYXRzLmJsb2NrKTtcbiAgICAgICAgZm9ybWF0cy5ibG9ja1dpdGhUcmFuc2FjdGlvbnMudHJhbnNhY3Rpb25zID0gRm9ybWF0dGVyLmFsbG93TnVsbChGb3JtYXR0ZXIuYXJyYXlPZih0aGlzLnRyYW5zYWN0aW9uUmVzcG9uc2UuYmluZCh0aGlzKSkpO1xuICAgICAgICBmb3JtYXRzLmZpbHRlciA9IHtcbiAgICAgICAgICAgIGZyb21CbG9jazogRm9ybWF0dGVyLmFsbG93TnVsbChibG9ja1RhZywgdW5kZWZpbmVkKSxcbiAgICAgICAgICAgIHRvQmxvY2s6IEZvcm1hdHRlci5hbGxvd051bGwoYmxvY2tUYWcsIHVuZGVmaW5lZCksXG4gICAgICAgICAgICBibG9ja0hhc2g6IEZvcm1hdHRlci5hbGxvd051bGwoaGFzaCwgdW5kZWZpbmVkKSxcbiAgICAgICAgICAgIGFkZHJlc3M6IEZvcm1hdHRlci5hbGxvd051bGwoYWRkcmVzcywgdW5kZWZpbmVkKSxcbiAgICAgICAgICAgIHRvcGljczogRm9ybWF0dGVyLmFsbG93TnVsbCh0aGlzLnRvcGljcy5iaW5kKHRoaXMpLCB1bmRlZmluZWQpLFxuICAgICAgICB9O1xuICAgICAgICBmb3JtYXRzLmZpbHRlckxvZyA9IHtcbiAgICAgICAgICAgIGJsb2NrTnVtYmVyOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKG51bWJlciksXG4gICAgICAgICAgICBibG9ja0hhc2g6IEZvcm1hdHRlci5hbGxvd051bGwoaGFzaCksXG4gICAgICAgICAgICB0cmFuc2FjdGlvbkluZGV4OiBudW1iZXIsXG4gICAgICAgICAgICByZW1vdmVkOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKHRoaXMuYm9vbGVhbi5iaW5kKHRoaXMpKSxcbiAgICAgICAgICAgIGFkZHJlc3M6IGFkZHJlc3MsXG4gICAgICAgICAgICBkYXRhOiBGb3JtYXR0ZXIuYWxsb3dGYWxzaXNoKGRhdGEsIFwiMHhcIiksXG4gICAgICAgICAgICB0b3BpY3M6IEZvcm1hdHRlci5hcnJheU9mKGhhc2gpLFxuICAgICAgICAgICAgdHJhbnNhY3Rpb25IYXNoOiBoYXNoLFxuICAgICAgICAgICAgbG9nSW5kZXg6IG51bWJlcixcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGZvcm1hdHM7XG4gICAgfVxuICAgIGFjY2Vzc0xpc3QoYWNjZXNzTGlzdCkge1xuICAgICAgICByZXR1cm4gYWNjZXNzTGlzdGlmeShhY2Nlc3NMaXN0IHx8IFtdKTtcbiAgICB9XG4gICAgLy8gUmVxdWlyZXMgYSBCaWdOdW1iZXJpc2ggdGhhdCBpcyB3aXRoaW4gdGhlIElFRUU3NTQgc2FmZSBpbnRlZ2VyIHJhbmdlOyByZXR1cm5zIGEgbnVtYmVyXG4gICAgLy8gU3RyaWN0ISBVc2VkIG9uIGlucHV0LlxuICAgIG51bWJlcihudW1iZXIpIHtcbiAgICAgICAgaWYgKG51bWJlciA9PT0gXCIweFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQmlnTnVtYmVyLmZyb20obnVtYmVyKS50b051bWJlcigpO1xuICAgIH1cbiAgICB0eXBlKG51bWJlcikge1xuICAgICAgICBpZiAobnVtYmVyID09PSBcIjB4XCIgfHwgbnVtYmVyID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBCaWdOdW1iZXIuZnJvbShudW1iZXIpLnRvTnVtYmVyKCk7XG4gICAgfVxuICAgIC8vIFN0cmljdCEgVXNlZCBvbiBpbnB1dC5cbiAgICBiaWdOdW1iZXIodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIEJpZ051bWJlci5mcm9tKHZhbHVlKTtcbiAgICB9XG4gICAgLy8gUmVxdWlyZXMgYSBib29sZWFuLCBcInRydWVcIiBvciAgXCJmYWxzZVwiOyByZXR1cm5zIGEgYm9vbGVhblxuICAgIGJvb2xlYW4odmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBcInRydWVcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBcImZhbHNlXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBib29sZWFuIC0gXCIgKyB2YWx1ZSk7XG4gICAgfVxuICAgIGhleCh2YWx1ZSwgc3RyaWN0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgaWYgKCFzdHJpY3QgJiYgdmFsdWUuc3Vic3RyaW5nKDAsIDIpICE9PSBcIjB4XCIpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IFwiMHhcIiArIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzSGV4U3RyaW5nKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBoYXNoXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgIH1cbiAgICBkYXRhKHZhbHVlLCBzdHJpY3QpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5oZXgodmFsdWUsIHN0cmljdCk7XG4gICAgICAgIGlmICgocmVzdWx0Lmxlbmd0aCAlIDIpICE9PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGRhdGE7IG9kZC1sZW5ndGggLSBcIiArIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvLyBSZXF1aXJlcyBhbiBhZGRyZXNzXG4gICAgLy8gU3RyaWN0ISBVc2VkIG9uIGlucHV0LlxuICAgIGFkZHJlc3ModmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGdldEFkZHJlc3ModmFsdWUpO1xuICAgIH1cbiAgICBjYWxsQWRkcmVzcyh2YWx1ZSkge1xuICAgICAgICBpZiAoIWlzSGV4U3RyaW5nKHZhbHVlLCAzMikpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFkZHJlc3MgPSBnZXRBZGRyZXNzKGhleERhdGFTbGljZSh2YWx1ZSwgMTIpKTtcbiAgICAgICAgcmV0dXJuIChhZGRyZXNzID09PSBBZGRyZXNzWmVybykgPyBudWxsIDogYWRkcmVzcztcbiAgICB9XG4gICAgY29udHJhY3RBZGRyZXNzKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBnZXRDb250cmFjdEFkZHJlc3ModmFsdWUpO1xuICAgIH1cbiAgICAvLyBTdHJpY3QhIFVzZWQgb24gaW5wdXQuXG4gICAgYmxvY2tUYWcoYmxvY2tUYWcpIHtcbiAgICAgICAgaWYgKGJsb2NrVGFnID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBcImxhdGVzdFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChibG9ja1RhZyA9PT0gXCJlYXJsaWVzdFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gXCIweDBcIjtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGJsb2NrVGFnKSB7XG4gICAgICAgICAgICBjYXNlIFwiZWFybGllc3RcIjogcmV0dXJuIFwiMHgwXCI7XG4gICAgICAgICAgICBjYXNlIFwibGF0ZXN0XCI6XG4gICAgICAgICAgICBjYXNlIFwicGVuZGluZ1wiOlxuICAgICAgICAgICAgY2FzZSBcInNhZmVcIjpcbiAgICAgICAgICAgIGNhc2UgXCJmaW5hbGl6ZWRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gYmxvY2tUYWc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAoYmxvY2tUYWcpID09PSBcIm51bWJlclwiIHx8IGlzSGV4U3RyaW5nKGJsb2NrVGFnKSkge1xuICAgICAgICAgICAgcmV0dXJuIGhleFZhbHVlKGJsb2NrVGFnKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGJsb2NrVGFnXCIpO1xuICAgIH1cbiAgICAvLyBSZXF1aXJlcyBhIGhhc2gsIG9wdGlvbmFsbHkgcmVxdWlyZXMgMHggcHJlZml4OyByZXR1cm5zIHByZWZpeGVkIGxvd2VyY2FzZSBoYXNoLlxuICAgIGhhc2godmFsdWUsIHN0cmljdCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmhleCh2YWx1ZSwgc3RyaWN0KTtcbiAgICAgICAgaWYgKGhleERhdGFMZW5ndGgocmVzdWx0KSAhPT0gMzIpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBoYXNoXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8vIFJldHVybnMgdGhlIGRpZmZpY3VsdHkgYXMgYSBudW1iZXIsIG9yIGlmIHRvbyBsYXJnZSAoaS5lLiBQb0EgbmV0d29yaykgbnVsbFxuICAgIGRpZmZpY3VsdHkodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHYgPSBCaWdOdW1iZXIuZnJvbSh2YWx1ZSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gdi50b051bWJlcigpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB1aW50MjU2KHZhbHVlKSB7XG4gICAgICAgIGlmICghaXNIZXhTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHVpbnQyNTZcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhleFplcm9QYWQodmFsdWUsIDMyKTtcbiAgICB9XG4gICAgX2Jsb2NrKHZhbHVlLCBmb3JtYXQpIHtcbiAgICAgICAgaWYgKHZhbHVlLmF1dGhvciAhPSBudWxsICYmIHZhbHVlLm1pbmVyID09IG51bGwpIHtcbiAgICAgICAgICAgIHZhbHVlLm1pbmVyID0gdmFsdWUuYXV0aG9yO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSBkaWZmaWN1bHR5IG1heSBuZWVkIHRvIGNvbWUgZnJvbSBfZGlmZmljdWx0eSBpbiByZWN1cnNlZCBibG9ja3NcbiAgICAgICAgY29uc3QgZGlmZmljdWx0eSA9ICh2YWx1ZS5fZGlmZmljdWx0eSAhPSBudWxsKSA/IHZhbHVlLl9kaWZmaWN1bHR5IDogdmFsdWUuZGlmZmljdWx0eTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gRm9ybWF0dGVyLmNoZWNrKGZvcm1hdCwgdmFsdWUpO1xuICAgICAgICByZXN1bHQuX2RpZmZpY3VsdHkgPSAoKGRpZmZpY3VsdHkgPT0gbnVsbCkgPyBudWxsIDogQmlnTnVtYmVyLmZyb20oZGlmZmljdWx0eSkpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBibG9jayh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYmxvY2sodmFsdWUsIHRoaXMuZm9ybWF0cy5ibG9jayk7XG4gICAgfVxuICAgIGJsb2NrV2l0aFRyYW5zYWN0aW9ucyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYmxvY2sodmFsdWUsIHRoaXMuZm9ybWF0cy5ibG9ja1dpdGhUcmFuc2FjdGlvbnMpO1xuICAgIH1cbiAgICAvLyBTdHJpY3QhIFVzZWQgb24gaW5wdXQuXG4gICAgdHJhbnNhY3Rpb25SZXF1ZXN0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBGb3JtYXR0ZXIuY2hlY2sodGhpcy5mb3JtYXRzLnRyYW5zYWN0aW9uUmVxdWVzdCwgdmFsdWUpO1xuICAgIH1cbiAgICB0cmFuc2FjdGlvblJlc3BvbnNlKHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIC8vIFJlbmFtZSBnYXMgdG8gZ2FzTGltaXRcbiAgICAgICAgaWYgKHRyYW5zYWN0aW9uLmdhcyAhPSBudWxsICYmIHRyYW5zYWN0aW9uLmdhc0xpbWl0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uLmdhc0xpbWl0ID0gdHJhbnNhY3Rpb24uZ2FzO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNvbWUgY2xpZW50cyAoVGVzdFJQQykgZG8gc3RyYW5nZSB0aGluZ3MgbGlrZSByZXR1cm4gMHgwIGZvciB0aGVcbiAgICAgICAgLy8gMCBhZGRyZXNzOyBjb3JyZWN0IHRoaXMgdG8gYmUgYSByZWFsIGFkZHJlc3NcbiAgICAgICAgaWYgKHRyYW5zYWN0aW9uLnRvICYmIEJpZ051bWJlci5mcm9tKHRyYW5zYWN0aW9uLnRvKS5pc1plcm8oKSkge1xuICAgICAgICAgICAgdHJhbnNhY3Rpb24udG8gPSBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlbmFtZSBpbnB1dCB0byBkYXRhXG4gICAgICAgIGlmICh0cmFuc2FjdGlvbi5pbnB1dCAhPSBudWxsICYmIHRyYW5zYWN0aW9uLmRhdGEgPT0gbnVsbCkge1xuICAgICAgICAgICAgdHJhbnNhY3Rpb24uZGF0YSA9IHRyYW5zYWN0aW9uLmlucHV0O1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRvIGFuZCBjcmVhdGVzIGFyZSBlbXB0eSwgcG9wdWxhdGUgdGhlIGNyZWF0ZXMgZnJvbSB0aGUgdHJhbnNhY3Rpb25cbiAgICAgICAgaWYgKHRyYW5zYWN0aW9uLnRvID09IG51bGwgJiYgdHJhbnNhY3Rpb24uY3JlYXRlcyA9PSBudWxsKSB7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbi5jcmVhdGVzID0gdGhpcy5jb250cmFjdEFkZHJlc3ModHJhbnNhY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmICgodHJhbnNhY3Rpb24udHlwZSA9PT0gMSB8fCB0cmFuc2FjdGlvbi50eXBlID09PSAyKSAmJiB0cmFuc2FjdGlvbi5hY2Nlc3NMaXN0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uLmFjY2Vzc0xpc3QgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBGb3JtYXR0ZXIuY2hlY2sodGhpcy5mb3JtYXRzLnRyYW5zYWN0aW9uLCB0cmFuc2FjdGlvbik7XG4gICAgICAgIGlmICh0cmFuc2FjdGlvbi5jaGFpbklkICE9IG51bGwpIHtcbiAgICAgICAgICAgIGxldCBjaGFpbklkID0gdHJhbnNhY3Rpb24uY2hhaW5JZDtcbiAgICAgICAgICAgIGlmIChpc0hleFN0cmluZyhjaGFpbklkKSkge1xuICAgICAgICAgICAgICAgIGNoYWluSWQgPSBCaWdOdW1iZXIuZnJvbShjaGFpbklkKS50b051bWJlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LmNoYWluSWQgPSBjaGFpbklkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGNoYWluSWQgPSB0cmFuc2FjdGlvbi5uZXR3b3JrSWQ7XG4gICAgICAgICAgICAvLyBnZXRoLWV0YyByZXR1cm5zIGNoYWluSWRcbiAgICAgICAgICAgIGlmIChjaGFpbklkID09IG51bGwgJiYgcmVzdWx0LnYgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNoYWluSWQgPSB0cmFuc2FjdGlvbi5jaGFpbklkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzSGV4U3RyaW5nKGNoYWluSWQpKSB7XG4gICAgICAgICAgICAgICAgY2hhaW5JZCA9IEJpZ051bWJlci5mcm9tKGNoYWluSWQpLnRvTnVtYmVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIChjaGFpbklkKSAhPT0gXCJudW1iZXJcIiAmJiByZXN1bHQudiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY2hhaW5JZCA9IChyZXN1bHQudiAtIDM1KSAvIDI7XG4gICAgICAgICAgICAgICAgaWYgKGNoYWluSWQgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYWluSWQgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjaGFpbklkID0gcGFyc2VJbnQoY2hhaW5JZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIChjaGFpbklkKSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIGNoYWluSWQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LmNoYWluSWQgPSBjaGFpbklkO1xuICAgICAgICB9XG4gICAgICAgIC8vIDB4MDAwMC4uLiBzaG91bGQgYWN0dWFsbHkgYmUgbnVsbFxuICAgICAgICBpZiAocmVzdWx0LmJsb2NrSGFzaCAmJiByZXN1bHQuYmxvY2tIYXNoLnJlcGxhY2UoLzAvZywgXCJcIikgPT09IFwieFwiKSB7XG4gICAgICAgICAgICByZXN1bHQuYmxvY2tIYXNoID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICB0cmFuc2FjdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gcGFyc2VUcmFuc2FjdGlvbih2YWx1ZSk7XG4gICAgfVxuICAgIHJlY2VpcHRMb2codmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIEZvcm1hdHRlci5jaGVjayh0aGlzLmZvcm1hdHMucmVjZWlwdExvZywgdmFsdWUpO1xuICAgIH1cbiAgICByZWNlaXB0KHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IEZvcm1hdHRlci5jaGVjayh0aGlzLmZvcm1hdHMucmVjZWlwdCwgdmFsdWUpO1xuICAgICAgICAvLyBSU0sgaW5jb3JyZWN0bHkgaW1wbGVtZW50ZWQgRUlQLTY1OCwgc28gd2UgbXVuZ2UgdGhpbmdzIGEgYml0IGhlcmUgZm9yIGl0XG4gICAgICAgIGlmIChyZXN1bHQucm9vdCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAocmVzdWx0LnJvb3QubGVuZ3RoIDw9IDQpIHtcbiAgICAgICAgICAgICAgICAvLyBDb3VsZCBiZSAweDAwLCAweDAsIDB4MDEgb3IgMHgxXG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBCaWdOdW1iZXIuZnJvbShyZXN1bHQucm9vdCkudG9OdW1iZXIoKTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IDAgfHwgdmFsdWUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIGlmIGJvdGggYXJlIHNwZWNpZmllZCwgdGhleSBtYXRjaFxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnN0YXR1cyAhPSBudWxsICYmIChyZXN1bHQuc3RhdHVzICE9PSB2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJhbHQtcm9vdC1zdGF0dXMvc3RhdHVzIG1pc21hdGNoXCIsIFwidmFsdWVcIiwgeyByb290OiByZXN1bHQucm9vdCwgc3RhdHVzOiByZXN1bHQuc3RhdHVzIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zdGF0dXMgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHJlc3VsdC5yb290O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgYWx0LXJvb3Qtc3RhdHVzXCIsIFwidmFsdWUucm9vdFwiLCByZXN1bHQucm9vdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocmVzdWx0LnJvb3QubGVuZ3RoICE9PSA2Nikge1xuICAgICAgICAgICAgICAgIC8vIE11c3QgYmUgYSB2YWxpZCBieXRlczMyXG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgcm9vdCBoYXNoXCIsIFwidmFsdWUucm9vdFwiLCByZXN1bHQucm9vdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdC5zdGF0dXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0LmJ5emFudGl1bSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgdG9waWNzKHZhbHVlKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLm1hcCgodikgPT4gdGhpcy50b3BpY3ModikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhhc2godmFsdWUsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmaWx0ZXIodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIEZvcm1hdHRlci5jaGVjayh0aGlzLmZvcm1hdHMuZmlsdGVyLCB2YWx1ZSk7XG4gICAgfVxuICAgIGZpbHRlckxvZyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gRm9ybWF0dGVyLmNoZWNrKHRoaXMuZm9ybWF0cy5maWx0ZXJMb2csIHZhbHVlKTtcbiAgICB9XG4gICAgc3RhdGljIGNoZWNrKGZvcm1hdCwgb2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBmb3JtYXQpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBmb3JtYXRba2V5XShvYmplY3Rba2V5XSk7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBlcnJvci5jaGVja0tleSA9IGtleTtcbiAgICAgICAgICAgICAgICBlcnJvci5jaGVja1ZhbHVlID0gb2JqZWN0W2tleV07XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLy8gaWYgdmFsdWUgaXMgbnVsbC1pc2gsIG51bGxWYWx1ZSBpcyByZXR1cm5lZFxuICAgIHN0YXRpYyBhbGxvd051bGwoZm9ybWF0LCBudWxsVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGxWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmb3JtYXQodmFsdWUpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gSWYgdmFsdWUgaXMgZmFsc2UtaXNoLCByZXBsYWNlVmFsdWUgaXMgcmV0dXJuZWRcbiAgICBzdGF0aWMgYWxsb3dGYWxzaXNoKGZvcm1hdCwgcmVwbGFjZVZhbHVlKSB7XG4gICAgICAgIHJldHVybiAoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcGxhY2VWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmb3JtYXQodmFsdWUpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gUmVxdWlyZXMgYW4gQXJyYXkgc2F0aXNmeWluZyBjaGVja1xuICAgIHN0YXRpYyBhcnJheU9mKGZvcm1hdCkge1xuICAgICAgICByZXR1cm4gKGZ1bmN0aW9uIChhcnJheSkge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGFycmF5KSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vdCBhbiBhcnJheVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgYXJyYXkuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChmb3JtYXQodmFsdWUpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGlzQ29tbXVuaXR5UmVzb3VyY2FibGUodmFsdWUpIHtcbiAgICByZXR1cm4gKHZhbHVlICYmIHR5cGVvZiAodmFsdWUuaXNDb21tdW5pdHlSZXNvdXJjZSkgPT09IFwiZnVuY3Rpb25cIik7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNDb21tdW5pdHlSZXNvdXJjZSh2YWx1ZSkge1xuICAgIHJldHVybiAoaXNDb21tdW5pdHlSZXNvdXJjYWJsZSh2YWx1ZSkgJiYgdmFsdWUuaXNDb21tdW5pdHlSZXNvdXJjZSgpKTtcbn1cbi8vIFNob3cgdGhlIHRocm90dGxlIG1lc3NhZ2Ugb25seSBvbmNlXG5sZXQgdGhyb3R0bGVNZXNzYWdlID0gZmFsc2U7XG5leHBvcnQgZnVuY3Rpb24gc2hvd1Rocm90dGxlTWVzc2FnZSgpIHtcbiAgICBpZiAodGhyb3R0bGVNZXNzYWdlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhyb3R0bGVNZXNzYWdlID0gdHJ1ZTtcbiAgICBjb25zb2xlLmxvZyhcIj09PT09PT09PSBOT1RJQ0UgPT09PT09PT09XCIpO1xuICAgIGNvbnNvbGUubG9nKFwiUmVxdWVzdC1SYXRlIEV4Y2VlZGVkICAodGhpcyBtZXNzYWdlIHdpbGwgbm90IGJlIHJlcGVhdGVkKVwiKTtcbiAgICBjb25zb2xlLmxvZyhcIlwiKTtcbiAgICBjb25zb2xlLmxvZyhcIlRoZSBkZWZhdWx0IEFQSSBrZXlzIGZvciBlYWNoIHNlcnZpY2UgYXJlIHByb3ZpZGVkIGFzIGEgaGlnaGx5LXRocm90dGxlZCxcIik7XG4gICAgY29uc29sZS5sb2coXCJjb21tdW5pdHkgcmVzb3VyY2UgZm9yIGxvdy10cmFmZmljIHByb2plY3RzIGFuZCBlYXJseSBwcm90b3R5cGluZy5cIik7XG4gICAgY29uc29sZS5sb2coXCJcIik7XG4gICAgY29uc29sZS5sb2coXCJXaGlsZSB5b3VyIGFwcGxpY2F0aW9uIHdpbGwgY29udGludWUgdG8gZnVuY3Rpb24sIHdlIGhpZ2hseSByZWNvbW1lbmRlZFwiKTtcbiAgICBjb25zb2xlLmxvZyhcInNpZ25pbmcgdXAgZm9yIHlvdXIgb3duIEFQSSBrZXlzIHRvIGltcHJvdmUgcGVyZm9ybWFuY2UsIGluY3JlYXNlIHlvdXJcIik7XG4gICAgY29uc29sZS5sb2coXCJyZXF1ZXN0IHJhdGUvbGltaXQgYW5kIGVuYWJsZSBvdGhlciBwZXJrcywgc3VjaCBhcyBtZXRyaWNzIGFuZCBhZHZhbmNlZCBBUElzLlwiKTtcbiAgICBjb25zb2xlLmxvZyhcIlwiKTtcbiAgICBjb25zb2xlLmxvZyhcIkZvciBtb3JlIGRldGFpbHM6IGh0dHBzOi9cXC9kb2NzLmV0aGVycy5pby9hcGkta2V5cy9cIik7XG4gICAgY29uc29sZS5sb2coXCI9PT09PT09PT09PT09PT09PT09PT09PT09PVwiKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZvcm1hdHRlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ethersproject/providers/lib.esm/formatter.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@ethersproject/providers/lib.esm/index.js":
/*!*****************************************************************!*\
  !*** ../node_modules/@ethersproject/providers/lib.esm/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AlchemyProvider: () => (/* reexport safe */ _alchemy_provider__WEBPACK_IMPORTED_MODULE_6__.AlchemyProvider),\n/* harmony export */   AlchemyWebSocketProvider: () => (/* reexport safe */ _alchemy_provider__WEBPACK_IMPORTED_MODULE_6__.AlchemyWebSocketProvider),\n/* harmony export */   AnkrProvider: () => (/* reexport safe */ _ankr_provider__WEBPACK_IMPORTED_MODULE_7__.AnkrProvider),\n/* harmony export */   BaseProvider: () => (/* reexport safe */ _base_provider__WEBPACK_IMPORTED_MODULE_16__.BaseProvider),\n/* harmony export */   CloudflareProvider: () => (/* reexport safe */ _cloudflare_provider__WEBPACK_IMPORTED_MODULE_8__.CloudflareProvider),\n/* harmony export */   EtherscanProvider: () => (/* reexport safe */ _etherscan_provider__WEBPACK_IMPORTED_MODULE_9__.EtherscanProvider),\n/* harmony export */   FallbackProvider: () => (/* reexport safe */ _fallback_provider__WEBPACK_IMPORTED_MODULE_5__.FallbackProvider),\n/* harmony export */   Formatter: () => (/* reexport safe */ _formatter__WEBPACK_IMPORTED_MODULE_19__.Formatter),\n/* harmony export */   InfuraProvider: () => (/* reexport safe */ _infura_provider__WEBPACK_IMPORTED_MODULE_10__.InfuraProvider),\n/* harmony export */   InfuraWebSocketProvider: () => (/* reexport safe */ _infura_provider__WEBPACK_IMPORTED_MODULE_10__.InfuraWebSocketProvider),\n/* harmony export */   IpcProvider: () => (/* reexport safe */ _ipc_provider__WEBPACK_IMPORTED_MODULE_14__.IpcProvider),\n/* harmony export */   JsonRpcBatchProvider: () => (/* reexport safe */ _json_rpc_batch_provider__WEBPACK_IMPORTED_MODULE_18__.JsonRpcBatchProvider),\n/* harmony export */   JsonRpcProvider: () => (/* reexport safe */ _json_rpc_provider__WEBPACK_IMPORTED_MODULE_2__.JsonRpcProvider),\n/* harmony export */   JsonRpcSigner: () => (/* reexport safe */ _json_rpc_provider__WEBPACK_IMPORTED_MODULE_2__.JsonRpcSigner),\n/* harmony export */   NodesmithProvider: () => (/* reexport safe */ _nodesmith_provider__WEBPACK_IMPORTED_MODULE_11__.NodesmithProvider),\n/* harmony export */   PocketProvider: () => (/* reexport safe */ _pocket_provider__WEBPACK_IMPORTED_MODULE_12__.PocketProvider),\n/* harmony export */   Provider: () => (/* reexport safe */ _ethersproject_abstract_provider__WEBPACK_IMPORTED_MODULE_15__.Provider),\n/* harmony export */   Resolver: () => (/* reexport safe */ _base_provider__WEBPACK_IMPORTED_MODULE_16__.Resolver),\n/* harmony export */   StaticJsonRpcProvider: () => (/* reexport safe */ _url_json_rpc_provider__WEBPACK_IMPORTED_MODULE_17__.StaticJsonRpcProvider),\n/* harmony export */   UrlJsonRpcProvider: () => (/* reexport safe */ _url_json_rpc_provider__WEBPACK_IMPORTED_MODULE_17__.UrlJsonRpcProvider),\n/* harmony export */   Web3Provider: () => (/* reexport safe */ _web3_provider__WEBPACK_IMPORTED_MODULE_13__.Web3Provider),\n/* harmony export */   WebSocketProvider: () => (/* reexport safe */ _websocket_provider__WEBPACK_IMPORTED_MODULE_3__.WebSocketProvider),\n/* harmony export */   getDefaultProvider: () => (/* binding */ getDefaultProvider),\n/* harmony export */   getNetwork: () => (/* reexport safe */ _ethersproject_networks__WEBPACK_IMPORTED_MODULE_4__.getNetwork),\n/* harmony export */   isCommunityResourcable: () => (/* reexport safe */ _formatter__WEBPACK_IMPORTED_MODULE_19__.isCommunityResourcable),\n/* harmony export */   isCommunityResource: () => (/* reexport safe */ _formatter__WEBPACK_IMPORTED_MODULE_19__.isCommunityResource),\n/* harmony export */   showThrottleMessage: () => (/* reexport safe */ _formatter__WEBPACK_IMPORTED_MODULE_19__.showThrottleMessage)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_abstract_provider__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @ethersproject/abstract-provider */ \"(ssr)/../node_modules/@ethersproject/abstract-provider/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_networks__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethersproject/networks */ \"(ssr)/../node_modules/@ethersproject/networks/lib.esm/index.js\");\n/* harmony import */ var _base_provider__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./base-provider */ \"(ssr)/../node_modules/@ethersproject/providers/lib.esm/base-provider.js\");\n/* harmony import */ var _alchemy_provider__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./alchemy-provider */ \"(ssr)/../node_modules/@ethersproject/providers/lib.esm/alchemy-provider.js\");\n/* harmony import */ var _ankr_provider__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./ankr-provider */ \"(ssr)/../node_modules/@ethersproject/providers/lib.esm/ankr-provider.js\");\n/* harmony import */ var _cloudflare_provider__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./cloudflare-provider */ \"(ssr)/../node_modules/@ethersproject/providers/lib.esm/cloudflare-provider.js\");\n/* harmony import */ var _etherscan_provider__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./etherscan-provider */ \"(ssr)/../node_modules/@ethersproject/providers/lib.esm/etherscan-provider.js\");\n/* harmony import */ var _fallback_provider__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./fallback-provider */ \"(ssr)/../node_modules/@ethersproject/providers/lib.esm/fallback-provider.js\");\n/* harmony import */ var _ipc_provider__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./ipc-provider */ \"(ssr)/../node_modules/@ethersproject/providers/lib.esm/ipc-provider.js\");\n/* harmony import */ var _infura_provider__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./infura-provider */ \"(ssr)/../node_modules/@ethersproject/providers/lib.esm/infura-provider.js\");\n/* harmony import */ var _json_rpc_provider__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./json-rpc-provider */ \"(ssr)/../node_modules/@ethersproject/providers/lib.esm/json-rpc-provider.js\");\n/* harmony import */ var _json_rpc_batch_provider__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./json-rpc-batch-provider */ \"(ssr)/../node_modules/@ethersproject/providers/lib.esm/json-rpc-batch-provider.js\");\n/* harmony import */ var _nodesmith_provider__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./nodesmith-provider */ \"(ssr)/../node_modules/@ethersproject/providers/lib.esm/nodesmith-provider.js\");\n/* harmony import */ var _pocket_provider__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./pocket-provider */ \"(ssr)/../node_modules/@ethersproject/providers/lib.esm/pocket-provider.js\");\n/* harmony import */ var _url_json_rpc_provider__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./url-json-rpc-provider */ \"(ssr)/../node_modules/@ethersproject/providers/lib.esm/url-json-rpc-provider.js\");\n/* harmony import */ var _web3_provider__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./web3-provider */ \"(ssr)/../node_modules/@ethersproject/providers/lib.esm/web3-provider.js\");\n/* harmony import */ var _websocket_provider__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./websocket-provider */ \"(ssr)/../node_modules/@ethersproject/providers/lib.esm/websocket-provider.js\");\n/* harmony import */ var _formatter__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./formatter */ \"(ssr)/../node_modules/@ethersproject/providers/lib.esm/formatter.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/../node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(ssr)/../node_modules/@ethersproject/providers/lib.esm/_version.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\n////////////////////////\n// Helper Functions\nfunction getDefaultProvider(network, options) {\n    if (network == null) {\n        network = \"homestead\";\n    }\n    // If passed a URL, figure out the right type of provider based on the scheme\n    if (typeof (network) === \"string\") {\n        // @TODO: Add support for IpcProvider; maybe if it ends in \".ipc\"?\n        // Handle http and ws (and their secure variants)\n        const match = network.match(/^(ws|http)s?:/i);\n        if (match) {\n            switch (match[1].toLowerCase()) {\n                case \"http\":\n                case \"https\":\n                    return new _json_rpc_provider__WEBPACK_IMPORTED_MODULE_2__.JsonRpcProvider(network);\n                case \"ws\":\n                case \"wss\":\n                    return new _websocket_provider__WEBPACK_IMPORTED_MODULE_3__.WebSocketProvider(network);\n                default:\n                    logger.throwArgumentError(\"unsupported URL scheme\", \"network\", network);\n            }\n        }\n    }\n    const n = (0,_ethersproject_networks__WEBPACK_IMPORTED_MODULE_4__.getNetwork)(network);\n    if (!n || !n._defaultProvider) {\n        logger.throwError(\"unsupported getDefaultProvider network\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.NETWORK_ERROR, {\n            operation: \"getDefaultProvider\",\n            network: network\n        });\n    }\n    return n._defaultProvider({\n        FallbackProvider: _fallback_provider__WEBPACK_IMPORTED_MODULE_5__.FallbackProvider,\n        AlchemyProvider: _alchemy_provider__WEBPACK_IMPORTED_MODULE_6__.AlchemyProvider,\n        AnkrProvider: _ankr_provider__WEBPACK_IMPORTED_MODULE_7__.AnkrProvider,\n        CloudflareProvider: _cloudflare_provider__WEBPACK_IMPORTED_MODULE_8__.CloudflareProvider,\n        EtherscanProvider: _etherscan_provider__WEBPACK_IMPORTED_MODULE_9__.EtherscanProvider,\n        InfuraProvider: _infura_provider__WEBPACK_IMPORTED_MODULE_10__.InfuraProvider,\n        JsonRpcProvider: _json_rpc_provider__WEBPACK_IMPORTED_MODULE_2__.JsonRpcProvider,\n        NodesmithProvider: _nodesmith_provider__WEBPACK_IMPORTED_MODULE_11__.NodesmithProvider,\n        PocketProvider: _pocket_provider__WEBPACK_IMPORTED_MODULE_12__.PocketProvider,\n        Web3Provider: _web3_provider__WEBPACK_IMPORTED_MODULE_13__.Web3Provider,\n        IpcProvider: _ipc_provider__WEBPACK_IMPORTED_MODULE_14__.IpcProvider,\n    }, options);\n}\n////////////////////////\n// Exports\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3Byb3ZpZGVycy9saWIuZXNtL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWE7QUFDK0M7QUFDUDtBQUNJO0FBQ3NCO0FBQ2hDO0FBQ1k7QUFDRjtBQUNGO0FBQ1Y7QUFDK0I7QUFDUDtBQUNKO0FBQ1I7QUFDTjtBQUNpQztBQUNyQztBQUNVO0FBQ2lEO0FBQzNEO0FBQ1Y7QUFDckMsbUJBQW1CLHlEQUFNLENBQUMsNkNBQU87QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsK0RBQWU7QUFDOUM7QUFDQTtBQUNBLCtCQUErQixrRUFBaUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsbUVBQVU7QUFDeEI7QUFDQSxvRUFBb0UseURBQU07QUFDMUU7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCLHVCQUF1QjtBQUN2QixvQkFBb0I7QUFDcEIsMEJBQTBCO0FBQzFCLHlCQUF5QjtBQUN6QixzQkFBc0I7QUFDdEIsdUJBQXVCO0FBQ3ZCLHlCQUF5QjtBQUN6QixzQkFBc0I7QUFDdEIsb0JBQW9CO0FBQ3BCLG1CQUFtQjtBQUNuQixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBZVk7QUFDWiIsInNvdXJjZXMiOlsid2VicGFjazovL2xlZGdpdHkteWllbGQtZnJvbnRlbmQvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3Byb3ZpZGVycy9saWIuZXNtL2luZGV4LmpzPzhlMmUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgeyBQcm92aWRlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9hYnN0cmFjdC1wcm92aWRlclwiO1xuaW1wb3J0IHsgZ2V0TmV0d29yayB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9uZXR3b3Jrc1wiO1xuaW1wb3J0IHsgQmFzZVByb3ZpZGVyLCBSZXNvbHZlciB9IGZyb20gXCIuL2Jhc2UtcHJvdmlkZXJcIjtcbmltcG9ydCB7IEFsY2hlbXlQcm92aWRlciwgQWxjaGVteVdlYlNvY2tldFByb3ZpZGVyIH0gZnJvbSBcIi4vYWxjaGVteS1wcm92aWRlclwiO1xuaW1wb3J0IHsgQW5rclByb3ZpZGVyIH0gZnJvbSBcIi4vYW5rci1wcm92aWRlclwiO1xuaW1wb3J0IHsgQ2xvdWRmbGFyZVByb3ZpZGVyIH0gZnJvbSBcIi4vY2xvdWRmbGFyZS1wcm92aWRlclwiO1xuaW1wb3J0IHsgRXRoZXJzY2FuUHJvdmlkZXIgfSBmcm9tIFwiLi9ldGhlcnNjYW4tcHJvdmlkZXJcIjtcbmltcG9ydCB7IEZhbGxiYWNrUHJvdmlkZXIgfSBmcm9tIFwiLi9mYWxsYmFjay1wcm92aWRlclwiO1xuaW1wb3J0IHsgSXBjUHJvdmlkZXIgfSBmcm9tIFwiLi9pcGMtcHJvdmlkZXJcIjtcbmltcG9ydCB7IEluZnVyYVByb3ZpZGVyLCBJbmZ1cmFXZWJTb2NrZXRQcm92aWRlciB9IGZyb20gXCIuL2luZnVyYS1wcm92aWRlclwiO1xuaW1wb3J0IHsgSnNvblJwY1Byb3ZpZGVyLCBKc29uUnBjU2lnbmVyIH0gZnJvbSBcIi4vanNvbi1ycGMtcHJvdmlkZXJcIjtcbmltcG9ydCB7IEpzb25ScGNCYXRjaFByb3ZpZGVyIH0gZnJvbSBcIi4vanNvbi1ycGMtYmF0Y2gtcHJvdmlkZXJcIjtcbmltcG9ydCB7IE5vZGVzbWl0aFByb3ZpZGVyIH0gZnJvbSBcIi4vbm9kZXNtaXRoLXByb3ZpZGVyXCI7XG5pbXBvcnQgeyBQb2NrZXRQcm92aWRlciB9IGZyb20gXCIuL3BvY2tldC1wcm92aWRlclwiO1xuaW1wb3J0IHsgU3RhdGljSnNvblJwY1Byb3ZpZGVyLCBVcmxKc29uUnBjUHJvdmlkZXIgfSBmcm9tIFwiLi91cmwtanNvbi1ycGMtcHJvdmlkZXJcIjtcbmltcG9ydCB7IFdlYjNQcm92aWRlciB9IGZyb20gXCIuL3dlYjMtcHJvdmlkZXJcIjtcbmltcG9ydCB7IFdlYlNvY2tldFByb3ZpZGVyIH0gZnJvbSBcIi4vd2Vic29ja2V0LXByb3ZpZGVyXCI7XG5pbXBvcnQgeyBGb3JtYXR0ZXIsIGlzQ29tbXVuaXR5UmVzb3VyY2FibGUsIGlzQ29tbXVuaXR5UmVzb3VyY2UsIHNob3dUaHJvdHRsZU1lc3NhZ2UgfSBmcm9tIFwiLi9mb3JtYXR0ZXJcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi9fdmVyc2lvblwiO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcih2ZXJzaW9uKTtcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gSGVscGVyIEZ1bmN0aW9uc1xuZnVuY3Rpb24gZ2V0RGVmYXVsdFByb3ZpZGVyKG5ldHdvcmssIG9wdGlvbnMpIHtcbiAgICBpZiAobmV0d29yayA9PSBudWxsKSB7XG4gICAgICAgIG5ldHdvcmsgPSBcImhvbWVzdGVhZFwiO1xuICAgIH1cbiAgICAvLyBJZiBwYXNzZWQgYSBVUkwsIGZpZ3VyZSBvdXQgdGhlIHJpZ2h0IHR5cGUgb2YgcHJvdmlkZXIgYmFzZWQgb24gdGhlIHNjaGVtZVxuICAgIGlmICh0eXBlb2YgKG5ldHdvcmspID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIC8vIEBUT0RPOiBBZGQgc3VwcG9ydCBmb3IgSXBjUHJvdmlkZXI7IG1heWJlIGlmIGl0IGVuZHMgaW4gXCIuaXBjXCI/XG4gICAgICAgIC8vIEhhbmRsZSBodHRwIGFuZCB3cyAoYW5kIHRoZWlyIHNlY3VyZSB2YXJpYW50cylcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBuZXR3b3JrLm1hdGNoKC9eKHdzfGh0dHApcz86L2kpO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIHN3aXRjaCAobWF0Y2hbMV0udG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJodHRwXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcImh0dHBzXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSnNvblJwY1Byb3ZpZGVyKG5ldHdvcmspO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJ3c1wiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJ3c3NcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBXZWJTb2NrZXRQcm92aWRlcihuZXR3b3JrKTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwidW5zdXBwb3J0ZWQgVVJMIHNjaGVtZVwiLCBcIm5ldHdvcmtcIiwgbmV0d29yayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbiA9IGdldE5ldHdvcmsobmV0d29yayk7XG4gICAgaWYgKCFuIHx8ICFuLl9kZWZhdWx0UHJvdmlkZXIpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJ1bnN1cHBvcnRlZCBnZXREZWZhdWx0UHJvdmlkZXIgbmV0d29ya1wiLCBMb2dnZXIuZXJyb3JzLk5FVFdPUktfRVJST1IsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJnZXREZWZhdWx0UHJvdmlkZXJcIixcbiAgICAgICAgICAgIG5ldHdvcms6IG5ldHdvcmtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBuLl9kZWZhdWx0UHJvdmlkZXIoe1xuICAgICAgICBGYWxsYmFja1Byb3ZpZGVyLFxuICAgICAgICBBbGNoZW15UHJvdmlkZXIsXG4gICAgICAgIEFua3JQcm92aWRlcixcbiAgICAgICAgQ2xvdWRmbGFyZVByb3ZpZGVyLFxuICAgICAgICBFdGhlcnNjYW5Qcm92aWRlcixcbiAgICAgICAgSW5mdXJhUHJvdmlkZXIsXG4gICAgICAgIEpzb25ScGNQcm92aWRlcixcbiAgICAgICAgTm9kZXNtaXRoUHJvdmlkZXIsXG4gICAgICAgIFBvY2tldFByb3ZpZGVyLFxuICAgICAgICBXZWIzUHJvdmlkZXIsXG4gICAgICAgIElwY1Byb3ZpZGVyLFxuICAgIH0sIG9wdGlvbnMpO1xufVxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBFeHBvcnRzXG5leHBvcnQgeyBcbi8vIEFic3RyYWN0IFByb3ZpZGVycyAob3IgQWJzdHJhY3QtaXNoKVxuUHJvdmlkZXIsIEJhc2VQcm92aWRlciwgUmVzb2x2ZXIsIFVybEpzb25ScGNQcm92aWRlciwgXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gQ29uY3JldGUgUHJvdmlkZXJzXG5GYWxsYmFja1Byb3ZpZGVyLCBBbGNoZW15UHJvdmlkZXIsIEFsY2hlbXlXZWJTb2NrZXRQcm92aWRlciwgQW5rclByb3ZpZGVyLCBDbG91ZGZsYXJlUHJvdmlkZXIsIEV0aGVyc2NhblByb3ZpZGVyLCBJbmZ1cmFQcm92aWRlciwgSW5mdXJhV2ViU29ja2V0UHJvdmlkZXIsIEpzb25ScGNQcm92aWRlciwgSnNvblJwY0JhdGNoUHJvdmlkZXIsIE5vZGVzbWl0aFByb3ZpZGVyLCBQb2NrZXRQcm92aWRlciwgU3RhdGljSnNvblJwY1Byb3ZpZGVyLCBXZWIzUHJvdmlkZXIsIFdlYlNvY2tldFByb3ZpZGVyLCBJcGNQcm92aWRlciwgXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gU2lnbmVyXG5Kc29uUnBjU2lnbmVyLCBcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBGdW5jdGlvbnNcbmdldERlZmF1bHRQcm92aWRlciwgZ2V0TmV0d29yaywgaXNDb21tdW5pdHlSZXNvdXJjZSwgaXNDb21tdW5pdHlSZXNvdXJjYWJsZSwgc2hvd1Rocm90dGxlTWVzc2FnZSwgXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gT2JqZWN0c1xuRm9ybWF0dGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ethersproject/providers/lib.esm/index.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@ethersproject/providers/lib.esm/infura-provider.js":
/*!***************************************************************************!*\
  !*** ../node_modules/@ethersproject/providers/lib.esm/infura-provider.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InfuraProvider: () => (/* binding */ InfuraProvider),\n/* harmony export */   InfuraWebSocketProvider: () => (/* binding */ InfuraWebSocketProvider)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/../node_modules/@ethersproject/properties/lib.esm/index.js\");\n/* harmony import */ var _websocket_provider__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./websocket-provider */ \"(ssr)/../node_modules/@ethersproject/providers/lib.esm/websocket-provider.js\");\n/* harmony import */ var _formatter__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./formatter */ \"(ssr)/../node_modules/@ethersproject/providers/lib.esm/formatter.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/../node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(ssr)/../node_modules/@ethersproject/providers/lib.esm/_version.js\");\n/* harmony import */ var _url_json_rpc_provider__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./url-json-rpc-provider */ \"(ssr)/../node_modules/@ethersproject/providers/lib.esm/url-json-rpc-provider.js\");\n\n\n\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\n\nconst defaultProjectId = \"84842078b09946638c03157f83405213\";\nclass InfuraWebSocketProvider extends _websocket_provider__WEBPACK_IMPORTED_MODULE_2__.WebSocketProvider {\n    constructor(network, apiKey) {\n        const provider = new InfuraProvider(network, apiKey);\n        const connection = provider.connection;\n        if (connection.password) {\n            logger.throwError(\"INFURA WebSocket project secrets unsupported\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"InfuraProvider.getWebSocketProvider()\"\n            });\n        }\n        const url = connection.url.replace(/^http/i, \"ws\").replace(\"/v3/\", \"/ws/v3/\");\n        super(url, network);\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"apiKey\", provider.projectId);\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"projectId\", provider.projectId);\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"projectSecret\", provider.projectSecret);\n    }\n    isCommunityResource() {\n        return (this.projectId === defaultProjectId);\n    }\n}\nclass InfuraProvider extends _url_json_rpc_provider__WEBPACK_IMPORTED_MODULE_4__.UrlJsonRpcProvider {\n    static getWebSocketProvider(network, apiKey) {\n        return new InfuraWebSocketProvider(network, apiKey);\n    }\n    static getApiKey(apiKey) {\n        const apiKeyObj = {\n            apiKey: defaultProjectId,\n            projectId: defaultProjectId,\n            projectSecret: null\n        };\n        if (apiKey == null) {\n            return apiKeyObj;\n        }\n        if (typeof (apiKey) === \"string\") {\n            apiKeyObj.projectId = apiKey;\n        }\n        else if (apiKey.projectSecret != null) {\n            logger.assertArgument((typeof (apiKey.projectId) === \"string\"), \"projectSecret requires a projectId\", \"projectId\", apiKey.projectId);\n            logger.assertArgument((typeof (apiKey.projectSecret) === \"string\"), \"invalid projectSecret\", \"projectSecret\", \"[REDACTED]\");\n            apiKeyObj.projectId = apiKey.projectId;\n            apiKeyObj.projectSecret = apiKey.projectSecret;\n        }\n        else if (apiKey.projectId) {\n            apiKeyObj.projectId = apiKey.projectId;\n        }\n        apiKeyObj.apiKey = apiKeyObj.projectId;\n        return apiKeyObj;\n    }\n    static getUrl(network, apiKey) {\n        let host = null;\n        switch (network ? network.name : \"unknown\") {\n            case \"homestead\":\n                host = \"mainnet.infura.io\";\n                break;\n            case \"goerli\":\n                host = \"goerli.infura.io\";\n                break;\n            case \"sepolia\":\n                host = \"sepolia.infura.io\";\n                break;\n            case \"matic\":\n                host = \"polygon-mainnet.infura.io\";\n                break;\n            case \"maticmum\":\n                host = \"polygon-mumbai.infura.io\";\n                break;\n            case \"optimism\":\n                host = \"optimism-mainnet.infura.io\";\n                break;\n            case \"optimism-goerli\":\n                host = \"optimism-goerli.infura.io\";\n                break;\n            case \"arbitrum\":\n                host = \"arbitrum-mainnet.infura.io\";\n                break;\n            case \"arbitrum-goerli\":\n                host = \"arbitrum-goerli.infura.io\";\n                break;\n            default:\n                logger.throwError(\"unsupported network\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.INVALID_ARGUMENT, {\n                    argument: \"network\",\n                    value: network\n                });\n        }\n        const connection = {\n            allowGzip: true,\n            url: (\"https:/\" + \"/\" + host + \"/v3/\" + apiKey.projectId),\n            throttleCallback: (attempt, url) => {\n                if (apiKey.projectId === defaultProjectId) {\n                    (0,_formatter__WEBPACK_IMPORTED_MODULE_5__.showThrottleMessage)();\n                }\n                return Promise.resolve(true);\n            }\n        };\n        if (apiKey.projectSecret != null) {\n            connection.user = \"\";\n            connection.password = apiKey.projectSecret;\n        }\n        return connection;\n    }\n    isCommunityResource() {\n        return (this.projectId === defaultProjectId);\n    }\n}\n//# sourceMappingURL=infura-provider.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3Byb3ZpZGVycy9saWIuZXNtL2luZnVyYS1wcm92aWRlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFhO0FBQzhDO0FBQ0Y7QUFDUDtBQUNIO0FBQ1Y7QUFDckMsbUJBQW1CLHlEQUFNLENBQUMsNkNBQU87QUFDNEI7QUFDN0Q7QUFDTyxzQ0FBc0Msa0VBQWlCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLHlEQUFNO0FBQ3BGO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFFBQVEseUVBQWM7QUFDdEIsUUFBUSx5RUFBYztBQUN0QixRQUFRLHlFQUFjO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyw2QkFBNkIsc0VBQWtCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELHlEQUFNO0FBQy9EO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLCtEQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sZWRnaXR5LXlpZWxkLWZyb250ZW5kLy4uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm92aWRlcnMvbGliLmVzbS9pbmZ1cmEtcHJvdmlkZXIuanM/YWY4YiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmltcG9ydCB7IGRlZmluZVJlYWRPbmx5IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3Byb3BlcnRpZXNcIjtcbmltcG9ydCB7IFdlYlNvY2tldFByb3ZpZGVyIH0gZnJvbSBcIi4vd2Vic29ja2V0LXByb3ZpZGVyXCI7XG5pbXBvcnQgeyBzaG93VGhyb3R0bGVNZXNzYWdlIH0gZnJvbSBcIi4vZm9ybWF0dGVyXCI7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvbG9nZ2VyXCI7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4vX3ZlcnNpb25cIjtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIodmVyc2lvbik7XG5pbXBvcnQgeyBVcmxKc29uUnBjUHJvdmlkZXIgfSBmcm9tIFwiLi91cmwtanNvbi1ycGMtcHJvdmlkZXJcIjtcbmNvbnN0IGRlZmF1bHRQcm9qZWN0SWQgPSBcIjg0ODQyMDc4YjA5OTQ2NjM4YzAzMTU3ZjgzNDA1MjEzXCI7XG5leHBvcnQgY2xhc3MgSW5mdXJhV2ViU29ja2V0UHJvdmlkZXIgZXh0ZW5kcyBXZWJTb2NrZXRQcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IobmV0d29yaywgYXBpS2V5KSB7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gbmV3IEluZnVyYVByb3ZpZGVyKG5ldHdvcmssIGFwaUtleSk7XG4gICAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSBwcm92aWRlci5jb25uZWN0aW9uO1xuICAgICAgICBpZiAoY29ubmVjdGlvbi5wYXNzd29yZCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJJTkZVUkEgV2ViU29ja2V0IHByb2plY3Qgc2VjcmV0cyB1bnN1cHBvcnRlZFwiLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJJbmZ1cmFQcm92aWRlci5nZXRXZWJTb2NrZXRQcm92aWRlcigpXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVybCA9IGNvbm5lY3Rpb24udXJsLnJlcGxhY2UoL15odHRwL2ksIFwid3NcIikucmVwbGFjZShcIi92My9cIiwgXCIvd3MvdjMvXCIpO1xuICAgICAgICBzdXBlcih1cmwsIG5ldHdvcmspO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcImFwaUtleVwiLCBwcm92aWRlci5wcm9qZWN0SWQpO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcInByb2plY3RJZFwiLCBwcm92aWRlci5wcm9qZWN0SWQpO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcInByb2plY3RTZWNyZXRcIiwgcHJvdmlkZXIucHJvamVjdFNlY3JldCk7XG4gICAgfVxuICAgIGlzQ29tbXVuaXR5UmVzb3VyY2UoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5wcm9qZWN0SWQgPT09IGRlZmF1bHRQcm9qZWN0SWQpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBJbmZ1cmFQcm92aWRlciBleHRlbmRzIFVybEpzb25ScGNQcm92aWRlciB7XG4gICAgc3RhdGljIGdldFdlYlNvY2tldFByb3ZpZGVyKG5ldHdvcmssIGFwaUtleSkge1xuICAgICAgICByZXR1cm4gbmV3IEluZnVyYVdlYlNvY2tldFByb3ZpZGVyKG5ldHdvcmssIGFwaUtleSk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRBcGlLZXkoYXBpS2V5KSB7XG4gICAgICAgIGNvbnN0IGFwaUtleU9iaiA9IHtcbiAgICAgICAgICAgIGFwaUtleTogZGVmYXVsdFByb2plY3RJZCxcbiAgICAgICAgICAgIHByb2plY3RJZDogZGVmYXVsdFByb2plY3RJZCxcbiAgICAgICAgICAgIHByb2plY3RTZWNyZXQ6IG51bGxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGFwaUtleSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYXBpS2V5T2JqO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKGFwaUtleSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGFwaUtleU9iai5wcm9qZWN0SWQgPSBhcGlLZXk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXBpS2V5LnByb2plY3RTZWNyZXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgbG9nZ2VyLmFzc2VydEFyZ3VtZW50KCh0eXBlb2YgKGFwaUtleS5wcm9qZWN0SWQpID09PSBcInN0cmluZ1wiKSwgXCJwcm9qZWN0U2VjcmV0IHJlcXVpcmVzIGEgcHJvamVjdElkXCIsIFwicHJvamVjdElkXCIsIGFwaUtleS5wcm9qZWN0SWQpO1xuICAgICAgICAgICAgbG9nZ2VyLmFzc2VydEFyZ3VtZW50KCh0eXBlb2YgKGFwaUtleS5wcm9qZWN0U2VjcmV0KSA9PT0gXCJzdHJpbmdcIiksIFwiaW52YWxpZCBwcm9qZWN0U2VjcmV0XCIsIFwicHJvamVjdFNlY3JldFwiLCBcIltSRURBQ1RFRF1cIik7XG4gICAgICAgICAgICBhcGlLZXlPYmoucHJvamVjdElkID0gYXBpS2V5LnByb2plY3RJZDtcbiAgICAgICAgICAgIGFwaUtleU9iai5wcm9qZWN0U2VjcmV0ID0gYXBpS2V5LnByb2plY3RTZWNyZXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXBpS2V5LnByb2plY3RJZCkge1xuICAgICAgICAgICAgYXBpS2V5T2JqLnByb2plY3RJZCA9IGFwaUtleS5wcm9qZWN0SWQ7XG4gICAgICAgIH1cbiAgICAgICAgYXBpS2V5T2JqLmFwaUtleSA9IGFwaUtleU9iai5wcm9qZWN0SWQ7XG4gICAgICAgIHJldHVybiBhcGlLZXlPYmo7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRVcmwobmV0d29yaywgYXBpS2V5KSB7XG4gICAgICAgIGxldCBob3N0ID0gbnVsbDtcbiAgICAgICAgc3dpdGNoIChuZXR3b3JrID8gbmV0d29yay5uYW1lIDogXCJ1bmtub3duXCIpIHtcbiAgICAgICAgICAgIGNhc2UgXCJob21lc3RlYWRcIjpcbiAgICAgICAgICAgICAgICBob3N0ID0gXCJtYWlubmV0LmluZnVyYS5pb1wiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImdvZXJsaVwiOlxuICAgICAgICAgICAgICAgIGhvc3QgPSBcImdvZXJsaS5pbmZ1cmEuaW9cIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJzZXBvbGlhXCI6XG4gICAgICAgICAgICAgICAgaG9zdCA9IFwic2Vwb2xpYS5pbmZ1cmEuaW9cIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJtYXRpY1wiOlxuICAgICAgICAgICAgICAgIGhvc3QgPSBcInBvbHlnb24tbWFpbm5ldC5pbmZ1cmEuaW9cIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJtYXRpY211bVwiOlxuICAgICAgICAgICAgICAgIGhvc3QgPSBcInBvbHlnb24tbXVtYmFpLmluZnVyYS5pb1wiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIm9wdGltaXNtXCI6XG4gICAgICAgICAgICAgICAgaG9zdCA9IFwib3B0aW1pc20tbWFpbm5ldC5pbmZ1cmEuaW9cIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJvcHRpbWlzbS1nb2VybGlcIjpcbiAgICAgICAgICAgICAgICBob3N0ID0gXCJvcHRpbWlzbS1nb2VybGkuaW5mdXJhLmlvXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiYXJiaXRydW1cIjpcbiAgICAgICAgICAgICAgICBob3N0ID0gXCJhcmJpdHJ1bS1tYWlubmV0LmluZnVyYS5pb1wiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImFyYml0cnVtLWdvZXJsaVwiOlxuICAgICAgICAgICAgICAgIGhvc3QgPSBcImFyYml0cnVtLWdvZXJsaS5pbmZ1cmEuaW9cIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJ1bnN1cHBvcnRlZCBuZXR3b3JrXCIsIExvZ2dlci5lcnJvcnMuSU5WQUxJRF9BUkdVTUVOVCwge1xuICAgICAgICAgICAgICAgICAgICBhcmd1bWVudDogXCJuZXR3b3JrXCIsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBuZXR3b3JrXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29ubmVjdGlvbiA9IHtcbiAgICAgICAgICAgIGFsbG93R3ppcDogdHJ1ZSxcbiAgICAgICAgICAgIHVybDogKFwiaHR0cHM6L1wiICsgXCIvXCIgKyBob3N0ICsgXCIvdjMvXCIgKyBhcGlLZXkucHJvamVjdElkKSxcbiAgICAgICAgICAgIHRocm90dGxlQ2FsbGJhY2s6IChhdHRlbXB0LCB1cmwpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoYXBpS2V5LnByb2plY3RJZCA9PT0gZGVmYXVsdFByb2plY3RJZCkge1xuICAgICAgICAgICAgICAgICAgICBzaG93VGhyb3R0bGVNZXNzYWdlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGlmIChhcGlLZXkucHJvamVjdFNlY3JldCAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25uZWN0aW9uLnVzZXIgPSBcIlwiO1xuICAgICAgICAgICAgY29ubmVjdGlvbi5wYXNzd29yZCA9IGFwaUtleS5wcm9qZWN0U2VjcmV0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb25uZWN0aW9uO1xuICAgIH1cbiAgICBpc0NvbW11bml0eVJlc291cmNlKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMucHJvamVjdElkID09PSBkZWZhdWx0UHJvamVjdElkKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmZ1cmEtcHJvdmlkZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ethersproject/providers/lib.esm/infura-provider.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@ethersproject/providers/lib.esm/ipc-provider.js":
/*!************************************************************************!*\
  !*** ../node_modules/@ethersproject/providers/lib.esm/ipc-provider.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IpcProvider: () => (/* binding */ IpcProvider)\n/* harmony export */ });\n\nconst IpcProvider = null;\n\n//# sourceMappingURL=ipc-provider.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3Byb3ZpZGVycy9saWIuZXNtL2lwYy1wcm92aWRlci5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQWE7QUFDYjtBQUN1QjtBQUN2QiIsInNvdXJjZXMiOlsid2VicGFjazovL2xlZGdpdHkteWllbGQtZnJvbnRlbmQvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3Byb3ZpZGVycy9saWIuZXNtL2lwYy1wcm92aWRlci5qcz9kZTNkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgSXBjUHJvdmlkZXIgPSBudWxsO1xuZXhwb3J0IHsgSXBjUHJvdmlkZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlwYy1wcm92aWRlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ethersproject/providers/lib.esm/ipc-provider.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@ethersproject/providers/lib.esm/json-rpc-batch-provider.js":
/*!***********************************************************************************!*\
  !*** ../node_modules/@ethersproject/providers/lib.esm/json-rpc-batch-provider.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   JsonRpcBatchProvider: () => (/* binding */ JsonRpcBatchProvider)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/../node_modules/@ethersproject/properties/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_web__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/web */ \"(ssr)/../node_modules/@ethersproject/web/lib.esm/index.js\");\n/* harmony import */ var _json_rpc_provider__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./json-rpc-provider */ \"(ssr)/../node_modules/@ethersproject/providers/lib.esm/json-rpc-provider.js\");\n\n\n\n// Experimental\nclass JsonRpcBatchProvider extends _json_rpc_provider__WEBPACK_IMPORTED_MODULE_0__.JsonRpcProvider {\n    send(method, params) {\n        const request = {\n            method: method,\n            params: params,\n            id: (this._nextId++),\n            jsonrpc: \"2.0\"\n        };\n        if (this._pendingBatch == null) {\n            this._pendingBatch = [];\n        }\n        const inflightRequest = { request, resolve: null, reject: null };\n        const promise = new Promise((resolve, reject) => {\n            inflightRequest.resolve = resolve;\n            inflightRequest.reject = reject;\n        });\n        this._pendingBatch.push(inflightRequest);\n        if (!this._pendingBatchAggregator) {\n            // Schedule batch for next event loop + short duration\n            this._pendingBatchAggregator = setTimeout(() => {\n                // Get teh current batch and clear it, so new requests\n                // go into the next batch\n                const batch = this._pendingBatch;\n                this._pendingBatch = null;\n                this._pendingBatchAggregator = null;\n                // Get the request as an array of requests\n                const request = batch.map((inflight) => inflight.request);\n                this.emit(\"debug\", {\n                    action: \"requestBatch\",\n                    request: (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_1__.deepCopy)(request),\n                    provider: this\n                });\n                return (0,_ethersproject_web__WEBPACK_IMPORTED_MODULE_2__.fetchJson)(this.connection, JSON.stringify(request)).then((result) => {\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        request: request,\n                        response: result,\n                        provider: this\n                    });\n                    // For each result, feed it to the correct Promise, depending\n                    // on whether it was a success or error\n                    batch.forEach((inflightRequest, index) => {\n                        const payload = result[index];\n                        if (payload.error) {\n                            const error = new Error(payload.error.message);\n                            error.code = payload.error.code;\n                            error.data = payload.error.data;\n                            inflightRequest.reject(error);\n                        }\n                        else {\n                            inflightRequest.resolve(payload.result);\n                        }\n                    });\n                }, (error) => {\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        error: error,\n                        request: request,\n                        provider: this\n                    });\n                    batch.forEach((inflightRequest) => {\n                        inflightRequest.reject(error);\n                    });\n                });\n            }, 10);\n        }\n        return promise;\n    }\n}\n//# sourceMappingURL=json-rpc-batch-provider.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3Byb3ZpZGVycy9saWIuZXNtL2pzb24tcnBjLWJhdGNoLXByb3ZpZGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBcUQ7QUFDTjtBQUNPO0FBQ3REO0FBQ08sbUNBQW1DLCtEQUFlO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixtRUFBUTtBQUNyQztBQUNBLGlCQUFpQjtBQUNqQix1QkFBdUIsNkRBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xlZGdpdHkteWllbGQtZnJvbnRlbmQvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3Byb3ZpZGVycy9saWIuZXNtL2pzb24tcnBjLWJhdGNoLXByb3ZpZGVyLmpzP2JlZjciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZGVlcENvcHkgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvcHJvcGVydGllc1wiO1xuaW1wb3J0IHsgZmV0Y2hKc29uIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3dlYlwiO1xuaW1wb3J0IHsgSnNvblJwY1Byb3ZpZGVyIH0gZnJvbSBcIi4vanNvbi1ycGMtcHJvdmlkZXJcIjtcbi8vIEV4cGVyaW1lbnRhbFxuZXhwb3J0IGNsYXNzIEpzb25ScGNCYXRjaFByb3ZpZGVyIGV4dGVuZHMgSnNvblJwY1Byb3ZpZGVyIHtcbiAgICBzZW5kKG1ldGhvZCwgcGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB7XG4gICAgICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgICAgIHBhcmFtczogcGFyYW1zLFxuICAgICAgICAgICAgaWQ6ICh0aGlzLl9uZXh0SWQrKyksXG4gICAgICAgICAgICBqc29ucnBjOiBcIjIuMFwiXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLl9wZW5kaW5nQmF0Y2ggPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fcGVuZGluZ0JhdGNoID0gW107XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW5mbGlnaHRSZXF1ZXN0ID0geyByZXF1ZXN0LCByZXNvbHZlOiBudWxsLCByZWplY3Q6IG51bGwgfTtcbiAgICAgICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGluZmxpZ2h0UmVxdWVzdC5yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgICAgICAgIGluZmxpZ2h0UmVxdWVzdC5yZWplY3QgPSByZWplY3Q7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9wZW5kaW5nQmF0Y2gucHVzaChpbmZsaWdodFJlcXVlc3QpO1xuICAgICAgICBpZiAoIXRoaXMuX3BlbmRpbmdCYXRjaEFnZ3JlZ2F0b3IpIHtcbiAgICAgICAgICAgIC8vIFNjaGVkdWxlIGJhdGNoIGZvciBuZXh0IGV2ZW50IGxvb3AgKyBzaG9ydCBkdXJhdGlvblxuICAgICAgICAgICAgdGhpcy5fcGVuZGluZ0JhdGNoQWdncmVnYXRvciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIEdldCB0ZWggY3VycmVudCBiYXRjaCBhbmQgY2xlYXIgaXQsIHNvIG5ldyByZXF1ZXN0c1xuICAgICAgICAgICAgICAgIC8vIGdvIGludG8gdGhlIG5leHQgYmF0Y2hcbiAgICAgICAgICAgICAgICBjb25zdCBiYXRjaCA9IHRoaXMuX3BlbmRpbmdCYXRjaDtcbiAgICAgICAgICAgICAgICB0aGlzLl9wZW5kaW5nQmF0Y2ggPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdCYXRjaEFnZ3JlZ2F0b3IgPSBudWxsO1xuICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgcmVxdWVzdCBhcyBhbiBhcnJheSBvZiByZXF1ZXN0c1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSBiYXRjaC5tYXAoKGluZmxpZ2h0KSA9PiBpbmZsaWdodC5yZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJyZXF1ZXN0QmF0Y2hcIixcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdDogZGVlcENvcHkocmVxdWVzdCksXG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyOiB0aGlzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZldGNoSnNvbih0aGlzLmNvbm5lY3Rpb24sIEpTT04uc3RyaW5naWZ5KHJlcXVlc3QpKS50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcInJlc3BvbnNlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0OiByZXF1ZXN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2U6IHJlc3VsdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyOiB0aGlzXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAvLyBGb3IgZWFjaCByZXN1bHQsIGZlZWQgaXQgdG8gdGhlIGNvcnJlY3QgUHJvbWlzZSwgZGVwZW5kaW5nXG4gICAgICAgICAgICAgICAgICAgIC8vIG9uIHdoZXRoZXIgaXQgd2FzIGEgc3VjY2VzcyBvciBlcnJvclxuICAgICAgICAgICAgICAgICAgICBiYXRjaC5mb3JFYWNoKChpbmZsaWdodFJlcXVlc3QsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gcmVzdWx0W2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXlsb2FkLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IocGF5bG9hZC5lcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvci5jb2RlID0gcGF5bG9hZC5lcnJvci5jb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLmRhdGEgPSBwYXlsb2FkLmVycm9yLmRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5mbGlnaHRSZXF1ZXN0LnJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmZsaWdodFJlcXVlc3QucmVzb2x2ZShwYXlsb2FkLnJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0sIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwicmVzcG9uc2VcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3Q6IHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlcjogdGhpc1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgYmF0Y2guZm9yRWFjaCgoaW5mbGlnaHRSZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmZsaWdodFJlcXVlc3QucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCAxMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9anNvbi1ycGMtYmF0Y2gtcHJvdmlkZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ethersproject/providers/lib.esm/json-rpc-batch-provider.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@ethersproject/providers/lib.esm/json-rpc-provider.js":
/*!*****************************************************************************!*\
  !*** ../node_modules/@ethersproject/providers/lib.esm/json-rpc-provider.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   JsonRpcProvider: () => (/* binding */ JsonRpcProvider),\n/* harmony export */   JsonRpcSigner: () => (/* binding */ JsonRpcSigner)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_abstract_signer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/abstract-signer */ \"(ssr)/../node_modules/@ethersproject/abstract-signer/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @ethersproject/bignumber */ \"(ssr)/../node_modules/@ethersproject/bignumber/lib.esm/bignumber.js\");\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/../node_modules/@ethersproject/bytes/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_hash__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @ethersproject/hash */ \"(ssr)/../node_modules/@ethersproject/hash/lib.esm/typed-data.js\");\n/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/../node_modules/@ethersproject/properties/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_strings__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @ethersproject/strings */ \"(ssr)/../node_modules/@ethersproject/strings/lib.esm/utf8.js\");\n/* harmony import */ var _ethersproject_transactions__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @ethersproject/transactions */ \"(ssr)/../node_modules/@ethersproject/transactions/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_web__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ethersproject/web */ \"(ssr)/../node_modules/@ethersproject/web/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/../node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(ssr)/../node_modules/@ethersproject/providers/lib.esm/_version.js\");\n/* harmony import */ var _base_provider__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./base-provider */ \"(ssr)/../node_modules/@ethersproject/providers/lib.esm/base-provider.js\");\n\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\n\n\n\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\n\nconst errorGas = [\"call\", \"estimateGas\"];\nfunction spelunk(value, requireData) {\n    if (value == null) {\n        return null;\n    }\n    // These *are* the droids we're looking for.\n    if (typeof (value.message) === \"string\" && value.message.match(\"reverted\")) {\n        const data = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.isHexString)(value.data) ? value.data : null;\n        if (!requireData || data) {\n            return { message: value.message, data };\n        }\n    }\n    // Spelunk further...\n    if (typeof (value) === \"object\") {\n        for (const key in value) {\n            const result = spelunk(value[key], requireData);\n            if (result) {\n                return result;\n            }\n        }\n        return null;\n    }\n    // Might be a JSON string we can further descend...\n    if (typeof (value) === \"string\") {\n        try {\n            return spelunk(JSON.parse(value), requireData);\n        }\n        catch (error) { }\n    }\n    return null;\n}\nfunction checkError(method, error, params) {\n    const transaction = params.transaction || params.signedTransaction;\n    // Undo the \"convenience\" some nodes are attempting to prevent backwards\n    // incompatibility; maybe for v6 consider forwarding reverts as errors\n    if (method === \"call\") {\n        const result = spelunk(error, true);\n        if (result) {\n            return result.data;\n        }\n        // Nothing descriptive..\n        logger.throwError(\"missing revert data in call exception; Transaction reverted without a reason string\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.CALL_EXCEPTION, {\n            data: \"0x\", transaction, error\n        });\n    }\n    if (method === \"estimateGas\") {\n        // Try to find something, with a preference on SERVER_ERROR body\n        let result = spelunk(error.body, false);\n        if (result == null) {\n            result = spelunk(error, false);\n        }\n        // Found \"reverted\", this is a CALL_EXCEPTION\n        if (result) {\n            logger.throwError(\"cannot estimate gas; transaction may fail or may require manual gas limit\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNPREDICTABLE_GAS_LIMIT, {\n                reason: result.message, method, transaction, error\n            });\n        }\n    }\n    // @TODO: Should we spelunk for message too?\n    let message = error.message;\n    if (error.code === _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.SERVER_ERROR && error.error && typeof (error.error.message) === \"string\") {\n        message = error.error.message;\n    }\n    else if (typeof (error.body) === \"string\") {\n        message = error.body;\n    }\n    else if (typeof (error.responseText) === \"string\") {\n        message = error.responseText;\n    }\n    message = (message || \"\").toLowerCase();\n    // \"insufficient funds for gas * price + value + cost(data)\"\n    if (message.match(/insufficient funds|base fee exceeds gas limit|InsufficientFunds/i)) {\n        logger.throwError(\"insufficient funds for intrinsic transaction cost\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.INSUFFICIENT_FUNDS, {\n            error, method, transaction\n        });\n    }\n    // \"nonce too low\"\n    if (message.match(/nonce (is )?too low/i)) {\n        logger.throwError(\"nonce has already been used\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.NONCE_EXPIRED, {\n            error, method, transaction\n        });\n    }\n    // \"replacement transaction underpriced\"\n    if (message.match(/replacement transaction underpriced|transaction gas price.*too low/i)) {\n        logger.throwError(\"replacement fee too low\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.REPLACEMENT_UNDERPRICED, {\n            error, method, transaction\n        });\n    }\n    // \"replacement transaction underpriced\"\n    if (message.match(/only replay-protected/i)) {\n        logger.throwError(\"legacy pre-eip-155 transactions not supported\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n            error, method, transaction\n        });\n    }\n    if (errorGas.indexOf(method) >= 0 && message.match(/gas required exceeds allowance|always failing transaction|execution reverted|revert/)) {\n        logger.throwError(\"cannot estimate gas; transaction may fail or may require manual gas limit\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNPREDICTABLE_GAS_LIMIT, {\n            error, method, transaction\n        });\n    }\n    throw error;\n}\nfunction timer(timeout) {\n    return new Promise(function (resolve) {\n        setTimeout(resolve, timeout);\n    });\n}\nfunction getResult(payload) {\n    if (payload.error) {\n        // @TODO: not any\n        const error = new Error(payload.error.message);\n        error.code = payload.error.code;\n        error.data = payload.error.data;\n        throw error;\n    }\n    return payload.result;\n}\nfunction getLowerCase(value) {\n    if (value) {\n        return value.toLowerCase();\n    }\n    return value;\n}\nconst _constructorGuard = {};\nclass JsonRpcSigner extends _ethersproject_abstract_signer__WEBPACK_IMPORTED_MODULE_3__.Signer {\n    constructor(constructorGuard, provider, addressOrIndex) {\n        super();\n        if (constructorGuard !== _constructorGuard) {\n            throw new Error(\"do not call the JsonRpcSigner constructor directly; use provider.getSigner\");\n        }\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.defineReadOnly)(this, \"provider\", provider);\n        if (addressOrIndex == null) {\n            addressOrIndex = 0;\n        }\n        if (typeof (addressOrIndex) === \"string\") {\n            (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.defineReadOnly)(this, \"_address\", this.provider.formatter.address(addressOrIndex));\n            (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.defineReadOnly)(this, \"_index\", null);\n        }\n        else if (typeof (addressOrIndex) === \"number\") {\n            (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.defineReadOnly)(this, \"_index\", addressOrIndex);\n            (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.defineReadOnly)(this, \"_address\", null);\n        }\n        else {\n            logger.throwArgumentError(\"invalid address or index\", \"addressOrIndex\", addressOrIndex);\n        }\n    }\n    connect(provider) {\n        return logger.throwError(\"cannot alter JSON-RPC Signer connection\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"connect\"\n        });\n    }\n    connectUnchecked() {\n        return new UncheckedJsonRpcSigner(_constructorGuard, this.provider, this._address || this._index);\n    }\n    getAddress() {\n        if (this._address) {\n            return Promise.resolve(this._address);\n        }\n        return this.provider.send(\"eth_accounts\", []).then((accounts) => {\n            if (accounts.length <= this._index) {\n                logger.throwError(\"unknown account #\" + this._index, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: \"getAddress\"\n                });\n            }\n            return this.provider.formatter.address(accounts[this._index]);\n        });\n    }\n    sendUncheckedTransaction(transaction) {\n        transaction = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.shallowCopy)(transaction);\n        const fromAddress = this.getAddress().then((address) => {\n            if (address) {\n                address = address.toLowerCase();\n            }\n            return address;\n        });\n        // The JSON-RPC for eth_sendTransaction uses 90000 gas; if the user\n        // wishes to use this, it is easy to specify explicitly, otherwise\n        // we look it up for them.\n        if (transaction.gasLimit == null) {\n            const estimate = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.shallowCopy)(transaction);\n            estimate.from = fromAddress;\n            transaction.gasLimit = this.provider.estimateGas(estimate);\n        }\n        if (transaction.to != null) {\n            transaction.to = Promise.resolve(transaction.to).then((to) => __awaiter(this, void 0, void 0, function* () {\n                if (to == null) {\n                    return null;\n                }\n                const address = yield this.provider.resolveName(to);\n                if (address == null) {\n                    logger.throwArgumentError(\"provided ENS name resolves to null\", \"tx.to\", to);\n                }\n                return address;\n            }));\n        }\n        return (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.resolveProperties)({\n            tx: (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.resolveProperties)(transaction),\n            sender: fromAddress\n        }).then(({ tx, sender }) => {\n            if (tx.from != null) {\n                if (tx.from.toLowerCase() !== sender) {\n                    logger.throwArgumentError(\"from address mismatch\", \"transaction\", transaction);\n                }\n            }\n            else {\n                tx.from = sender;\n            }\n            const hexTx = this.provider.constructor.hexlifyTransaction(tx, { from: true });\n            return this.provider.send(\"eth_sendTransaction\", [hexTx]).then((hash) => {\n                return hash;\n            }, (error) => {\n                if (typeof (error.message) === \"string\" && error.message.match(/user denied/i)) {\n                    logger.throwError(\"user rejected transaction\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.ACTION_REJECTED, {\n                        action: \"sendTransaction\",\n                        transaction: tx\n                    });\n                }\n                return checkError(\"sendTransaction\", error, hexTx);\n            });\n        });\n    }\n    signTransaction(transaction) {\n        return logger.throwError(\"signing transactions is unsupported\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"signTransaction\"\n        });\n    }\n    sendTransaction(transaction) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // This cannot be mined any earlier than any recent block\n            const blockNumber = yield this.provider._getInternalBlockNumber(100 + 2 * this.provider.pollingInterval);\n            // Send the transaction\n            const hash = yield this.sendUncheckedTransaction(transaction);\n            try {\n                // Unfortunately, JSON-RPC only provides and opaque transaction hash\n                // for a response, and we need the actual transaction, so we poll\n                // for it; it should show up very quickly\n                return yield (0,_ethersproject_web__WEBPACK_IMPORTED_MODULE_5__.poll)(() => __awaiter(this, void 0, void 0, function* () {\n                    const tx = yield this.provider.getTransaction(hash);\n                    if (tx === null) {\n                        return undefined;\n                    }\n                    return this.provider._wrapTransaction(tx, hash, blockNumber);\n                }), { oncePoll: this.provider });\n            }\n            catch (error) {\n                error.transactionHash = hash;\n                throw error;\n            }\n        });\n    }\n    signMessage(message) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const data = ((typeof (message) === \"string\") ? (0,_ethersproject_strings__WEBPACK_IMPORTED_MODULE_6__.toUtf8Bytes)(message) : message);\n            const address = yield this.getAddress();\n            try {\n                return yield this.provider.send(\"personal_sign\", [(0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.hexlify)(data), address.toLowerCase()]);\n            }\n            catch (error) {\n                if (typeof (error.message) === \"string\" && error.message.match(/user denied/i)) {\n                    logger.throwError(\"user rejected signing\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.ACTION_REJECTED, {\n                        action: \"signMessage\",\n                        from: address,\n                        messageData: message\n                    });\n                }\n                throw error;\n            }\n        });\n    }\n    _legacySignMessage(message) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const data = ((typeof (message) === \"string\") ? (0,_ethersproject_strings__WEBPACK_IMPORTED_MODULE_6__.toUtf8Bytes)(message) : message);\n            const address = yield this.getAddress();\n            try {\n                // https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign\n                return yield this.provider.send(\"eth_sign\", [address.toLowerCase(), (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.hexlify)(data)]);\n            }\n            catch (error) {\n                if (typeof (error.message) === \"string\" && error.message.match(/user denied/i)) {\n                    logger.throwError(\"user rejected signing\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.ACTION_REJECTED, {\n                        action: \"_legacySignMessage\",\n                        from: address,\n                        messageData: message\n                    });\n                }\n                throw error;\n            }\n        });\n    }\n    _signTypedData(domain, types, value) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Populate any ENS names (in-place)\n            const populated = yield _ethersproject_hash__WEBPACK_IMPORTED_MODULE_7__.TypedDataEncoder.resolveNames(domain, types, value, (name) => {\n                return this.provider.resolveName(name);\n            });\n            const address = yield this.getAddress();\n            try {\n                return yield this.provider.send(\"eth_signTypedData_v4\", [\n                    address.toLowerCase(),\n                    JSON.stringify(_ethersproject_hash__WEBPACK_IMPORTED_MODULE_7__.TypedDataEncoder.getPayload(populated.domain, types, populated.value))\n                ]);\n            }\n            catch (error) {\n                if (typeof (error.message) === \"string\" && error.message.match(/user denied/i)) {\n                    logger.throwError(\"user rejected signing\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.ACTION_REJECTED, {\n                        action: \"_signTypedData\",\n                        from: address,\n                        messageData: { domain: populated.domain, types, value: populated.value }\n                    });\n                }\n                throw error;\n            }\n        });\n    }\n    unlock(password) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const provider = this.provider;\n            const address = yield this.getAddress();\n            return provider.send(\"personal_unlockAccount\", [address.toLowerCase(), password, null]);\n        });\n    }\n}\nclass UncheckedJsonRpcSigner extends JsonRpcSigner {\n    sendTransaction(transaction) {\n        return this.sendUncheckedTransaction(transaction).then((hash) => {\n            return {\n                hash: hash,\n                nonce: null,\n                gasLimit: null,\n                gasPrice: null,\n                data: null,\n                value: null,\n                chainId: null,\n                confirmations: 0,\n                from: null,\n                wait: (confirmations) => { return this.provider.waitForTransaction(hash, confirmations); }\n            };\n        });\n    }\n}\nconst allowedTransactionKeys = {\n    chainId: true, data: true, gasLimit: true, gasPrice: true, nonce: true, to: true, value: true,\n    type: true, accessList: true,\n    maxFeePerGas: true, maxPriorityFeePerGas: true\n};\nclass JsonRpcProvider extends _base_provider__WEBPACK_IMPORTED_MODULE_8__.BaseProvider {\n    constructor(url, network) {\n        let networkOrReady = network;\n        // The network is unknown, query the JSON-RPC for it\n        if (networkOrReady == null) {\n            networkOrReady = new Promise((resolve, reject) => {\n                setTimeout(() => {\n                    this.detectNetwork().then((network) => {\n                        resolve(network);\n                    }, (error) => {\n                        reject(error);\n                    });\n                }, 0);\n            });\n        }\n        super(networkOrReady);\n        // Default URL\n        if (!url) {\n            url = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.getStatic)(this.constructor, \"defaultUrl\")();\n        }\n        if (typeof (url) === \"string\") {\n            (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.defineReadOnly)(this, \"connection\", Object.freeze({\n                url: url\n            }));\n        }\n        else {\n            (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.defineReadOnly)(this, \"connection\", Object.freeze((0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.shallowCopy)(url)));\n        }\n        this._nextId = 42;\n    }\n    get _cache() {\n        if (this._eventLoopCache == null) {\n            this._eventLoopCache = {};\n        }\n        return this._eventLoopCache;\n    }\n    static defaultUrl() {\n        return \"http:/\\/localhost:8545\";\n    }\n    detectNetwork() {\n        if (!this._cache[\"detectNetwork\"]) {\n            this._cache[\"detectNetwork\"] = this._uncachedDetectNetwork();\n            // Clear this cache at the beginning of the next event loop\n            setTimeout(() => {\n                this._cache[\"detectNetwork\"] = null;\n            }, 0);\n        }\n        return this._cache[\"detectNetwork\"];\n    }\n    _uncachedDetectNetwork() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield timer(0);\n            let chainId = null;\n            try {\n                chainId = yield this.send(\"eth_chainId\", []);\n            }\n            catch (error) {\n                try {\n                    chainId = yield this.send(\"net_version\", []);\n                }\n                catch (error) { }\n            }\n            if (chainId != null) {\n                const getNetwork = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.getStatic)(this.constructor, \"getNetwork\");\n                try {\n                    return getNetwork(_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_9__.BigNumber.from(chainId).toNumber());\n                }\n                catch (error) {\n                    return logger.throwError(\"could not detect network\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.NETWORK_ERROR, {\n                        chainId: chainId,\n                        event: \"invalidNetwork\",\n                        serverError: error\n                    });\n                }\n            }\n            return logger.throwError(\"could not detect network\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.NETWORK_ERROR, {\n                event: \"noNetwork\"\n            });\n        });\n    }\n    getSigner(addressOrIndex) {\n        return new JsonRpcSigner(_constructorGuard, this, addressOrIndex);\n    }\n    getUncheckedSigner(addressOrIndex) {\n        return this.getSigner(addressOrIndex).connectUnchecked();\n    }\n    listAccounts() {\n        return this.send(\"eth_accounts\", []).then((accounts) => {\n            return accounts.map((a) => this.formatter.address(a));\n        });\n    }\n    send(method, params) {\n        const request = {\n            method: method,\n            params: params,\n            id: (this._nextId++),\n            jsonrpc: \"2.0\"\n        };\n        this.emit(\"debug\", {\n            action: \"request\",\n            request: (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.deepCopy)(request),\n            provider: this\n        });\n        // We can expand this in the future to any call, but for now these\n        // are the biggest wins and do not require any serializing parameters.\n        const cache = ([\"eth_chainId\", \"eth_blockNumber\"].indexOf(method) >= 0);\n        if (cache && this._cache[method]) {\n            return this._cache[method];\n        }\n        const result = (0,_ethersproject_web__WEBPACK_IMPORTED_MODULE_5__.fetchJson)(this.connection, JSON.stringify(request), getResult).then((result) => {\n            this.emit(\"debug\", {\n                action: \"response\",\n                request: request,\n                response: result,\n                provider: this\n            });\n            return result;\n        }, (error) => {\n            this.emit(\"debug\", {\n                action: \"response\",\n                error: error,\n                request: request,\n                provider: this\n            });\n            throw error;\n        });\n        // Cache the fetch, but clear it on the next event loop\n        if (cache) {\n            this._cache[method] = result;\n            setTimeout(() => {\n                this._cache[method] = null;\n            }, 0);\n        }\n        return result;\n    }\n    prepareRequest(method, params) {\n        switch (method) {\n            case \"getBlockNumber\":\n                return [\"eth_blockNumber\", []];\n            case \"getGasPrice\":\n                return [\"eth_gasPrice\", []];\n            case \"getBalance\":\n                return [\"eth_getBalance\", [getLowerCase(params.address), params.blockTag]];\n            case \"getTransactionCount\":\n                return [\"eth_getTransactionCount\", [getLowerCase(params.address), params.blockTag]];\n            case \"getCode\":\n                return [\"eth_getCode\", [getLowerCase(params.address), params.blockTag]];\n            case \"getStorageAt\":\n                return [\"eth_getStorageAt\", [getLowerCase(params.address), (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.hexZeroPad)(params.position, 32), params.blockTag]];\n            case \"sendTransaction\":\n                return [\"eth_sendRawTransaction\", [params.signedTransaction]];\n            case \"getBlock\":\n                if (params.blockTag) {\n                    return [\"eth_getBlockByNumber\", [params.blockTag, !!params.includeTransactions]];\n                }\n                else if (params.blockHash) {\n                    return [\"eth_getBlockByHash\", [params.blockHash, !!params.includeTransactions]];\n                }\n                return null;\n            case \"getTransaction\":\n                return [\"eth_getTransactionByHash\", [params.transactionHash]];\n            case \"getTransactionReceipt\":\n                return [\"eth_getTransactionReceipt\", [params.transactionHash]];\n            case \"call\": {\n                const hexlifyTransaction = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.getStatic)(this.constructor, \"hexlifyTransaction\");\n                return [\"eth_call\", [hexlifyTransaction(params.transaction, { from: true }), params.blockTag]];\n            }\n            case \"estimateGas\": {\n                const hexlifyTransaction = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.getStatic)(this.constructor, \"hexlifyTransaction\");\n                return [\"eth_estimateGas\", [hexlifyTransaction(params.transaction, { from: true })]];\n            }\n            case \"getLogs\":\n                if (params.filter && params.filter.address != null) {\n                    params.filter.address = getLowerCase(params.filter.address);\n                }\n                return [\"eth_getLogs\", [params.filter]];\n            default:\n                break;\n        }\n        return null;\n    }\n    perform(method, params) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Legacy networks do not like the type field being passed along (which\n            // is fair), so we delete type if it is 0 and a non-EIP-1559 network\n            if (method === \"call\" || method === \"estimateGas\") {\n                const tx = params.transaction;\n                if (tx && tx.type != null && _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_9__.BigNumber.from(tx.type).isZero()) {\n                    // If there are no EIP-1559 properties, it might be non-EIP-1559\n                    if (tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null) {\n                        const feeData = yield this.getFeeData();\n                        if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {\n                            // Network doesn't know about EIP-1559 (and hence type)\n                            params = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.shallowCopy)(params);\n                            params.transaction = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.shallowCopy)(tx);\n                            delete params.transaction.type;\n                        }\n                    }\n                }\n            }\n            const args = this.prepareRequest(method, params);\n            if (args == null) {\n                logger.throwError(method + \" not implemented\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.NOT_IMPLEMENTED, { operation: method });\n            }\n            try {\n                return yield this.send(args[0], args[1]);\n            }\n            catch (error) {\n                return checkError(method, error, params);\n            }\n        });\n    }\n    _startEvent(event) {\n        if (event.tag === \"pending\") {\n            this._startPending();\n        }\n        super._startEvent(event);\n    }\n    _startPending() {\n        if (this._pendingFilter != null) {\n            return;\n        }\n        const self = this;\n        const pendingFilter = this.send(\"eth_newPendingTransactionFilter\", []);\n        this._pendingFilter = pendingFilter;\n        pendingFilter.then(function (filterId) {\n            function poll() {\n                self.send(\"eth_getFilterChanges\", [filterId]).then(function (hashes) {\n                    if (self._pendingFilter != pendingFilter) {\n                        return null;\n                    }\n                    let seq = Promise.resolve();\n                    hashes.forEach(function (hash) {\n                        // @TODO: This should be garbage collected at some point... How? When?\n                        self._emitted[\"t:\" + hash.toLowerCase()] = \"pending\";\n                        seq = seq.then(function () {\n                            return self.getTransaction(hash).then(function (tx) {\n                                self.emit(\"pending\", tx);\n                                return null;\n                            });\n                        });\n                    });\n                    return seq.then(function () {\n                        return timer(1000);\n                    });\n                }).then(function () {\n                    if (self._pendingFilter != pendingFilter) {\n                        self.send(\"eth_uninstallFilter\", [filterId]);\n                        return;\n                    }\n                    setTimeout(function () { poll(); }, 0);\n                    return null;\n                }).catch((error) => { });\n            }\n            poll();\n            return filterId;\n        }).catch((error) => { });\n    }\n    _stopEvent(event) {\n        if (event.tag === \"pending\" && this.listenerCount(\"pending\") === 0) {\n            this._pendingFilter = null;\n        }\n        super._stopEvent(event);\n    }\n    // Convert an ethers.js transaction into a JSON-RPC transaction\n    //  - gasLimit => gas\n    //  - All values hexlified\n    //  - All numeric values zero-striped\n    //  - All addresses are lowercased\n    // NOTE: This allows a TransactionRequest, but all values should be resolved\n    //       before this is called\n    // @TODO: This will likely be removed in future versions and prepareRequest\n    //        will be the preferred method for this.\n    static hexlifyTransaction(transaction, allowExtra) {\n        // Check only allowed properties are given\n        const allowed = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.shallowCopy)(allowedTransactionKeys);\n        if (allowExtra) {\n            for (const key in allowExtra) {\n                if (allowExtra[key]) {\n                    allowed[key] = true;\n                }\n            }\n        }\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.checkProperties)(transaction, allowed);\n        const result = {};\n        // JSON-RPC now requires numeric values to be \"quantity\" values\n        [\"chainId\", \"gasLimit\", \"gasPrice\", \"type\", \"maxFeePerGas\", \"maxPriorityFeePerGas\", \"nonce\", \"value\"].forEach(function (key) {\n            if (transaction[key] == null) {\n                return;\n            }\n            const value = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.hexValue)(_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_9__.BigNumber.from(transaction[key]));\n            if (key === \"gasLimit\") {\n                key = \"gas\";\n            }\n            result[key] = value;\n        });\n        [\"from\", \"to\", \"data\"].forEach(function (key) {\n            if (transaction[key] == null) {\n                return;\n            }\n            result[key] = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.hexlify)(transaction[key]);\n        });\n        if (transaction.accessList) {\n            result[\"accessList\"] = (0,_ethersproject_transactions__WEBPACK_IMPORTED_MODULE_10__.accessListify)(transaction.accessList);\n        }\n        return result;\n    }\n}\n//# sourceMappingURL=json-rpc-provider.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3Byb3ZpZGVycy9saWIuZXNtL2pzb24tcnBjLXByb3ZpZGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBYTtBQUNiLGlCQUFpQixTQUFJLElBQUksU0FBSTtBQUM3Qiw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUN3RDtBQUNIO0FBQzZCO0FBQzFCO0FBQ3lFO0FBQzVFO0FBQ087QUFDUDtBQUNOO0FBQ1Y7QUFDckMsbUJBQW1CLHlEQUFNLENBQUMsNkNBQU87QUFDYztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixpRUFBVztBQUNoQztBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLCtDQUErQyx5REFBTTtBQUN2SDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsdURBQXVELHlEQUFNO0FBQ2pIO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHlEQUFNO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0UseURBQU07QUFDckY7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EseURBQXlELHlEQUFNO0FB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QUNBO0FBQ0EsNkNBQTZDLFNBQVM7QUFDdEQ7QUFDQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLFNBQVMsc0JBQXNCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzRUFBVztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsMEVBQWU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDhEQUFRLENBQUMsK0RBQVM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsNkRBQU87QUFDakMsU0FBUztBQUNUO0FBQ0EsbUNBQW1DLDJFQUFhO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sZWRnaXR5LXlpZWxkLWZyb250ZW5kLy4uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm92aWRlcnMvbGliLmVzbS9qc29uLXJwYy1wcm92aWRlci5qcz84YzlhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5pbXBvcnQgeyBTaWduZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYWJzdHJhY3Qtc2lnbmVyXCI7XG5pbXBvcnQgeyBCaWdOdW1iZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYmlnbnVtYmVyXCI7XG5pbXBvcnQgeyBoZXhsaWZ5LCBoZXhWYWx1ZSwgaGV4WmVyb1BhZCwgaXNIZXhTdHJpbmcgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYnl0ZXNcIjtcbmltcG9ydCB7IF9UeXBlZERhdGFFbmNvZGVyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2hhc2hcIjtcbmltcG9ydCB7IGNoZWNrUHJvcGVydGllcywgZGVlcENvcHksIGRlZmluZVJlYWRPbmx5LCBnZXRTdGF0aWMsIHJlc29sdmVQcm9wZXJ0aWVzLCBzaGFsbG93Q29weSB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9wcm9wZXJ0aWVzXCI7XG5pbXBvcnQgeyB0b1V0ZjhCeXRlcyB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9zdHJpbmdzXCI7XG5pbXBvcnQgeyBhY2Nlc3NMaXN0aWZ5IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3RyYW5zYWN0aW9uc1wiO1xuaW1wb3J0IHsgZmV0Y2hKc29uLCBwb2xsIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3dlYlwiO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2xvZ2dlclwiO1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gXCIuL192ZXJzaW9uXCI7XG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyKHZlcnNpb24pO1xuaW1wb3J0IHsgQmFzZVByb3ZpZGVyIH0gZnJvbSBcIi4vYmFzZS1wcm92aWRlclwiO1xuY29uc3QgZXJyb3JHYXMgPSBbXCJjYWxsXCIsIFwiZXN0aW1hdGVHYXNcIl07XG5mdW5jdGlvbiBzcGVsdW5rKHZhbHVlLCByZXF1aXJlRGF0YSkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBUaGVzZSAqYXJlKiB0aGUgZHJvaWRzIHdlJ3JlIGxvb2tpbmcgZm9yLlxuICAgIGlmICh0eXBlb2YgKHZhbHVlLm1lc3NhZ2UpID09PSBcInN0cmluZ1wiICYmIHZhbHVlLm1lc3NhZ2UubWF0Y2goXCJyZXZlcnRlZFwiKSkge1xuICAgICAgICBjb25zdCBkYXRhID0gaXNIZXhTdHJpbmcodmFsdWUuZGF0YSkgPyB2YWx1ZS5kYXRhIDogbnVsbDtcbiAgICAgICAgaWYgKCFyZXF1aXJlRGF0YSB8fCBkYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4geyBtZXNzYWdlOiB2YWx1ZS5tZXNzYWdlLCBkYXRhIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gU3BlbHVuayBmdXJ0aGVyLi4uXG4gICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHZhbHVlKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBzcGVsdW5rKHZhbHVlW2tleV0sIHJlcXVpcmVEYXRhKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBNaWdodCBiZSBhIEpTT04gc3RyaW5nIHdlIGNhbiBmdXJ0aGVyIGRlc2NlbmQuLi5cbiAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBzcGVsdW5rKEpTT04ucGFyc2UodmFsdWUpLCByZXF1aXJlRGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBjaGVja0Vycm9yKG1ldGhvZCwgZXJyb3IsIHBhcmFtcykge1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gcGFyYW1zLnRyYW5zYWN0aW9uIHx8IHBhcmFtcy5zaWduZWRUcmFuc2FjdGlvbjtcbiAgICAvLyBVbmRvIHRoZSBcImNvbnZlbmllbmNlXCIgc29tZSBub2RlcyBhcmUgYXR0ZW1wdGluZyB0byBwcmV2ZW50IGJhY2t3YXJkc1xuICAgIC8vIGluY29tcGF0aWJpbGl0eTsgbWF5YmUgZm9yIHY2IGNvbnNpZGVyIGZvcndhcmRpbmcgcmV2ZXJ0cyBhcyBlcnJvcnNcbiAgICBpZiAobWV0aG9kID09PSBcImNhbGxcIikge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBzcGVsdW5rKGVycm9yLCB0cnVlKTtcbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5kYXRhO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vdGhpbmcgZGVzY3JpcHRpdmUuLlxuICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcIm1pc3NpbmcgcmV2ZXJ0IGRhdGEgaW4gY2FsbCBleGNlcHRpb247IFRyYW5zYWN0aW9uIHJldmVydGVkIHdpdGhvdXQgYSByZWFzb24gc3RyaW5nXCIsIExvZ2dlci5lcnJvcnMuQ0FMTF9FWENFUFRJT04sIHtcbiAgICAgICAgICAgIGRhdGE6IFwiMHhcIiwgdHJhbnNhY3Rpb24sIGVycm9yXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAobWV0aG9kID09PSBcImVzdGltYXRlR2FzXCIpIHtcbiAgICAgICAgLy8gVHJ5IHRvIGZpbmQgc29tZXRoaW5nLCB3aXRoIGEgcHJlZmVyZW5jZSBvbiBTRVJWRVJfRVJST1IgYm9keVxuICAgICAgICBsZXQgcmVzdWx0ID0gc3BlbHVuayhlcnJvci5ib2R5LCBmYWxzZSk7XG4gICAgICAgIGlmIChyZXN1bHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gc3BlbHVuayhlcnJvciwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZvdW5kIFwicmV2ZXJ0ZWRcIiwgdGhpcyBpcyBhIENBTExfRVhDRVBUSU9OXG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiY2Fubm90IGVzdGltYXRlIGdhczsgdHJhbnNhY3Rpb24gbWF5IGZhaWwgb3IgbWF5IHJlcXVpcmUgbWFudWFsIGdhcyBsaW1pdFwiLCBMb2dnZXIuZXJyb3JzLlVOUFJFRElDVEFCTEVfR0FTX0xJTUlULCB7XG4gICAgICAgICAgICAgICAgcmVhc29uOiByZXN1bHQubWVzc2FnZSwgbWV0aG9kLCB0cmFuc2FjdGlvbiwgZXJyb3JcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEBUT0RPOiBTaG91bGQgd2Ugc3BlbHVuayBmb3IgbWVzc2FnZSB0b28/XG4gICAgbGV0IG1lc3NhZ2UgPSBlcnJvci5tZXNzYWdlO1xuICAgIGlmIChlcnJvci5jb2RlID09PSBMb2dnZXIuZXJyb3JzLlNFUlZFUl9FUlJPUiAmJiBlcnJvci5lcnJvciAmJiB0eXBlb2YgKGVycm9yLmVycm9yLm1lc3NhZ2UpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIG1lc3NhZ2UgPSBlcnJvci5lcnJvci5tZXNzYWdlO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgKGVycm9yLmJvZHkpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIG1lc3NhZ2UgPSBlcnJvci5ib2R5O1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgKGVycm9yLnJlc3BvbnNlVGV4dCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgbWVzc2FnZSA9IGVycm9yLnJlc3BvbnNlVGV4dDtcbiAgICB9XG4gICAgbWVzc2FnZSA9IChtZXNzYWdlIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCk7XG4gICAgLy8gXCJpbnN1ZmZpY2llbnQgZnVuZHMgZm9yIGdhcyAqIHByaWNlICsgdmFsdWUgKyBjb3N0KGRhdGEpXCJcbiAgICBpZiAobWVzc2FnZS5tYXRjaCgvaW5zdWZmaWNpZW50IGZ1bmRzfGJhc2UgZmVlIGV4Y2VlZHMgZ2FzIGxpbWl0fEluc3VmZmljaWVudEZ1bmRzL2kpKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiaW5zdWZmaWNpZW50IGZ1bmRzIGZvciBpbnRyaW5zaWMgdHJhbnNhY3Rpb24gY29zdFwiLCBMb2dnZXIuZXJyb3JzLklOU1VGRklDSUVOVF9GVU5EUywge1xuICAgICAgICAgICAgZXJyb3IsIG1ldGhvZCwgdHJhbnNhY3Rpb25cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIFwibm9uY2UgdG9vIGxvd1wiXG4gICAgaWYgKG1lc3NhZ2UubWF0Y2goL25vbmNlIChpcyApP3RvbyBsb3cvaSkpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJub25jZSBoYXMgYWxyZWFkeSBiZWVuIHVzZWRcIiwgTG9nZ2VyLmVycm9ycy5OT05DRV9FWFBJUkVELCB7XG4gICAgICAgICAgICBlcnJvciwgbWV0aG9kLCB0cmFuc2FjdGlvblxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gXCJyZXBsYWNlbWVudCB0cmFuc2FjdGlvbiB1bmRlcnByaWNlZFwiXG4gICAgaWYgKG1lc3NhZ2UubWF0Y2goL3JlcGxhY2VtZW50IHRyYW5zYWN0aW9uIHVuZGVycHJpY2VkfHRyYW5zYWN0aW9uIGdhcyBwcmljZS4qdG9vIGxvdy9pKSkge1xuICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcInJlcGxhY2VtZW50IGZlZSB0b28gbG93XCIsIExvZ2dlci5lcnJvcnMuUkVQTEFDRU1FTlRfVU5ERVJQUklDRUQsIHtcbiAgICAgICAgICAgIGVycm9yLCBtZXRob2QsIHRyYW5zYWN0aW9uXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBcInJlcGxhY2VtZW50IHRyYW5zYWN0aW9uIHVuZGVycHJpY2VkXCJcbiAgICBpZiAobWVzc2FnZS5tYXRjaCgvb25seSByZXBsYXktcHJvdGVjdGVkL2kpKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwibGVnYWN5IHByZS1laXAtMTU1IHRyYW5zYWN0aW9ucyBub3Qgc3VwcG9ydGVkXCIsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICBlcnJvciwgbWV0aG9kLCB0cmFuc2FjdGlvblxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGVycm9yR2FzLmluZGV4T2YobWV0aG9kKSA+PSAwICYmIG1lc3NhZ2UubWF0Y2goL2dhcyByZXF1aXJlZCBleGNlZWRzIGFsbG93YW5jZXxhbHdheXMgZmFpbGluZyB0cmFuc2FjdGlvbnxleGVjdXRpb24gcmV2ZXJ0ZWR8cmV2ZXJ0LykpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJjYW5ub3QgZXN0aW1hdGUgZ2FzOyB0cmFuc2FjdGlvbiBtYXkgZmFpbCBvciBtYXkgcmVxdWlyZSBtYW51YWwgZ2FzIGxpbWl0XCIsIExvZ2dlci5lcnJvcnMuVU5QUkVESUNUQUJMRV9HQVNfTElNSVQsIHtcbiAgICAgICAgICAgIGVycm9yLCBtZXRob2QsIHRyYW5zYWN0aW9uXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB0aHJvdyBlcnJvcjtcbn1cbmZ1bmN0aW9uIHRpbWVyKHRpbWVvdXQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgc2V0VGltZW91dChyZXNvbHZlLCB0aW1lb3V0KTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGdldFJlc3VsdChwYXlsb2FkKSB7XG4gICAgaWYgKHBheWxvYWQuZXJyb3IpIHtcbiAgICAgICAgLy8gQFRPRE86IG5vdCBhbnlcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IocGF5bG9hZC5lcnJvci5tZXNzYWdlKTtcbiAgICAgICAgZXJyb3IuY29kZSA9IHBheWxvYWQuZXJyb3IuY29kZTtcbiAgICAgICAgZXJyb3IuZGF0YSA9IHBheWxvYWQuZXJyb3IuZGF0YTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIHJldHVybiBwYXlsb2FkLnJlc3VsdDtcbn1cbmZ1bmN0aW9uIGdldExvd2VyQ2FzZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuY29uc3QgX2NvbnN0cnVjdG9yR3VhcmQgPSB7fTtcbmV4cG9ydCBjbGFzcyBKc29uUnBjU2lnbmVyIGV4dGVuZHMgU2lnbmVyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25zdHJ1Y3Rvckd1YXJkLCBwcm92aWRlciwgYWRkcmVzc09ySW5kZXgpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgaWYgKGNvbnN0cnVjdG9yR3VhcmQgIT09IF9jb25zdHJ1Y3Rvckd1YXJkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJkbyBub3QgY2FsbCB0aGUgSnNvblJwY1NpZ25lciBjb25zdHJ1Y3RvciBkaXJlY3RseTsgdXNlIHByb3ZpZGVyLmdldFNpZ25lclwiKTtcbiAgICAgICAgfVxuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcInByb3ZpZGVyXCIsIHByb3ZpZGVyKTtcbiAgICAgICAgaWYgKGFkZHJlc3NPckluZGV4ID09IG51bGwpIHtcbiAgICAgICAgICAgIGFkZHJlc3NPckluZGV4ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIChhZGRyZXNzT3JJbmRleCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiX2FkZHJlc3NcIiwgdGhpcy5wcm92aWRlci5mb3JtYXR0ZXIuYWRkcmVzcyhhZGRyZXNzT3JJbmRleCkpO1xuICAgICAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJfaW5kZXhcIiwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIChhZGRyZXNzT3JJbmRleCkgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiX2luZGV4XCIsIGFkZHJlc3NPckluZGV4KTtcbiAgICAgICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiX2FkZHJlc3NcIiwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBhZGRyZXNzIG9yIGluZGV4XCIsIFwiYWRkcmVzc09ySW5kZXhcIiwgYWRkcmVzc09ySW5kZXgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbm5lY3QocHJvdmlkZXIpIHtcbiAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0Vycm9yKFwiY2Fubm90IGFsdGVyIEpTT04tUlBDIFNpZ25lciBjb25uZWN0aW9uXCIsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwiY29ubmVjdFwiXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25uZWN0VW5jaGVja2VkKCkge1xuICAgICAgICByZXR1cm4gbmV3IFVuY2hlY2tlZEpzb25ScGNTaWduZXIoX2NvbnN0cnVjdG9yR3VhcmQsIHRoaXMucHJvdmlkZXIsIHRoaXMuX2FkZHJlc3MgfHwgdGhpcy5faW5kZXgpO1xuICAgIH1cbiAgICBnZXRBZGRyZXNzKCkge1xuICAgICAgICBpZiAodGhpcy5fYWRkcmVzcykge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLl9hZGRyZXNzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlci5zZW5kKFwiZXRoX2FjY291bnRzXCIsIFtdKS50aGVuKChhY2NvdW50cykgPT4ge1xuICAgICAgICAgICAgaWYgKGFjY291bnRzLmxlbmd0aCA8PSB0aGlzLl9pbmRleCkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwidW5rbm93biBhY2NvdW50ICNcIiArIHRoaXMuX2luZGV4LCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwiZ2V0QWRkcmVzc1wiXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlci5mb3JtYXR0ZXIuYWRkcmVzcyhhY2NvdW50c1t0aGlzLl9pbmRleF0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2VuZFVuY2hlY2tlZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIHRyYW5zYWN0aW9uID0gc2hhbGxvd0NvcHkodHJhbnNhY3Rpb24pO1xuICAgICAgICBjb25zdCBmcm9tQWRkcmVzcyA9IHRoaXMuZ2V0QWRkcmVzcygpLnRoZW4oKGFkZHJlc3MpID0+IHtcbiAgICAgICAgICAgIGlmIChhZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgYWRkcmVzcyA9IGFkZHJlc3MudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhZGRyZXNzO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gVGhlIEpTT04tUlBDIGZvciBldGhfc2VuZFRyYW5zYWN0aW9uIHVzZXMgOTAwMDAgZ2FzOyBpZiB0aGUgdXNlclxuICAgICAgICAvLyB3aXNoZXMgdG8gdXNlIHRoaXMsIGl0IGlzIGVhc3kgdG8gc3BlY2lmeSBleHBsaWNpdGx5LCBvdGhlcndpc2VcbiAgICAgICAgLy8gd2UgbG9vayBpdCB1cCBmb3IgdGhlbS5cbiAgICAgICAgaWYgKHRyYW5zYWN0aW9uLmdhc0xpbWl0ID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IGVzdGltYXRlID0gc2hhbGxvd0NvcHkodHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgZXN0aW1hdGUuZnJvbSA9IGZyb21BZGRyZXNzO1xuICAgICAgICAgICAgdHJhbnNhY3Rpb24uZ2FzTGltaXQgPSB0aGlzLnByb3ZpZGVyLmVzdGltYXRlR2FzKGVzdGltYXRlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHJhbnNhY3Rpb24udG8gIT0gbnVsbCkge1xuICAgICAgICAgICAgdHJhbnNhY3Rpb24udG8gPSBQcm9taXNlLnJlc29sdmUodHJhbnNhY3Rpb24udG8pLnRoZW4oKHRvKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRvID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGFkZHJlc3MgPSB5aWVsZCB0aGlzLnByb3ZpZGVyLnJlc29sdmVOYW1lKHRvKTtcbiAgICAgICAgICAgICAgICBpZiAoYWRkcmVzcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJwcm92aWRlZCBFTlMgbmFtZSByZXNvbHZlcyB0byBudWxsXCIsIFwidHgudG9cIiwgdG8pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYWRkcmVzcztcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzb2x2ZVByb3BlcnRpZXMoe1xuICAgICAgICAgICAgdHg6IHJlc29sdmVQcm9wZXJ0aWVzKHRyYW5zYWN0aW9uKSxcbiAgICAgICAgICAgIHNlbmRlcjogZnJvbUFkZHJlc3NcbiAgICAgICAgfSkudGhlbigoeyB0eCwgc2VuZGVyIH0pID0+IHtcbiAgICAgICAgICAgIGlmICh0eC5mcm9tICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodHguZnJvbS50b0xvd2VyQ2FzZSgpICE9PSBzZW5kZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImZyb20gYWRkcmVzcyBtaXNtYXRjaFwiLCBcInRyYW5zYWN0aW9uXCIsIHRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0eC5mcm9tID0gc2VuZGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaGV4VHggPSB0aGlzLnByb3ZpZGVyLmNvbnN0cnVjdG9yLmhleGxpZnlUcmFuc2FjdGlvbih0eCwgeyBmcm9tOiB0cnVlIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXIuc2VuZChcImV0aF9zZW5kVHJhbnNhY3Rpb25cIiwgW2hleFR4XSkudGhlbigoaGFzaCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBoYXNoO1xuICAgICAgICAgICAgfSwgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAoZXJyb3IubWVzc2FnZSkgPT09IFwic3RyaW5nXCIgJiYgZXJyb3IubWVzc2FnZS5tYXRjaCgvdXNlciBkZW5pZWQvaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJ1c2VyIHJlamVjdGVkIHRyYW5zYWN0aW9uXCIsIExvZ2dlci5lcnJvcnMuQUNUSU9OX1JFSkVDVEVELCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwic2VuZFRyYW5zYWN0aW9uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbjogdHhcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjaGVja0Vycm9yKFwic2VuZFRyYW5zYWN0aW9uXCIsIGVycm9yLCBoZXhUeCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNpZ25UcmFuc2FjdGlvbih0cmFuc2FjdGlvbikge1xuICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93RXJyb3IoXCJzaWduaW5nIHRyYW5zYWN0aW9ucyBpcyB1bnN1cHBvcnRlZFwiLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcInNpZ25UcmFuc2FjdGlvblwiXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzZW5kVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgY2Fubm90IGJlIG1pbmVkIGFueSBlYXJsaWVyIHRoYW4gYW55IHJlY2VudCBibG9ja1xuICAgICAgICAgICAgY29uc3QgYmxvY2tOdW1iZXIgPSB5aWVsZCB0aGlzLnByb3ZpZGVyLl9nZXRJbnRlcm5hbEJsb2NrTnVtYmVyKDEwMCArIDIgKiB0aGlzLnByb3ZpZGVyLnBvbGxpbmdJbnRlcnZhbCk7XG4gICAgICAgICAgICAvLyBTZW5kIHRoZSB0cmFuc2FjdGlvblxuICAgICAgICAgICAgY29uc3QgaGFzaCA9IHlpZWxkIHRoaXMuc2VuZFVuY2hlY2tlZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLy8gVW5mb3J0dW5hdGVseSwgSlNPTi1SUEMgb25seSBwcm92aWRlcyBhbmQgb3BhcXVlIHRyYW5zYWN0aW9uIGhhc2hcbiAgICAgICAgICAgICAgICAvLyBmb3IgYSByZXNwb25zZSwgYW5kIHdlIG5lZWQgdGhlIGFjdHVhbCB0cmFuc2FjdGlvbiwgc28gd2UgcG9sbFxuICAgICAgICAgICAgICAgIC8vIGZvciBpdDsgaXQgc2hvdWxkIHNob3cgdXAgdmVyeSBxdWlja2x5XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHBvbGwoKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0eCA9IHlpZWxkIHRoaXMucHJvdmlkZXIuZ2V0VHJhbnNhY3Rpb24oaGFzaCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlci5fd3JhcFRyYW5zYWN0aW9uKHR4LCBoYXNoLCBibG9ja051bWJlcik7XG4gICAgICAgICAgICAgICAgfSksIHsgb25jZVBvbGw6IHRoaXMucHJvdmlkZXIgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBlcnJvci50cmFuc2FjdGlvbkhhc2ggPSBoYXNoO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2lnbk1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9ICgodHlwZW9mIChtZXNzYWdlKSA9PT0gXCJzdHJpbmdcIikgPyB0b1V0ZjhCeXRlcyhtZXNzYWdlKSA6IG1lc3NhZ2UpO1xuICAgICAgICAgICAgY29uc3QgYWRkcmVzcyA9IHlpZWxkIHRoaXMuZ2V0QWRkcmVzcygpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5wcm92aWRlci5zZW5kKFwicGVyc29uYWxfc2lnblwiLCBbaGV4bGlmeShkYXRhKSwgYWRkcmVzcy50b0xvd2VyQ2FzZSgpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChlcnJvci5tZXNzYWdlKSA9PT0gXCJzdHJpbmdcIiAmJiBlcnJvci5tZXNzYWdlLm1hdGNoKC91c2VyIGRlbmllZC9pKSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcInVzZXIgcmVqZWN0ZWQgc2lnbmluZ1wiLCBMb2dnZXIuZXJyb3JzLkFDVElPTl9SRUpFQ1RFRCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcInNpZ25NZXNzYWdlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBmcm9tOiBhZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZURhdGE6IG1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2xlZ2FjeVNpZ25NZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSAoKHR5cGVvZiAobWVzc2FnZSkgPT09IFwic3RyaW5nXCIpID8gdG9VdGY4Qnl0ZXMobWVzc2FnZSkgOiBtZXNzYWdlKTtcbiAgICAgICAgICAgIGNvbnN0IGFkZHJlc3MgPSB5aWVsZCB0aGlzLmdldEFkZHJlc3MoKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL3dpa2kvd2lraS9KU09OLVJQQyNldGhfc2lnblxuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLnByb3ZpZGVyLnNlbmQoXCJldGhfc2lnblwiLCBbYWRkcmVzcy50b0xvd2VyQ2FzZSgpLCBoZXhsaWZ5KGRhdGEpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChlcnJvci5tZXNzYWdlKSA9PT0gXCJzdHJpbmdcIiAmJiBlcnJvci5tZXNzYWdlLm1hdGNoKC91c2VyIGRlbmllZC9pKSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcInVzZXIgcmVqZWN0ZWQgc2lnbmluZ1wiLCBMb2dnZXIuZXJyb3JzLkFDVElPTl9SRUpFQ1RFRCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcIl9sZWdhY3lTaWduTWVzc2FnZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgZnJvbTogYWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VEYXRhOiBtZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9zaWduVHlwZWREYXRhKGRvbWFpbiwgdHlwZXMsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAvLyBQb3B1bGF0ZSBhbnkgRU5TIG5hbWVzIChpbi1wbGFjZSlcbiAgICAgICAgICAgIGNvbnN0IHBvcHVsYXRlZCA9IHlpZWxkIF9UeXBlZERhdGFFbmNvZGVyLnJlc29sdmVOYW1lcyhkb21haW4sIHR5cGVzLCB2YWx1ZSwgKG5hbWUpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlci5yZXNvbHZlTmFtZShuYW1lKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgYWRkcmVzcyA9IHlpZWxkIHRoaXMuZ2V0QWRkcmVzcygpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5wcm92aWRlci5zZW5kKFwiZXRoX3NpZ25UeXBlZERhdGFfdjRcIiwgW1xuICAgICAgICAgICAgICAgICAgICBhZGRyZXNzLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KF9UeXBlZERhdGFFbmNvZGVyLmdldFBheWxvYWQocG9wdWxhdGVkLmRvbWFpbiwgdHlwZXMsIHBvcHVsYXRlZC52YWx1ZSkpXG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChlcnJvci5tZXNzYWdlKSA9PT0gXCJzdHJpbmdcIiAmJiBlcnJvci5tZXNzYWdlLm1hdGNoKC91c2VyIGRlbmllZC9pKSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcInVzZXIgcmVqZWN0ZWQgc2lnbmluZ1wiLCBMb2dnZXIuZXJyb3JzLkFDVElPTl9SRUpFQ1RFRCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcIl9zaWduVHlwZWREYXRhXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBmcm9tOiBhZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZURhdGE6IHsgZG9tYWluOiBwb3B1bGF0ZWQuZG9tYWluLCB0eXBlcywgdmFsdWU6IHBvcHVsYXRlZC52YWx1ZSB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHVubG9jayhwYXNzd29yZCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB0aGlzLnByb3ZpZGVyO1xuICAgICAgICAgICAgY29uc3QgYWRkcmVzcyA9IHlpZWxkIHRoaXMuZ2V0QWRkcmVzcygpO1xuICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVyLnNlbmQoXCJwZXJzb25hbF91bmxvY2tBY2NvdW50XCIsIFthZGRyZXNzLnRvTG93ZXJDYXNlKCksIHBhc3N3b3JkLCBudWxsXSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmNsYXNzIFVuY2hlY2tlZEpzb25ScGNTaWduZXIgZXh0ZW5kcyBKc29uUnBjU2lnbmVyIHtcbiAgICBzZW5kVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZFVuY2hlY2tlZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKS50aGVuKChoYXNoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGhhc2g6IGhhc2gsXG4gICAgICAgICAgICAgICAgbm9uY2U6IG51bGwsXG4gICAgICAgICAgICAgICAgZ2FzTGltaXQ6IG51bGwsXG4gICAgICAgICAgICAgICAgZ2FzUHJpY2U6IG51bGwsXG4gICAgICAgICAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogbnVsbCxcbiAgICAgICAgICAgICAgICBjaGFpbklkOiBudWxsLFxuICAgICAgICAgICAgICAgIGNvbmZpcm1hdGlvbnM6IDAsXG4gICAgICAgICAgICAgICAgZnJvbTogbnVsbCxcbiAgICAgICAgICAgICAgICB3YWl0OiAoY29uZmlybWF0aW9ucykgPT4geyByZXR1cm4gdGhpcy5wcm92aWRlci53YWl0Rm9yVHJhbnNhY3Rpb24oaGFzaCwgY29uZmlybWF0aW9ucyk7IH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmNvbnN0IGFsbG93ZWRUcmFuc2FjdGlvbktleXMgPSB7XG4gICAgY2hhaW5JZDogdHJ1ZSwgZGF0YTogdHJ1ZSwgZ2FzTGltaXQ6IHRydWUsIGdhc1ByaWNlOiB0cnVlLCBub25jZTogdHJ1ZSwgdG86IHRydWUsIHZhbHVlOiB0cnVlLFxuICAgIHR5cGU6IHRydWUsIGFjY2Vzc0xpc3Q6IHRydWUsXG4gICAgbWF4RmVlUGVyR2FzOiB0cnVlLCBtYXhQcmlvcml0eUZlZVBlckdhczogdHJ1ZVxufTtcbmV4cG9ydCBjbGFzcyBKc29uUnBjUHJvdmlkZXIgZXh0ZW5kcyBCYXNlUHJvdmlkZXIge1xuICAgIGNvbnN0cnVjdG9yKHVybCwgbmV0d29yaykge1xuICAgICAgICBsZXQgbmV0d29ya09yUmVhZHkgPSBuZXR3b3JrO1xuICAgICAgICAvLyBUaGUgbmV0d29yayBpcyB1bmtub3duLCBxdWVyeSB0aGUgSlNPTi1SUEMgZm9yIGl0XG4gICAgICAgIGlmIChuZXR3b3JrT3JSZWFkeSA9PSBudWxsKSB7XG4gICAgICAgICAgICBuZXR3b3JrT3JSZWFkeSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZXRlY3ROZXR3b3JrKCkudGhlbigobmV0d29yaykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShuZXR3b3JrKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKG5ldHdvcmtPclJlYWR5KTtcbiAgICAgICAgLy8gRGVmYXVsdCBVUkxcbiAgICAgICAgaWYgKCF1cmwpIHtcbiAgICAgICAgICAgIHVybCA9IGdldFN0YXRpYyh0aGlzLmNvbnN0cnVjdG9yLCBcImRlZmF1bHRVcmxcIikoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mICh1cmwpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcImNvbm5lY3Rpb25cIiwgT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgICAgICAgICAgdXJsOiB1cmxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiY29ubmVjdGlvblwiLCBPYmplY3QuZnJlZXplKHNoYWxsb3dDb3B5KHVybCkpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9uZXh0SWQgPSA0MjtcbiAgICB9XG4gICAgZ2V0IF9jYWNoZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2V2ZW50TG9vcENhY2hlID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50TG9vcENhY2hlID0ge307XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2V2ZW50TG9vcENhY2hlO1xuICAgIH1cbiAgICBzdGF0aWMgZGVmYXVsdFVybCgpIHtcbiAgICAgICAgcmV0dXJuIFwiaHR0cDovXFwvbG9jYWxob3N0Ojg1NDVcIjtcbiAgICB9XG4gICAgZGV0ZWN0TmV0d29yaygpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9jYWNoZVtcImRldGVjdE5ldHdvcmtcIl0pIHtcbiAgICAgICAgICAgIHRoaXMuX2NhY2hlW1wiZGV0ZWN0TmV0d29ya1wiXSA9IHRoaXMuX3VuY2FjaGVkRGV0ZWN0TmV0d29yaygpO1xuICAgICAgICAgICAgLy8gQ2xlYXIgdGhpcyBjYWNoZSBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBuZXh0IGV2ZW50IGxvb3BcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlW1wiZGV0ZWN0TmV0d29ya1wiXSA9IG51bGw7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGVbXCJkZXRlY3ROZXR3b3JrXCJdO1xuICAgIH1cbiAgICBfdW5jYWNoZWREZXRlY3ROZXR3b3JrKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgeWllbGQgdGltZXIoMCk7XG4gICAgICAgICAgICBsZXQgY2hhaW5JZCA9IG51bGw7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNoYWluSWQgPSB5aWVsZCB0aGlzLnNlbmQoXCJldGhfY2hhaW5JZFwiLCBbXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjaGFpbklkID0geWllbGQgdGhpcy5zZW5kKFwibmV0X3ZlcnNpb25cIiwgW10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNoYWluSWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGdldE5ldHdvcmsgPSBnZXRTdGF0aWModGhpcy5jb25zdHJ1Y3RvciwgXCJnZXROZXR3b3JrXCIpO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXROZXR3b3JrKEJpZ051bWJlci5mcm9tKGNoYWluSWQpLnRvTnVtYmVyKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0Vycm9yKFwiY291bGQgbm90IGRldGVjdCBuZXR3b3JrXCIsIExvZ2dlci5lcnJvcnMuTkVUV09SS19FUlJPUiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhaW5JZDogY2hhaW5JZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50OiBcImludmFsaWROZXR3b3JrXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJFcnJvcjogZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0Vycm9yKFwiY291bGQgbm90IGRldGVjdCBuZXR3b3JrXCIsIExvZ2dlci5lcnJvcnMuTkVUV09SS19FUlJPUiwge1xuICAgICAgICAgICAgICAgIGV2ZW50OiBcIm5vTmV0d29ya1wiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldFNpZ25lcihhZGRyZXNzT3JJbmRleCkge1xuICAgICAgICByZXR1cm4gbmV3IEpzb25ScGNTaWduZXIoX2NvbnN0cnVjdG9yR3VhcmQsIHRoaXMsIGFkZHJlc3NPckluZGV4KTtcbiAgICB9XG4gICAgZ2V0VW5jaGVja2VkU2lnbmVyKGFkZHJlc3NPckluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFNpZ25lcihhZGRyZXNzT3JJbmRleCkuY29ubmVjdFVuY2hlY2tlZCgpO1xuICAgIH1cbiAgICBsaXN0QWNjb3VudHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQoXCJldGhfYWNjb3VudHNcIiwgW10pLnRoZW4oKGFjY291bnRzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gYWNjb3VudHMubWFwKChhKSA9PiB0aGlzLmZvcm1hdHRlci5hZGRyZXNzKGEpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNlbmQobWV0aG9kLCBwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHtcbiAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgICAgICAgcGFyYW1zOiBwYXJhbXMsXG4gICAgICAgICAgICBpZDogKHRoaXMuX25leHRJZCsrKSxcbiAgICAgICAgICAgIGpzb25ycGM6IFwiMi4wXCJcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwge1xuICAgICAgICAgICAgYWN0aW9uOiBcInJlcXVlc3RcIixcbiAgICAgICAgICAgIHJlcXVlc3Q6IGRlZXBDb3B5KHJlcXVlc3QpLFxuICAgICAgICAgICAgcHJvdmlkZXI6IHRoaXNcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFdlIGNhbiBleHBhbmQgdGhpcyBpbiB0aGUgZnV0dXJlIHRvIGFueSBjYWxsLCBidXQgZm9yIG5vdyB0aGVzZVxuICAgICAgICAvLyBhcmUgdGhlIGJpZ2dlc3Qgd2lucyBhbmQgZG8gbm90IHJlcXVpcmUgYW55IHNlcmlhbGl6aW5nIHBhcmFtZXRlcnMuXG4gICAgICAgIGNvbnN0IGNhY2hlID0gKFtcImV0aF9jaGFpbklkXCIsIFwiZXRoX2Jsb2NrTnVtYmVyXCJdLmluZGV4T2YobWV0aG9kKSA+PSAwKTtcbiAgICAgICAgaWYgKGNhY2hlICYmIHRoaXMuX2NhY2hlW21ldGhvZF0pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYWNoZVttZXRob2RdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGZldGNoSnNvbih0aGlzLmNvbm5lY3Rpb24sIEpTT04uc3RyaW5naWZ5KHJlcXVlc3QpLCBnZXRSZXN1bHQpLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwge1xuICAgICAgICAgICAgICAgIGFjdGlvbjogXCJyZXNwb25zZVwiLFxuICAgICAgICAgICAgICAgIHJlcXVlc3Q6IHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgcmVzcG9uc2U6IHJlc3VsdCxcbiAgICAgICAgICAgICAgICBwcm92aWRlcjogdGhpc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LCAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHtcbiAgICAgICAgICAgICAgICBhY3Rpb246IFwicmVzcG9uc2VcIixcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgICAgICAgICAgcmVxdWVzdDogcmVxdWVzdCxcbiAgICAgICAgICAgICAgICBwcm92aWRlcjogdGhpc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIENhY2hlIHRoZSBmZXRjaCwgYnV0IGNsZWFyIGl0IG9uIHRoZSBuZXh0IGV2ZW50IGxvb3BcbiAgICAgICAgaWYgKGNhY2hlKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWNoZVttZXRob2RdID0gcmVzdWx0O1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2FjaGVbbWV0aG9kXSA9IG51bGw7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBwcmVwYXJlUmVxdWVzdChtZXRob2QsIHBhcmFtcykge1xuICAgICAgICBzd2l0Y2ggKG1ldGhvZCkge1xuICAgICAgICAgICAgY2FzZSBcImdldEJsb2NrTnVtYmVyXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcImV0aF9ibG9ja051bWJlclwiLCBbXV07XG4gICAgICAgICAgICBjYXNlIFwiZ2V0R2FzUHJpY2VcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gW1wiZXRoX2dhc1ByaWNlXCIsIFtdXTtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRCYWxhbmNlXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcImV0aF9nZXRCYWxhbmNlXCIsIFtnZXRMb3dlckNhc2UocGFyYW1zLmFkZHJlc3MpLCBwYXJhbXMuYmxvY2tUYWddXTtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRUcmFuc2FjdGlvbkNvdW50XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcImV0aF9nZXRUcmFuc2FjdGlvbkNvdW50XCIsIFtnZXRMb3dlckNhc2UocGFyYW1zLmFkZHJlc3MpLCBwYXJhbXMuYmxvY2tUYWddXTtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRDb2RlXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcImV0aF9nZXRDb2RlXCIsIFtnZXRMb3dlckNhc2UocGFyYW1zLmFkZHJlc3MpLCBwYXJhbXMuYmxvY2tUYWddXTtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRTdG9yYWdlQXRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gW1wiZXRoX2dldFN0b3JhZ2VBdFwiLCBbZ2V0TG93ZXJDYXNlKHBhcmFtcy5hZGRyZXNzKSwgaGV4WmVyb1BhZChwYXJhbXMucG9zaXRpb24sIDMyKSwgcGFyYW1zLmJsb2NrVGFnXV07XG4gICAgICAgICAgICBjYXNlIFwic2VuZFRyYW5zYWN0aW9uXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcImV0aF9zZW5kUmF3VHJhbnNhY3Rpb25cIiwgW3BhcmFtcy5zaWduZWRUcmFuc2FjdGlvbl1dO1xuICAgICAgICAgICAgY2FzZSBcImdldEJsb2NrXCI6XG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5ibG9ja1RhZykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1wiZXRoX2dldEJsb2NrQnlOdW1iZXJcIiwgW3BhcmFtcy5ibG9ja1RhZywgISFwYXJhbXMuaW5jbHVkZVRyYW5zYWN0aW9uc11dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwYXJhbXMuYmxvY2tIYXNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXCJldGhfZ2V0QmxvY2tCeUhhc2hcIiwgW3BhcmFtcy5ibG9ja0hhc2gsICEhcGFyYW1zLmluY2x1ZGVUcmFuc2FjdGlvbnNdXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBjYXNlIFwiZ2V0VHJhbnNhY3Rpb25cIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gW1wiZXRoX2dldFRyYW5zYWN0aW9uQnlIYXNoXCIsIFtwYXJhbXMudHJhbnNhY3Rpb25IYXNoXV07XG4gICAgICAgICAgICBjYXNlIFwiZ2V0VHJhbnNhY3Rpb25SZWNlaXB0XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcImV0aF9nZXRUcmFuc2FjdGlvblJlY2VpcHRcIiwgW3BhcmFtcy50cmFuc2FjdGlvbkhhc2hdXTtcbiAgICAgICAgICAgIGNhc2UgXCJjYWxsXCI6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBoZXhsaWZ5VHJhbnNhY3Rpb24gPSBnZXRTdGF0aWModGhpcy5jb25zdHJ1Y3RvciwgXCJoZXhsaWZ5VHJhbnNhY3Rpb25cIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcImV0aF9jYWxsXCIsIFtoZXhsaWZ5VHJhbnNhY3Rpb24ocGFyYW1zLnRyYW5zYWN0aW9uLCB7IGZyb206IHRydWUgfSksIHBhcmFtcy5ibG9ja1RhZ11dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcImVzdGltYXRlR2FzXCI6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBoZXhsaWZ5VHJhbnNhY3Rpb24gPSBnZXRTdGF0aWModGhpcy5jb25zdHJ1Y3RvciwgXCJoZXhsaWZ5VHJhbnNhY3Rpb25cIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcImV0aF9lc3RpbWF0ZUdhc1wiLCBbaGV4bGlmeVRyYW5zYWN0aW9uKHBhcmFtcy50cmFuc2FjdGlvbiwgeyBmcm9tOiB0cnVlIH0pXV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwiZ2V0TG9nc1wiOlxuICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuZmlsdGVyICYmIHBhcmFtcy5maWx0ZXIuYWRkcmVzcyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcy5maWx0ZXIuYWRkcmVzcyA9IGdldExvd2VyQ2FzZShwYXJhbXMuZmlsdGVyLmFkZHJlc3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gW1wiZXRoX2dldExvZ3NcIiwgW3BhcmFtcy5maWx0ZXJdXTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHBlcmZvcm0obWV0aG9kLCBwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIC8vIExlZ2FjeSBuZXR3b3JrcyBkbyBub3QgbGlrZSB0aGUgdHlwZSBmaWVsZCBiZWluZyBwYXNzZWQgYWxvbmcgKHdoaWNoXG4gICAgICAgICAgICAvLyBpcyBmYWlyKSwgc28gd2UgZGVsZXRlIHR5cGUgaWYgaXQgaXMgMCBhbmQgYSBub24tRUlQLTE1NTkgbmV0d29ya1xuICAgICAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJjYWxsXCIgfHwgbWV0aG9kID09PSBcImVzdGltYXRlR2FzXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0eCA9IHBhcmFtcy50cmFuc2FjdGlvbjtcbiAgICAgICAgICAgICAgICBpZiAodHggJiYgdHgudHlwZSAhPSBudWxsICYmIEJpZ051bWJlci5mcm9tKHR4LnR5cGUpLmlzWmVybygpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBFSVAtMTU1OSBwcm9wZXJ0aWVzLCBpdCBtaWdodCBiZSBub24tRUlQLTE1NTlcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR4Lm1heEZlZVBlckdhcyA9PSBudWxsICYmIHR4Lm1heFByaW9yaXR5RmVlUGVyR2FzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZlZURhdGEgPSB5aWVsZCB0aGlzLmdldEZlZURhdGEoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmZWVEYXRhLm1heEZlZVBlckdhcyA9PSBudWxsICYmIGZlZURhdGEubWF4UHJpb3JpdHlGZWVQZXJHYXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5ldHdvcmsgZG9lc24ndCBrbm93IGFib3V0IEVJUC0xNTU5IChhbmQgaGVuY2UgdHlwZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPSBzaGFsbG93Q29weShwYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy50cmFuc2FjdGlvbiA9IHNoYWxsb3dDb3B5KHR4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgcGFyYW1zLnRyYW5zYWN0aW9uLnR5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhcmdzID0gdGhpcy5wcmVwYXJlUmVxdWVzdChtZXRob2QsIHBhcmFtcyk7XG4gICAgICAgICAgICBpZiAoYXJncyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IobWV0aG9kICsgXCIgbm90IGltcGxlbWVudGVkXCIsIExvZ2dlci5lcnJvcnMuTk9UX0lNUExFTUVOVEVELCB7IG9wZXJhdGlvbjogbWV0aG9kIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5zZW5kKGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoZWNrRXJyb3IobWV0aG9kLCBlcnJvciwgcGFyYW1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9zdGFydEV2ZW50KGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC50YWcgPT09IFwicGVuZGluZ1wiKSB7XG4gICAgICAgICAgICB0aGlzLl9zdGFydFBlbmRpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlci5fc3RhcnRFdmVudChldmVudCk7XG4gICAgfVxuICAgIF9zdGFydFBlbmRpbmcoKSB7XG4gICAgICAgIGlmICh0aGlzLl9wZW5kaW5nRmlsdGVyICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgY29uc3QgcGVuZGluZ0ZpbHRlciA9IHRoaXMuc2VuZChcImV0aF9uZXdQZW5kaW5nVHJhbnNhY3Rpb25GaWx0ZXJcIiwgW10pO1xuICAgICAgICB0aGlzLl9wZW5kaW5nRmlsdGVyID0gcGVuZGluZ0ZpbHRlcjtcbiAgICAgICAgcGVuZGluZ0ZpbHRlci50aGVuKGZ1bmN0aW9uIChmaWx0ZXJJZCkge1xuICAgICAgICAgICAgZnVuY3Rpb24gcG9sbCgpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnNlbmQoXCJldGhfZ2V0RmlsdGVyQ2hhbmdlc1wiLCBbZmlsdGVySWRdKS50aGVuKGZ1bmN0aW9uIChoYXNoZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuX3BlbmRpbmdGaWx0ZXIgIT0gcGVuZGluZ0ZpbHRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGV0IHNlcSA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICBoYXNoZXMuZm9yRWFjaChmdW5jdGlvbiAoaGFzaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQFRPRE86IFRoaXMgc2hvdWxkIGJlIGdhcmJhZ2UgY29sbGVjdGVkIGF0IHNvbWUgcG9pbnQuLi4gSG93PyBXaGVuP1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fZW1pdHRlZFtcInQ6XCIgKyBoYXNoLnRvTG93ZXJDYXNlKCldID0gXCJwZW5kaW5nXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXEgPSBzZXEudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuZ2V0VHJhbnNhY3Rpb24oaGFzaCkudGhlbihmdW5jdGlvbiAodHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5lbWl0KFwicGVuZGluZ1wiLCB0eCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VxLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRpbWVyKDEwMDApO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuX3BlbmRpbmdGaWx0ZXIgIT0gcGVuZGluZ0ZpbHRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5zZW5kKFwiZXRoX3VuaW5zdGFsbEZpbHRlclwiLCBbZmlsdGVySWRdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcG9sbCgpOyB9LCAwKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfSkuY2F0Y2goKGVycm9yKSA9PiB7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9sbCgpO1xuICAgICAgICAgICAgcmV0dXJuIGZpbHRlcklkO1xuICAgICAgICB9KS5jYXRjaCgoZXJyb3IpID0+IHsgfSk7XG4gICAgfVxuICAgIF9zdG9wRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LnRhZyA9PT0gXCJwZW5kaW5nXCIgJiYgdGhpcy5saXN0ZW5lckNvdW50KFwicGVuZGluZ1wiKSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5fcGVuZGluZ0ZpbHRlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIuX3N0b3BFdmVudChldmVudCk7XG4gICAgfVxuICAgIC8vIENvbnZlcnQgYW4gZXRoZXJzLmpzIHRyYW5zYWN0aW9uIGludG8gYSBKU09OLVJQQyB0cmFuc2FjdGlvblxuICAgIC8vICAtIGdhc0xpbWl0ID0+IGdhc1xuICAgIC8vICAtIEFsbCB2YWx1ZXMgaGV4bGlmaWVkXG4gICAgLy8gIC0gQWxsIG51bWVyaWMgdmFsdWVzIHplcm8tc3RyaXBlZFxuICAgIC8vICAtIEFsbCBhZGRyZXNzZXMgYXJlIGxvd2VyY2FzZWRcbiAgICAvLyBOT1RFOiBUaGlzIGFsbG93cyBhIFRyYW5zYWN0aW9uUmVxdWVzdCwgYnV0IGFsbCB2YWx1ZXMgc2hvdWxkIGJlIHJlc29sdmVkXG4gICAgLy8gICAgICAgYmVmb3JlIHRoaXMgaXMgY2FsbGVkXG4gICAgLy8gQFRPRE86IFRoaXMgd2lsbCBsaWtlbHkgYmUgcmVtb3ZlZCBpbiBmdXR1cmUgdmVyc2lvbnMgYW5kIHByZXBhcmVSZXF1ZXN0XG4gICAgLy8gICAgICAgIHdpbGwgYmUgdGhlIHByZWZlcnJlZCBtZXRob2QgZm9yIHRoaXMuXG4gICAgc3RhdGljIGhleGxpZnlUcmFuc2FjdGlvbih0cmFuc2FjdGlvbiwgYWxsb3dFeHRyYSkge1xuICAgICAgICAvLyBDaGVjayBvbmx5IGFsbG93ZWQgcHJvcGVydGllcyBhcmUgZ2l2ZW5cbiAgICAgICAgY29uc3QgYWxsb3dlZCA9IHNoYWxsb3dDb3B5KGFsbG93ZWRUcmFuc2FjdGlvbktleXMpO1xuICAgICAgICBpZiAoYWxsb3dFeHRyYSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gYWxsb3dFeHRyYSkge1xuICAgICAgICAgICAgICAgIGlmIChhbGxvd0V4dHJhW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dlZFtrZXldID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2hlY2tQcm9wZXJ0aWVzKHRyYW5zYWN0aW9uLCBhbGxvd2VkKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgICAgIC8vIEpTT04tUlBDIG5vdyByZXF1aXJlcyBudW1lcmljIHZhbHVlcyB0byBiZSBcInF1YW50aXR5XCIgdmFsdWVzXG4gICAgICAgIFtcImNoYWluSWRcIiwgXCJnYXNMaW1pdFwiLCBcImdhc1ByaWNlXCIsIFwidHlwZVwiLCBcIm1heEZlZVBlckdhc1wiLCBcIm1heFByaW9yaXR5RmVlUGVyR2FzXCIsIFwibm9uY2VcIiwgXCJ2YWx1ZVwiXS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGlmICh0cmFuc2FjdGlvbltrZXldID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGhleFZhbHVlKEJpZ051bWJlci5mcm9tKHRyYW5zYWN0aW9uW2tleV0pKTtcbiAgICAgICAgICAgIGlmIChrZXkgPT09IFwiZ2FzTGltaXRcIikge1xuICAgICAgICAgICAgICAgIGtleSA9IFwiZ2FzXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgICAgW1wiZnJvbVwiLCBcInRvXCIsIFwiZGF0YVwiXS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGlmICh0cmFuc2FjdGlvbltrZXldID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IGhleGxpZnkodHJhbnNhY3Rpb25ba2V5XSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodHJhbnNhY3Rpb24uYWNjZXNzTGlzdCkge1xuICAgICAgICAgICAgcmVzdWx0W1wiYWNjZXNzTGlzdFwiXSA9IGFjY2Vzc0xpc3RpZnkodHJhbnNhY3Rpb24uYWNjZXNzTGlzdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1qc29uLXJwYy1wcm92aWRlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ethersproject/providers/lib.esm/json-rpc-provider.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@ethersproject/providers/lib.esm/nodesmith-provider.js":
/*!******************************************************************************!*\
  !*** ../node_modules/@ethersproject/providers/lib.esm/nodesmith-provider.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NodesmithProvider: () => (/* binding */ NodesmithProvider)\n/* harmony export */ });\n/* harmony import */ var _url_json_rpc_provider__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./url-json-rpc-provider */ \"(ssr)/../node_modules/@ethersproject/providers/lib.esm/url-json-rpc-provider.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/../node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(ssr)/../node_modules/@ethersproject/providers/lib.esm/_version.js\");\n/* istanbul ignore file */\n\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\n// Special API key provided by Nodesmith for ethers.js\nconst defaultApiKey = \"ETHERS_JS_SHARED\";\nclass NodesmithProvider extends _url_json_rpc_provider__WEBPACK_IMPORTED_MODULE_2__.UrlJsonRpcProvider {\n    static getApiKey(apiKey) {\n        if (apiKey && typeof (apiKey) !== \"string\") {\n            logger.throwArgumentError(\"invalid apiKey\", \"apiKey\", apiKey);\n        }\n        return apiKey || defaultApiKey;\n    }\n    static getUrl(network, apiKey) {\n        logger.warn(\"NodeSmith will be discontinued on 2019-12-20; please migrate to another platform.\");\n        let host = null;\n        switch (network.name) {\n            case \"homestead\":\n                host = \"https://ethereum.api.nodesmith.io/v1/mainnet/jsonrpc\";\n                break;\n            case \"ropsten\":\n                host = \"https://ethereum.api.nodesmith.io/v1/ropsten/jsonrpc\";\n                break;\n            case \"rinkeby\":\n                host = \"https://ethereum.api.nodesmith.io/v1/rinkeby/jsonrpc\";\n                break;\n            case \"goerli\":\n                host = \"https://ethereum.api.nodesmith.io/v1/goerli/jsonrpc\";\n                break;\n            case \"kovan\":\n                host = \"https://ethereum.api.nodesmith.io/v1/kovan/jsonrpc\";\n                break;\n            default:\n                logger.throwArgumentError(\"unsupported network\", \"network\", arguments[0]);\n        }\n        return (host + \"?apiKey=\" + apiKey);\n    }\n}\n//# sourceMappingURL=nodesmith-provider.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3Byb3ZpZGVycy9saWIuZXNtL25vZGVzbWl0aC1wcm92aWRlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDYTtBQUNnRDtBQUNkO0FBQ1Y7QUFDckMsbUJBQW1CLHlEQUFNLENBQUMsNkNBQU87QUFDakM7QUFDQTtBQUNPLGdDQUFnQyxzRUFBa0I7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGVkZ2l0eS15aWVsZC1mcm9udGVuZC8uLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvcHJvdmlkZXJzL2xpYi5lc20vbm9kZXNtaXRoLXByb3ZpZGVyLmpzPzQ0ZDIiXSwic291cmNlc0NvbnRlbnQiOlsiLyogaXN0YW5idWwgaWdub3JlIGZpbGUgKi9cblwidXNlIHN0cmljdFwiO1xuaW1wb3J0IHsgVXJsSnNvblJwY1Byb3ZpZGVyIH0gZnJvbSBcIi4vdXJsLWpzb24tcnBjLXByb3ZpZGVyXCI7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvbG9nZ2VyXCI7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4vX3ZlcnNpb25cIjtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIodmVyc2lvbik7XG4vLyBTcGVjaWFsIEFQSSBrZXkgcHJvdmlkZWQgYnkgTm9kZXNtaXRoIGZvciBldGhlcnMuanNcbmNvbnN0IGRlZmF1bHRBcGlLZXkgPSBcIkVUSEVSU19KU19TSEFSRURcIjtcbmV4cG9ydCBjbGFzcyBOb2Rlc21pdGhQcm92aWRlciBleHRlbmRzIFVybEpzb25ScGNQcm92aWRlciB7XG4gICAgc3RhdGljIGdldEFwaUtleShhcGlLZXkpIHtcbiAgICAgICAgaWYgKGFwaUtleSAmJiB0eXBlb2YgKGFwaUtleSkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGFwaUtleVwiLCBcImFwaUtleVwiLCBhcGlLZXkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcGlLZXkgfHwgZGVmYXVsdEFwaUtleTtcbiAgICB9XG4gICAgc3RhdGljIGdldFVybChuZXR3b3JrLCBhcGlLZXkpIHtcbiAgICAgICAgbG9nZ2VyLndhcm4oXCJOb2RlU21pdGggd2lsbCBiZSBkaXNjb250aW51ZWQgb24gMjAxOS0xMi0yMDsgcGxlYXNlIG1pZ3JhdGUgdG8gYW5vdGhlciBwbGF0Zm9ybS5cIik7XG4gICAgICAgIGxldCBob3N0ID0gbnVsbDtcbiAgICAgICAgc3dpdGNoIChuZXR3b3JrLm5hbWUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJob21lc3RlYWRcIjpcbiAgICAgICAgICAgICAgICBob3N0ID0gXCJodHRwczovL2V0aGVyZXVtLmFwaS5ub2Rlc21pdGguaW8vdjEvbWFpbm5ldC9qc29ucnBjXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwicm9wc3RlblwiOlxuICAgICAgICAgICAgICAgIGhvc3QgPSBcImh0dHBzOi8vZXRoZXJldW0uYXBpLm5vZGVzbWl0aC5pby92MS9yb3BzdGVuL2pzb25ycGNcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJyaW5rZWJ5XCI6XG4gICAgICAgICAgICAgICAgaG9zdCA9IFwiaHR0cHM6Ly9ldGhlcmV1bS5hcGkubm9kZXNtaXRoLmlvL3YxL3JpbmtlYnkvanNvbnJwY1wiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImdvZXJsaVwiOlxuICAgICAgICAgICAgICAgIGhvc3QgPSBcImh0dHBzOi8vZXRoZXJldW0uYXBpLm5vZGVzbWl0aC5pby92MS9nb2VybGkvanNvbnJwY1wiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImtvdmFuXCI6XG4gICAgICAgICAgICAgICAgaG9zdCA9IFwiaHR0cHM6Ly9ldGhlcmV1bS5hcGkubm9kZXNtaXRoLmlvL3YxL2tvdmFuL2pzb25ycGNcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInVuc3VwcG9ydGVkIG5ldHdvcmtcIiwgXCJuZXR3b3JrXCIsIGFyZ3VtZW50c1swXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChob3N0ICsgXCI/YXBpS2V5PVwiICsgYXBpS2V5KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ub2Rlc21pdGgtcHJvdmlkZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ethersproject/providers/lib.esm/nodesmith-provider.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@ethersproject/providers/lib.esm/pocket-provider.js":
/*!***************************************************************************!*\
  !*** ../node_modules/@ethersproject/providers/lib.esm/pocket-provider.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PocketProvider: () => (/* binding */ PocketProvider)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/../node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(ssr)/../node_modules/@ethersproject/providers/lib.esm/_version.js\");\n/* harmony import */ var _url_json_rpc_provider__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./url-json-rpc-provider */ \"(ssr)/../node_modules/@ethersproject/providers/lib.esm/url-json-rpc-provider.js\");\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\n\nconst defaultApplicationId = \"62e1ad51b37b8e00394bda3b\";\nclass PocketProvider extends _url_json_rpc_provider__WEBPACK_IMPORTED_MODULE_2__.UrlJsonRpcProvider {\n    static getApiKey(apiKey) {\n        const apiKeyObj = {\n            applicationId: null,\n            loadBalancer: true,\n            applicationSecretKey: null\n        };\n        // Parse applicationId and applicationSecretKey\n        if (apiKey == null) {\n            apiKeyObj.applicationId = defaultApplicationId;\n        }\n        else if (typeof (apiKey) === \"string\") {\n            apiKeyObj.applicationId = apiKey;\n        }\n        else if (apiKey.applicationSecretKey != null) {\n            apiKeyObj.applicationId = apiKey.applicationId;\n            apiKeyObj.applicationSecretKey = apiKey.applicationSecretKey;\n        }\n        else if (apiKey.applicationId) {\n            apiKeyObj.applicationId = apiKey.applicationId;\n        }\n        else {\n            logger.throwArgumentError(\"unsupported PocketProvider apiKey\", \"apiKey\", apiKey);\n        }\n        return apiKeyObj;\n    }\n    static getUrl(network, apiKey) {\n        let host = null;\n        switch (network ? network.name : \"unknown\") {\n            case \"goerli\":\n                host = \"eth-goerli.gateway.pokt.network\";\n                break;\n            case \"homestead\":\n                host = \"eth-mainnet.gateway.pokt.network\";\n                break;\n            case \"kovan\":\n                host = \"poa-kovan.gateway.pokt.network\";\n                break;\n            case \"matic\":\n                host = \"poly-mainnet.gateway.pokt.network\";\n                break;\n            case \"maticmum\":\n                host = \"polygon-mumbai-rpc.gateway.pokt.network\";\n                break;\n            case \"rinkeby\":\n                host = \"eth-rinkeby.gateway.pokt.network\";\n                break;\n            case \"ropsten\":\n                host = \"eth-ropsten.gateway.pokt.network\";\n                break;\n            default:\n                logger.throwError(\"unsupported network\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.INVALID_ARGUMENT, {\n                    argument: \"network\",\n                    value: network\n                });\n        }\n        const url = `https:/\\/${host}/v1/lb/${apiKey.applicationId}`;\n        const connection = { headers: {}, url };\n        if (apiKey.applicationSecretKey != null) {\n            connection.user = \"\";\n            connection.password = apiKey.applicationSecretKey;\n        }\n        return connection;\n    }\n    isCommunityResource() {\n        return (this.applicationId === defaultApplicationId);\n    }\n}\n//# sourceMappingURL=pocket-provider.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3Byb3ZpZGVycy9saWIuZXNtL3BvY2tldC1wcm92aWRlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQWE7QUFDa0M7QUFDVjtBQUNyQyxtQkFBbUIseURBQU0sQ0FBQyw2Q0FBTztBQUM0QjtBQUM3RDtBQUNPLDZCQUE2QixzRUFBa0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCx5REFBTTtBQUMvRDtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsZ0NBQWdDLEtBQUssU0FBUyxxQkFBcUI7QUFDbkUsNkJBQTZCLFdBQVc7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xlZGdpdHkteWllbGQtZnJvbnRlbmQvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3Byb3ZpZGVycy9saWIuZXNtL3BvY2tldC1wcm92aWRlci5qcz8yMWRkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2xvZ2dlclwiO1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gXCIuL192ZXJzaW9uXCI7XG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyKHZlcnNpb24pO1xuaW1wb3J0IHsgVXJsSnNvblJwY1Byb3ZpZGVyIH0gZnJvbSBcIi4vdXJsLWpzb24tcnBjLXByb3ZpZGVyXCI7XG5jb25zdCBkZWZhdWx0QXBwbGljYXRpb25JZCA9IFwiNjJlMWFkNTFiMzdiOGUwMDM5NGJkYTNiXCI7XG5leHBvcnQgY2xhc3MgUG9ja2V0UHJvdmlkZXIgZXh0ZW5kcyBVcmxKc29uUnBjUHJvdmlkZXIge1xuICAgIHN0YXRpYyBnZXRBcGlLZXkoYXBpS2V5KSB7XG4gICAgICAgIGNvbnN0IGFwaUtleU9iaiA9IHtcbiAgICAgICAgICAgIGFwcGxpY2F0aW9uSWQ6IG51bGwsXG4gICAgICAgICAgICBsb2FkQmFsYW5jZXI6IHRydWUsXG4gICAgICAgICAgICBhcHBsaWNhdGlvblNlY3JldEtleTogbnVsbFxuICAgICAgICB9O1xuICAgICAgICAvLyBQYXJzZSBhcHBsaWNhdGlvbklkIGFuZCBhcHBsaWNhdGlvblNlY3JldEtleVxuICAgICAgICBpZiAoYXBpS2V5ID09IG51bGwpIHtcbiAgICAgICAgICAgIGFwaUtleU9iai5hcHBsaWNhdGlvbklkID0gZGVmYXVsdEFwcGxpY2F0aW9uSWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIChhcGlLZXkpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBhcGlLZXlPYmouYXBwbGljYXRpb25JZCA9IGFwaUtleTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhcGlLZXkuYXBwbGljYXRpb25TZWNyZXRLZXkgIT0gbnVsbCkge1xuICAgICAgICAgICAgYXBpS2V5T2JqLmFwcGxpY2F0aW9uSWQgPSBhcGlLZXkuYXBwbGljYXRpb25JZDtcbiAgICAgICAgICAgIGFwaUtleU9iai5hcHBsaWNhdGlvblNlY3JldEtleSA9IGFwaUtleS5hcHBsaWNhdGlvblNlY3JldEtleTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhcGlLZXkuYXBwbGljYXRpb25JZCkge1xuICAgICAgICAgICAgYXBpS2V5T2JqLmFwcGxpY2F0aW9uSWQgPSBhcGlLZXkuYXBwbGljYXRpb25JZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ1bnN1cHBvcnRlZCBQb2NrZXRQcm92aWRlciBhcGlLZXlcIiwgXCJhcGlLZXlcIiwgYXBpS2V5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXBpS2V5T2JqO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0VXJsKG5ldHdvcmssIGFwaUtleSkge1xuICAgICAgICBsZXQgaG9zdCA9IG51bGw7XG4gICAgICAgIHN3aXRjaCAobmV0d29yayA/IG5ldHdvcmsubmFtZSA6IFwidW5rbm93blwiKSB7XG4gICAgICAgICAgICBjYXNlIFwiZ29lcmxpXCI6XG4gICAgICAgICAgICAgICAgaG9zdCA9IFwiZXRoLWdvZXJsaS5nYXRld2F5LnBva3QubmV0d29ya1wiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImhvbWVzdGVhZFwiOlxuICAgICAgICAgICAgICAgIGhvc3QgPSBcImV0aC1tYWlubmV0LmdhdGV3YXkucG9rdC5uZXR3b3JrXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwia292YW5cIjpcbiAgICAgICAgICAgICAgICBob3N0ID0gXCJwb2Eta292YW4uZ2F0ZXdheS5wb2t0Lm5ldHdvcmtcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJtYXRpY1wiOlxuICAgICAgICAgICAgICAgIGhvc3QgPSBcInBvbHktbWFpbm5ldC5nYXRld2F5LnBva3QubmV0d29ya1wiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIm1hdGljbXVtXCI6XG4gICAgICAgICAgICAgICAgaG9zdCA9IFwicG9seWdvbi1tdW1iYWktcnBjLmdhdGV3YXkucG9rdC5uZXR3b3JrXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwicmlua2VieVwiOlxuICAgICAgICAgICAgICAgIGhvc3QgPSBcImV0aC1yaW5rZWJ5LmdhdGV3YXkucG9rdC5uZXR3b3JrXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwicm9wc3RlblwiOlxuICAgICAgICAgICAgICAgIGhvc3QgPSBcImV0aC1yb3BzdGVuLmdhdGV3YXkucG9rdC5uZXR3b3JrXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwidW5zdXBwb3J0ZWQgbmV0d29ya1wiLCBMb2dnZXIuZXJyb3JzLklOVkFMSURfQVJHVU1FTlQsIHtcbiAgICAgICAgICAgICAgICAgICAgYXJndW1lbnQ6IFwibmV0d29ya1wiLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbmV0d29ya1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVybCA9IGBodHRwczovXFwvJHtob3N0fS92MS9sYi8ke2FwaUtleS5hcHBsaWNhdGlvbklkfWA7XG4gICAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSB7IGhlYWRlcnM6IHt9LCB1cmwgfTtcbiAgICAgICAgaWYgKGFwaUtleS5hcHBsaWNhdGlvblNlY3JldEtleSAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25uZWN0aW9uLnVzZXIgPSBcIlwiO1xuICAgICAgICAgICAgY29ubmVjdGlvbi5wYXNzd29yZCA9IGFwaUtleS5hcHBsaWNhdGlvblNlY3JldEtleTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29ubmVjdGlvbjtcbiAgICB9XG4gICAgaXNDb21tdW5pdHlSZXNvdXJjZSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmFwcGxpY2F0aW9uSWQgPT09IGRlZmF1bHRBcHBsaWNhdGlvbklkKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wb2NrZXQtcHJvdmlkZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ethersproject/providers/lib.esm/pocket-provider.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@ethersproject/providers/lib.esm/url-json-rpc-provider.js":
/*!*********************************************************************************!*\
  !*** ../node_modules/@ethersproject/providers/lib.esm/url-json-rpc-provider.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StaticJsonRpcProvider: () => (/* binding */ StaticJsonRpcProvider),\n/* harmony export */   UrlJsonRpcProvider: () => (/* binding */ UrlJsonRpcProvider)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/../node_modules/@ethersproject/properties/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/../node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(ssr)/../node_modules/@ethersproject/providers/lib.esm/_version.js\");\n/* harmony import */ var _json_rpc_provider__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./json-rpc-provider */ \"(ssr)/../node_modules/@ethersproject/providers/lib.esm/json-rpc-provider.js\");\n\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\n\n// A StaticJsonRpcProvider is useful when you *know* for certain that\n// the backend will never change, as it never calls eth_chainId to\n// verify its backend. However, if the backend does change, the effects\n// are undefined and may include:\n// - inconsistent results\n// - locking up the UI\n// - block skew warnings\n// - wrong results\n// If the network is not explicit (i.e. auto-detection is expected), the\n// node MUST be running and available to respond to requests BEFORE this\n// is instantiated.\nclass StaticJsonRpcProvider extends _json_rpc_provider__WEBPACK_IMPORTED_MODULE_2__.JsonRpcProvider {\n    detectNetwork() {\n        const _super = Object.create(null, {\n            detectNetwork: { get: () => super.detectNetwork }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            let network = this.network;\n            if (network == null) {\n                network = yield _super.detectNetwork.call(this);\n                if (!network) {\n                    logger.throwError(\"no network detected\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNKNOWN_ERROR, {});\n                }\n                // If still not set, set it\n                if (this._network == null) {\n                    // A static network does not support \"any\"\n                    (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"_network\", network);\n                    this.emit(\"network\", network, null);\n                }\n            }\n            return network;\n        });\n    }\n}\nclass UrlJsonRpcProvider extends StaticJsonRpcProvider {\n    constructor(network, apiKey) {\n        logger.checkAbstract(new.target, UrlJsonRpcProvider);\n        // Normalize the Network and API Key\n        network = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.getStatic)(new.target, \"getNetwork\")(network);\n        apiKey = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.getStatic)(new.target, \"getApiKey\")(apiKey);\n        const connection = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.getStatic)(new.target, \"getUrl\")(network, apiKey);\n        super(connection, network);\n        if (typeof (apiKey) === \"string\") {\n            (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"apiKey\", apiKey);\n        }\n        else if (apiKey != null) {\n            Object.keys(apiKey).forEach((key) => {\n                (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, key, apiKey[key]);\n            });\n        }\n    }\n    _startPending() {\n        logger.warn(\"WARNING: API provider does not support pending filters\");\n    }\n    isCommunityResource() {\n        return false;\n    }\n    getSigner(address) {\n        return logger.throwError(\"API provider does not support signing\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, { operation: \"getSigner\" });\n    }\n    listAccounts() {\n        return Promise.resolve([]);\n    }\n    // Return a defaultApiKey if null, otherwise validate the API key\n    static getApiKey(apiKey) {\n        return apiKey;\n    }\n    // Returns the url or connection for the given network and API key. The\n    // API key will have been sanitized by the getApiKey first, so any validation\n    // or transformations can be done there.\n    static getUrl(network, apiKey) {\n        return logger.throwError(\"not implemented; sub-classes must override getUrl\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.NOT_IMPLEMENTED, {\n            operation: \"getUrl\"\n        });\n    }\n}\n//# sourceMappingURL=url-json-rpc-provider.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3Byb3ZpZGVycy9saWIuZXNtL3VybC1qc29uLXJwYy1wcm92aWRlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBYTtBQUNiLGlCQUFpQixTQUFJLElBQUksU0FBSTtBQUM3Qiw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNzRTtBQUN2QjtBQUNWO0FBQ3JDLG1CQUFtQix5REFBTSxDQUFDLDZDQUFPO0FBQ3FCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxvQ0FBb0MsK0RBQWU7QUFDMUQ7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCx5REFBTSx5QkFBeUI7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseUVBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG9FQUFTO0FBQzNCLGlCQUFpQixvRUFBUztBQUMxQiwyQkFBMkIsb0VBQVM7QUFDcEM7QUFDQTtBQUNBLFlBQVkseUVBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHlFQUFjO0FBQzlCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUseURBQU0saUNBQWlDLHdCQUF3QjtBQUN6STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsbUNBQW1DLHlEQUFNO0FBQzVGO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xlZGdpdHkteWllbGQtZnJvbnRlbmQvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3Byb3ZpZGVycy9saWIuZXNtL3VybC1qc29uLXJwYy1wcm92aWRlci5qcz9jMWEzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5pbXBvcnQgeyBkZWZpbmVSZWFkT25seSwgZ2V0U3RhdGljIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3Byb3BlcnRpZXNcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi9fdmVyc2lvblwiO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcih2ZXJzaW9uKTtcbmltcG9ydCB7IEpzb25ScGNQcm92aWRlciB9IGZyb20gXCIuL2pzb24tcnBjLXByb3ZpZGVyXCI7XG4vLyBBIFN0YXRpY0pzb25ScGNQcm92aWRlciBpcyB1c2VmdWwgd2hlbiB5b3UgKmtub3cqIGZvciBjZXJ0YWluIHRoYXRcbi8vIHRoZSBiYWNrZW5kIHdpbGwgbmV2ZXIgY2hhbmdlLCBhcyBpdCBuZXZlciBjYWxscyBldGhfY2hhaW5JZCB0b1xuLy8gdmVyaWZ5IGl0cyBiYWNrZW5kLiBIb3dldmVyLCBpZiB0aGUgYmFja2VuZCBkb2VzIGNoYW5nZSwgdGhlIGVmZmVjdHNcbi8vIGFyZSB1bmRlZmluZWQgYW5kIG1heSBpbmNsdWRlOlxuLy8gLSBpbmNvbnNpc3RlbnQgcmVzdWx0c1xuLy8gLSBsb2NraW5nIHVwIHRoZSBVSVxuLy8gLSBibG9jayBza2V3IHdhcm5pbmdzXG4vLyAtIHdyb25nIHJlc3VsdHNcbi8vIElmIHRoZSBuZXR3b3JrIGlzIG5vdCBleHBsaWNpdCAoaS5lLiBhdXRvLWRldGVjdGlvbiBpcyBleHBlY3RlZCksIHRoZVxuLy8gbm9kZSBNVVNUIGJlIHJ1bm5pbmcgYW5kIGF2YWlsYWJsZSB0byByZXNwb25kIHRvIHJlcXVlc3RzIEJFRk9SRSB0aGlzXG4vLyBpcyBpbnN0YW50aWF0ZWQuXG5leHBvcnQgY2xhc3MgU3RhdGljSnNvblJwY1Byb3ZpZGVyIGV4dGVuZHMgSnNvblJwY1Byb3ZpZGVyIHtcbiAgICBkZXRlY3ROZXR3b3JrKCkge1xuICAgICAgICBjb25zdCBfc3VwZXIgPSBPYmplY3QuY3JlYXRlKG51bGwsIHtcbiAgICAgICAgICAgIGRldGVjdE5ldHdvcms6IHsgZ2V0OiAoKSA9PiBzdXBlci5kZXRlY3ROZXR3b3JrIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBsZXQgbmV0d29yayA9IHRoaXMubmV0d29yaztcbiAgICAgICAgICAgIGlmIChuZXR3b3JrID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBuZXR3b3JrID0geWllbGQgX3N1cGVyLmRldGVjdE5ldHdvcmsuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgICBpZiAoIW5ldHdvcmspIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJubyBuZXR3b3JrIGRldGVjdGVkXCIsIExvZ2dlci5lcnJvcnMuVU5LTk9XTl9FUlJPUiwge30pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJZiBzdGlsbCBub3Qgc2V0LCBzZXQgaXRcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fbmV0d29yayA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEEgc3RhdGljIG5ldHdvcmsgZG9lcyBub3Qgc3VwcG9ydCBcImFueVwiXG4gICAgICAgICAgICAgICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiX25ldHdvcmtcIiwgbmV0d29yayk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcIm5ldHdvcmtcIiwgbmV0d29yaywgbnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldHdvcms7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBVcmxKc29uUnBjUHJvdmlkZXIgZXh0ZW5kcyBTdGF0aWNKc29uUnBjUHJvdmlkZXIge1xuICAgIGNvbnN0cnVjdG9yKG5ldHdvcmssIGFwaUtleSkge1xuICAgICAgICBsb2dnZXIuY2hlY2tBYnN0cmFjdChuZXcudGFyZ2V0LCBVcmxKc29uUnBjUHJvdmlkZXIpO1xuICAgICAgICAvLyBOb3JtYWxpemUgdGhlIE5ldHdvcmsgYW5kIEFQSSBLZXlcbiAgICAgICAgbmV0d29yayA9IGdldFN0YXRpYyhuZXcudGFyZ2V0LCBcImdldE5ldHdvcmtcIikobmV0d29yayk7XG4gICAgICAgIGFwaUtleSA9IGdldFN0YXRpYyhuZXcudGFyZ2V0LCBcImdldEFwaUtleVwiKShhcGlLZXkpO1xuICAgICAgICBjb25zdCBjb25uZWN0aW9uID0gZ2V0U3RhdGljKG5ldy50YXJnZXQsIFwiZ2V0VXJsXCIpKG5ldHdvcmssIGFwaUtleSk7XG4gICAgICAgIHN1cGVyKGNvbm5lY3Rpb24sIG5ldHdvcmspO1xuICAgICAgICBpZiAodHlwZW9mIChhcGlLZXkpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcImFwaUtleVwiLCBhcGlLZXkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFwaUtleSAhPSBudWxsKSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhhcGlLZXkpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIGtleSwgYXBpS2V5W2tleV0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3N0YXJ0UGVuZGluZygpIHtcbiAgICAgICAgbG9nZ2VyLndhcm4oXCJXQVJOSU5HOiBBUEkgcHJvdmlkZXIgZG9lcyBub3Qgc3VwcG9ydCBwZW5kaW5nIGZpbHRlcnNcIik7XG4gICAgfVxuICAgIGlzQ29tbXVuaXR5UmVzb3VyY2UoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZ2V0U2lnbmVyKGFkZHJlc3MpIHtcbiAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0Vycm9yKFwiQVBJIHByb3ZpZGVyIGRvZXMgbm90IHN1cHBvcnQgc2lnbmluZ1wiLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwgeyBvcGVyYXRpb246IFwiZ2V0U2lnbmVyXCIgfSk7XG4gICAgfVxuICAgIGxpc3RBY2NvdW50cygpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShbXSk7XG4gICAgfVxuICAgIC8vIFJldHVybiBhIGRlZmF1bHRBcGlLZXkgaWYgbnVsbCwgb3RoZXJ3aXNlIHZhbGlkYXRlIHRoZSBBUEkga2V5XG4gICAgc3RhdGljIGdldEFwaUtleShhcGlLZXkpIHtcbiAgICAgICAgcmV0dXJuIGFwaUtleTtcbiAgICB9XG4gICAgLy8gUmV0dXJucyB0aGUgdXJsIG9yIGNvbm5lY3Rpb24gZm9yIHRoZSBnaXZlbiBuZXR3b3JrIGFuZCBBUEkga2V5LiBUaGVcbiAgICAvLyBBUEkga2V5IHdpbGwgaGF2ZSBiZWVuIHNhbml0aXplZCBieSB0aGUgZ2V0QXBpS2V5IGZpcnN0LCBzbyBhbnkgdmFsaWRhdGlvblxuICAgIC8vIG9yIHRyYW5zZm9ybWF0aW9ucyBjYW4gYmUgZG9uZSB0aGVyZS5cbiAgICBzdGF0aWMgZ2V0VXJsKG5ldHdvcmssIGFwaUtleSkge1xuICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93RXJyb3IoXCJub3QgaW1wbGVtZW50ZWQ7IHN1Yi1jbGFzc2VzIG11c3Qgb3ZlcnJpZGUgZ2V0VXJsXCIsIExvZ2dlci5lcnJvcnMuTk9UX0lNUExFTUVOVEVELCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwiZ2V0VXJsXCJcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXJsLWpzb24tcnBjLXByb3ZpZGVyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ethersproject/providers/lib.esm/url-json-rpc-provider.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@ethersproject/providers/lib.esm/web3-provider.js":
/*!*************************************************************************!*\
  !*** ../node_modules/@ethersproject/providers/lib.esm/web3-provider.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Web3Provider: () => (/* binding */ Web3Provider)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/../node_modules/@ethersproject/properties/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/../node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(ssr)/../node_modules/@ethersproject/providers/lib.esm/_version.js\");\n/* harmony import */ var _json_rpc_provider__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./json-rpc-provider */ \"(ssr)/../node_modules/@ethersproject/providers/lib.esm/json-rpc-provider.js\");\n\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\n\nlet _nextId = 1;\nfunction buildWeb3LegacyFetcher(provider, sendFunc) {\n    const fetcher = \"Web3LegacyFetcher\";\n    return function (method, params) {\n        const request = {\n            method: method,\n            params: params,\n            id: (_nextId++),\n            jsonrpc: \"2.0\"\n        };\n        return new Promise((resolve, reject) => {\n            this.emit(\"debug\", {\n                action: \"request\",\n                fetcher,\n                request: (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.deepCopy)(request),\n                provider: this\n            });\n            sendFunc(request, (error, response) => {\n                if (error) {\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        fetcher,\n                        error,\n                        request,\n                        provider: this\n                    });\n                    return reject(error);\n                }\n                this.emit(\"debug\", {\n                    action: \"response\",\n                    fetcher,\n                    request,\n                    response,\n                    provider: this\n                });\n                if (response.error) {\n                    const error = new Error(response.error.message);\n                    error.code = response.error.code;\n                    error.data = response.error.data;\n                    return reject(error);\n                }\n                resolve(response.result);\n            });\n        });\n    };\n}\nfunction buildEip1193Fetcher(provider) {\n    return function (method, params) {\n        if (params == null) {\n            params = [];\n        }\n        const request = { method, params };\n        this.emit(\"debug\", {\n            action: \"request\",\n            fetcher: \"Eip1193Fetcher\",\n            request: (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.deepCopy)(request),\n            provider: this\n        });\n        return provider.request(request).then((response) => {\n            this.emit(\"debug\", {\n                action: \"response\",\n                fetcher: \"Eip1193Fetcher\",\n                request,\n                response,\n                provider: this\n            });\n            return response;\n        }, (error) => {\n            this.emit(\"debug\", {\n                action: \"response\",\n                fetcher: \"Eip1193Fetcher\",\n                request,\n                error,\n                provider: this\n            });\n            throw error;\n        });\n    };\n}\nclass Web3Provider extends _json_rpc_provider__WEBPACK_IMPORTED_MODULE_3__.JsonRpcProvider {\n    constructor(provider, network) {\n        if (provider == null) {\n            logger.throwArgumentError(\"missing provider\", \"provider\", provider);\n        }\n        let path = null;\n        let jsonRpcFetchFunc = null;\n        let subprovider = null;\n        if (typeof (provider) === \"function\") {\n            path = \"unknown:\";\n            jsonRpcFetchFunc = provider;\n        }\n        else {\n            path = provider.host || provider.path || \"\";\n            if (!path && provider.isMetaMask) {\n                path = \"metamask\";\n            }\n            subprovider = provider;\n            if (provider.request) {\n                if (path === \"\") {\n                    path = \"eip-1193:\";\n                }\n                jsonRpcFetchFunc = buildEip1193Fetcher(provider);\n            }\n            else if (provider.sendAsync) {\n                jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.sendAsync.bind(provider));\n            }\n            else if (provider.send) {\n                jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.send.bind(provider));\n            }\n            else {\n                logger.throwArgumentError(\"unsupported provider\", \"provider\", provider);\n            }\n            if (!path) {\n                path = \"unknown:\";\n            }\n        }\n        super(path, network);\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.defineReadOnly)(this, \"jsonRpcFetchFunc\", jsonRpcFetchFunc);\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.defineReadOnly)(this, \"provider\", subprovider);\n    }\n    send(method, params) {\n        return this.jsonRpcFetchFunc(method, params);\n    }\n}\n//# sourceMappingURL=web3-provider.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3Byb3ZpZGVycy9saWIuZXNtL3dlYjMtcHJvdmlkZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBYTtBQUN3RDtBQUN0QjtBQUNWO0FBQ3JDLG1CQUFtQix5REFBTSxDQUFDLDZDQUFPO0FBQ3FCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsbUVBQVE7QUFDakM7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsbUVBQVE7QUFDN0I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDTywyQkFBMkIsK0RBQWU7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHlFQUFjO0FBQ3RCLFFBQVEseUVBQWM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGVkZ2l0eS15aWVsZC1mcm9udGVuZC8uLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvcHJvdmlkZXJzL2xpYi5lc20vd2ViMy1wcm92aWRlci5qcz8wNjNlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuaW1wb3J0IHsgZGVlcENvcHksIGRlZmluZVJlYWRPbmx5IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3Byb3BlcnRpZXNcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi9fdmVyc2lvblwiO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcih2ZXJzaW9uKTtcbmltcG9ydCB7IEpzb25ScGNQcm92aWRlciB9IGZyb20gXCIuL2pzb24tcnBjLXByb3ZpZGVyXCI7XG5sZXQgX25leHRJZCA9IDE7XG5mdW5jdGlvbiBidWlsZFdlYjNMZWdhY3lGZXRjaGVyKHByb3ZpZGVyLCBzZW5kRnVuYykge1xuICAgIGNvbnN0IGZldGNoZXIgPSBcIldlYjNMZWdhY3lGZXRjaGVyXCI7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtZXRob2QsIHBhcmFtcykge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0ge1xuICAgICAgICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICAgICAgICBwYXJhbXM6IHBhcmFtcyxcbiAgICAgICAgICAgIGlkOiAoX25leHRJZCsrKSxcbiAgICAgICAgICAgIGpzb25ycGM6IFwiMi4wXCJcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHtcbiAgICAgICAgICAgICAgICBhY3Rpb246IFwicmVxdWVzdFwiLFxuICAgICAgICAgICAgICAgIGZldGNoZXIsXG4gICAgICAgICAgICAgICAgcmVxdWVzdDogZGVlcENvcHkocmVxdWVzdCksXG4gICAgICAgICAgICAgICAgcHJvdmlkZXI6IHRoaXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2VuZEZ1bmMocmVxdWVzdCwgKGVycm9yLCByZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwicmVzcG9uc2VcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGZldGNoZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlcjogdGhpc1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcInJlc3BvbnNlXCIsXG4gICAgICAgICAgICAgICAgICAgIGZldGNoZXIsXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgICBwcm92aWRlcjogdGhpc1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihyZXNwb25zZS5lcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IuY29kZSA9IHJlc3BvbnNlLmVycm9yLmNvZGU7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLmRhdGEgPSByZXNwb25zZS5lcnJvci5kYXRhO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZXNwb25zZS5yZXN1bHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG59XG5mdW5jdGlvbiBidWlsZEVpcDExOTNGZXRjaGVyKHByb3ZpZGVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtZXRob2QsIHBhcmFtcykge1xuICAgICAgICBpZiAocGFyYW1zID09IG51bGwpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB7IG1ldGhvZCwgcGFyYW1zIH07XG4gICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHtcbiAgICAgICAgICAgIGFjdGlvbjogXCJyZXF1ZXN0XCIsXG4gICAgICAgICAgICBmZXRjaGVyOiBcIkVpcDExOTNGZXRjaGVyXCIsXG4gICAgICAgICAgICByZXF1ZXN0OiBkZWVwQ29weShyZXF1ZXN0KSxcbiAgICAgICAgICAgIHByb3ZpZGVyOiB0aGlzXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcHJvdmlkZXIucmVxdWVzdChyZXF1ZXN0KS50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwge1xuICAgICAgICAgICAgICAgIGFjdGlvbjogXCJyZXNwb25zZVwiLFxuICAgICAgICAgICAgICAgIGZldGNoZXI6IFwiRWlwMTE5M0ZldGNoZXJcIixcbiAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyOiB0aGlzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgfSwgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7XG4gICAgICAgICAgICAgICAgYWN0aW9uOiBcInJlc3BvbnNlXCIsXG4gICAgICAgICAgICAgICAgZmV0Y2hlcjogXCJFaXAxMTkzRmV0Y2hlclwiLFxuICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICAgICAgcHJvdmlkZXI6IHRoaXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH0pO1xuICAgIH07XG59XG5leHBvcnQgY2xhc3MgV2ViM1Byb3ZpZGVyIGV4dGVuZHMgSnNvblJwY1Byb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihwcm92aWRlciwgbmV0d29yaykge1xuICAgICAgICBpZiAocHJvdmlkZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcIm1pc3NpbmcgcHJvdmlkZXJcIiwgXCJwcm92aWRlclwiLCBwcm92aWRlcik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBhdGggPSBudWxsO1xuICAgICAgICBsZXQganNvblJwY0ZldGNoRnVuYyA9IG51bGw7XG4gICAgICAgIGxldCBzdWJwcm92aWRlciA9IG51bGw7XG4gICAgICAgIGlmICh0eXBlb2YgKHByb3ZpZGVyKSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBwYXRoID0gXCJ1bmtub3duOlwiO1xuICAgICAgICAgICAganNvblJwY0ZldGNoRnVuYyA9IHByb3ZpZGVyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGF0aCA9IHByb3ZpZGVyLmhvc3QgfHwgcHJvdmlkZXIucGF0aCB8fCBcIlwiO1xuICAgICAgICAgICAgaWYgKCFwYXRoICYmIHByb3ZpZGVyLmlzTWV0YU1hc2spIHtcbiAgICAgICAgICAgICAgICBwYXRoID0gXCJtZXRhbWFza1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3VicHJvdmlkZXIgPSBwcm92aWRlcjtcbiAgICAgICAgICAgIGlmIChwcm92aWRlci5yZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhdGggPT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aCA9IFwiZWlwLTExOTM6XCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGpzb25ScGNGZXRjaEZ1bmMgPSBidWlsZEVpcDExOTNGZXRjaGVyKHByb3ZpZGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHByb3ZpZGVyLnNlbmRBc3luYykge1xuICAgICAgICAgICAgICAgIGpzb25ScGNGZXRjaEZ1bmMgPSBidWlsZFdlYjNMZWdhY3lGZXRjaGVyKHByb3ZpZGVyLCBwcm92aWRlci5zZW5kQXN5bmMuYmluZChwcm92aWRlcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocHJvdmlkZXIuc2VuZCkge1xuICAgICAgICAgICAgICAgIGpzb25ScGNGZXRjaEZ1bmMgPSBidWlsZFdlYjNMZWdhY3lGZXRjaGVyKHByb3ZpZGVyLCBwcm92aWRlci5zZW5kLmJpbmQocHJvdmlkZXIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ1bnN1cHBvcnRlZCBwcm92aWRlclwiLCBcInByb3ZpZGVyXCIsIHByb3ZpZGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcGF0aCkge1xuICAgICAgICAgICAgICAgIHBhdGggPSBcInVua25vd246XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIocGF0aCwgbmV0d29yayk7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwianNvblJwY0ZldGNoRnVuY1wiLCBqc29uUnBjRmV0Y2hGdW5jKTtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJwcm92aWRlclwiLCBzdWJwcm92aWRlcik7XG4gICAgfVxuICAgIHNlbmQobWV0aG9kLCBwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuanNvblJwY0ZldGNoRnVuYyhtZXRob2QsIHBhcmFtcyk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2ViMy1wcm92aWRlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ethersproject/providers/lib.esm/web3-provider.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@ethersproject/providers/lib.esm/websocket-provider.js":
/*!******************************************************************************!*\
  !*** ../node_modules/@ethersproject/providers/lib.esm/websocket-provider.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WebSocketProvider: () => (/* binding */ WebSocketProvider)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ethersproject/bignumber */ \"(ssr)/../node_modules/@ethersproject/bignumber/lib.esm/bignumber.js\");\n/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/../node_modules/@ethersproject/properties/lib.esm/index.js\");\n/* harmony import */ var _json_rpc_provider__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./json-rpc-provider */ \"(ssr)/../node_modules/@ethersproject/providers/lib.esm/json-rpc-provider.js\");\n/* harmony import */ var _ws__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ws */ \"(ssr)/../node_modules/@ethersproject/providers/lib.esm/ws.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/../node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(ssr)/../node_modules/@ethersproject/providers/lib.esm/_version.js\");\n\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\n/**\n *  Notes:\n *\n *  This provider differs a bit from the polling providers. One main\n *  difference is how it handles consistency. The polling providers\n *  will stall responses to ensure a consistent state, while this\n *  WebSocket provider assumes the connected backend will manage this.\n *\n *  For example, if a polling provider emits an event which indicates\n *  the event occurred in blockhash XXX, a call to fetch that block by\n *  its hash XXX, if not present will retry until it is present. This\n *  can occur when querying a pool of nodes that are mildly out of sync\n *  with each other.\n */\nlet NextId = 1;\n// For more info about the Real-time Event API see:\n//   https://geth.ethereum.org/docs/rpc/pubsub\nclass WebSocketProvider extends _json_rpc_provider__WEBPACK_IMPORTED_MODULE_2__.JsonRpcProvider {\n    constructor(url, network) {\n        // This will be added in the future; please open an issue to expedite\n        if (network === \"any\") {\n            logger.throwError(\"WebSocketProvider does not support 'any' network yet\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"network:any\"\n            });\n        }\n        if (typeof (url) === \"string\") {\n            super(url, network);\n        }\n        else {\n            super(\"_websocket\", network);\n        }\n        this._pollingInterval = -1;\n        this._wsReady = false;\n        if (typeof (url) === \"string\") {\n            (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"_websocket\", new _ws__WEBPACK_IMPORTED_MODULE_4__.WebSocket(this.connection.url));\n        }\n        else {\n            (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"_websocket\", url);\n        }\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"_requests\", {});\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"_subs\", {});\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"_subIds\", {});\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"_detectNetwork\", super.detectNetwork());\n        // Stall sending requests until the socket is open...\n        this.websocket.onopen = () => {\n            this._wsReady = true;\n            Object.keys(this._requests).forEach((id) => {\n                this.websocket.send(this._requests[id].payload);\n            });\n        };\n        this.websocket.onmessage = (messageEvent) => {\n            const data = messageEvent.data;\n            const result = JSON.parse(data);\n            if (result.id != null) {\n                const id = String(result.id);\n                const request = this._requests[id];\n                delete this._requests[id];\n                if (result.result !== undefined) {\n                    request.callback(null, result.result);\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        request: JSON.parse(request.payload),\n                        response: result.result,\n                        provider: this\n                    });\n                }\n                else {\n                    let error = null;\n                    if (result.error) {\n                        error = new Error(result.error.message || \"unknown error\");\n                        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(error, \"code\", result.error.code || null);\n                        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(error, \"response\", data);\n                    }\n                    else {\n                        error = new Error(\"unknown error\");\n                    }\n                    request.callback(error, undefined);\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        error: error,\n                        request: JSON.parse(request.payload),\n                        provider: this\n                    });\n                }\n            }\n            else if (result.method === \"eth_subscription\") {\n                // Subscription...\n                const sub = this._subs[result.params.subscription];\n                if (sub) {\n                    //this.emit.apply(this,                  );\n                    sub.processFunc(result.params.result);\n                }\n            }\n            else {\n                console.warn(\"this should not happen\");\n            }\n        };\n        // This Provider does not actually poll, but we want to trigger\n        // poll events for things that depend on them (like stalling for\n        // block and transaction lookups)\n        const fauxPoll = setInterval(() => {\n            this.emit(\"poll\");\n        }, 1000);\n        if (fauxPoll.unref) {\n            fauxPoll.unref();\n        }\n    }\n    // Cannot narrow the type of _websocket, as that is not backwards compatible\n    // so we add a getter and let the WebSocket be a public API.\n    get websocket() { return this._websocket; }\n    detectNetwork() {\n        return this._detectNetwork;\n    }\n    get pollingInterval() {\n        return 0;\n    }\n    resetEventsBlock(blockNumber) {\n        logger.throwError(\"cannot reset events block on WebSocketProvider\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"resetEventBlock\"\n        });\n    }\n    set pollingInterval(value) {\n        logger.throwError(\"cannot set polling interval on WebSocketProvider\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"setPollingInterval\"\n        });\n    }\n    poll() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return null;\n        });\n    }\n    set polling(value) {\n        if (!value) {\n            return;\n        }\n        logger.throwError(\"cannot set polling on WebSocketProvider\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"setPolling\"\n        });\n    }\n    send(method, params) {\n        const rid = NextId++;\n        return new Promise((resolve, reject) => {\n            function callback(error, result) {\n                if (error) {\n                    return reject(error);\n                }\n                return resolve(result);\n            }\n            const payload = JSON.stringify({\n                method: method,\n                params: params,\n                id: rid,\n                jsonrpc: \"2.0\"\n            });\n            this.emit(\"debug\", {\n                action: \"request\",\n                request: JSON.parse(payload),\n                provider: this\n            });\n            this._requests[String(rid)] = { callback, payload };\n            if (this._wsReady) {\n                this.websocket.send(payload);\n            }\n        });\n    }\n    static defaultUrl() {\n        return \"ws:/\\/localhost:8546\";\n    }\n    _subscribe(tag, param, processFunc) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let subIdPromise = this._subIds[tag];\n            if (subIdPromise == null) {\n                subIdPromise = Promise.all(param).then((param) => {\n                    return this.send(\"eth_subscribe\", param);\n                });\n                this._subIds[tag] = subIdPromise;\n            }\n            const subId = yield subIdPromise;\n            this._subs[subId] = { tag, processFunc };\n        });\n    }\n    _startEvent(event) {\n        switch (event.type) {\n            case \"block\":\n                this._subscribe(\"block\", [\"newHeads\"], (result) => {\n                    const blockNumber = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_5__.BigNumber.from(result.number).toNumber();\n                    this._emitted.block = blockNumber;\n                    this.emit(\"block\", blockNumber);\n                });\n                break;\n            case \"pending\":\n                this._subscribe(\"pending\", [\"newPendingTransactions\"], (result) => {\n                    this.emit(\"pending\", result);\n                });\n                break;\n            case \"filter\":\n                this._subscribe(event.tag, [\"logs\", this._getFilter(event.filter)], (result) => {\n                    if (result.removed == null) {\n                        result.removed = false;\n                    }\n                    this.emit(event.filter, this.formatter.filterLog(result));\n                });\n                break;\n            case \"tx\": {\n                const emitReceipt = (event) => {\n                    const hash = event.hash;\n                    this.getTransactionReceipt(hash).then((receipt) => {\n                        if (!receipt) {\n                            return;\n                        }\n                        this.emit(hash, receipt);\n                    });\n                };\n                // In case it is already mined\n                emitReceipt(event);\n                // To keep things simple, we start up a single newHeads subscription\n                // to keep an eye out for transactions we are watching for.\n                // Starting a subscription for an event (i.e. \"tx\") that is already\n                // running is (basically) a nop.\n                this._subscribe(\"tx\", [\"newHeads\"], (result) => {\n                    this._events.filter((e) => (e.type === \"tx\")).forEach(emitReceipt);\n                });\n                break;\n            }\n            // Nothing is needed\n            case \"debug\":\n            case \"poll\":\n            case \"willPoll\":\n            case \"didPoll\":\n            case \"error\":\n                break;\n            default:\n                console.log(\"unhandled:\", event);\n                break;\n        }\n    }\n    _stopEvent(event) {\n        let tag = event.tag;\n        if (event.type === \"tx\") {\n            // There are remaining transaction event listeners\n            if (this._events.filter((e) => (e.type === \"tx\")).length) {\n                return;\n            }\n            tag = \"tx\";\n        }\n        else if (this.listenerCount(event.event)) {\n            // There are remaining event listeners\n            return;\n        }\n        const subId = this._subIds[tag];\n        if (!subId) {\n            return;\n        }\n        delete this._subIds[tag];\n        subId.then((subId) => {\n            if (!this._subs[subId]) {\n                return;\n            }\n            delete this._subs[subId];\n            this.send(\"eth_unsubscribe\", [subId]);\n        });\n    }\n    destroy() {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Wait until we have connected before trying to disconnect\n            if (this.websocket.readyState === _ws__WEBPACK_IMPORTED_MODULE_4__.WebSocket.CONNECTING) {\n                yield (new Promise((resolve) => {\n                    this.websocket.onopen = function () {\n                        resolve(true);\n                    };\n                    this.websocket.onerror = function () {\n                        resolve(false);\n                    };\n                }));\n            }\n            // Hangup\n            // See: https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes\n            this.websocket.close(1000);\n        });\n    }\n}\n//# sourceMappingURL=websocket-provider.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3Byb3ZpZGVycy9saWIuZXNtL3dlYnNvY2tldC1wcm92aWRlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQWE7QUFDYixpQkFBaUIsU0FBSSxJQUFJLFNBQUk7QUFDN0IsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDcUQ7QUFDTTtBQUNMO0FBQ3JCO0FBQ2M7QUFDVjtBQUNyQyxtQkFBbUIseURBQU0sQ0FBQyw2Q0FBTztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sZ0NBQWdDLCtEQUFlO0FBQ3REO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0Esc0ZBQXNGLHlEQUFNO0FBQzVGO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx5RUFBYyx5QkFBeUIsMENBQVM7QUFDNUQ7QUFDQTtBQUNBLFlBQVkseUVBQWM7QUFDMUI7QUFDQSxRQUFRLHlFQUFjLHNCQUFzQjtBQUM1QyxRQUFRLHlFQUFjLGtCQUFrQjtBQUN4QyxRQUFRLHlFQUFjLG9CQUFvQjtBQUMxQyxRQUFRLHlFQUFjO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IseUVBQWM7QUFDdEMsd0JBQXdCLHlFQUFjO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSx5REFBTTtBQUNsRjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsOEVBQThFLHlEQUFNO0FBQ3BGO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUseURBQU07QUFDM0U7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLCtEQUFTO0FBQ2pEO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLDBDQUFTO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xlZGdpdHkteWllbGQtZnJvbnRlbmQvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3Byb3ZpZGVycy9saWIuZXNtL3dlYnNvY2tldC1wcm92aWRlci5qcz8yMzQwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5pbXBvcnQgeyBCaWdOdW1iZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYmlnbnVtYmVyXCI7XG5pbXBvcnQgeyBkZWZpbmVSZWFkT25seSB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9wcm9wZXJ0aWVzXCI7XG5pbXBvcnQgeyBKc29uUnBjUHJvdmlkZXIgfSBmcm9tIFwiLi9qc29uLXJwYy1wcm92aWRlclwiO1xuaW1wb3J0IHsgV2ViU29ja2V0IH0gZnJvbSBcIi4vd3NcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi9fdmVyc2lvblwiO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcih2ZXJzaW9uKTtcbi8qKlxuICogIE5vdGVzOlxuICpcbiAqICBUaGlzIHByb3ZpZGVyIGRpZmZlcnMgYSBiaXQgZnJvbSB0aGUgcG9sbGluZyBwcm92aWRlcnMuIE9uZSBtYWluXG4gKiAgZGlmZmVyZW5jZSBpcyBob3cgaXQgaGFuZGxlcyBjb25zaXN0ZW5jeS4gVGhlIHBvbGxpbmcgcHJvdmlkZXJzXG4gKiAgd2lsbCBzdGFsbCByZXNwb25zZXMgdG8gZW5zdXJlIGEgY29uc2lzdGVudCBzdGF0ZSwgd2hpbGUgdGhpc1xuICogIFdlYlNvY2tldCBwcm92aWRlciBhc3N1bWVzIHRoZSBjb25uZWN0ZWQgYmFja2VuZCB3aWxsIG1hbmFnZSB0aGlzLlxuICpcbiAqICBGb3IgZXhhbXBsZSwgaWYgYSBwb2xsaW5nIHByb3ZpZGVyIGVtaXRzIGFuIGV2ZW50IHdoaWNoIGluZGljYXRlc1xuICogIHRoZSBldmVudCBvY2N1cnJlZCBpbiBibG9ja2hhc2ggWFhYLCBhIGNhbGwgdG8gZmV0Y2ggdGhhdCBibG9jayBieVxuICogIGl0cyBoYXNoIFhYWCwgaWYgbm90IHByZXNlbnQgd2lsbCByZXRyeSB1bnRpbCBpdCBpcyBwcmVzZW50LiBUaGlzXG4gKiAgY2FuIG9jY3VyIHdoZW4gcXVlcnlpbmcgYSBwb29sIG9mIG5vZGVzIHRoYXQgYXJlIG1pbGRseSBvdXQgb2Ygc3luY1xuICogIHdpdGggZWFjaCBvdGhlci5cbiAqL1xubGV0IE5leHRJZCA9IDE7XG4vLyBGb3IgbW9yZSBpbmZvIGFib3V0IHRoZSBSZWFsLXRpbWUgRXZlbnQgQVBJIHNlZTpcbi8vICAgaHR0cHM6Ly9nZXRoLmV0aGVyZXVtLm9yZy9kb2NzL3JwYy9wdWJzdWJcbmV4cG9ydCBjbGFzcyBXZWJTb2NrZXRQcm92aWRlciBleHRlbmRzIEpzb25ScGNQcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IodXJsLCBuZXR3b3JrKSB7XG4gICAgICAgIC8vIFRoaXMgd2lsbCBiZSBhZGRlZCBpbiB0aGUgZnV0dXJlOyBwbGVhc2Ugb3BlbiBhbiBpc3N1ZSB0byBleHBlZGl0ZVxuICAgICAgICBpZiAobmV0d29yayA9PT0gXCJhbnlcIikge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJXZWJTb2NrZXRQcm92aWRlciBkb2VzIG5vdCBzdXBwb3J0ICdhbnknIG5ldHdvcmsgeWV0XCIsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcIm5ldHdvcms6YW55XCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKHVybCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHN1cGVyKHVybCwgbmV0d29yayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdXBlcihcIl93ZWJzb2NrZXRcIiwgbmV0d29yayk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcG9sbGluZ0ludGVydmFsID0gLTE7XG4gICAgICAgIHRoaXMuX3dzUmVhZHkgPSBmYWxzZTtcbiAgICAgICAgaWYgKHR5cGVvZiAodXJsKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJfd2Vic29ja2V0XCIsIG5ldyBXZWJTb2NrZXQodGhpcy5jb25uZWN0aW9uLnVybCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJfd2Vic29ja2V0XCIsIHVybCk7XG4gICAgICAgIH1cbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJfcmVxdWVzdHNcIiwge30pO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcIl9zdWJzXCIsIHt9KTtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJfc3ViSWRzXCIsIHt9KTtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJfZGV0ZWN0TmV0d29ya1wiLCBzdXBlci5kZXRlY3ROZXR3b3JrKCkpO1xuICAgICAgICAvLyBTdGFsbCBzZW5kaW5nIHJlcXVlc3RzIHVudGlsIHRoZSBzb2NrZXQgaXMgb3Blbi4uLlxuICAgICAgICB0aGlzLndlYnNvY2tldC5vbm9wZW4gPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl93c1JlYWR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHRoaXMuX3JlcXVlc3RzKS5mb3JFYWNoKChpZCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMud2Vic29ja2V0LnNlbmQodGhpcy5fcmVxdWVzdHNbaWRdLnBheWxvYWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMud2Vic29ja2V0Lm9ubWVzc2FnZSA9IChtZXNzYWdlRXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBtZXNzYWdlRXZlbnQuZGF0YTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0LmlkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpZCA9IFN0cmluZyhyZXN1bHQuaWQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLl9yZXF1ZXN0c1tpZF07XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3JlcXVlc3RzW2lkXTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3QuY2FsbGJhY2sobnVsbCwgcmVzdWx0LnJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJyZXNwb25zZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdDogSlNPTi5wYXJzZShyZXF1ZXN0LnBheWxvYWQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2U6IHJlc3VsdC5yZXN1bHQsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlcjogdGhpc1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBlcnJvciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKHJlc3VsdC5lcnJvci5tZXNzYWdlIHx8IFwidW5rbm93biBlcnJvclwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmluZVJlYWRPbmx5KGVycm9yLCBcImNvZGVcIiwgcmVzdWx0LmVycm9yLmNvZGUgfHwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZpbmVSZWFkT25seShlcnJvciwgXCJyZXNwb25zZVwiLCBkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKFwidW5rbm93biBlcnJvclwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LmNhbGxiYWNrKGVycm9yLCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwicmVzcG9uc2VcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3Q6IEpTT04ucGFyc2UocmVxdWVzdC5wYXlsb2FkKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyOiB0aGlzXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJlc3VsdC5tZXRob2QgPT09IFwiZXRoX3N1YnNjcmlwdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgLy8gU3Vic2NyaXB0aW9uLi4uXG4gICAgICAgICAgICAgICAgY29uc3Qgc3ViID0gdGhpcy5fc3Vic1tyZXN1bHQucGFyYW1zLnN1YnNjcmlwdGlvbl07XG4gICAgICAgICAgICAgICAgaWYgKHN1Yikge1xuICAgICAgICAgICAgICAgICAgICAvL3RoaXMuZW1pdC5hcHBseSh0aGlzLCAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIHN1Yi5wcm9jZXNzRnVuYyhyZXN1bHQucGFyYW1zLnJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwidGhpcyBzaG91bGQgbm90IGhhcHBlblwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLy8gVGhpcyBQcm92aWRlciBkb2VzIG5vdCBhY3R1YWxseSBwb2xsLCBidXQgd2Ugd2FudCB0byB0cmlnZ2VyXG4gICAgICAgIC8vIHBvbGwgZXZlbnRzIGZvciB0aGluZ3MgdGhhdCBkZXBlbmQgb24gdGhlbSAobGlrZSBzdGFsbGluZyBmb3JcbiAgICAgICAgLy8gYmxvY2sgYW5kIHRyYW5zYWN0aW9uIGxvb2t1cHMpXG4gICAgICAgIGNvbnN0IGZhdXhQb2xsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwicG9sbFwiKTtcbiAgICAgICAgfSwgMTAwMCk7XG4gICAgICAgIGlmIChmYXV4UG9sbC51bnJlZikge1xuICAgICAgICAgICAgZmF1eFBvbGwudW5yZWYoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBDYW5ub3QgbmFycm93IHRoZSB0eXBlIG9mIF93ZWJzb2NrZXQsIGFzIHRoYXQgaXMgbm90IGJhY2t3YXJkcyBjb21wYXRpYmxlXG4gICAgLy8gc28gd2UgYWRkIGEgZ2V0dGVyIGFuZCBsZXQgdGhlIFdlYlNvY2tldCBiZSBhIHB1YmxpYyBBUEkuXG4gICAgZ2V0IHdlYnNvY2tldCgpIHsgcmV0dXJuIHRoaXMuX3dlYnNvY2tldDsgfVxuICAgIGRldGVjdE5ldHdvcmsoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZXRlY3ROZXR3b3JrO1xuICAgIH1cbiAgICBnZXQgcG9sbGluZ0ludGVydmFsKCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgcmVzZXRFdmVudHNCbG9jayhibG9ja051bWJlcikge1xuICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImNhbm5vdCByZXNldCBldmVudHMgYmxvY2sgb24gV2ViU29ja2V0UHJvdmlkZXJcIiwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJyZXNldEV2ZW50QmxvY2tcIlxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2V0IHBvbGxpbmdJbnRlcnZhbCh2YWx1ZSkge1xuICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImNhbm5vdCBzZXQgcG9sbGluZyBpbnRlcnZhbCBvbiBXZWJTb2NrZXRQcm92aWRlclwiLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcInNldFBvbGxpbmdJbnRlcnZhbFwiXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwb2xsKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzZXQgcG9sbGluZyh2YWx1ZSkge1xuICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJjYW5ub3Qgc2V0IHBvbGxpbmcgb24gV2ViU29ja2V0UHJvdmlkZXJcIiwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJzZXRQb2xsaW5nXCJcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNlbmQobWV0aG9kLCBwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgcmlkID0gTmV4dElkKys7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBmdW5jdGlvbiBjYWxsYmFjayhlcnJvciwgcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgICAgICAgICBwYXJhbXM6IHBhcmFtcyxcbiAgICAgICAgICAgICAgICBpZDogcmlkLFxuICAgICAgICAgICAgICAgIGpzb25ycGM6IFwiMi4wXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwge1xuICAgICAgICAgICAgICAgIGFjdGlvbjogXCJyZXF1ZXN0XCIsXG4gICAgICAgICAgICAgICAgcmVxdWVzdDogSlNPTi5wYXJzZShwYXlsb2FkKSxcbiAgICAgICAgICAgICAgICBwcm92aWRlcjogdGhpc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLl9yZXF1ZXN0c1tTdHJpbmcocmlkKV0gPSB7IGNhbGxiYWNrLCBwYXlsb2FkIH07XG4gICAgICAgICAgICBpZiAodGhpcy5fd3NSZWFkeSkge1xuICAgICAgICAgICAgICAgIHRoaXMud2Vic29ja2V0LnNlbmQocGF5bG9hZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgZGVmYXVsdFVybCgpIHtcbiAgICAgICAgcmV0dXJuIFwid3M6L1xcL2xvY2FsaG9zdDo4NTQ2XCI7XG4gICAgfVxuICAgIF9zdWJzY3JpYmUodGFnLCBwYXJhbSwgcHJvY2Vzc0Z1bmMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGxldCBzdWJJZFByb21pc2UgPSB0aGlzLl9zdWJJZHNbdGFnXTtcbiAgICAgICAgICAgIGlmIChzdWJJZFByb21pc2UgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHN1YklkUHJvbWlzZSA9IFByb21pc2UuYWxsKHBhcmFtKS50aGVuKChwYXJhbSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZW5kKFwiZXRoX3N1YnNjcmliZVwiLCBwYXJhbSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3ViSWRzW3RhZ10gPSBzdWJJZFByb21pc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzdWJJZCA9IHlpZWxkIHN1YklkUHJvbWlzZTtcbiAgICAgICAgICAgIHRoaXMuX3N1YnNbc3ViSWRdID0geyB0YWcsIHByb2Nlc3NGdW5jIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfc3RhcnRFdmVudChldmVudCkge1xuICAgICAgICBzd2l0Y2ggKGV2ZW50LnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJibG9ja1wiOlxuICAgICAgICAgICAgICAgIHRoaXMuX3N1YnNjcmliZShcImJsb2NrXCIsIFtcIm5ld0hlYWRzXCJdLCAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJsb2NrTnVtYmVyID0gQmlnTnVtYmVyLmZyb20ocmVzdWx0Lm51bWJlcikudG9OdW1iZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZW1pdHRlZC5ibG9jayA9IGJsb2NrTnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJibG9ja1wiLCBibG9ja051bWJlcik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwicGVuZGluZ1wiOlxuICAgICAgICAgICAgICAgIHRoaXMuX3N1YnNjcmliZShcInBlbmRpbmdcIiwgW1wibmV3UGVuZGluZ1RyYW5zYWN0aW9uc1wiXSwgKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJwZW5kaW5nXCIsIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZmlsdGVyXCI6XG4gICAgICAgICAgICAgICAgdGhpcy5fc3Vic2NyaWJlKGV2ZW50LnRhZywgW1wibG9nc1wiLCB0aGlzLl9nZXRGaWx0ZXIoZXZlbnQuZmlsdGVyKV0sIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5yZW1vdmVkID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5yZW1vdmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KGV2ZW50LmZpbHRlciwgdGhpcy5mb3JtYXR0ZXIuZmlsdGVyTG9nKHJlc3VsdCkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInR4XCI6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbWl0UmVjZWlwdCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBoYXNoID0gZXZlbnQuaGFzaDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRUcmFuc2FjdGlvblJlY2VpcHQoaGFzaCkudGhlbigocmVjZWlwdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyZWNlaXB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KGhhc2gsIHJlY2VpcHQpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8vIEluIGNhc2UgaXQgaXMgYWxyZWFkeSBtaW5lZFxuICAgICAgICAgICAgICAgIGVtaXRSZWNlaXB0KGV2ZW50KTtcbiAgICAgICAgICAgICAgICAvLyBUbyBrZWVwIHRoaW5ncyBzaW1wbGUsIHdlIHN0YXJ0IHVwIGEgc2luZ2xlIG5ld0hlYWRzIHN1YnNjcmlwdGlvblxuICAgICAgICAgICAgICAgIC8vIHRvIGtlZXAgYW4gZXllIG91dCBmb3IgdHJhbnNhY3Rpb25zIHdlIGFyZSB3YXRjaGluZyBmb3IuXG4gICAgICAgICAgICAgICAgLy8gU3RhcnRpbmcgYSBzdWJzY3JpcHRpb24gZm9yIGFuIGV2ZW50IChpLmUuIFwidHhcIikgdGhhdCBpcyBhbHJlYWR5XG4gICAgICAgICAgICAgICAgLy8gcnVubmluZyBpcyAoYmFzaWNhbGx5KSBhIG5vcC5cbiAgICAgICAgICAgICAgICB0aGlzLl9zdWJzY3JpYmUoXCJ0eFwiLCBbXCJuZXdIZWFkc1wiXSwgKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ldmVudHMuZmlsdGVyKChlKSA9PiAoZS50eXBlID09PSBcInR4XCIpKS5mb3JFYWNoKGVtaXRSZWNlaXB0KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5vdGhpbmcgaXMgbmVlZGVkXG4gICAgICAgICAgICBjYXNlIFwiZGVidWdcIjpcbiAgICAgICAgICAgIGNhc2UgXCJwb2xsXCI6XG4gICAgICAgICAgICBjYXNlIFwid2lsbFBvbGxcIjpcbiAgICAgICAgICAgIGNhc2UgXCJkaWRQb2xsXCI6XG4gICAgICAgICAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJ1bmhhbmRsZWQ6XCIsIGV2ZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBfc3RvcEV2ZW50KGV2ZW50KSB7XG4gICAgICAgIGxldCB0YWcgPSBldmVudC50YWc7XG4gICAgICAgIGlmIChldmVudC50eXBlID09PSBcInR4XCIpIHtcbiAgICAgICAgICAgIC8vIFRoZXJlIGFyZSByZW1haW5pbmcgdHJhbnNhY3Rpb24gZXZlbnQgbGlzdGVuZXJzXG4gICAgICAgICAgICBpZiAodGhpcy5fZXZlbnRzLmZpbHRlcigoZSkgPT4gKGUudHlwZSA9PT0gXCJ0eFwiKSkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFnID0gXCJ0eFwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMubGlzdGVuZXJDb3VudChldmVudC5ldmVudCkpIHtcbiAgICAgICAgICAgIC8vIFRoZXJlIGFyZSByZW1haW5pbmcgZXZlbnQgbGlzdGVuZXJzXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3ViSWQgPSB0aGlzLl9zdWJJZHNbdGFnXTtcbiAgICAgICAgaWYgKCFzdWJJZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9zdWJJZHNbdGFnXTtcbiAgICAgICAgc3ViSWQudGhlbigoc3ViSWQpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fc3Vic1tzdWJJZF0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fc3Vic1tzdWJJZF07XG4gICAgICAgICAgICB0aGlzLnNlbmQoXCJldGhfdW5zdWJzY3JpYmVcIiwgW3N1YklkXSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgLy8gV2FpdCB1bnRpbCB3ZSBoYXZlIGNvbm5lY3RlZCBiZWZvcmUgdHJ5aW5nIHRvIGRpc2Nvbm5lY3RcbiAgICAgICAgICAgIGlmICh0aGlzLndlYnNvY2tldC5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ09OTkVDVElORykge1xuICAgICAgICAgICAgICAgIHlpZWxkIChuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLndlYnNvY2tldC5vbm9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLndlYnNvY2tldC5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSGFuZ3VwXG4gICAgICAgICAgICAvLyBTZWU6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DbG9zZUV2ZW50I1N0YXR1c19jb2Rlc1xuICAgICAgICAgICAgdGhpcy53ZWJzb2NrZXQuY2xvc2UoMTAwMCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdlYnNvY2tldC1wcm92aWRlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ethersproject/providers/lib.esm/websocket-provider.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@ethersproject/providers/lib.esm/ws.js":
/*!**************************************************************!*\
  !*** ../node_modules/@ethersproject/providers/lib.esm/ws.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WebSocket: () => (/* binding */ WS)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/../node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(ssr)/../node_modules/@ethersproject/providers/lib.esm/_version.js\");\n\n\n\nlet WS = null;\ntry {\n    WS = WebSocket;\n    if (WS == null) {\n        throw new Error(\"inject please\");\n    }\n}\ncatch (error) {\n    const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\n    WS = function () {\n        logger.throwError(\"WebSockets not supported in this environment\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"new WebSocket()\"\n        });\n    };\n}\n//export default WS;\n//module.exports = WS;\n\n//# sourceMappingURL=ws.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3Byb3ZpZGVycy9saWIuZXNtL3dzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFhO0FBQ2tDO0FBQ1Y7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix5REFBTSxDQUFDLDZDQUFPO0FBQ3JDO0FBQ0EsMEVBQTBFLHlEQUFNO0FBQ2hGO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQzJCO0FBQzNCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGVkZ2l0eS15aWVsZC1mcm9udGVuZC8uLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvcHJvdmlkZXJzL2xpYi5lc20vd3MuanM/ZWM1MiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi9fdmVyc2lvblwiO1xubGV0IFdTID0gbnVsbDtcbnRyeSB7XG4gICAgV1MgPSBXZWJTb2NrZXQ7XG4gICAgaWYgKFdTID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW5qZWN0IHBsZWFzZVwiKTtcbiAgICB9XG59XG5jYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyKHZlcnNpb24pO1xuICAgIFdTID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcIldlYlNvY2tldHMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGVudmlyb25tZW50XCIsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwibmV3IFdlYlNvY2tldCgpXCJcbiAgICAgICAgfSk7XG4gICAgfTtcbn1cbi8vZXhwb3J0IGRlZmF1bHQgV1M7XG4vL21vZHVsZS5leHBvcnRzID0gV1M7XG5leHBvcnQgeyBXUyBhcyBXZWJTb2NrZXQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ethersproject/providers/lib.esm/ws.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@ethersproject/random/lib.esm/shuffle.js":
/*!****************************************************************!*\
  !*** ../node_modules/@ethersproject/random/lib.esm/shuffle.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   shuffled: () => (/* binding */ shuffled)\n/* harmony export */ });\n\nfunction shuffled(array) {\n    array = array.slice();\n    for (let i = array.length - 1; i > 0; i--) {\n        const j = Math.floor(Math.random() * (i + 1));\n        const tmp = array[i];\n        array[i] = array[j];\n        array[j] = tmp;\n    }\n    return array;\n}\n//# sourceMappingURL=shuffle.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3JhbmRvbS9saWIuZXNtL3NodWZmbGUuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFhO0FBQ047QUFDUDtBQUNBLG1DQUFtQyxPQUFPO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sZWRnaXR5LXlpZWxkLWZyb250ZW5kLy4uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9yYW5kb20vbGliLmVzbS9zaHVmZmxlLmpzPzFkNTYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnQgZnVuY3Rpb24gc2h1ZmZsZWQoYXJyYXkpIHtcbiAgICBhcnJheSA9IGFycmF5LnNsaWNlKCk7XG4gICAgZm9yIChsZXQgaSA9IGFycmF5Lmxlbmd0aCAtIDE7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgY29uc3QgaiA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChpICsgMSkpO1xuICAgICAgICBjb25zdCB0bXAgPSBhcnJheVtpXTtcbiAgICAgICAgYXJyYXlbaV0gPSBhcnJheVtqXTtcbiAgICAgICAgYXJyYXlbal0gPSB0bXA7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNodWZmbGUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ethersproject/random/lib.esm/shuffle.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@ethersproject/rlp/lib.esm/_version.js":
/*!**************************************************************!*\
  !*** ../node_modules/@ethersproject/rlp/lib.esm/_version.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\nconst version = \"rlp/5.7.0\";\n//# sourceMappingURL=_version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3JscC9saWIuZXNtL192ZXJzaW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBTztBQUNQIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGVkZ2l0eS15aWVsZC1mcm9udGVuZC8uLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvcmxwL2xpYi5lc20vX3ZlcnNpb24uanM/OTAzZCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgdmVyc2lvbiA9IFwicmxwLzUuNy4wXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdmVyc2lvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ethersproject/rlp/lib.esm/_version.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@ethersproject/rlp/lib.esm/index.js":
/*!***********************************************************!*\
  !*** ../node_modules/@ethersproject/rlp/lib.esm/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decode: () => (/* binding */ decode),\n/* harmony export */   encode: () => (/* binding */ encode)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/../node_modules/@ethersproject/bytes/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/../node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(ssr)/../node_modules/@ethersproject/rlp/lib.esm/_version.js\");\n\n//See: https://github.com/ethereum/wiki/wiki/RLP\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\nfunction arrayifyInteger(value) {\n    const result = [];\n    while (value) {\n        result.unshift(value & 0xff);\n        value >>= 8;\n    }\n    return result;\n}\nfunction unarrayifyInteger(data, offset, length) {\n    let result = 0;\n    for (let i = 0; i < length; i++) {\n        result = (result * 256) + data[offset + i];\n    }\n    return result;\n}\nfunction _encode(object) {\n    if (Array.isArray(object)) {\n        let payload = [];\n        object.forEach(function (child) {\n            payload = payload.concat(_encode(child));\n        });\n        if (payload.length <= 55) {\n            payload.unshift(0xc0 + payload.length);\n            return payload;\n        }\n        const length = arrayifyInteger(payload.length);\n        length.unshift(0xf7 + length.length);\n        return length.concat(payload);\n    }\n    if (!(0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.isBytesLike)(object)) {\n        logger.throwArgumentError(\"RLP object must be BytesLike\", \"object\", object);\n    }\n    const data = Array.prototype.slice.call((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.arrayify)(object));\n    if (data.length === 1 && data[0] <= 0x7f) {\n        return data;\n    }\n    else if (data.length <= 55) {\n        data.unshift(0x80 + data.length);\n        return data;\n    }\n    const length = arrayifyInteger(data.length);\n    length.unshift(0xb7 + length.length);\n    return length.concat(data);\n}\nfunction encode(object) {\n    return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.hexlify)(_encode(object));\n}\nfunction _decodeChildren(data, offset, childOffset, length) {\n    const result = [];\n    while (childOffset < offset + 1 + length) {\n        const decoded = _decode(data, childOffset);\n        result.push(decoded.result);\n        childOffset += decoded.consumed;\n        if (childOffset > offset + 1 + length) {\n            logger.throwError(\"child data too short\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.BUFFER_OVERRUN, {});\n        }\n    }\n    return { consumed: (1 + length), result: result };\n}\n// returns { consumed: number, result: Object }\nfunction _decode(data, offset) {\n    if (data.length === 0) {\n        logger.throwError(\"data too short\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.BUFFER_OVERRUN, {});\n    }\n    // Array with extra length prefix\n    if (data[offset] >= 0xf8) {\n        const lengthLength = data[offset] - 0xf7;\n        if (offset + 1 + lengthLength > data.length) {\n            logger.throwError(\"data short segment too short\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.BUFFER_OVERRUN, {});\n        }\n        const length = unarrayifyInteger(data, offset + 1, lengthLength);\n        if (offset + 1 + lengthLength + length > data.length) {\n            logger.throwError(\"data long segment too short\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.BUFFER_OVERRUN, {});\n        }\n        return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length);\n    }\n    else if (data[offset] >= 0xc0) {\n        const length = data[offset] - 0xc0;\n        if (offset + 1 + length > data.length) {\n            logger.throwError(\"data array too short\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.BUFFER_OVERRUN, {});\n        }\n        return _decodeChildren(data, offset, offset + 1, length);\n    }\n    else if (data[offset] >= 0xb8) {\n        const lengthLength = data[offset] - 0xb7;\n        if (offset + 1 + lengthLength > data.length) {\n            logger.throwError(\"data array too short\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.BUFFER_OVERRUN, {});\n        }\n        const length = unarrayifyInteger(data, offset + 1, lengthLength);\n        if (offset + 1 + lengthLength + length > data.length) {\n            logger.throwError(\"data array too short\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.BUFFER_OVERRUN, {});\n        }\n        const result = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.hexlify)(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length));\n        return { consumed: (1 + lengthLength + length), result: result };\n    }\n    else if (data[offset] >= 0x80) {\n        const length = data[offset] - 0x80;\n        if (offset + 1 + length > data.length) {\n            logger.throwError(\"data too short\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.BUFFER_OVERRUN, {});\n        }\n        const result = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.hexlify)(data.slice(offset + 1, offset + 1 + length));\n        return { consumed: (1 + length), result: result };\n    }\n    return { consumed: 1, result: (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.hexlify)(data[offset]) };\n}\nfunction decode(data) {\n    const bytes = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.arrayify)(data);\n    const decoded = _decode(bytes, 0);\n    if (decoded.consumed !== bytes.length) {\n        logger.throwArgumentError(\"invalid rlp data\", \"data\", data);\n    }\n    return decoded.result;\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3JscC9saWIuZXNtL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQWE7QUFDYjtBQUNzRTtBQUN2QjtBQUNWO0FBQ3JDLG1CQUFtQix5REFBTSxDQUFDLDZDQUFPO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLGlFQUFXO0FBQ3BCO0FBQ0E7QUFDQSw0Q0FBNEMsOERBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsV0FBVyw2REFBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELHlEQUFNLDBCQUEwQjtBQUN0RjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSw0Q0FBNEMseURBQU0sMEJBQTBCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQseURBQU0sMEJBQTBCO0FBQzlGO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCx5REFBTSwwQkFBMEI7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELHlEQUFNLDBCQUEwQjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QseURBQU0sMEJBQTBCO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCx5REFBTSwwQkFBMEI7QUFDdEY7QUFDQSx1QkFBdUIsNkRBQU87QUFDOUIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELHlEQUFNLDBCQUEwQjtBQUNoRjtBQUNBLHVCQUF1Qiw2REFBTztBQUM5QixpQkFBaUI7QUFDakI7QUFDQSxhQUFhLHFCQUFxQiw2REFBTztBQUN6QztBQUNPO0FBQ1Asa0JBQWtCLDhEQUFRO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGVkZ2l0eS15aWVsZC1mcm9udGVuZC8uLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvcmxwL2xpYi5lc20vaW5kZXguanM/NDhlMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vd2lraS93aWtpL1JMUFxuaW1wb3J0IHsgYXJyYXlpZnksIGhleGxpZnksIGlzQnl0ZXNMaWtlIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2J5dGVzXCI7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvbG9nZ2VyXCI7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4vX3ZlcnNpb25cIjtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIodmVyc2lvbik7XG5mdW5jdGlvbiBhcnJheWlmeUludGVnZXIodmFsdWUpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICB3aGlsZSAodmFsdWUpIHtcbiAgICAgICAgcmVzdWx0LnVuc2hpZnQodmFsdWUgJiAweGZmKTtcbiAgICAgICAgdmFsdWUgPj49IDg7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB1bmFycmF5aWZ5SW50ZWdlcihkYXRhLCBvZmZzZXQsIGxlbmd0aCkge1xuICAgIGxldCByZXN1bHQgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0ID0gKHJlc3VsdCAqIDI1NikgKyBkYXRhW29mZnNldCArIGldO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gX2VuY29kZShvYmplY3QpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XG4gICAgICAgIGxldCBwYXlsb2FkID0gW107XG4gICAgICAgIG9iamVjdC5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgcGF5bG9hZCA9IHBheWxvYWQuY29uY2F0KF9lbmNvZGUoY2hpbGQpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChwYXlsb2FkLmxlbmd0aCA8PSA1NSkge1xuICAgICAgICAgICAgcGF5bG9hZC51bnNoaWZ0KDB4YzAgKyBwYXlsb2FkLmxlbmd0aCk7XG4gICAgICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsZW5ndGggPSBhcnJheWlmeUludGVnZXIocGF5bG9hZC5sZW5ndGgpO1xuICAgICAgICBsZW5ndGgudW5zaGlmdCgweGY3ICsgbGVuZ3RoLmxlbmd0aCk7XG4gICAgICAgIHJldHVybiBsZW5ndGguY29uY2F0KHBheWxvYWQpO1xuICAgIH1cbiAgICBpZiAoIWlzQnl0ZXNMaWtlKG9iamVjdCkpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcIlJMUCBvYmplY3QgbXVzdCBiZSBCeXRlc0xpa2VcIiwgXCJvYmplY3RcIiwgb2JqZWN0KTtcbiAgICB9XG4gICAgY29uc3QgZGF0YSA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFycmF5aWZ5KG9iamVjdCkpO1xuICAgIGlmIChkYXRhLmxlbmd0aCA9PT0gMSAmJiBkYXRhWzBdIDw9IDB4N2YpIHtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGVsc2UgaWYgKGRhdGEubGVuZ3RoIDw9IDU1KSB7XG4gICAgICAgIGRhdGEudW5zaGlmdCgweDgwICsgZGF0YS5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgY29uc3QgbGVuZ3RoID0gYXJyYXlpZnlJbnRlZ2VyKGRhdGEubGVuZ3RoKTtcbiAgICBsZW5ndGgudW5zaGlmdCgweGI3ICsgbGVuZ3RoLmxlbmd0aCk7XG4gICAgcmV0dXJuIGxlbmd0aC5jb25jYXQoZGF0YSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlKG9iamVjdCkge1xuICAgIHJldHVybiBoZXhsaWZ5KF9lbmNvZGUob2JqZWN0KSk7XG59XG5mdW5jdGlvbiBfZGVjb2RlQ2hpbGRyZW4oZGF0YSwgb2Zmc2V0LCBjaGlsZE9mZnNldCwgbGVuZ3RoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgd2hpbGUgKGNoaWxkT2Zmc2V0IDwgb2Zmc2V0ICsgMSArIGxlbmd0aCkge1xuICAgICAgICBjb25zdCBkZWNvZGVkID0gX2RlY29kZShkYXRhLCBjaGlsZE9mZnNldCk7XG4gICAgICAgIHJlc3VsdC5wdXNoKGRlY29kZWQucmVzdWx0KTtcbiAgICAgICAgY2hpbGRPZmZzZXQgKz0gZGVjb2RlZC5jb25zdW1lZDtcbiAgICAgICAgaWYgKGNoaWxkT2Zmc2V0ID4gb2Zmc2V0ICsgMSArIGxlbmd0aCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJjaGlsZCBkYXRhIHRvbyBzaG9ydFwiLCBMb2dnZXIuZXJyb3JzLkJVRkZFUl9PVkVSUlVOLCB7fSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgY29uc3VtZWQ6ICgxICsgbGVuZ3RoKSwgcmVzdWx0OiByZXN1bHQgfTtcbn1cbi8vIHJldHVybnMgeyBjb25zdW1lZDogbnVtYmVyLCByZXN1bHQ6IE9iamVjdCB9XG5mdW5jdGlvbiBfZGVjb2RlKGRhdGEsIG9mZnNldCkge1xuICAgIGlmIChkYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImRhdGEgdG9vIHNob3J0XCIsIExvZ2dlci5lcnJvcnMuQlVGRkVSX09WRVJSVU4sIHt9KTtcbiAgICB9XG4gICAgLy8gQXJyYXkgd2l0aCBleHRyYSBsZW5ndGggcHJlZml4XG4gICAgaWYgKGRhdGFbb2Zmc2V0XSA+PSAweGY4KSB7XG4gICAgICAgIGNvbnN0IGxlbmd0aExlbmd0aCA9IGRhdGFbb2Zmc2V0XSAtIDB4Zjc7XG4gICAgICAgIGlmIChvZmZzZXQgKyAxICsgbGVuZ3RoTGVuZ3RoID4gZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiZGF0YSBzaG9ydCBzZWdtZW50IHRvbyBzaG9ydFwiLCBMb2dnZXIuZXJyb3JzLkJVRkZFUl9PVkVSUlVOLCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGVuZ3RoID0gdW5hcnJheWlmeUludGVnZXIoZGF0YSwgb2Zmc2V0ICsgMSwgbGVuZ3RoTGVuZ3RoKTtcbiAgICAgICAgaWYgKG9mZnNldCArIDEgKyBsZW5ndGhMZW5ndGggKyBsZW5ndGggPiBkYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJkYXRhIGxvbmcgc2VnbWVudCB0b28gc2hvcnRcIiwgTG9nZ2VyLmVycm9ycy5CVUZGRVJfT1ZFUlJVTiwge30pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfZGVjb2RlQ2hpbGRyZW4oZGF0YSwgb2Zmc2V0LCBvZmZzZXQgKyAxICsgbGVuZ3RoTGVuZ3RoLCBsZW5ndGhMZW5ndGggKyBsZW5ndGgpO1xuICAgIH1cbiAgICBlbHNlIGlmIChkYXRhW29mZnNldF0gPj0gMHhjMCkge1xuICAgICAgICBjb25zdCBsZW5ndGggPSBkYXRhW29mZnNldF0gLSAweGMwO1xuICAgICAgICBpZiAob2Zmc2V0ICsgMSArIGxlbmd0aCA+IGRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImRhdGEgYXJyYXkgdG9vIHNob3J0XCIsIExvZ2dlci5lcnJvcnMuQlVGRkVSX09WRVJSVU4sIHt9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX2RlY29kZUNoaWxkcmVuKGRhdGEsIG9mZnNldCwgb2Zmc2V0ICsgMSwgbGVuZ3RoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZGF0YVtvZmZzZXRdID49IDB4YjgpIHtcbiAgICAgICAgY29uc3QgbGVuZ3RoTGVuZ3RoID0gZGF0YVtvZmZzZXRdIC0gMHhiNztcbiAgICAgICAgaWYgKG9mZnNldCArIDEgKyBsZW5ndGhMZW5ndGggPiBkYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJkYXRhIGFycmF5IHRvbyBzaG9ydFwiLCBMb2dnZXIuZXJyb3JzLkJVRkZFUl9PVkVSUlVOLCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGVuZ3RoID0gdW5hcnJheWlmeUludGVnZXIoZGF0YSwgb2Zmc2V0ICsgMSwgbGVuZ3RoTGVuZ3RoKTtcbiAgICAgICAgaWYgKG9mZnNldCArIDEgKyBsZW5ndGhMZW5ndGggKyBsZW5ndGggPiBkYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJkYXRhIGFycmF5IHRvbyBzaG9ydFwiLCBMb2dnZXIuZXJyb3JzLkJVRkZFUl9PVkVSUlVOLCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gaGV4bGlmeShkYXRhLnNsaWNlKG9mZnNldCArIDEgKyBsZW5ndGhMZW5ndGgsIG9mZnNldCArIDEgKyBsZW5ndGhMZW5ndGggKyBsZW5ndGgpKTtcbiAgICAgICAgcmV0dXJuIHsgY29uc3VtZWQ6ICgxICsgbGVuZ3RoTGVuZ3RoICsgbGVuZ3RoKSwgcmVzdWx0OiByZXN1bHQgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZGF0YVtvZmZzZXRdID49IDB4ODApIHtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gZGF0YVtvZmZzZXRdIC0gMHg4MDtcbiAgICAgICAgaWYgKG9mZnNldCArIDEgKyBsZW5ndGggPiBkYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJkYXRhIHRvbyBzaG9ydFwiLCBMb2dnZXIuZXJyb3JzLkJVRkZFUl9PVkVSUlVOLCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gaGV4bGlmeShkYXRhLnNsaWNlKG9mZnNldCArIDEsIG9mZnNldCArIDEgKyBsZW5ndGgpKTtcbiAgICAgICAgcmV0dXJuIHsgY29uc3VtZWQ6ICgxICsgbGVuZ3RoKSwgcmVzdWx0OiByZXN1bHQgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgY29uc3VtZWQ6IDEsIHJlc3VsdDogaGV4bGlmeShkYXRhW29mZnNldF0pIH07XG59XG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlKGRhdGEpIHtcbiAgICBjb25zdCBieXRlcyA9IGFycmF5aWZ5KGRhdGEpO1xuICAgIGNvbnN0IGRlY29kZWQgPSBfZGVjb2RlKGJ5dGVzLCAwKTtcbiAgICBpZiAoZGVjb2RlZC5jb25zdW1lZCAhPT0gYnl0ZXMubGVuZ3RoKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIHJscCBkYXRhXCIsIFwiZGF0YVwiLCBkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlY29kZWQucmVzdWx0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ethersproject/rlp/lib.esm/index.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@ethersproject/sha2/lib.esm/_version.js":
/*!***************************************************************!*\
  !*** ../node_modules/@ethersproject/sha2/lib.esm/_version.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\nconst version = \"sha2/5.7.0\";\n//# sourceMappingURL=_version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3NoYTIvbGliLmVzbS9fdmVyc2lvbi5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU87QUFDUCIsInNvdXJjZXMiOlsid2VicGFjazovL2xlZGdpdHkteWllbGQtZnJvbnRlbmQvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3NoYTIvbGliLmVzbS9fdmVyc2lvbi5qcz85NjJhIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCB2ZXJzaW9uID0gXCJzaGEyLzUuNy4wXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdmVyc2lvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ethersproject/sha2/lib.esm/_version.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@ethersproject/sha2/lib.esm/sha2.js":
/*!***********************************************************!*\
  !*** ../node_modules/@ethersproject/sha2/lib.esm/sha2.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   computeHmac: () => (/* binding */ computeHmac),\n/* harmony export */   ripemd160: () => (/* binding */ ripemd160),\n/* harmony export */   sha256: () => (/* binding */ sha256),\n/* harmony export */   sha512: () => (/* binding */ sha512)\n/* harmony export */ });\n/* harmony import */ var hash_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! hash.js */ \"(ssr)/../node_modules/hash.js/lib/hash.js\");\n/* harmony import */ var hash_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(hash_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/../node_modules/@ethersproject/bytes/lib.esm/index.js\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./types */ \"(ssr)/../node_modules/@ethersproject/sha2/lib.esm/types.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/../node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_version */ \"(ssr)/../node_modules/@ethersproject/sha2/lib.esm/_version.js\");\n\n\n//const _ripemd160 = _hash.ripemd160;\n\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger(_version__WEBPACK_IMPORTED_MODULE_2__.version);\nfunction ripemd160(data) {\n    return \"0x\" + (hash_js__WEBPACK_IMPORTED_MODULE_0___default().ripemd160().update((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.arrayify)(data)).digest(\"hex\"));\n}\nfunction sha256(data) {\n    return \"0x\" + (hash_js__WEBPACK_IMPORTED_MODULE_0___default().sha256().update((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.arrayify)(data)).digest(\"hex\"));\n}\nfunction sha512(data) {\n    return \"0x\" + (hash_js__WEBPACK_IMPORTED_MODULE_0___default().sha512().update((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.arrayify)(data)).digest(\"hex\"));\n}\nfunction computeHmac(algorithm, key, data) {\n    if (!_types__WEBPACK_IMPORTED_MODULE_4__.SupportedAlgorithm[algorithm]) {\n        logger.throwError(\"unsupported algorithm \" + algorithm, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"hmac\",\n            algorithm: algorithm\n        });\n    }\n    return \"0x\" + hash_js__WEBPACK_IMPORTED_MODULE_0___default().hmac((hash_js__WEBPACK_IMPORTED_MODULE_0___default())[algorithm], (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.arrayify)(key)).update((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.arrayify)(data)).digest(\"hex\");\n}\n//# sourceMappingURL=sha2.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3NoYTIvbGliLmVzbS9zaGEyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBYTtBQUNjO0FBQzNCO0FBQ2dEO0FBQ0g7QUFDRTtBQUNWO0FBQ3JDLG1CQUFtQix5REFBTSxDQUFDLDZDQUFPO0FBQzFCO0FBQ1AsbUJBQW1CLHdEQUFjLFVBQVUsOERBQVE7QUFDbkQ7QUFDTztBQUNQLG1CQUFtQixxREFBVyxVQUFVLDhEQUFRO0FBQ2hEO0FBQ087QUFDUCxtQkFBbUIscURBQVcsVUFBVSw4REFBUTtBQUNoRDtBQUNPO0FBQ1AsU0FBUyxzREFBa0I7QUFDM0IsZ0VBQWdFLHlEQUFNO0FBQ3RFO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxrQkFBa0IsbURBQVMsQ0FBQyxnREFBSSxhQUFhLDhEQUFRLGNBQWMsOERBQVE7QUFDM0U7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xlZGdpdHkteWllbGQtZnJvbnRlbmQvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3NoYTIvbGliLmVzbS9zaGEyLmpzPzVhMmMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgaGFzaCBmcm9tIFwiaGFzaC5qc1wiO1xuLy9jb25zdCBfcmlwZW1kMTYwID0gX2hhc2gucmlwZW1kMTYwO1xuaW1wb3J0IHsgYXJyYXlpZnkgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYnl0ZXNcIjtcbmltcG9ydCB7IFN1cHBvcnRlZEFsZ29yaXRobSB9IGZyb20gXCIuL3R5cGVzXCI7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvbG9nZ2VyXCI7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4vX3ZlcnNpb25cIjtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIodmVyc2lvbik7XG5leHBvcnQgZnVuY3Rpb24gcmlwZW1kMTYwKGRhdGEpIHtcbiAgICByZXR1cm4gXCIweFwiICsgKGhhc2gucmlwZW1kMTYwKCkudXBkYXRlKGFycmF5aWZ5KGRhdGEpKS5kaWdlc3QoXCJoZXhcIikpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNoYTI1NihkYXRhKSB7XG4gICAgcmV0dXJuIFwiMHhcIiArIChoYXNoLnNoYTI1NigpLnVwZGF0ZShhcnJheWlmeShkYXRhKSkuZGlnZXN0KFwiaGV4XCIpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzaGE1MTIoZGF0YSkge1xuICAgIHJldHVybiBcIjB4XCIgKyAoaGFzaC5zaGE1MTIoKS51cGRhdGUoYXJyYXlpZnkoZGF0YSkpLmRpZ2VzdChcImhleFwiKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZUhtYWMoYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcbiAgICBpZiAoIVN1cHBvcnRlZEFsZ29yaXRobVthbGdvcml0aG1dKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwidW5zdXBwb3J0ZWQgYWxnb3JpdGhtIFwiICsgYWxnb3JpdGhtLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcImhtYWNcIixcbiAgICAgICAgICAgIGFsZ29yaXRobTogYWxnb3JpdGhtXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gXCIweFwiICsgaGFzaC5obWFjKGhhc2hbYWxnb3JpdGhtXSwgYXJyYXlpZnkoa2V5KSkudXBkYXRlKGFycmF5aWZ5KGRhdGEpKS5kaWdlc3QoXCJoZXhcIik7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGEyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ethersproject/sha2/lib.esm/sha2.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@ethersproject/sha2/lib.esm/types.js":
/*!************************************************************!*\
  !*** ../node_modules/@ethersproject/sha2/lib.esm/types.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SupportedAlgorithm: () => (/* binding */ SupportedAlgorithm)\n/* harmony export */ });\nvar SupportedAlgorithm;\n(function (SupportedAlgorithm) {\n    SupportedAlgorithm[\"sha256\"] = \"sha256\";\n    SupportedAlgorithm[\"sha512\"] = \"sha512\";\n})(SupportedAlgorithm || (SupportedAlgorithm = {}));\n;\n//# sourceMappingURL=types.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3NoYTIvbGliLmVzbS90eXBlcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdEQUFnRDtBQUNqRDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGVkZ2l0eS15aWVsZC1mcm9udGVuZC8uLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3Qvc2hhMi9saWIuZXNtL3R5cGVzLmpzP2M4NGEiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHZhciBTdXBwb3J0ZWRBbGdvcml0aG07XG4oZnVuY3Rpb24gKFN1cHBvcnRlZEFsZ29yaXRobSkge1xuICAgIFN1cHBvcnRlZEFsZ29yaXRobVtcInNoYTI1NlwiXSA9IFwic2hhMjU2XCI7XG4gICAgU3VwcG9ydGVkQWxnb3JpdGhtW1wic2hhNTEyXCJdID0gXCJzaGE1MTJcIjtcbn0pKFN1cHBvcnRlZEFsZ29yaXRobSB8fCAoU3VwcG9ydGVkQWxnb3JpdGhtID0ge30pKTtcbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGVzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ethersproject/sha2/lib.esm/types.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@ethersproject/signing-key/lib.esm/_version.js":
/*!**********************************************************************!*\
  !*** ../node_modules/@ethersproject/signing-key/lib.esm/_version.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\nconst version = \"signing-key/5.7.0\";\n//# sourceMappingURL=_version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3NpZ25pbmcta2V5L2xpYi5lc20vX3ZlcnNpb24uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFPO0FBQ1AiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sZWRnaXR5LXlpZWxkLWZyb250ZW5kLy4uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9zaWduaW5nLWtleS9saWIuZXNtL192ZXJzaW9uLmpzP2Y4MjgiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IHZlcnNpb24gPSBcInNpZ25pbmcta2V5LzUuNy4wXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdmVyc2lvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ethersproject/signing-key/lib.esm/_version.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@ethersproject/signing-key/lib.esm/elliptic.js":
/*!**********************************************************************!*\
  !*** ../node_modules/@ethersproject/signing-key/lib.esm/elliptic.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EC: () => (/* binding */ EC$1)\n/* harmony export */ });\n/* harmony import */ var bn_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! bn.js */ \"(ssr)/../node_modules/bn.js/lib/bn.js\");\n/* harmony import */ var bn_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(bn_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var hash_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! hash.js */ \"(ssr)/../node_modules/hash.js/lib/hash.js\");\n/* harmony import */ var hash_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(hash_js__WEBPACK_IMPORTED_MODULE_1__);\n\n\n\nvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\nfunction getDefaultExportFromCjs (x) {\n\treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n}\n\nfunction createCommonjsModule(fn, basedir, module) {\n\treturn module = {\n\t\tpath: basedir,\n\t\texports: {},\n\t\trequire: function (path, base) {\n\t\t\treturn commonjsRequire(path, (base === undefined || base === null) ? module.path : base);\n\t\t}\n\t}, fn(module, module.exports), module.exports;\n}\n\nfunction getDefaultExportFromNamespaceIfPresent (n) {\n\treturn n && Object.prototype.hasOwnProperty.call(n, 'default') ? n['default'] : n;\n}\n\nfunction getDefaultExportFromNamespaceIfNotNamed (n) {\n\treturn n && Object.prototype.hasOwnProperty.call(n, 'default') && Object.keys(n).length === 1 ? n['default'] : n;\n}\n\nfunction getAugmentedNamespace(n) {\n\tif (n.__esModule) return n;\n\tvar a = Object.defineProperty({}, '__esModule', {value: true});\n\tObject.keys(n).forEach(function (k) {\n\t\tvar d = Object.getOwnPropertyDescriptor(n, k);\n\t\tObject.defineProperty(a, k, d.get ? d : {\n\t\t\tenumerable: true,\n\t\t\tget: function () {\n\t\t\t\treturn n[k];\n\t\t\t}\n\t\t});\n\t});\n\treturn a;\n}\n\nfunction commonjsRequire () {\n\tthrow new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');\n}\n\nvar minimalisticAssert = assert;\n\nfunction assert(val, msg) {\n  if (!val)\n    throw new Error(msg || 'Assertion failed');\n}\n\nassert.equal = function assertEqual(l, r, msg) {\n  if (l != r)\n    throw new Error(msg || ('Assertion failed: ' + l + ' != ' + r));\n};\n\nvar utils_1 = createCommonjsModule(function (module, exports) {\n'use strict';\n\nvar utils = exports;\n\nfunction toArray(msg, enc) {\n  if (Array.isArray(msg))\n    return msg.slice();\n  if (!msg)\n    return [];\n  var res = [];\n  if (typeof msg !== 'string') {\n    for (var i = 0; i < msg.length; i++)\n      res[i] = msg[i] | 0;\n    return res;\n  }\n  if (enc === 'hex') {\n    msg = msg.replace(/[^a-z0-9]+/ig, '');\n    if (msg.length % 2 !== 0)\n      msg = '0' + msg;\n    for (var i = 0; i < msg.length; i += 2)\n      res.push(parseInt(msg[i] + msg[i + 1], 16));\n  } else {\n    for (var i = 0; i < msg.length; i++) {\n      var c = msg.charCodeAt(i);\n      var hi = c >> 8;\n      var lo = c & 0xff;\n      if (hi)\n        res.push(hi, lo);\n      else\n        res.push(lo);\n    }\n  }\n  return res;\n}\nutils.toArray = toArray;\n\nfunction zero2(word) {\n  if (word.length === 1)\n    return '0' + word;\n  else\n    return word;\n}\nutils.zero2 = zero2;\n\nfunction toHex(msg) {\n  var res = '';\n  for (var i = 0; i < msg.length; i++)\n    res += zero2(msg[i].toString(16));\n  return res;\n}\nutils.toHex = toHex;\n\nutils.encode = function encode(arr, enc) {\n  if (enc === 'hex')\n    return toHex(arr);\n  else\n    return arr;\n};\n});\n\nvar utils_1$1 = createCommonjsModule(function (module, exports) {\n'use strict';\n\nvar utils = exports;\n\n\n\n\nutils.assert = minimalisticAssert;\nutils.toArray = utils_1.toArray;\nutils.zero2 = utils_1.zero2;\nutils.toHex = utils_1.toHex;\nutils.encode = utils_1.encode;\n\n// Represent num in a w-NAF form\nfunction getNAF(num, w, bits) {\n  var naf = new Array(Math.max(num.bitLength(), bits) + 1);\n  naf.fill(0);\n\n  var ws = 1 << (w + 1);\n  var k = num.clone();\n\n  for (var i = 0; i < naf.length; i++) {\n    var z;\n    var mod = k.andln(ws - 1);\n    if (k.isOdd()) {\n      if (mod > (ws >> 1) - 1)\n        z = (ws >> 1) - mod;\n      else\n        z = mod;\n      k.isubn(z);\n    } else {\n      z = 0;\n    }\n\n    naf[i] = z;\n    k.iushrn(1);\n  }\n\n  return naf;\n}\nutils.getNAF = getNAF;\n\n// Represent k1, k2 in a Joint Sparse Form\nfunction getJSF(k1, k2) {\n  var jsf = [\n    [],\n    [],\n  ];\n\n  k1 = k1.clone();\n  k2 = k2.clone();\n  var d1 = 0;\n  var d2 = 0;\n  var m8;\n  while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {\n    // First phase\n    var m14 = (k1.andln(3) + d1) & 3;\n    var m24 = (k2.andln(3) + d2) & 3;\n    if (m14 === 3)\n      m14 = -1;\n    if (m24 === 3)\n      m24 = -1;\n    var u1;\n    if ((m14 & 1) === 0) {\n      u1 = 0;\n    } else {\n      m8 = (k1.andln(7) + d1) & 7;\n      if ((m8 === 3 || m8 === 5) && m24 === 2)\n        u1 = -m14;\n      else\n        u1 = m14;\n    }\n    jsf[0].push(u1);\n\n    var u2;\n    if ((m24 & 1) === 0) {\n      u2 = 0;\n    } else {\n      m8 = (k2.andln(7) + d2) & 7;\n      if ((m8 === 3 || m8 === 5) && m14 === 2)\n        u2 = -m24;\n      else\n        u2 = m24;\n    }\n    jsf[1].push(u2);\n\n    // Second phase\n    if (2 * d1 === u1 + 1)\n      d1 = 1 - d1;\n    if (2 * d2 === u2 + 1)\n      d2 = 1 - d2;\n    k1.iushrn(1);\n    k2.iushrn(1);\n  }\n\n  return jsf;\n}\nutils.getJSF = getJSF;\n\nfunction cachedProperty(obj, name, computer) {\n  var key = '_' + name;\n  obj.prototype[name] = function cachedProperty() {\n    return this[key] !== undefined ? this[key] :\n      this[key] = computer.call(this);\n  };\n}\nutils.cachedProperty = cachedProperty;\n\nfunction parseBytes(bytes) {\n  return typeof bytes === 'string' ? utils.toArray(bytes, 'hex') :\n    bytes;\n}\nutils.parseBytes = parseBytes;\n\nfunction intFromLE(bytes) {\n  return new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(bytes, 'hex', 'le');\n}\nutils.intFromLE = intFromLE;\n});\n\n'use strict';\n\n\n\nvar getNAF = utils_1$1.getNAF;\nvar getJSF = utils_1$1.getJSF;\nvar assert$1 = utils_1$1.assert;\n\nfunction BaseCurve(type, conf) {\n  this.type = type;\n  this.p = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(conf.p, 16);\n\n  // Use Montgomery, when there is no fast reduction for the prime\n  this.red = conf.prime ? bn_js__WEBPACK_IMPORTED_MODULE_0___default().red(conf.prime) : bn_js__WEBPACK_IMPORTED_MODULE_0___default().mont(this.p);\n\n  // Useful for many curves\n  this.zero = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(0).toRed(this.red);\n  this.one = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(1).toRed(this.red);\n  this.two = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(2).toRed(this.red);\n\n  // Curve configuration, optional\n  this.n = conf.n && new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(conf.n, 16);\n  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);\n\n  // Temporary arrays\n  this._wnafT1 = new Array(4);\n  this._wnafT2 = new Array(4);\n  this._wnafT3 = new Array(4);\n  this._wnafT4 = new Array(4);\n\n  this._bitLength = this.n ? this.n.bitLength() : 0;\n\n  // Generalized Greg Maxwell's trick\n  var adjustCount = this.n && this.p.div(this.n);\n  if (!adjustCount || adjustCount.cmpn(100) > 0) {\n    this.redN = null;\n  } else {\n    this._maxwellTrick = true;\n    this.redN = this.n.toRed(this.red);\n  }\n}\nvar base = BaseCurve;\n\nBaseCurve.prototype.point = function point() {\n  throw new Error('Not implemented');\n};\n\nBaseCurve.prototype.validate = function validate() {\n  throw new Error('Not implemented');\n};\n\nBaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {\n  assert$1(p.precomputed);\n  var doubles = p._getDoubles();\n\n  var naf = getNAF(k, 1, this._bitLength);\n  var I = (1 << (doubles.step + 1)) - (doubles.step % 2 === 0 ? 2 : 1);\n  I /= 3;\n\n  // Translate into more windowed form\n  var repr = [];\n  var j;\n  var nafW;\n  for (j = 0; j < naf.length; j += doubles.step) {\n    nafW = 0;\n    for (var l = j + doubles.step - 1; l >= j; l--)\n      nafW = (nafW << 1) + naf[l];\n    repr.push(nafW);\n  }\n\n  var a = this.jpoint(null, null, null);\n  var b = this.jpoint(null, null, null);\n  for (var i = I; i > 0; i--) {\n    for (j = 0; j < repr.length; j++) {\n      nafW = repr[j];\n      if (nafW === i)\n        b = b.mixedAdd(doubles.points[j]);\n      else if (nafW === -i)\n        b = b.mixedAdd(doubles.points[j].neg());\n    }\n    a = a.add(b);\n  }\n  return a.toP();\n};\n\nBaseCurve.prototype._wnafMul = function _wnafMul(p, k) {\n  var w = 4;\n\n  // Precompute window\n  var nafPoints = p._getNAFPoints(w);\n  w = nafPoints.wnd;\n  var wnd = nafPoints.points;\n\n  // Get NAF form\n  var naf = getNAF(k, w, this._bitLength);\n\n  // Add `this`*(N+1) for every w-NAF index\n  var acc = this.jpoint(null, null, null);\n  for (var i = naf.length - 1; i >= 0; i--) {\n    // Count zeroes\n    for (var l = 0; i >= 0 && naf[i] === 0; i--)\n      l++;\n    if (i >= 0)\n      l++;\n    acc = acc.dblp(l);\n\n    if (i < 0)\n      break;\n    var z = naf[i];\n    assert$1(z !== 0);\n    if (p.type === 'affine') {\n      // J +- P\n      if (z > 0)\n        acc = acc.mixedAdd(wnd[(z - 1) >> 1]);\n      else\n        acc = acc.mixedAdd(wnd[(-z - 1) >> 1].neg());\n    } else {\n      // J +- J\n      if (z > 0)\n        acc = acc.add(wnd[(z - 1) >> 1]);\n      else\n        acc = acc.add(wnd[(-z - 1) >> 1].neg());\n    }\n  }\n  return p.type === 'affine' ? acc.toP() : acc;\n};\n\nBaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW,\n  points,\n  coeffs,\n  len,\n  jacobianResult) {\n  var wndWidth = this._wnafT1;\n  var wnd = this._wnafT2;\n  var naf = this._wnafT3;\n\n  // Fill all arrays\n  var max = 0;\n  var i;\n  var j;\n  var p;\n  for (i = 0; i < len; i++) {\n    p = points[i];\n    var nafPoints = p._getNAFPoints(defW);\n    wndWidth[i] = nafPoints.wnd;\n    wnd[i] = nafPoints.points;\n  }\n\n  // Comb small window NAFs\n  for (i = len - 1; i >= 1; i -= 2) {\n    var a = i - 1;\n    var b = i;\n    if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {\n      naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);\n      naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);\n      max = Math.max(naf[a].length, max);\n      max = Math.max(naf[b].length, max);\n      continue;\n    }\n\n    var comb = [\n      points[a], /* 1 */\n      null, /* 3 */\n      null, /* 5 */\n      points[b], /* 7 */\n    ];\n\n    // Try to avoid Projective points, if possible\n    if (points[a].y.cmp(points[b].y) === 0) {\n      comb[1] = points[a].add(points[b]);\n      comb[2] = points[a].toJ().mixedAdd(points[b].neg());\n    } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {\n      comb[1] = points[a].toJ().mixedAdd(points[b]);\n      comb[2] = points[a].add(points[b].neg());\n    } else {\n      comb[1] = points[a].toJ().mixedAdd(points[b]);\n      comb[2] = points[a].toJ().mixedAdd(points[b].neg());\n    }\n\n    var index = [\n      -3, /* -1 -1 */\n      -1, /* -1 0 */\n      -5, /* -1 1 */\n      -7, /* 0 -1 */\n      0, /* 0 0 */\n      7, /* 0 1 */\n      5, /* 1 -1 */\n      1, /* 1 0 */\n      3,  /* 1 1 */\n    ];\n\n    var jsf = getJSF(coeffs[a], coeffs[b]);\n    max = Math.max(jsf[0].length, max);\n    naf[a] = new Array(max);\n    naf[b] = new Array(max);\n    for (j = 0; j < max; j++) {\n      var ja = jsf[0][j] | 0;\n      var jb = jsf[1][j] | 0;\n\n      naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];\n      naf[b][j] = 0;\n      wnd[a] = comb;\n    }\n  }\n\n  var acc = this.jpoint(null, null, null);\n  var tmp = this._wnafT4;\n  for (i = max; i >= 0; i--) {\n    var k = 0;\n\n    while (i >= 0) {\n      var zero = true;\n      for (j = 0; j < len; j++) {\n        tmp[j] = naf[j][i] | 0;\n        if (tmp[j] !== 0)\n          zero = false;\n      }\n      if (!zero)\n        break;\n      k++;\n      i--;\n    }\n    if (i >= 0)\n      k++;\n    acc = acc.dblp(k);\n    if (i < 0)\n      break;\n\n    for (j = 0; j < len; j++) {\n      var z = tmp[j];\n      p;\n      if (z === 0)\n        continue;\n      else if (z > 0)\n        p = wnd[j][(z - 1) >> 1];\n      else if (z < 0)\n        p = wnd[j][(-z - 1) >> 1].neg();\n\n      if (p.type === 'affine')\n        acc = acc.mixedAdd(p);\n      else\n        acc = acc.add(p);\n    }\n  }\n  // Zeroify references\n  for (i = 0; i < len; i++)\n    wnd[i] = null;\n\n  if (jacobianResult)\n    return acc;\n  else\n    return acc.toP();\n};\n\nfunction BasePoint(curve, type) {\n  this.curve = curve;\n  this.type = type;\n  this.precomputed = null;\n}\nBaseCurve.BasePoint = BasePoint;\n\nBasePoint.prototype.eq = function eq(/*other*/) {\n  throw new Error('Not implemented');\n};\n\nBasePoint.prototype.validate = function validate() {\n  return this.curve.validate(this);\n};\n\nBaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {\n  bytes = utils_1$1.toArray(bytes, enc);\n\n  var len = this.p.byteLength();\n\n  // uncompressed, hybrid-odd, hybrid-even\n  if ((bytes[0] === 0x04 || bytes[0] === 0x06 || bytes[0] === 0x07) &&\n      bytes.length - 1 === 2 * len) {\n    if (bytes[0] === 0x06)\n      assert$1(bytes[bytes.length - 1] % 2 === 0);\n    else if (bytes[0] === 0x07)\n      assert$1(bytes[bytes.length - 1] % 2 === 1);\n\n    var res =  this.point(bytes.slice(1, 1 + len),\n      bytes.slice(1 + len, 1 + 2 * len));\n\n    return res;\n  } else if ((bytes[0] === 0x02 || bytes[0] === 0x03) &&\n              bytes.length - 1 === len) {\n    return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 0x03);\n  }\n  throw new Error('Unknown point format');\n};\n\nBasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {\n  return this.encode(enc, true);\n};\n\nBasePoint.prototype._encode = function _encode(compact) {\n  var len = this.curve.p.byteLength();\n  var x = this.getX().toArray('be', len);\n\n  if (compact)\n    return [ this.getY().isEven() ? 0x02 : 0x03 ].concat(x);\n\n  return [ 0x04 ].concat(x, this.getY().toArray('be', len));\n};\n\nBasePoint.prototype.encode = function encode(enc, compact) {\n  return utils_1$1.encode(this._encode(compact), enc);\n};\n\nBasePoint.prototype.precompute = function precompute(power) {\n  if (this.precomputed)\n    return this;\n\n  var precomputed = {\n    doubles: null,\n    naf: null,\n    beta: null,\n  };\n  precomputed.naf = this._getNAFPoints(8);\n  precomputed.doubles = this._getDoubles(4, power);\n  precomputed.beta = this._getBeta();\n  this.precomputed = precomputed;\n\n  return this;\n};\n\nBasePoint.prototype._hasDoubles = function _hasDoubles(k) {\n  if (!this.precomputed)\n    return false;\n\n  var doubles = this.precomputed.doubles;\n  if (!doubles)\n    return false;\n\n  return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);\n};\n\nBasePoint.prototype._getDoubles = function _getDoubles(step, power) {\n  if (this.precomputed && this.precomputed.doubles)\n    return this.precomputed.doubles;\n\n  var doubles = [ this ];\n  var acc = this;\n  for (var i = 0; i < power; i += step) {\n    for (var j = 0; j < step; j++)\n      acc = acc.dbl();\n    doubles.push(acc);\n  }\n  return {\n    step: step,\n    points: doubles,\n  };\n};\n\nBasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {\n  if (this.precomputed && this.precomputed.naf)\n    return this.precomputed.naf;\n\n  var res = [ this ];\n  var max = (1 << wnd) - 1;\n  var dbl = max === 1 ? null : this.dbl();\n  for (var i = 1; i < max; i++)\n    res[i] = res[i - 1].add(dbl);\n  return {\n    wnd: wnd,\n    points: res,\n  };\n};\n\nBasePoint.prototype._getBeta = function _getBeta() {\n  return null;\n};\n\nBasePoint.prototype.dblp = function dblp(k) {\n  var r = this;\n  for (var i = 0; i < k; i++)\n    r = r.dbl();\n  return r;\n};\n\nvar inherits_browser = createCommonjsModule(function (module) {\nif (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor;\n      ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n          value: ctor,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      });\n    }\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor;\n      var TempCtor = function () {};\n      TempCtor.prototype = superCtor.prototype;\n      ctor.prototype = new TempCtor();\n      ctor.prototype.constructor = ctor;\n    }\n  };\n}\n});\n\n'use strict';\n\n\n\n\n\n\nvar assert$2 = utils_1$1.assert;\n\nfunction ShortCurve(conf) {\n  base.call(this, 'short', conf);\n\n  this.a = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(conf.a, 16).toRed(this.red);\n  this.b = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(conf.b, 16).toRed(this.red);\n  this.tinv = this.two.redInvm();\n\n  this.zeroA = this.a.fromRed().cmpn(0) === 0;\n  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;\n\n  // If the curve is endomorphic, precalculate beta and lambda\n  this.endo = this._getEndomorphism(conf);\n  this._endoWnafT1 = new Array(4);\n  this._endoWnafT2 = new Array(4);\n}\ninherits_browser(ShortCurve, base);\nvar short_1 = ShortCurve;\n\nShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {\n  // No efficient endomorphism\n  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)\n    return;\n\n  // Compute beta and lambda, that lambda * P = (beta * Px; Py)\n  var beta;\n  var lambda;\n  if (conf.beta) {\n    beta = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(conf.beta, 16).toRed(this.red);\n  } else {\n    var betas = this._getEndoRoots(this.p);\n    // Choose the smallest beta\n    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];\n    beta = beta.toRed(this.red);\n  }\n  if (conf.lambda) {\n    lambda = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(conf.lambda, 16);\n  } else {\n    // Choose the lambda that is matching selected beta\n    var lambdas = this._getEndoRoots(this.n);\n    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {\n      lambda = lambdas[0];\n    } else {\n      lambda = lambdas[1];\n      assert$2(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);\n    }\n  }\n\n  // Get basis vectors, used for balanced length-two representation\n  var basis;\n  if (conf.basis) {\n    basis = conf.basis.map(function(vec) {\n      return {\n        a: new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(vec.a, 16),\n        b: new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(vec.b, 16),\n      };\n    });\n  } else {\n    basis = this._getEndoBasis(lambda);\n  }\n\n  return {\n    beta: beta,\n    lambda: lambda,\n    basis: basis,\n  };\n};\n\nShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {\n  // Find roots of for x^2 + x + 1 in F\n  // Root = (-1 +- Sqrt(-3)) / 2\n  //\n  var red = num === this.p ? this.red : bn_js__WEBPACK_IMPORTED_MODULE_0___default().mont(num);\n  var tinv = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(2).toRed(red).redInvm();\n  var ntinv = tinv.redNeg();\n\n  var s = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(3).toRed(red).redNeg().redSqrt().redMul(tinv);\n\n  var l1 = ntinv.redAdd(s).fromRed();\n  var l2 = ntinv.redSub(s).fromRed();\n  return [ l1, l2 ];\n};\n\nShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {\n  // aprxSqrt >= sqrt(this.n)\n  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));\n\n  // 3.74\n  // Run EGCD, until r(L + 1) < aprxSqrt\n  var u = lambda;\n  var v = this.n.clone();\n  var x1 = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(1);\n  var y1 = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(0);\n  var x2 = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(0);\n  var y2 = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(1);\n\n  // NOTE: all vectors are roots of: a + b * lambda = 0 (mod n)\n  var a0;\n  var b0;\n  // First vector\n  var a1;\n  var b1;\n  // Second vector\n  var a2;\n  var b2;\n\n  var prevR;\n  var i = 0;\n  var r;\n  var x;\n  while (u.cmpn(0) !== 0) {\n    var q = v.div(u);\n    r = v.sub(q.mul(u));\n    x = x2.sub(q.mul(x1));\n    var y = y2.sub(q.mul(y1));\n\n    if (!a1 && r.cmp(aprxSqrt) < 0) {\n      a0 = prevR.neg();\n      b0 = x1;\n      a1 = r.neg();\n      b1 = x;\n    } else if (a1 && ++i === 2) {\n      break;\n    }\n    prevR = r;\n\n    v = u;\n    u = r;\n    x2 = x1;\n    x1 = x;\n    y2 = y1;\n    y1 = y;\n  }\n  a2 = r.neg();\n  b2 = x;\n\n  var len1 = a1.sqr().add(b1.sqr());\n  var len2 = a2.sqr().add(b2.sqr());\n  if (len2.cmp(len1) >= 0) {\n    a2 = a0;\n    b2 = b0;\n  }\n\n  // Normalize signs\n  if (a1.negative) {\n    a1 = a1.neg();\n    b1 = b1.neg();\n  }\n  if (a2.negative) {\n    a2 = a2.neg();\n    b2 = b2.neg();\n  }\n\n  return [\n    { a: a1, b: b1 },\n    { a: a2, b: b2 },\n  ];\n};\n\nShortCurve.prototype._endoSplit = function _endoSplit(k) {\n  var basis = this.endo.basis;\n  var v1 = basis[0];\n  var v2 = basis[1];\n\n  var c1 = v2.b.mul(k).divRound(this.n);\n  var c2 = v1.b.neg().mul(k).divRound(this.n);\n\n  var p1 = c1.mul(v1.a);\n  var p2 = c2.mul(v2.a);\n  var q1 = c1.mul(v1.b);\n  var q2 = c2.mul(v2.b);\n\n  // Calculate answer\n  var k1 = k.sub(p1).sub(p2);\n  var k2 = q1.add(q2).neg();\n  return { k1: k1, k2: k2 };\n};\n\nShortCurve.prototype.pointFromX = function pointFromX(x, odd) {\n  x = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(x, 16);\n  if (!x.red)\n    x = x.toRed(this.red);\n\n  var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);\n  var y = y2.redSqrt();\n  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)\n    throw new Error('invalid point');\n\n  // XXX Is there any way to tell if the number is odd without converting it\n  // to non-red form?\n  var isOdd = y.fromRed().isOdd();\n  if (odd && !isOdd || !odd && isOdd)\n    y = y.redNeg();\n\n  return this.point(x, y);\n};\n\nShortCurve.prototype.validate = function validate(point) {\n  if (point.inf)\n    return true;\n\n  var x = point.x;\n  var y = point.y;\n\n  var ax = this.a.redMul(x);\n  var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);\n  return y.redSqr().redISub(rhs).cmpn(0) === 0;\n};\n\nShortCurve.prototype._endoWnafMulAdd =\n    function _endoWnafMulAdd(points, coeffs, jacobianResult) {\n      var npoints = this._endoWnafT1;\n      var ncoeffs = this._endoWnafT2;\n      for (var i = 0; i < points.length; i++) {\n        var split = this._endoSplit(coeffs[i]);\n        var p = points[i];\n        var beta = p._getBeta();\n\n        if (split.k1.negative) {\n          split.k1.ineg();\n          p = p.neg(true);\n        }\n        if (split.k2.negative) {\n          split.k2.ineg();\n          beta = beta.neg(true);\n        }\n\n        npoints[i * 2] = p;\n        npoints[i * 2 + 1] = beta;\n        ncoeffs[i * 2] = split.k1;\n        ncoeffs[i * 2 + 1] = split.k2;\n      }\n      var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);\n\n      // Clean-up references to points and coefficients\n      for (var j = 0; j < i * 2; j++) {\n        npoints[j] = null;\n        ncoeffs[j] = null;\n      }\n      return res;\n    };\n\nfunction Point(curve, x, y, isRed) {\n  base.BasePoint.call(this, curve, 'affine');\n  if (x === null && y === null) {\n    this.x = null;\n    this.y = null;\n    this.inf = true;\n  } else {\n    this.x = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(x, 16);\n    this.y = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(y, 16);\n    // Force redgomery representation when loading from JSON\n    if (isRed) {\n      this.x.forceRed(this.curve.red);\n      this.y.forceRed(this.curve.red);\n    }\n    if (!this.x.red)\n      this.x = this.x.toRed(this.curve.red);\n    if (!this.y.red)\n      this.y = this.y.toRed(this.curve.red);\n    this.inf = false;\n  }\n}\ninherits_browser(Point, base.BasePoint);\n\nShortCurve.prototype.point = function point(x, y, isRed) {\n  return new Point(this, x, y, isRed);\n};\n\nShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {\n  return Point.fromJSON(this, obj, red);\n};\n\nPoint.prototype._getBeta = function _getBeta() {\n  if (!this.curve.endo)\n    return;\n\n  var pre = this.precomputed;\n  if (pre && pre.beta)\n    return pre.beta;\n\n  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);\n  if (pre) {\n    var curve = this.curve;\n    var endoMul = function(p) {\n      return curve.point(p.x.redMul(curve.endo.beta), p.y);\n    };\n    pre.beta = beta;\n    beta.precomputed = {\n      beta: null,\n      naf: pre.naf && {\n        wnd: pre.naf.wnd,\n        points: pre.naf.points.map(endoMul),\n      },\n      doubles: pre.doubles && {\n        step: pre.doubles.step,\n        points: pre.doubles.points.map(endoMul),\n      },\n    };\n  }\n  return beta;\n};\n\nPoint.prototype.toJSON = function toJSON() {\n  if (!this.precomputed)\n    return [ this.x, this.y ];\n\n  return [ this.x, this.y, this.precomputed && {\n    doubles: this.precomputed.doubles && {\n      step: this.precomputed.doubles.step,\n      points: this.precomputed.doubles.points.slice(1),\n    },\n    naf: this.precomputed.naf && {\n      wnd: this.precomputed.naf.wnd,\n      points: this.precomputed.naf.points.slice(1),\n    },\n  } ];\n};\n\nPoint.fromJSON = function fromJSON(curve, obj, red) {\n  if (typeof obj === 'string')\n    obj = JSON.parse(obj);\n  var res = curve.point(obj[0], obj[1], red);\n  if (!obj[2])\n    return res;\n\n  function obj2point(obj) {\n    return curve.point(obj[0], obj[1], red);\n  }\n\n  var pre = obj[2];\n  res.precomputed = {\n    beta: null,\n    doubles: pre.doubles && {\n      step: pre.doubles.step,\n      points: [ res ].concat(pre.doubles.points.map(obj2point)),\n    },\n    naf: pre.naf && {\n      wnd: pre.naf.wnd,\n      points: [ res ].concat(pre.naf.points.map(obj2point)),\n    },\n  };\n  return res;\n};\n\nPoint.prototype.inspect = function inspect() {\n  if (this.isInfinity())\n    return '<EC Point Infinity>';\n  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +\n      ' y: ' + this.y.fromRed().toString(16, 2) + '>';\n};\n\nPoint.prototype.isInfinity = function isInfinity() {\n  return this.inf;\n};\n\nPoint.prototype.add = function add(p) {\n  // O + P = P\n  if (this.inf)\n    return p;\n\n  // P + O = P\n  if (p.inf)\n    return this;\n\n  // P + P = 2P\n  if (this.eq(p))\n    return this.dbl();\n\n  // P + (-P) = O\n  if (this.neg().eq(p))\n    return this.curve.point(null, null);\n\n  // P + Q = O\n  if (this.x.cmp(p.x) === 0)\n    return this.curve.point(null, null);\n\n  var c = this.y.redSub(p.y);\n  if (c.cmpn(0) !== 0)\n    c = c.redMul(this.x.redSub(p.x).redInvm());\n  var nx = c.redSqr().redISub(this.x).redISub(p.x);\n  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);\n  return this.curve.point(nx, ny);\n};\n\nPoint.prototype.dbl = function dbl() {\n  if (this.inf)\n    return this;\n\n  // 2P = O\n  var ys1 = this.y.redAdd(this.y);\n  if (ys1.cmpn(0) === 0)\n    return this.curve.point(null, null);\n\n  var a = this.curve.a;\n\n  var x2 = this.x.redSqr();\n  var dyinv = ys1.redInvm();\n  var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);\n\n  var nx = c.redSqr().redISub(this.x.redAdd(this.x));\n  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);\n  return this.curve.point(nx, ny);\n};\n\nPoint.prototype.getX = function getX() {\n  return this.x.fromRed();\n};\n\nPoint.prototype.getY = function getY() {\n  return this.y.fromRed();\n};\n\nPoint.prototype.mul = function mul(k) {\n  k = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(k, 16);\n  if (this.isInfinity())\n    return this;\n  else if (this._hasDoubles(k))\n    return this.curve._fixedNafMul(this, k);\n  else if (this.curve.endo)\n    return this.curve._endoWnafMulAdd([ this ], [ k ]);\n  else\n    return this.curve._wnafMul(this, k);\n};\n\nPoint.prototype.mulAdd = function mulAdd(k1, p2, k2) {\n  var points = [ this, p2 ];\n  var coeffs = [ k1, k2 ];\n  if (this.curve.endo)\n    return this.curve._endoWnafMulAdd(points, coeffs);\n  else\n    return this.curve._wnafMulAdd(1, points, coeffs, 2);\n};\n\nPoint.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {\n  var points = [ this, p2 ];\n  var coeffs = [ k1, k2 ];\n  if (this.curve.endo)\n    return this.curve._endoWnafMulAdd(points, coeffs, true);\n  else\n    return this.curve._wnafMulAdd(1, points, coeffs, 2, true);\n};\n\nPoint.prototype.eq = function eq(p) {\n  return this === p ||\n         this.inf === p.inf &&\n             (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);\n};\n\nPoint.prototype.neg = function neg(_precompute) {\n  if (this.inf)\n    return this;\n\n  var res = this.curve.point(this.x, this.y.redNeg());\n  if (_precompute && this.precomputed) {\n    var pre = this.precomputed;\n    var negate = function(p) {\n      return p.neg();\n    };\n    res.precomputed = {\n      naf: pre.naf && {\n        wnd: pre.naf.wnd,\n        points: pre.naf.points.map(negate),\n      },\n      doubles: pre.doubles && {\n        step: pre.doubles.step,\n        points: pre.doubles.points.map(negate),\n      },\n    };\n  }\n  return res;\n};\n\nPoint.prototype.toJ = function toJ() {\n  if (this.inf)\n    return this.curve.jpoint(null, null, null);\n\n  var res = this.curve.jpoint(this.x, this.y, this.curve.one);\n  return res;\n};\n\nfunction JPoint(curve, x, y, z) {\n  base.BasePoint.call(this, curve, 'jacobian');\n  if (x === null && y === null && z === null) {\n    this.x = this.curve.one;\n    this.y = this.curve.one;\n    this.z = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(0);\n  } else {\n    this.x = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(x, 16);\n    this.y = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(y, 16);\n    this.z = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(z, 16);\n  }\n  if (!this.x.red)\n    this.x = this.x.toRed(this.curve.red);\n  if (!this.y.red)\n    this.y = this.y.toRed(this.curve.red);\n  if (!this.z.red)\n    this.z = this.z.toRed(this.curve.red);\n\n  this.zOne = this.z === this.curve.one;\n}\ninherits_browser(JPoint, base.BasePoint);\n\nShortCurve.prototype.jpoint = function jpoint(x, y, z) {\n  return new JPoint(this, x, y, z);\n};\n\nJPoint.prototype.toP = function toP() {\n  if (this.isInfinity())\n    return this.curve.point(null, null);\n\n  var zinv = this.z.redInvm();\n  var zinv2 = zinv.redSqr();\n  var ax = this.x.redMul(zinv2);\n  var ay = this.y.redMul(zinv2).redMul(zinv);\n\n  return this.curve.point(ax, ay);\n};\n\nJPoint.prototype.neg = function neg() {\n  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);\n};\n\nJPoint.prototype.add = function add(p) {\n  // O + P = P\n  if (this.isInfinity())\n    return p;\n\n  // P + O = P\n  if (p.isInfinity())\n    return this;\n\n  // 12M + 4S + 7A\n  var pz2 = p.z.redSqr();\n  var z2 = this.z.redSqr();\n  var u1 = this.x.redMul(pz2);\n  var u2 = p.x.redMul(z2);\n  var s1 = this.y.redMul(pz2.redMul(p.z));\n  var s2 = p.y.redMul(z2.redMul(this.z));\n\n  var h = u1.redSub(u2);\n  var r = s1.redSub(s2);\n  if (h.cmpn(0) === 0) {\n    if (r.cmpn(0) !== 0)\n      return this.curve.jpoint(null, null, null);\n    else\n      return this.dbl();\n  }\n\n  var h2 = h.redSqr();\n  var h3 = h2.redMul(h);\n  var v = u1.redMul(h2);\n\n  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);\n  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));\n  var nz = this.z.redMul(p.z).redMul(h);\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype.mixedAdd = function mixedAdd(p) {\n  // O + P = P\n  if (this.isInfinity())\n    return p.toJ();\n\n  // P + O = P\n  if (p.isInfinity())\n    return this;\n\n  // 8M + 3S + 7A\n  var z2 = this.z.redSqr();\n  var u1 = this.x;\n  var u2 = p.x.redMul(z2);\n  var s1 = this.y;\n  var s2 = p.y.redMul(z2).redMul(this.z);\n\n  var h = u1.redSub(u2);\n  var r = s1.redSub(s2);\n  if (h.cmpn(0) === 0) {\n    if (r.cmpn(0) !== 0)\n      return this.curve.jpoint(null, null, null);\n    else\n      return this.dbl();\n  }\n\n  var h2 = h.redSqr();\n  var h3 = h2.redMul(h);\n  var v = u1.redMul(h2);\n\n  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);\n  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));\n  var nz = this.z.redMul(h);\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype.dblp = function dblp(pow) {\n  if (pow === 0)\n    return this;\n  if (this.isInfinity())\n    return this;\n  if (!pow)\n    return this.dbl();\n\n  var i;\n  if (this.curve.zeroA || this.curve.threeA) {\n    var r = this;\n    for (i = 0; i < pow; i++)\n      r = r.dbl();\n    return r;\n  }\n\n  // 1M + 2S + 1A + N * (4S + 5M + 8A)\n  // N = 1 => 6M + 6S + 9A\n  var a = this.curve.a;\n  var tinv = this.curve.tinv;\n\n  var jx = this.x;\n  var jy = this.y;\n  var jz = this.z;\n  var jz4 = jz.redSqr().redSqr();\n\n  // Reuse results\n  var jyd = jy.redAdd(jy);\n  for (i = 0; i < pow; i++) {\n    var jx2 = jx.redSqr();\n    var jyd2 = jyd.redSqr();\n    var jyd4 = jyd2.redSqr();\n    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));\n\n    var t1 = jx.redMul(jyd2);\n    var nx = c.redSqr().redISub(t1.redAdd(t1));\n    var t2 = t1.redISub(nx);\n    var dny = c.redMul(t2);\n    dny = dny.redIAdd(dny).redISub(jyd4);\n    var nz = jyd.redMul(jz);\n    if (i + 1 < pow)\n      jz4 = jz4.redMul(jyd4);\n\n    jx = nx;\n    jz = nz;\n    jyd = dny;\n  }\n\n  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);\n};\n\nJPoint.prototype.dbl = function dbl() {\n  if (this.isInfinity())\n    return this;\n\n  if (this.curve.zeroA)\n    return this._zeroDbl();\n  else if (this.curve.threeA)\n    return this._threeDbl();\n  else\n    return this._dbl();\n};\n\nJPoint.prototype._zeroDbl = function _zeroDbl() {\n  var nx;\n  var ny;\n  var nz;\n  // Z = 1\n  if (this.zOne) {\n    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html\n    //     #doubling-mdbl-2007-bl\n    // 1M + 5S + 14A\n\n    // XX = X1^2\n    var xx = this.x.redSqr();\n    // YY = Y1^2\n    var yy = this.y.redSqr();\n    // YYYY = YY^2\n    var yyyy = yy.redSqr();\n    // S = 2 * ((X1 + YY)^2 - XX - YYYY)\n    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);\n    s = s.redIAdd(s);\n    // M = 3 * XX + a; a = 0\n    var m = xx.redAdd(xx).redIAdd(xx);\n    // T = M ^ 2 - 2*S\n    var t = m.redSqr().redISub(s).redISub(s);\n\n    // 8 * YYYY\n    var yyyy8 = yyyy.redIAdd(yyyy);\n    yyyy8 = yyyy8.redIAdd(yyyy8);\n    yyyy8 = yyyy8.redIAdd(yyyy8);\n\n    // X3 = T\n    nx = t;\n    // Y3 = M * (S - T) - 8 * YYYY\n    ny = m.redMul(s.redISub(t)).redISub(yyyy8);\n    // Z3 = 2*Y1\n    nz = this.y.redAdd(this.y);\n  } else {\n    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html\n    //     #doubling-dbl-2009-l\n    // 2M + 5S + 13A\n\n    // A = X1^2\n    var a = this.x.redSqr();\n    // B = Y1^2\n    var b = this.y.redSqr();\n    // C = B^2\n    var c = b.redSqr();\n    // D = 2 * ((X1 + B)^2 - A - C)\n    var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);\n    d = d.redIAdd(d);\n    // E = 3 * A\n    var e = a.redAdd(a).redIAdd(a);\n    // F = E^2\n    var f = e.redSqr();\n\n    // 8 * C\n    var c8 = c.redIAdd(c);\n    c8 = c8.redIAdd(c8);\n    c8 = c8.redIAdd(c8);\n\n    // X3 = F - 2 * D\n    nx = f.redISub(d).redISub(d);\n    // Y3 = E * (D - X3) - 8 * C\n    ny = e.redMul(d.redISub(nx)).redISub(c8);\n    // Z3 = 2 * Y1 * Z1\n    nz = this.y.redMul(this.z);\n    nz = nz.redIAdd(nz);\n  }\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype._threeDbl = function _threeDbl() {\n  var nx;\n  var ny;\n  var nz;\n  // Z = 1\n  if (this.zOne) {\n    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html\n    //     #doubling-mdbl-2007-bl\n    // 1M + 5S + 15A\n\n    // XX = X1^2\n    var xx = this.x.redSqr();\n    // YY = Y1^2\n    var yy = this.y.redSqr();\n    // YYYY = YY^2\n    var yyyy = yy.redSqr();\n    // S = 2 * ((X1 + YY)^2 - XX - YYYY)\n    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);\n    s = s.redIAdd(s);\n    // M = 3 * XX + a\n    var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);\n    // T = M^2 - 2 * S\n    var t = m.redSqr().redISub(s).redISub(s);\n    // X3 = T\n    nx = t;\n    // Y3 = M * (S - T) - 8 * YYYY\n    var yyyy8 = yyyy.redIAdd(yyyy);\n    yyyy8 = yyyy8.redIAdd(yyyy8);\n    yyyy8 = yyyy8.redIAdd(yyyy8);\n    ny = m.redMul(s.redISub(t)).redISub(yyyy8);\n    // Z3 = 2 * Y1\n    nz = this.y.redAdd(this.y);\n  } else {\n    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b\n    // 3M + 5S\n\n    // delta = Z1^2\n    var delta = this.z.redSqr();\n    // gamma = Y1^2\n    var gamma = this.y.redSqr();\n    // beta = X1 * gamma\n    var beta = this.x.redMul(gamma);\n    // alpha = 3 * (X1 - delta) * (X1 + delta)\n    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));\n    alpha = alpha.redAdd(alpha).redIAdd(alpha);\n    // X3 = alpha^2 - 8 * beta\n    var beta4 = beta.redIAdd(beta);\n    beta4 = beta4.redIAdd(beta4);\n    var beta8 = beta4.redAdd(beta4);\n    nx = alpha.redSqr().redISub(beta8);\n    // Z3 = (Y1 + Z1)^2 - gamma - delta\n    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);\n    // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2\n    var ggamma8 = gamma.redSqr();\n    ggamma8 = ggamma8.redIAdd(ggamma8);\n    ggamma8 = ggamma8.redIAdd(ggamma8);\n    ggamma8 = ggamma8.redIAdd(ggamma8);\n    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);\n  }\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype._dbl = function _dbl() {\n  var a = this.curve.a;\n\n  // 4M + 6S + 10A\n  var jx = this.x;\n  var jy = this.y;\n  var jz = this.z;\n  var jz4 = jz.redSqr().redSqr();\n\n  var jx2 = jx.redSqr();\n  var jy2 = jy.redSqr();\n\n  var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));\n\n  var jxd4 = jx.redAdd(jx);\n  jxd4 = jxd4.redIAdd(jxd4);\n  var t1 = jxd4.redMul(jy2);\n  var nx = c.redSqr().redISub(t1.redAdd(t1));\n  var t2 = t1.redISub(nx);\n\n  var jyd8 = jy2.redSqr();\n  jyd8 = jyd8.redIAdd(jyd8);\n  jyd8 = jyd8.redIAdd(jyd8);\n  jyd8 = jyd8.redIAdd(jyd8);\n  var ny = c.redMul(t2).redISub(jyd8);\n  var nz = jy.redAdd(jy).redMul(jz);\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype.trpl = function trpl() {\n  if (!this.curve.zeroA)\n    return this.dbl().add(this);\n\n  // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#tripling-tpl-2007-bl\n  // 5M + 10S + ...\n\n  // XX = X1^2\n  var xx = this.x.redSqr();\n  // YY = Y1^2\n  var yy = this.y.redSqr();\n  // ZZ = Z1^2\n  var zz = this.z.redSqr();\n  // YYYY = YY^2\n  var yyyy = yy.redSqr();\n  // M = 3 * XX + a * ZZ2; a = 0\n  var m = xx.redAdd(xx).redIAdd(xx);\n  // MM = M^2\n  var mm = m.redSqr();\n  // E = 6 * ((X1 + YY)^2 - XX - YYYY) - MM\n  var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);\n  e = e.redIAdd(e);\n  e = e.redAdd(e).redIAdd(e);\n  e = e.redISub(mm);\n  // EE = E^2\n  var ee = e.redSqr();\n  // T = 16*YYYY\n  var t = yyyy.redIAdd(yyyy);\n  t = t.redIAdd(t);\n  t = t.redIAdd(t);\n  t = t.redIAdd(t);\n  // U = (M + E)^2 - MM - EE - T\n  var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);\n  // X3 = 4 * (X1 * EE - 4 * YY * U)\n  var yyu4 = yy.redMul(u);\n  yyu4 = yyu4.redIAdd(yyu4);\n  yyu4 = yyu4.redIAdd(yyu4);\n  var nx = this.x.redMul(ee).redISub(yyu4);\n  nx = nx.redIAdd(nx);\n  nx = nx.redIAdd(nx);\n  // Y3 = 8 * Y1 * (U * (T - U) - E * EE)\n  var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));\n  ny = ny.redIAdd(ny);\n  ny = ny.redIAdd(ny);\n  ny = ny.redIAdd(ny);\n  // Z3 = (Z1 + E)^2 - ZZ - EE\n  var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype.mul = function mul(k, kbase) {\n  k = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(k, kbase);\n\n  return this.curve._wnafMul(this, k);\n};\n\nJPoint.prototype.eq = function eq(p) {\n  if (p.type === 'affine')\n    return this.eq(p.toJ());\n\n  if (this === p)\n    return true;\n\n  // x1 * z2^2 == x2 * z1^2\n  var z2 = this.z.redSqr();\n  var pz2 = p.z.redSqr();\n  if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)\n    return false;\n\n  // y1 * z2^3 == y2 * z1^3\n  var z3 = z2.redMul(this.z);\n  var pz3 = pz2.redMul(p.z);\n  return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;\n};\n\nJPoint.prototype.eqXToP = function eqXToP(x) {\n  var zs = this.z.redSqr();\n  var rx = x.toRed(this.curve.red).redMul(zs);\n  if (this.x.cmp(rx) === 0)\n    return true;\n\n  var xc = x.clone();\n  var t = this.curve.redN.redMul(zs);\n  for (;;) {\n    xc.iadd(this.curve.n);\n    if (xc.cmp(this.curve.p) >= 0)\n      return false;\n\n    rx.redIAdd(t);\n    if (this.x.cmp(rx) === 0)\n      return true;\n  }\n};\n\nJPoint.prototype.inspect = function inspect() {\n  if (this.isInfinity())\n    return '<EC JPoint Infinity>';\n  return '<EC JPoint x: ' + this.x.toString(16, 2) +\n      ' y: ' + this.y.toString(16, 2) +\n      ' z: ' + this.z.toString(16, 2) + '>';\n};\n\nJPoint.prototype.isInfinity = function isInfinity() {\n  // XXX This code assumes that zero is always zero in red\n  return this.z.cmpn(0) === 0;\n};\n\nvar curve_1 = createCommonjsModule(function (module, exports) {\n'use strict';\n\nvar curve = exports;\n\ncurve.base = base;\ncurve.short = short_1;\ncurve.mont = /*RicMoo:ethers:require(./mont)*/(null);\ncurve.edwards = /*RicMoo:ethers:require(./edwards)*/(null);\n});\n\nvar curves_1 = createCommonjsModule(function (module, exports) {\n'use strict';\n\nvar curves = exports;\n\n\n\n\n\nvar assert = utils_1$1.assert;\n\nfunction PresetCurve(options) {\n  if (options.type === 'short')\n    this.curve = new curve_1.short(options);\n  else if (options.type === 'edwards')\n    this.curve = new curve_1.edwards(options);\n  else\n    this.curve = new curve_1.mont(options);\n  this.g = this.curve.g;\n  this.n = this.curve.n;\n  this.hash = options.hash;\n\n  assert(this.g.validate(), 'Invalid curve');\n  assert(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O');\n}\ncurves.PresetCurve = PresetCurve;\n\nfunction defineCurve(name, options) {\n  Object.defineProperty(curves, name, {\n    configurable: true,\n    enumerable: true,\n    get: function() {\n      var curve = new PresetCurve(options);\n      Object.defineProperty(curves, name, {\n        configurable: true,\n        enumerable: true,\n        value: curve,\n      });\n      return curve;\n    },\n  });\n}\n\ndefineCurve('p192', {\n  type: 'short',\n  prime: 'p192',\n  p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',\n  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',\n  b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',\n  n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',\n  hash: (hash_js__WEBPACK_IMPORTED_MODULE_1___default().sha256),\n  gRed: false,\n  g: [\n    '188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012',\n    '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811',\n  ],\n});\n\ndefineCurve('p224', {\n  type: 'short',\n  prime: 'p224',\n  p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',\n  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',\n  b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',\n  n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',\n  hash: (hash_js__WEBPACK_IMPORTED_MODULE_1___default().sha256),\n  gRed: false,\n  g: [\n    'b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21',\n    'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34',\n  ],\n});\n\ndefineCurve('p256', {\n  type: 'short',\n  prime: null,\n  p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',\n  a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',\n  b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',\n  n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',\n  hash: (hash_js__WEBPACK_IMPORTED_MODULE_1___default().sha256),\n  gRed: false,\n  g: [\n    '6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296',\n    '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5',\n  ],\n});\n\ndefineCurve('p384', {\n  type: 'short',\n  prime: null,\n  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'fffffffe ffffffff 00000000 00000000 ffffffff',\n  a: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'fffffffe ffffffff 00000000 00000000 fffffffc',\n  b: 'b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f ' +\n     '5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef',\n  n: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 ' +\n     'f4372ddf 581a0db2 48b0a77a ecec196a ccc52973',\n  hash: (hash_js__WEBPACK_IMPORTED_MODULE_1___default().sha384),\n  gRed: false,\n  g: [\n    'aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 ' +\n    '5502f25d bf55296c 3a545e38 72760ab7',\n    '3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 ' +\n    '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f',\n  ],\n});\n\ndefineCurve('p521', {\n  type: 'short',\n  prime: null,\n  p: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff ffffffff ffffffff ffffffff',\n  a: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff ffffffff ffffffff fffffffc',\n  b: '00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b ' +\n     '99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd ' +\n     '3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00',\n  n: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 ' +\n     'f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409',\n  hash: (hash_js__WEBPACK_IMPORTED_MODULE_1___default().sha512),\n  gRed: false,\n  g: [\n    '000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 ' +\n    '053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 ' +\n    'a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66',\n    '00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 ' +\n    '579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 ' +\n    '3fad0761 353c7086 a272c240 88be9476 9fd16650',\n  ],\n});\n\ndefineCurve('curve25519', {\n  type: 'mont',\n  prime: 'p25519',\n  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',\n  a: '76d06',\n  b: '1',\n  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',\n  hash: (hash_js__WEBPACK_IMPORTED_MODULE_1___default().sha256),\n  gRed: false,\n  g: [\n    '9',\n  ],\n});\n\ndefineCurve('ed25519', {\n  type: 'edwards',\n  prime: 'p25519',\n  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',\n  a: '-1',\n  c: '1',\n  // -121665 * (121666^(-1)) (mod P)\n  d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',\n  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',\n  hash: (hash_js__WEBPACK_IMPORTED_MODULE_1___default().sha256),\n  gRed: false,\n  g: [\n    '216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a',\n\n    // 4/5\n    '6666666666666666666666666666666666666666666666666666666666666658',\n  ],\n});\n\nvar pre;\ntry {\n  pre = /*RicMoo:ethers:require(./precomputed/secp256k1)*/(null).crash();\n} catch (e) {\n  pre = undefined;\n}\n\ndefineCurve('secp256k1', {\n  type: 'short',\n  prime: 'k256',\n  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',\n  a: '0',\n  b: '7',\n  n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',\n  h: '1',\n  hash: (hash_js__WEBPACK_IMPORTED_MODULE_1___default().sha256),\n\n  // Precomputed endomorphism\n  beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',\n  lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',\n  basis: [\n    {\n      a: '3086d221a7d46bcde86c90e49284eb15',\n      b: '-e4437ed6010e88286f547fa90abfe4c3',\n    },\n    {\n      a: '114ca50f7a8e2f3f657c1108d9d44cfd8',\n      b: '3086d221a7d46bcde86c90e49284eb15',\n    },\n  ],\n\n  gRed: false,\n  g: [\n    '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',\n    '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',\n    pre,\n  ],\n});\n});\n\n'use strict';\n\n\n\n\n\nfunction HmacDRBG(options) {\n  if (!(this instanceof HmacDRBG))\n    return new HmacDRBG(options);\n  this.hash = options.hash;\n  this.predResist = !!options.predResist;\n\n  this.outLen = this.hash.outSize;\n  this.minEntropy = options.minEntropy || this.hash.hmacStrength;\n\n  this._reseed = null;\n  this.reseedInterval = null;\n  this.K = null;\n  this.V = null;\n\n  var entropy = utils_1.toArray(options.entropy, options.entropyEnc || 'hex');\n  var nonce = utils_1.toArray(options.nonce, options.nonceEnc || 'hex');\n  var pers = utils_1.toArray(options.pers, options.persEnc || 'hex');\n  minimalisticAssert(entropy.length >= (this.minEntropy / 8),\n         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');\n  this._init(entropy, nonce, pers);\n}\nvar hmacDrbg = HmacDRBG;\n\nHmacDRBG.prototype._init = function init(entropy, nonce, pers) {\n  var seed = entropy.concat(nonce).concat(pers);\n\n  this.K = new Array(this.outLen / 8);\n  this.V = new Array(this.outLen / 8);\n  for (var i = 0; i < this.V.length; i++) {\n    this.K[i] = 0x00;\n    this.V[i] = 0x01;\n  }\n\n  this._update(seed);\n  this._reseed = 1;\n  this.reseedInterval = 0x1000000000000;  // 2^48\n};\n\nHmacDRBG.prototype._hmac = function hmac() {\n  return new (hash_js__WEBPACK_IMPORTED_MODULE_1___default().hmac)(this.hash, this.K);\n};\n\nHmacDRBG.prototype._update = function update(seed) {\n  var kmac = this._hmac()\n                 .update(this.V)\n                 .update([ 0x00 ]);\n  if (seed)\n    kmac = kmac.update(seed);\n  this.K = kmac.digest();\n  this.V = this._hmac().update(this.V).digest();\n  if (!seed)\n    return;\n\n  this.K = this._hmac()\n               .update(this.V)\n               .update([ 0x01 ])\n               .update(seed)\n               .digest();\n  this.V = this._hmac().update(this.V).digest();\n};\n\nHmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {\n  // Optional entropy enc\n  if (typeof entropyEnc !== 'string') {\n    addEnc = add;\n    add = entropyEnc;\n    entropyEnc = null;\n  }\n\n  entropy = utils_1.toArray(entropy, entropyEnc);\n  add = utils_1.toArray(add, addEnc);\n\n  minimalisticAssert(entropy.length >= (this.minEntropy / 8),\n         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');\n\n  this._update(entropy.concat(add || []));\n  this._reseed = 1;\n};\n\nHmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {\n  if (this._reseed > this.reseedInterval)\n    throw new Error('Reseed is required');\n\n  // Optional encoding\n  if (typeof enc !== 'string') {\n    addEnc = add;\n    add = enc;\n    enc = null;\n  }\n\n  // Optional additional data\n  if (add) {\n    add = utils_1.toArray(add, addEnc || 'hex');\n    this._update(add);\n  }\n\n  var temp = [];\n  while (temp.length < len) {\n    this.V = this._hmac().update(this.V).digest();\n    temp = temp.concat(this.V);\n  }\n\n  var res = temp.slice(0, len);\n  this._update(add);\n  this._reseed++;\n  return utils_1.encode(res, enc);\n};\n\n'use strict';\n\n\n\nvar assert$3 = utils_1$1.assert;\n\nfunction KeyPair(ec, options) {\n  this.ec = ec;\n  this.priv = null;\n  this.pub = null;\n\n  // KeyPair(ec, { priv: ..., pub: ... })\n  if (options.priv)\n    this._importPrivate(options.priv, options.privEnc);\n  if (options.pub)\n    this._importPublic(options.pub, options.pubEnc);\n}\nvar key = KeyPair;\n\nKeyPair.fromPublic = function fromPublic(ec, pub, enc) {\n  if (pub instanceof KeyPair)\n    return pub;\n\n  return new KeyPair(ec, {\n    pub: pub,\n    pubEnc: enc,\n  });\n};\n\nKeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {\n  if (priv instanceof KeyPair)\n    return priv;\n\n  return new KeyPair(ec, {\n    priv: priv,\n    privEnc: enc,\n  });\n};\n\nKeyPair.prototype.validate = function validate() {\n  var pub = this.getPublic();\n\n  if (pub.isInfinity())\n    return { result: false, reason: 'Invalid public key' };\n  if (!pub.validate())\n    return { result: false, reason: 'Public key is not a point' };\n  if (!pub.mul(this.ec.curve.n).isInfinity())\n    return { result: false, reason: 'Public key * N != O' };\n\n  return { result: true, reason: null };\n};\n\nKeyPair.prototype.getPublic = function getPublic(compact, enc) {\n  // compact is optional argument\n  if (typeof compact === 'string') {\n    enc = compact;\n    compact = null;\n  }\n\n  if (!this.pub)\n    this.pub = this.ec.g.mul(this.priv);\n\n  if (!enc)\n    return this.pub;\n\n  return this.pub.encode(enc, compact);\n};\n\nKeyPair.prototype.getPrivate = function getPrivate(enc) {\n  if (enc === 'hex')\n    return this.priv.toString(16, 2);\n  else\n    return this.priv;\n};\n\nKeyPair.prototype._importPrivate = function _importPrivate(key, enc) {\n  this.priv = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(key, enc || 16);\n\n  // Ensure that the priv won't be bigger than n, otherwise we may fail\n  // in fixed multiplication method\n  this.priv = this.priv.umod(this.ec.curve.n);\n};\n\nKeyPair.prototype._importPublic = function _importPublic(key, enc) {\n  if (key.x || key.y) {\n    // Montgomery points only have an `x` coordinate.\n    // Weierstrass/Edwards points on the other hand have both `x` and\n    // `y` coordinates.\n    if (this.ec.curve.type === 'mont') {\n      assert$3(key.x, 'Need x coordinate');\n    } else if (this.ec.curve.type === 'short' ||\n               this.ec.curve.type === 'edwards') {\n      assert$3(key.x && key.y, 'Need both x and y coordinate');\n    }\n    this.pub = this.ec.curve.point(key.x, key.y);\n    return;\n  }\n  this.pub = this.ec.curve.decodePoint(key, enc);\n};\n\n// ECDH\nKeyPair.prototype.derive = function derive(pub) {\n  if(!pub.validate()) {\n    assert$3(pub.validate(), 'public point not validated');\n  }\n  return pub.mul(this.priv).getX();\n};\n\n// ECDSA\nKeyPair.prototype.sign = function sign(msg, enc, options) {\n  return this.ec.sign(msg, this, enc, options);\n};\n\nKeyPair.prototype.verify = function verify(msg, signature) {\n  return this.ec.verify(msg, signature, this);\n};\n\nKeyPair.prototype.inspect = function inspect() {\n  return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) +\n         ' pub: ' + (this.pub && this.pub.inspect()) + ' >';\n};\n\n'use strict';\n\n\n\n\nvar assert$4 = utils_1$1.assert;\n\nfunction Signature(options, enc) {\n  if (options instanceof Signature)\n    return options;\n\n  if (this._importDER(options, enc))\n    return;\n\n  assert$4(options.r && options.s, 'Signature without r or s');\n  this.r = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(options.r, 16);\n  this.s = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(options.s, 16);\n  if (options.recoveryParam === undefined)\n    this.recoveryParam = null;\n  else\n    this.recoveryParam = options.recoveryParam;\n}\nvar signature = Signature;\n\nfunction Position() {\n  this.place = 0;\n}\n\nfunction getLength(buf, p) {\n  var initial = buf[p.place++];\n  if (!(initial & 0x80)) {\n    return initial;\n  }\n  var octetLen = initial & 0xf;\n\n  // Indefinite length or overflow\n  if (octetLen === 0 || octetLen > 4) {\n    return false;\n  }\n\n  var val = 0;\n  for (var i = 0, off = p.place; i < octetLen; i++, off++) {\n    val <<= 8;\n    val |= buf[off];\n    val >>>= 0;\n  }\n\n  // Leading zeroes\n  if (val <= 0x7f) {\n    return false;\n  }\n\n  p.place = off;\n  return val;\n}\n\nfunction rmPadding(buf) {\n  var i = 0;\n  var len = buf.length - 1;\n  while (!buf[i] && !(buf[i + 1] & 0x80) && i < len) {\n    i++;\n  }\n  if (i === 0) {\n    return buf;\n  }\n  return buf.slice(i);\n}\n\nSignature.prototype._importDER = function _importDER(data, enc) {\n  data = utils_1$1.toArray(data, enc);\n  var p = new Position();\n  if (data[p.place++] !== 0x30) {\n    return false;\n  }\n  var len = getLength(data, p);\n  if (len === false) {\n    return false;\n  }\n  if ((len + p.place) !== data.length) {\n    return false;\n  }\n  if (data[p.place++] !== 0x02) {\n    return false;\n  }\n  var rlen = getLength(data, p);\n  if (rlen === false) {\n    return false;\n  }\n  var r = data.slice(p.place, rlen + p.place);\n  p.place += rlen;\n  if (data[p.place++] !== 0x02) {\n    return false;\n  }\n  var slen = getLength(data, p);\n  if (slen === false) {\n    return false;\n  }\n  if (data.length !== slen + p.place) {\n    return false;\n  }\n  var s = data.slice(p.place, slen + p.place);\n  if (r[0] === 0) {\n    if (r[1] & 0x80) {\n      r = r.slice(1);\n    } else {\n      // Leading zeroes\n      return false;\n    }\n  }\n  if (s[0] === 0) {\n    if (s[1] & 0x80) {\n      s = s.slice(1);\n    } else {\n      // Leading zeroes\n      return false;\n    }\n  }\n\n  this.r = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(r);\n  this.s = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(s);\n  this.recoveryParam = null;\n\n  return true;\n};\n\nfunction constructLength(arr, len) {\n  if (len < 0x80) {\n    arr.push(len);\n    return;\n  }\n  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);\n  arr.push(octets | 0x80);\n  while (--octets) {\n    arr.push((len >>> (octets << 3)) & 0xff);\n  }\n  arr.push(len);\n}\n\nSignature.prototype.toDER = function toDER(enc) {\n  var r = this.r.toArray();\n  var s = this.s.toArray();\n\n  // Pad values\n  if (r[0] & 0x80)\n    r = [ 0 ].concat(r);\n  // Pad values\n  if (s[0] & 0x80)\n    s = [ 0 ].concat(s);\n\n  r = rmPadding(r);\n  s = rmPadding(s);\n\n  while (!s[0] && !(s[1] & 0x80)) {\n    s = s.slice(1);\n  }\n  var arr = [ 0x02 ];\n  constructLength(arr, r.length);\n  arr = arr.concat(r);\n  arr.push(0x02);\n  constructLength(arr, s.length);\n  var backHalf = arr.concat(s);\n  var res = [ 0x30 ];\n  constructLength(res, backHalf.length);\n  res = res.concat(backHalf);\n  return utils_1$1.encode(res, enc);\n};\n\n'use strict';\n\n\n\n\n\nvar rand = /*RicMoo:ethers:require(brorand)*/(function() { throw new Error('unsupported'); });\nvar assert$5 = utils_1$1.assert;\n\n\n\n\nfunction EC(options) {\n  if (!(this instanceof EC))\n    return new EC(options);\n\n  // Shortcut `elliptic.ec(curve-name)`\n  if (typeof options === 'string') {\n    assert$5(Object.prototype.hasOwnProperty.call(curves_1, options),\n      'Unknown curve ' + options);\n\n    options = curves_1[options];\n  }\n\n  // Shortcut for `elliptic.ec(elliptic.curves.curveName)`\n  if (options instanceof curves_1.PresetCurve)\n    options = { curve: options };\n\n  this.curve = options.curve.curve;\n  this.n = this.curve.n;\n  this.nh = this.n.ushrn(1);\n  this.g = this.curve.g;\n\n  // Point on curve\n  this.g = options.curve.g;\n  this.g.precompute(options.curve.n.bitLength() + 1);\n\n  // Hash for function for DRBG\n  this.hash = options.hash || options.curve.hash;\n}\nvar ec = EC;\n\nEC.prototype.keyPair = function keyPair(options) {\n  return new key(this, options);\n};\n\nEC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {\n  return key.fromPrivate(this, priv, enc);\n};\n\nEC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {\n  return key.fromPublic(this, pub, enc);\n};\n\nEC.prototype.genKeyPair = function genKeyPair(options) {\n  if (!options)\n    options = {};\n\n  // Instantiate Hmac_DRBG\n  var drbg = new hmacDrbg({\n    hash: this.hash,\n    pers: options.pers,\n    persEnc: options.persEnc || 'utf8',\n    entropy: options.entropy || rand(this.hash.hmacStrength),\n    entropyEnc: options.entropy && options.entropyEnc || 'utf8',\n    nonce: this.n.toArray(),\n  });\n\n  var bytes = this.n.byteLength();\n  var ns2 = this.n.sub(new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(2));\n  for (;;) {\n    var priv = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(drbg.generate(bytes));\n    if (priv.cmp(ns2) > 0)\n      continue;\n\n    priv.iaddn(1);\n    return this.keyFromPrivate(priv);\n  }\n};\n\nEC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {\n  var delta = msg.byteLength() * 8 - this.n.bitLength();\n  if (delta > 0)\n    msg = msg.ushrn(delta);\n  if (!truncOnly && msg.cmp(this.n) >= 0)\n    return msg.sub(this.n);\n  else\n    return msg;\n};\n\nEC.prototype.sign = function sign(msg, key, enc, options) {\n  if (typeof enc === 'object') {\n    options = enc;\n    enc = null;\n  }\n  if (!options)\n    options = {};\n\n  key = this.keyFromPrivate(key, enc);\n  msg = this._truncateToN(new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(msg, 16));\n\n  // Zero-extend key to provide enough entropy\n  var bytes = this.n.byteLength();\n  var bkey = key.getPrivate().toArray('be', bytes);\n\n  // Zero-extend nonce to have the same byte size as N\n  var nonce = msg.toArray('be', bytes);\n\n  // Instantiate Hmac_DRBG\n  var drbg = new hmacDrbg({\n    hash: this.hash,\n    entropy: bkey,\n    nonce: nonce,\n    pers: options.pers,\n    persEnc: options.persEnc || 'utf8',\n  });\n\n  // Number of bytes to generate\n  var ns1 = this.n.sub(new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(1));\n\n  for (var iter = 0; ; iter++) {\n    var k = options.k ?\n      options.k(iter) :\n      new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(drbg.generate(this.n.byteLength()));\n    k = this._truncateToN(k, true);\n    if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)\n      continue;\n\n    var kp = this.g.mul(k);\n    if (kp.isInfinity())\n      continue;\n\n    var kpX = kp.getX();\n    var r = kpX.umod(this.n);\n    if (r.cmpn(0) === 0)\n      continue;\n\n    var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));\n    s = s.umod(this.n);\n    if (s.cmpn(0) === 0)\n      continue;\n\n    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) |\n                        (kpX.cmp(r) !== 0 ? 2 : 0);\n\n    // Use complement of `s`, if it is > `n / 2`\n    if (options.canonical && s.cmp(this.nh) > 0) {\n      s = this.n.sub(s);\n      recoveryParam ^= 1;\n    }\n\n    return new signature({ r: r, s: s, recoveryParam: recoveryParam });\n  }\n};\n\nEC.prototype.verify = function verify(msg, signature$1, key, enc) {\n  msg = this._truncateToN(new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(msg, 16));\n  key = this.keyFromPublic(key, enc);\n  signature$1 = new signature(signature$1, 'hex');\n\n  // Perform primitive values validation\n  var r = signature$1.r;\n  var s = signature$1.s;\n  if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)\n    return false;\n  if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)\n    return false;\n\n  // Validate signature\n  var sinv = s.invm(this.n);\n  var u1 = sinv.mul(msg).umod(this.n);\n  var u2 = sinv.mul(r).umod(this.n);\n  var p;\n\n  if (!this.curve._maxwellTrick) {\n    p = this.g.mulAdd(u1, key.getPublic(), u2);\n    if (p.isInfinity())\n      return false;\n\n    return p.getX().umod(this.n).cmp(r) === 0;\n  }\n\n  // NOTE: Greg Maxwell's trick, inspired by:\n  // https://git.io/vad3K\n\n  p = this.g.jmulAdd(u1, key.getPublic(), u2);\n  if (p.isInfinity())\n    return false;\n\n  // Compare `p.x` of Jacobian point with `r`,\n  // this will do `p.x == r * p.z^2` instead of multiplying `p.x` by the\n  // inverse of `p.z^2`\n  return p.eqXToP(r);\n};\n\nEC.prototype.recoverPubKey = function(msg, signature$1, j, enc) {\n  assert$5((3 & j) === j, 'The recovery param is more than two bits');\n  signature$1 = new signature(signature$1, enc);\n\n  var n = this.n;\n  var e = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(msg);\n  var r = signature$1.r;\n  var s = signature$1.s;\n\n  // A set LSB signifies that the y-coordinate is odd\n  var isYOdd = j & 1;\n  var isSecondKey = j >> 1;\n  if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)\n    throw new Error('Unable to find sencond key candinate');\n\n  // 1.1. Let x = r + jn.\n  if (isSecondKey)\n    r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);\n  else\n    r = this.curve.pointFromX(r, isYOdd);\n\n  var rInv = signature$1.r.invm(n);\n  var s1 = n.sub(e).mul(rInv).umod(n);\n  var s2 = s.mul(rInv).umod(n);\n\n  // 1.6.1 Compute Q = r^-1 (sR -  eG)\n  //               Q = r^-1 (sR + -eG)\n  return this.g.mulAdd(s1, r, s2);\n};\n\nEC.prototype.getKeyRecoveryParam = function(e, signature$1, Q, enc) {\n  signature$1 = new signature(signature$1, enc);\n  if (signature$1.recoveryParam !== null)\n    return signature$1.recoveryParam;\n\n  for (var i = 0; i < 4; i++) {\n    var Qprime;\n    try {\n      Qprime = this.recoverPubKey(e, signature$1, i);\n    } catch (e) {\n      continue;\n    }\n\n    if (Qprime.eq(Q))\n      return i;\n  }\n  throw new Error('Unable to find valid recovery factor');\n};\n\nvar elliptic_1 = createCommonjsModule(function (module, exports) {\n'use strict';\n\nvar elliptic = exports;\n\nelliptic.version = /*RicMoo:ethers*/{ version: \"6.5.4\" }.version;\nelliptic.utils = utils_1$1;\nelliptic.rand = /*RicMoo:ethers:require(brorand)*/(function() { throw new Error('unsupported'); });\nelliptic.curve = curve_1;\nelliptic.curves = curves_1;\n\n// Protocols\nelliptic.ec = ec;\nelliptic.eddsa = /*RicMoo:ethers:require(./elliptic/eddsa)*/(null);\n});\n\nvar EC$1 = elliptic_1.ec;\n\n\n//# sourceMappingURL=elliptic.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3NpZ25pbmcta2V5L2xpYi5lc20vZWxsaXB0aWMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBdUI7QUFDSTs7QUFFM0I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUNBQWlDLGlCQUFpQixZQUFZO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQSxJQUFJO0FBQ0osb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FB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O0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFVBQVUsOENBQUU7O0FBRVo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7Ozs7OztBQU1BOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdURBQVc7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHVEQUFXO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx1REFBVztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx1REFBVztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx1REFBVztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx1REFBVztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx1REFBVztBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx1REFBVzs7QUFFbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxDQUFDOztBQUVEOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDOztBQUVBO0FBQ0EsYUFBYSxxREFBUztBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7QUFJQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIscUJBQXFCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLDJCQUEyQiw4Q0FBRTs7QUFFN0IsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQSxVQUFVLDhDQUFFO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCLDBDQUEwQztBQUNyRTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCLDhDQUFFO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyw4Q0FBRTtBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLHNDQUFzQyxrQkFBa0I7QUFDeEQ7QUFDQSxnRUFBZ0UsaUNBQWlDO0FBQ2pHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFc0I7QUFDdEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sZWRnaXR5LXlpZWxkLWZyb250ZW5kLy4uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9zaWduaW5nLWtleS9saWIuZXNtL2VsbGlwdGljLmpzP2RhYmEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEJOIGZyb20gJ2JuLmpzJztcbmltcG9ydCBoYXNoIGZyb20gJ2hhc2guanMnO1xuXG52YXIgY29tbW9uanNHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB7fTtcblxuZnVuY3Rpb24gZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMgKHgpIHtcblx0cmV0dXJuIHggJiYgeC5fX2VzTW9kdWxlICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnZGVmYXVsdCcpID8geFsnZGVmYXVsdCddIDogeDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tbW9uanNNb2R1bGUoZm4sIGJhc2VkaXIsIG1vZHVsZSkge1xuXHRyZXR1cm4gbW9kdWxlID0ge1xuXHRcdHBhdGg6IGJhc2VkaXIsXG5cdFx0ZXhwb3J0czoge30sXG5cdFx0cmVxdWlyZTogZnVuY3Rpb24gKHBhdGgsIGJhc2UpIHtcblx0XHRcdHJldHVybiBjb21tb25qc1JlcXVpcmUocGF0aCwgKGJhc2UgPT09IHVuZGVmaW5lZCB8fCBiYXNlID09PSBudWxsKSA/IG1vZHVsZS5wYXRoIDogYmFzZSk7XG5cdFx0fVxuXHR9LCBmbihtb2R1bGUsIG1vZHVsZS5leHBvcnRzKSwgbW9kdWxlLmV4cG9ydHM7XG59XG5cbmZ1bmN0aW9uIGdldERlZmF1bHRFeHBvcnRGcm9tTmFtZXNwYWNlSWZQcmVzZW50IChuKSB7XG5cdHJldHVybiBuICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChuLCAnZGVmYXVsdCcpID8gblsnZGVmYXVsdCddIDogbjtcbn1cblxuZnVuY3Rpb24gZ2V0RGVmYXVsdEV4cG9ydEZyb21OYW1lc3BhY2VJZk5vdE5hbWVkIChuKSB7XG5cdHJldHVybiBuICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChuLCAnZGVmYXVsdCcpICYmIE9iamVjdC5rZXlzKG4pLmxlbmd0aCA9PT0gMSA/IG5bJ2RlZmF1bHQnXSA6IG47XG59XG5cbmZ1bmN0aW9uIGdldEF1Z21lbnRlZE5hbWVzcGFjZShuKSB7XG5cdGlmIChuLl9fZXNNb2R1bGUpIHJldHVybiBuO1xuXHR2YXIgYSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ19fZXNNb2R1bGUnLCB7dmFsdWU6IHRydWV9KTtcblx0T2JqZWN0LmtleXMobikuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuXHRcdHZhciBkID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihuLCBrKTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoYSwgaywgZC5nZXQgPyBkIDoge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRyZXR1cm4gbltrXTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSk7XG5cdHJldHVybiBhO1xufVxuXG5mdW5jdGlvbiBjb21tb25qc1JlcXVpcmUgKCkge1xuXHR0aHJvdyBuZXcgRXJyb3IoJ0R5bmFtaWMgcmVxdWlyZXMgYXJlIG5vdCBjdXJyZW50bHkgc3VwcG9ydGVkIGJ5IEByb2xsdXAvcGx1Z2luLWNvbW1vbmpzJyk7XG59XG5cbnZhciBtaW5pbWFsaXN0aWNBc3NlcnQgPSBhc3NlcnQ7XG5cbmZ1bmN0aW9uIGFzc2VydCh2YWwsIG1zZykge1xuICBpZiAoIXZhbClcbiAgICB0aHJvdyBuZXcgRXJyb3IobXNnIHx8ICdBc3NlcnRpb24gZmFpbGVkJyk7XG59XG5cbmFzc2VydC5lcXVhbCA9IGZ1bmN0aW9uIGFzc2VydEVxdWFsKGwsIHIsIG1zZykge1xuICBpZiAobCAhPSByKVxuICAgIHRocm93IG5ldyBFcnJvcihtc2cgfHwgKCdBc3NlcnRpb24gZmFpbGVkOiAnICsgbCArICcgIT0gJyArIHIpKTtcbn07XG5cbnZhciB1dGlsc18xID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSBleHBvcnRzO1xuXG5mdW5jdGlvbiB0b0FycmF5KG1zZywgZW5jKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KG1zZykpXG4gICAgcmV0dXJuIG1zZy5zbGljZSgpO1xuICBpZiAoIW1zZylcbiAgICByZXR1cm4gW107XG4gIHZhciByZXMgPSBbXTtcbiAgaWYgKHR5cGVvZiBtc2cgIT09ICdzdHJpbmcnKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyBpKyspXG4gICAgICByZXNbaV0gPSBtc2dbaV0gfCAwO1xuICAgIHJldHVybiByZXM7XG4gIH1cbiAgaWYgKGVuYyA9PT0gJ2hleCcpIHtcbiAgICBtc2cgPSBtc2cucmVwbGFjZSgvW15hLXowLTldKy9pZywgJycpO1xuICAgIGlmIChtc2cubGVuZ3RoICUgMiAhPT0gMClcbiAgICAgIG1zZyA9ICcwJyArIG1zZztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkgKz0gMilcbiAgICAgIHJlcy5wdXNoKHBhcnNlSW50KG1zZ1tpXSArIG1zZ1tpICsgMV0sIDE2KSk7XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjID0gbXNnLmNoYXJDb2RlQXQoaSk7XG4gICAgICB2YXIgaGkgPSBjID4+IDg7XG4gICAgICB2YXIgbG8gPSBjICYgMHhmZjtcbiAgICAgIGlmIChoaSlcbiAgICAgICAgcmVzLnB1c2goaGksIGxvKTtcbiAgICAgIGVsc2VcbiAgICAgICAgcmVzLnB1c2gobG8pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzO1xufVxudXRpbHMudG9BcnJheSA9IHRvQXJyYXk7XG5cbmZ1bmN0aW9uIHplcm8yKHdvcmQpIHtcbiAgaWYgKHdvcmQubGVuZ3RoID09PSAxKVxuICAgIHJldHVybiAnMCcgKyB3b3JkO1xuICBlbHNlXG4gICAgcmV0dXJuIHdvcmQ7XG59XG51dGlscy56ZXJvMiA9IHplcm8yO1xuXG5mdW5jdGlvbiB0b0hleChtc2cpIHtcbiAgdmFyIHJlcyA9ICcnO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkrKylcbiAgICByZXMgKz0gemVybzIobXNnW2ldLnRvU3RyaW5nKDE2KSk7XG4gIHJldHVybiByZXM7XG59XG51dGlscy50b0hleCA9IHRvSGV4O1xuXG51dGlscy5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUoYXJyLCBlbmMpIHtcbiAgaWYgKGVuYyA9PT0gJ2hleCcpXG4gICAgcmV0dXJuIHRvSGV4KGFycik7XG4gIGVsc2VcbiAgICByZXR1cm4gYXJyO1xufTtcbn0pO1xuXG52YXIgdXRpbHNfMSQxID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSBleHBvcnRzO1xuXG5cblxuXG51dGlscy5hc3NlcnQgPSBtaW5pbWFsaXN0aWNBc3NlcnQ7XG51dGlscy50b0FycmF5ID0gdXRpbHNfMS50b0FycmF5O1xudXRpbHMuemVybzIgPSB1dGlsc18xLnplcm8yO1xudXRpbHMudG9IZXggPSB1dGlsc18xLnRvSGV4O1xudXRpbHMuZW5jb2RlID0gdXRpbHNfMS5lbmNvZGU7XG5cbi8vIFJlcHJlc2VudCBudW0gaW4gYSB3LU5BRiBmb3JtXG5mdW5jdGlvbiBnZXROQUYobnVtLCB3LCBiaXRzKSB7XG4gIHZhciBuYWYgPSBuZXcgQXJyYXkoTWF0aC5tYXgobnVtLmJpdExlbmd0aCgpLCBiaXRzKSArIDEpO1xuICBuYWYuZmlsbCgwKTtcblxuICB2YXIgd3MgPSAxIDw8ICh3ICsgMSk7XG4gIHZhciBrID0gbnVtLmNsb25lKCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYWYubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgejtcbiAgICB2YXIgbW9kID0gay5hbmRsbih3cyAtIDEpO1xuICAgIGlmIChrLmlzT2RkKCkpIHtcbiAgICAgIGlmIChtb2QgPiAod3MgPj4gMSkgLSAxKVxuICAgICAgICB6ID0gKHdzID4+IDEpIC0gbW9kO1xuICAgICAgZWxzZVxuICAgICAgICB6ID0gbW9kO1xuICAgICAgay5pc3Vibih6KTtcbiAgICB9IGVsc2Uge1xuICAgICAgeiA9IDA7XG4gICAgfVxuXG4gICAgbmFmW2ldID0gejtcbiAgICBrLml1c2hybigxKTtcbiAgfVxuXG4gIHJldHVybiBuYWY7XG59XG51dGlscy5nZXROQUYgPSBnZXROQUY7XG5cbi8vIFJlcHJlc2VudCBrMSwgazIgaW4gYSBKb2ludCBTcGFyc2UgRm9ybVxuZnVuY3Rpb24gZ2V0SlNGKGsxLCBrMikge1xuICB2YXIganNmID0gW1xuICAgIFtdLFxuICAgIFtdLFxuICBdO1xuXG4gIGsxID0gazEuY2xvbmUoKTtcbiAgazIgPSBrMi5jbG9uZSgpO1xuICB2YXIgZDEgPSAwO1xuICB2YXIgZDIgPSAwO1xuICB2YXIgbTg7XG4gIHdoaWxlIChrMS5jbXBuKC1kMSkgPiAwIHx8IGsyLmNtcG4oLWQyKSA+IDApIHtcbiAgICAvLyBGaXJzdCBwaGFzZVxuICAgIHZhciBtMTQgPSAoazEuYW5kbG4oMykgKyBkMSkgJiAzO1xuICAgIHZhciBtMjQgPSAoazIuYW5kbG4oMykgKyBkMikgJiAzO1xuICAgIGlmIChtMTQgPT09IDMpXG4gICAgICBtMTQgPSAtMTtcbiAgICBpZiAobTI0ID09PSAzKVxuICAgICAgbTI0ID0gLTE7XG4gICAgdmFyIHUxO1xuICAgIGlmICgobTE0ICYgMSkgPT09IDApIHtcbiAgICAgIHUxID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgbTggPSAoazEuYW5kbG4oNykgKyBkMSkgJiA3O1xuICAgICAgaWYgKChtOCA9PT0gMyB8fCBtOCA9PT0gNSkgJiYgbTI0ID09PSAyKVxuICAgICAgICB1MSA9IC1tMTQ7XG4gICAgICBlbHNlXG4gICAgICAgIHUxID0gbTE0O1xuICAgIH1cbiAgICBqc2ZbMF0ucHVzaCh1MSk7XG5cbiAgICB2YXIgdTI7XG4gICAgaWYgKChtMjQgJiAxKSA9PT0gMCkge1xuICAgICAgdTIgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBtOCA9IChrMi5hbmRsbig3KSArIGQyKSAmIDc7XG4gICAgICBpZiAoKG04ID09PSAzIHx8IG04ID09PSA1KSAmJiBtMTQgPT09IDIpXG4gICAgICAgIHUyID0gLW0yNDtcbiAgICAgIGVsc2VcbiAgICAgICAgdTIgPSBtMjQ7XG4gICAgfVxuICAgIGpzZlsxXS5wdXNoKHUyKTtcblxuICAgIC8vIFNlY29uZCBwaGFzZVxuICAgIGlmICgyICogZDEgPT09IHUxICsgMSlcbiAgICAgIGQxID0gMSAtIGQxO1xuICAgIGlmICgyICogZDIgPT09IHUyICsgMSlcbiAgICAgIGQyID0gMSAtIGQyO1xuICAgIGsxLml1c2hybigxKTtcbiAgICBrMi5pdXNocm4oMSk7XG4gIH1cblxuICByZXR1cm4ganNmO1xufVxudXRpbHMuZ2V0SlNGID0gZ2V0SlNGO1xuXG5mdW5jdGlvbiBjYWNoZWRQcm9wZXJ0eShvYmosIG5hbWUsIGNvbXB1dGVyKSB7XG4gIHZhciBrZXkgPSAnXycgKyBuYW1lO1xuICBvYmoucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24gY2FjaGVkUHJvcGVydHkoKSB7XG4gICAgcmV0dXJuIHRoaXNba2V5XSAhPT0gdW5kZWZpbmVkID8gdGhpc1trZXldIDpcbiAgICAgIHRoaXNba2V5XSA9IGNvbXB1dGVyLmNhbGwodGhpcyk7XG4gIH07XG59XG51dGlscy5jYWNoZWRQcm9wZXJ0eSA9IGNhY2hlZFByb3BlcnR5O1xuXG5mdW5jdGlvbiBwYXJzZUJ5dGVzKGJ5dGVzKSB7XG4gIHJldHVybiB0eXBlb2YgYnl0ZXMgPT09ICdzdHJpbmcnID8gdXRpbHMudG9BcnJheShieXRlcywgJ2hleCcpIDpcbiAgICBieXRlcztcbn1cbnV0aWxzLnBhcnNlQnl0ZXMgPSBwYXJzZUJ5dGVzO1xuXG5mdW5jdGlvbiBpbnRGcm9tTEUoYnl0ZXMpIHtcbiAgcmV0dXJuIG5ldyBCTihieXRlcywgJ2hleCcsICdsZScpO1xufVxudXRpbHMuaW50RnJvbUxFID0gaW50RnJvbUxFO1xufSk7XG5cbid1c2Ugc3RyaWN0JztcblxuXG5cbnZhciBnZXROQUYgPSB1dGlsc18xJDEuZ2V0TkFGO1xudmFyIGdldEpTRiA9IHV0aWxzXzEkMS5nZXRKU0Y7XG52YXIgYXNzZXJ0JDEgPSB1dGlsc18xJDEuYXNzZXJ0O1xuXG5mdW5jdGlvbiBCYXNlQ3VydmUodHlwZSwgY29uZikge1xuICB0aGlzLnR5cGUgPSB0eXBlO1xuICB0aGlzLnAgPSBuZXcgQk4oY29uZi5wLCAxNik7XG5cbiAgLy8gVXNlIE1vbnRnb21lcnksIHdoZW4gdGhlcmUgaXMgbm8gZmFzdCByZWR1Y3Rpb24gZm9yIHRoZSBwcmltZVxuICB0aGlzLnJlZCA9IGNvbmYucHJpbWUgPyBCTi5yZWQoY29uZi5wcmltZSkgOiBCTi5tb250KHRoaXMucCk7XG5cbiAgLy8gVXNlZnVsIGZvciBtYW55IGN1cnZlc1xuICB0aGlzLnplcm8gPSBuZXcgQk4oMCkudG9SZWQodGhpcy5yZWQpO1xuICB0aGlzLm9uZSA9IG5ldyBCTigxKS50b1JlZCh0aGlzLnJlZCk7XG4gIHRoaXMudHdvID0gbmV3IEJOKDIpLnRvUmVkKHRoaXMucmVkKTtcblxuICAvLyBDdXJ2ZSBjb25maWd1cmF0aW9uLCBvcHRpb25hbFxuICB0aGlzLm4gPSBjb25mLm4gJiYgbmV3IEJOKGNvbmYubiwgMTYpO1xuICB0aGlzLmcgPSBjb25mLmcgJiYgdGhpcy5wb2ludEZyb21KU09OKGNvbmYuZywgY29uZi5nUmVkKTtcblxuICAvLyBUZW1wb3JhcnkgYXJyYXlzXG4gIHRoaXMuX3duYWZUMSA9IG5ldyBBcnJheSg0KTtcbiAgdGhpcy5fd25hZlQyID0gbmV3IEFycmF5KDQpO1xuICB0aGlzLl93bmFmVDMgPSBuZXcgQXJyYXkoNCk7XG4gIHRoaXMuX3duYWZUNCA9IG5ldyBBcnJheSg0KTtcblxuICB0aGlzLl9iaXRMZW5ndGggPSB0aGlzLm4gPyB0aGlzLm4uYml0TGVuZ3RoKCkgOiAwO1xuXG4gIC8vIEdlbmVyYWxpemVkIEdyZWcgTWF4d2VsbCdzIHRyaWNrXG4gIHZhciBhZGp1c3RDb3VudCA9IHRoaXMubiAmJiB0aGlzLnAuZGl2KHRoaXMubik7XG4gIGlmICghYWRqdXN0Q291bnQgfHwgYWRqdXN0Q291bnQuY21wbigxMDApID4gMCkge1xuICAgIHRoaXMucmVkTiA9IG51bGw7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fbWF4d2VsbFRyaWNrID0gdHJ1ZTtcbiAgICB0aGlzLnJlZE4gPSB0aGlzLm4udG9SZWQodGhpcy5yZWQpO1xuICB9XG59XG52YXIgYmFzZSA9IEJhc2VDdXJ2ZTtcblxuQmFzZUN1cnZlLnByb3RvdHlwZS5wb2ludCA9IGZ1bmN0aW9uIHBvaW50KCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZCcpO1xufTtcblxuQmFzZUN1cnZlLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uIHZhbGlkYXRlKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZCcpO1xufTtcblxuQmFzZUN1cnZlLnByb3RvdHlwZS5fZml4ZWROYWZNdWwgPSBmdW5jdGlvbiBfZml4ZWROYWZNdWwocCwgaykge1xuICBhc3NlcnQkMShwLnByZWNvbXB1dGVkKTtcbiAgdmFyIGRvdWJsZXMgPSBwLl9nZXREb3VibGVzKCk7XG5cbiAgdmFyIG5hZiA9IGdldE5BRihrLCAxLCB0aGlzLl9iaXRMZW5ndGgpO1xuICB2YXIgSSA9ICgxIDw8IChkb3VibGVzLnN0ZXAgKyAxKSkgLSAoZG91Ymxlcy5zdGVwICUgMiA9PT0gMCA/IDIgOiAxKTtcbiAgSSAvPSAzO1xuXG4gIC8vIFRyYW5zbGF0ZSBpbnRvIG1vcmUgd2luZG93ZWQgZm9ybVxuICB2YXIgcmVwciA9IFtdO1xuICB2YXIgajtcbiAgdmFyIG5hZlc7XG4gIGZvciAoaiA9IDA7IGogPCBuYWYubGVuZ3RoOyBqICs9IGRvdWJsZXMuc3RlcCkge1xuICAgIG5hZlcgPSAwO1xuICAgIGZvciAodmFyIGwgPSBqICsgZG91Ymxlcy5zdGVwIC0gMTsgbCA+PSBqOyBsLS0pXG4gICAgICBuYWZXID0gKG5hZlcgPDwgMSkgKyBuYWZbbF07XG4gICAgcmVwci5wdXNoKG5hZlcpO1xuICB9XG5cbiAgdmFyIGEgPSB0aGlzLmpwb2ludChudWxsLCBudWxsLCBudWxsKTtcbiAgdmFyIGIgPSB0aGlzLmpwb2ludChudWxsLCBudWxsLCBudWxsKTtcbiAgZm9yICh2YXIgaSA9IEk7IGkgPiAwOyBpLS0pIHtcbiAgICBmb3IgKGogPSAwOyBqIDwgcmVwci5sZW5ndGg7IGorKykge1xuICAgICAgbmFmVyA9IHJlcHJbal07XG4gICAgICBpZiAobmFmVyA9PT0gaSlcbiAgICAgICAgYiA9IGIubWl4ZWRBZGQoZG91Ymxlcy5wb2ludHNbal0pO1xuICAgICAgZWxzZSBpZiAobmFmVyA9PT0gLWkpXG4gICAgICAgIGIgPSBiLm1peGVkQWRkKGRvdWJsZXMucG9pbnRzW2pdLm5lZygpKTtcbiAgICB9XG4gICAgYSA9IGEuYWRkKGIpO1xuICB9XG4gIHJldHVybiBhLnRvUCgpO1xufTtcblxuQmFzZUN1cnZlLnByb3RvdHlwZS5fd25hZk11bCA9IGZ1bmN0aW9uIF93bmFmTXVsKHAsIGspIHtcbiAgdmFyIHcgPSA0O1xuXG4gIC8vIFByZWNvbXB1dGUgd2luZG93XG4gIHZhciBuYWZQb2ludHMgPSBwLl9nZXROQUZQb2ludHModyk7XG4gIHcgPSBuYWZQb2ludHMud25kO1xuICB2YXIgd25kID0gbmFmUG9pbnRzLnBvaW50cztcblxuICAvLyBHZXQgTkFGIGZvcm1cbiAgdmFyIG5hZiA9IGdldE5BRihrLCB3LCB0aGlzLl9iaXRMZW5ndGgpO1xuXG4gIC8vIEFkZCBgdGhpc2AqKE4rMSkgZm9yIGV2ZXJ5IHctTkFGIGluZGV4XG4gIHZhciBhY2MgPSB0aGlzLmpwb2ludChudWxsLCBudWxsLCBudWxsKTtcbiAgZm9yICh2YXIgaSA9IG5hZi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIC8vIENvdW50IHplcm9lc1xuICAgIGZvciAodmFyIGwgPSAwOyBpID49IDAgJiYgbmFmW2ldID09PSAwOyBpLS0pXG4gICAgICBsKys7XG4gICAgaWYgKGkgPj0gMClcbiAgICAgIGwrKztcbiAgICBhY2MgPSBhY2MuZGJscChsKTtcblxuICAgIGlmIChpIDwgMClcbiAgICAgIGJyZWFrO1xuICAgIHZhciB6ID0gbmFmW2ldO1xuICAgIGFzc2VydCQxKHogIT09IDApO1xuICAgIGlmIChwLnR5cGUgPT09ICdhZmZpbmUnKSB7XG4gICAgICAvLyBKICstIFBcbiAgICAgIGlmICh6ID4gMClcbiAgICAgICAgYWNjID0gYWNjLm1peGVkQWRkKHduZFsoeiAtIDEpID4+IDFdKTtcbiAgICAgIGVsc2VcbiAgICAgICAgYWNjID0gYWNjLm1peGVkQWRkKHduZFsoLXogLSAxKSA+PiAxXS5uZWcoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEogKy0gSlxuICAgICAgaWYgKHogPiAwKVxuICAgICAgICBhY2MgPSBhY2MuYWRkKHduZFsoeiAtIDEpID4+IDFdKTtcbiAgICAgIGVsc2VcbiAgICAgICAgYWNjID0gYWNjLmFkZCh3bmRbKC16IC0gMSkgPj4gMV0ubmVnKCkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcC50eXBlID09PSAnYWZmaW5lJyA/IGFjYy50b1AoKSA6IGFjYztcbn07XG5cbkJhc2VDdXJ2ZS5wcm90b3R5cGUuX3duYWZNdWxBZGQgPSBmdW5jdGlvbiBfd25hZk11bEFkZChkZWZXLFxuICBwb2ludHMsXG4gIGNvZWZmcyxcbiAgbGVuLFxuICBqYWNvYmlhblJlc3VsdCkge1xuICB2YXIgd25kV2lkdGggPSB0aGlzLl93bmFmVDE7XG4gIHZhciB3bmQgPSB0aGlzLl93bmFmVDI7XG4gIHZhciBuYWYgPSB0aGlzLl93bmFmVDM7XG5cbiAgLy8gRmlsbCBhbGwgYXJyYXlzXG4gIHZhciBtYXggPSAwO1xuICB2YXIgaTtcbiAgdmFyIGo7XG4gIHZhciBwO1xuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBwID0gcG9pbnRzW2ldO1xuICAgIHZhciBuYWZQb2ludHMgPSBwLl9nZXROQUZQb2ludHMoZGVmVyk7XG4gICAgd25kV2lkdGhbaV0gPSBuYWZQb2ludHMud25kO1xuICAgIHduZFtpXSA9IG5hZlBvaW50cy5wb2ludHM7XG4gIH1cblxuICAvLyBDb21iIHNtYWxsIHdpbmRvdyBOQUZzXG4gIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMTsgaSAtPSAyKSB7XG4gICAgdmFyIGEgPSBpIC0gMTtcbiAgICB2YXIgYiA9IGk7XG4gICAgaWYgKHduZFdpZHRoW2FdICE9PSAxIHx8IHduZFdpZHRoW2JdICE9PSAxKSB7XG4gICAgICBuYWZbYV0gPSBnZXROQUYoY29lZmZzW2FdLCB3bmRXaWR0aFthXSwgdGhpcy5fYml0TGVuZ3RoKTtcbiAgICAgIG5hZltiXSA9IGdldE5BRihjb2VmZnNbYl0sIHduZFdpZHRoW2JdLCB0aGlzLl9iaXRMZW5ndGgpO1xuICAgICAgbWF4ID0gTWF0aC5tYXgobmFmW2FdLmxlbmd0aCwgbWF4KTtcbiAgICAgIG1heCA9IE1hdGgubWF4KG5hZltiXS5sZW5ndGgsIG1heCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgY29tYiA9IFtcbiAgICAgIHBvaW50c1thXSwgLyogMSAqL1xuICAgICAgbnVsbCwgLyogMyAqL1xuICAgICAgbnVsbCwgLyogNSAqL1xuICAgICAgcG9pbnRzW2JdLCAvKiA3ICovXG4gICAgXTtcblxuICAgIC8vIFRyeSB0byBhdm9pZCBQcm9qZWN0aXZlIHBvaW50cywgaWYgcG9zc2libGVcbiAgICBpZiAocG9pbnRzW2FdLnkuY21wKHBvaW50c1tiXS55KSA9PT0gMCkge1xuICAgICAgY29tYlsxXSA9IHBvaW50c1thXS5hZGQocG9pbnRzW2JdKTtcbiAgICAgIGNvbWJbMl0gPSBwb2ludHNbYV0udG9KKCkubWl4ZWRBZGQocG9pbnRzW2JdLm5lZygpKTtcbiAgICB9IGVsc2UgaWYgKHBvaW50c1thXS55LmNtcChwb2ludHNbYl0ueS5yZWROZWcoKSkgPT09IDApIHtcbiAgICAgIGNvbWJbMV0gPSBwb2ludHNbYV0udG9KKCkubWl4ZWRBZGQocG9pbnRzW2JdKTtcbiAgICAgIGNvbWJbMl0gPSBwb2ludHNbYV0uYWRkKHBvaW50c1tiXS5uZWcoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbWJbMV0gPSBwb2ludHNbYV0udG9KKCkubWl4ZWRBZGQocG9pbnRzW2JdKTtcbiAgICAgIGNvbWJbMl0gPSBwb2ludHNbYV0udG9KKCkubWl4ZWRBZGQocG9pbnRzW2JdLm5lZygpKTtcbiAgICB9XG5cbiAgICB2YXIgaW5kZXggPSBbXG4gICAgICAtMywgLyogLTEgLTEgKi9cbiAgICAgIC0xLCAvKiAtMSAwICovXG4gICAgICAtNSwgLyogLTEgMSAqL1xuICAgICAgLTcsIC8qIDAgLTEgKi9cbiAgICAgIDAsIC8qIDAgMCAqL1xuICAgICAgNywgLyogMCAxICovXG4gICAgICA1LCAvKiAxIC0xICovXG4gICAgICAxLCAvKiAxIDAgKi9cbiAgICAgIDMsICAvKiAxIDEgKi9cbiAgICBdO1xuXG4gICAgdmFyIGpzZiA9IGdldEpTRihjb2VmZnNbYV0sIGNvZWZmc1tiXSk7XG4gICAgbWF4ID0gTWF0aC5tYXgoanNmWzBdLmxlbmd0aCwgbWF4KTtcbiAgICBuYWZbYV0gPSBuZXcgQXJyYXkobWF4KTtcbiAgICBuYWZbYl0gPSBuZXcgQXJyYXkobWF4KTtcbiAgICBmb3IgKGogPSAwOyBqIDwgbWF4OyBqKyspIHtcbiAgICAgIHZhciBqYSA9IGpzZlswXVtqXSB8IDA7XG4gICAgICB2YXIgamIgPSBqc2ZbMV1bal0gfCAwO1xuXG4gICAgICBuYWZbYV1bal0gPSBpbmRleFsoamEgKyAxKSAqIDMgKyAoamIgKyAxKV07XG4gICAgICBuYWZbYl1bal0gPSAwO1xuICAgICAgd25kW2FdID0gY29tYjtcbiAgICB9XG4gIH1cblxuICB2YXIgYWNjID0gdGhpcy5qcG9pbnQobnVsbCwgbnVsbCwgbnVsbCk7XG4gIHZhciB0bXAgPSB0aGlzLl93bmFmVDQ7XG4gIGZvciAoaSA9IG1heDsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgayA9IDA7XG5cbiAgICB3aGlsZSAoaSA+PSAwKSB7XG4gICAgICB2YXIgemVybyA9IHRydWU7XG4gICAgICBmb3IgKGogPSAwOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgdG1wW2pdID0gbmFmW2pdW2ldIHwgMDtcbiAgICAgICAgaWYgKHRtcFtqXSAhPT0gMClcbiAgICAgICAgICB6ZXJvID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoIXplcm8pXG4gICAgICAgIGJyZWFrO1xuICAgICAgaysrO1xuICAgICAgaS0tO1xuICAgIH1cbiAgICBpZiAoaSA+PSAwKVxuICAgICAgaysrO1xuICAgIGFjYyA9IGFjYy5kYmxwKGspO1xuICAgIGlmIChpIDwgMClcbiAgICAgIGJyZWFrO1xuXG4gICAgZm9yIChqID0gMDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICB2YXIgeiA9IHRtcFtqXTtcbiAgICAgIHA7XG4gICAgICBpZiAoeiA9PT0gMClcbiAgICAgICAgY29udGludWU7XG4gICAgICBlbHNlIGlmICh6ID4gMClcbiAgICAgICAgcCA9IHduZFtqXVsoeiAtIDEpID4+IDFdO1xuICAgICAgZWxzZSBpZiAoeiA8IDApXG4gICAgICAgIHAgPSB3bmRbal1bKC16IC0gMSkgPj4gMV0ubmVnKCk7XG5cbiAgICAgIGlmIChwLnR5cGUgPT09ICdhZmZpbmUnKVxuICAgICAgICBhY2MgPSBhY2MubWl4ZWRBZGQocCk7XG4gICAgICBlbHNlXG4gICAgICAgIGFjYyA9IGFjYy5hZGQocCk7XG4gICAgfVxuICB9XG4gIC8vIFplcm9pZnkgcmVmZXJlbmNlc1xuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgd25kW2ldID0gbnVsbDtcblxuICBpZiAoamFjb2JpYW5SZXN1bHQpXG4gICAgcmV0dXJuIGFjYztcbiAgZWxzZVxuICAgIHJldHVybiBhY2MudG9QKCk7XG59O1xuXG5mdW5jdGlvbiBCYXNlUG9pbnQoY3VydmUsIHR5cGUpIHtcbiAgdGhpcy5jdXJ2ZSA9IGN1cnZlO1xuICB0aGlzLnR5cGUgPSB0eXBlO1xuICB0aGlzLnByZWNvbXB1dGVkID0gbnVsbDtcbn1cbkJhc2VDdXJ2ZS5CYXNlUG9pbnQgPSBCYXNlUG9pbnQ7XG5cbkJhc2VQb2ludC5wcm90b3R5cGUuZXEgPSBmdW5jdGlvbiBlcSgvKm90aGVyKi8pIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQnKTtcbn07XG5cbkJhc2VQb2ludC5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiB2YWxpZGF0ZSgpIHtcbiAgcmV0dXJuIHRoaXMuY3VydmUudmFsaWRhdGUodGhpcyk7XG59O1xuXG5CYXNlQ3VydmUucHJvdG90eXBlLmRlY29kZVBvaW50ID0gZnVuY3Rpb24gZGVjb2RlUG9pbnQoYnl0ZXMsIGVuYykge1xuICBieXRlcyA9IHV0aWxzXzEkMS50b0FycmF5KGJ5dGVzLCBlbmMpO1xuXG4gIHZhciBsZW4gPSB0aGlzLnAuYnl0ZUxlbmd0aCgpO1xuXG4gIC8vIHVuY29tcHJlc3NlZCwgaHlicmlkLW9kZCwgaHlicmlkLWV2ZW5cbiAgaWYgKChieXRlc1swXSA9PT0gMHgwNCB8fCBieXRlc1swXSA9PT0gMHgwNiB8fCBieXRlc1swXSA9PT0gMHgwNykgJiZcbiAgICAgIGJ5dGVzLmxlbmd0aCAtIDEgPT09IDIgKiBsZW4pIHtcbiAgICBpZiAoYnl0ZXNbMF0gPT09IDB4MDYpXG4gICAgICBhc3NlcnQkMShieXRlc1tieXRlcy5sZW5ndGggLSAxXSAlIDIgPT09IDApO1xuICAgIGVsc2UgaWYgKGJ5dGVzWzBdID09PSAweDA3KVxuICAgICAgYXNzZXJ0JDEoYnl0ZXNbYnl0ZXMubGVuZ3RoIC0gMV0gJSAyID09PSAxKTtcblxuICAgIHZhciByZXMgPSAgdGhpcy5wb2ludChieXRlcy5zbGljZSgxLCAxICsgbGVuKSxcbiAgICAgIGJ5dGVzLnNsaWNlKDEgKyBsZW4sIDEgKyAyICogbGVuKSk7XG5cbiAgICByZXR1cm4gcmVzO1xuICB9IGVsc2UgaWYgKChieXRlc1swXSA9PT0gMHgwMiB8fCBieXRlc1swXSA9PT0gMHgwMykgJiZcbiAgICAgICAgICAgICAgYnl0ZXMubGVuZ3RoIC0gMSA9PT0gbGVuKSB7XG4gICAgcmV0dXJuIHRoaXMucG9pbnRGcm9tWChieXRlcy5zbGljZSgxLCAxICsgbGVuKSwgYnl0ZXNbMF0gPT09IDB4MDMpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcignVW5rbm93biBwb2ludCBmb3JtYXQnKTtcbn07XG5cbkJhc2VQb2ludC5wcm90b3R5cGUuZW5jb2RlQ29tcHJlc3NlZCA9IGZ1bmN0aW9uIGVuY29kZUNvbXByZXNzZWQoZW5jKSB7XG4gIHJldHVybiB0aGlzLmVuY29kZShlbmMsIHRydWUpO1xufTtcblxuQmFzZVBvaW50LnByb3RvdHlwZS5fZW5jb2RlID0gZnVuY3Rpb24gX2VuY29kZShjb21wYWN0KSB7XG4gIHZhciBsZW4gPSB0aGlzLmN1cnZlLnAuYnl0ZUxlbmd0aCgpO1xuICB2YXIgeCA9IHRoaXMuZ2V0WCgpLnRvQXJyYXkoJ2JlJywgbGVuKTtcblxuICBpZiAoY29tcGFjdClcbiAgICByZXR1cm4gWyB0aGlzLmdldFkoKS5pc0V2ZW4oKSA/IDB4MDIgOiAweDAzIF0uY29uY2F0KHgpO1xuXG4gIHJldHVybiBbIDB4MDQgXS5jb25jYXQoeCwgdGhpcy5nZXRZKCkudG9BcnJheSgnYmUnLCBsZW4pKTtcbn07XG5cbkJhc2VQb2ludC5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKGVuYywgY29tcGFjdCkge1xuICByZXR1cm4gdXRpbHNfMSQxLmVuY29kZSh0aGlzLl9lbmNvZGUoY29tcGFjdCksIGVuYyk7XG59O1xuXG5CYXNlUG9pbnQucHJvdG90eXBlLnByZWNvbXB1dGUgPSBmdW5jdGlvbiBwcmVjb21wdXRlKHBvd2VyKSB7XG4gIGlmICh0aGlzLnByZWNvbXB1dGVkKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIHZhciBwcmVjb21wdXRlZCA9IHtcbiAgICBkb3VibGVzOiBudWxsLFxuICAgIG5hZjogbnVsbCxcbiAgICBiZXRhOiBudWxsLFxuICB9O1xuICBwcmVjb21wdXRlZC5uYWYgPSB0aGlzLl9nZXROQUZQb2ludHMoOCk7XG4gIHByZWNvbXB1dGVkLmRvdWJsZXMgPSB0aGlzLl9nZXREb3VibGVzKDQsIHBvd2VyKTtcbiAgcHJlY29tcHV0ZWQuYmV0YSA9IHRoaXMuX2dldEJldGEoKTtcbiAgdGhpcy5wcmVjb21wdXRlZCA9IHByZWNvbXB1dGVkO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuQmFzZVBvaW50LnByb3RvdHlwZS5faGFzRG91YmxlcyA9IGZ1bmN0aW9uIF9oYXNEb3VibGVzKGspIHtcbiAgaWYgKCF0aGlzLnByZWNvbXB1dGVkKVxuICAgIHJldHVybiBmYWxzZTtcblxuICB2YXIgZG91YmxlcyA9IHRoaXMucHJlY29tcHV0ZWQuZG91YmxlcztcbiAgaWYgKCFkb3VibGVzKVxuICAgIHJldHVybiBmYWxzZTtcblxuICByZXR1cm4gZG91Ymxlcy5wb2ludHMubGVuZ3RoID49IE1hdGguY2VpbCgoay5iaXRMZW5ndGgoKSArIDEpIC8gZG91Ymxlcy5zdGVwKTtcbn07XG5cbkJhc2VQb2ludC5wcm90b3R5cGUuX2dldERvdWJsZXMgPSBmdW5jdGlvbiBfZ2V0RG91YmxlcyhzdGVwLCBwb3dlcikge1xuICBpZiAodGhpcy5wcmVjb21wdXRlZCAmJiB0aGlzLnByZWNvbXB1dGVkLmRvdWJsZXMpXG4gICAgcmV0dXJuIHRoaXMucHJlY29tcHV0ZWQuZG91YmxlcztcblxuICB2YXIgZG91YmxlcyA9IFsgdGhpcyBdO1xuICB2YXIgYWNjID0gdGhpcztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb3dlcjsgaSArPSBzdGVwKSB7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBzdGVwOyBqKyspXG4gICAgICBhY2MgPSBhY2MuZGJsKCk7XG4gICAgZG91Ymxlcy5wdXNoKGFjYyk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzdGVwOiBzdGVwLFxuICAgIHBvaW50czogZG91YmxlcyxcbiAgfTtcbn07XG5cbkJhc2VQb2ludC5wcm90b3R5cGUuX2dldE5BRlBvaW50cyA9IGZ1bmN0aW9uIF9nZXROQUZQb2ludHMod25kKSB7XG4gIGlmICh0aGlzLnByZWNvbXB1dGVkICYmIHRoaXMucHJlY29tcHV0ZWQubmFmKVxuICAgIHJldHVybiB0aGlzLnByZWNvbXB1dGVkLm5hZjtcblxuICB2YXIgcmVzID0gWyB0aGlzIF07XG4gIHZhciBtYXggPSAoMSA8PCB3bmQpIC0gMTtcbiAgdmFyIGRibCA9IG1heCA9PT0gMSA/IG51bGwgOiB0aGlzLmRibCgpO1xuICBmb3IgKHZhciBpID0gMTsgaSA8IG1heDsgaSsrKVxuICAgIHJlc1tpXSA9IHJlc1tpIC0gMV0uYWRkKGRibCk7XG4gIHJldHVybiB7XG4gICAgd25kOiB3bmQsXG4gICAgcG9pbnRzOiByZXMsXG4gIH07XG59O1xuXG5CYXNlUG9pbnQucHJvdG90eXBlLl9nZXRCZXRhID0gZnVuY3Rpb24gX2dldEJldGEoKSB7XG4gIHJldHVybiBudWxsO1xufTtcblxuQmFzZVBvaW50LnByb3RvdHlwZS5kYmxwID0gZnVuY3Rpb24gZGJscChrKSB7XG4gIHZhciByID0gdGhpcztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrOyBpKyspXG4gICAgciA9IHIuZGJsKCk7XG4gIHJldHVybiByO1xufTtcblxudmFyIGluaGVyaXRzX2Jyb3dzZXIgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG5pZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gaW1wbGVtZW50YXRpb24gZnJvbSBzdGFuZGFyZCBub2RlLmpzICd1dGlsJyBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBpZiAoc3VwZXJDdG9yKSB7XG4gICAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvcjtcbiAgICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbn0gZWxzZSB7XG4gIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgaWYgKHN1cGVyQ3Rvcikge1xuICAgICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3I7XG4gICAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGU7XG4gICAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpO1xuICAgICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yO1xuICAgIH1cbiAgfTtcbn1cbn0pO1xuXG4ndXNlIHN0cmljdCc7XG5cblxuXG5cblxuXG52YXIgYXNzZXJ0JDIgPSB1dGlsc18xJDEuYXNzZXJ0O1xuXG5mdW5jdGlvbiBTaG9ydEN1cnZlKGNvbmYpIHtcbiAgYmFzZS5jYWxsKHRoaXMsICdzaG9ydCcsIGNvbmYpO1xuXG4gIHRoaXMuYSA9IG5ldyBCTihjb25mLmEsIDE2KS50b1JlZCh0aGlzLnJlZCk7XG4gIHRoaXMuYiA9IG5ldyBCTihjb25mLmIsIDE2KS50b1JlZCh0aGlzLnJlZCk7XG4gIHRoaXMudGludiA9IHRoaXMudHdvLnJlZEludm0oKTtcblxuICB0aGlzLnplcm9BID0gdGhpcy5hLmZyb21SZWQoKS5jbXBuKDApID09PSAwO1xuICB0aGlzLnRocmVlQSA9IHRoaXMuYS5mcm9tUmVkKCkuc3ViKHRoaXMucCkuY21wbigtMykgPT09IDA7XG5cbiAgLy8gSWYgdGhlIGN1cnZlIGlzIGVuZG9tb3JwaGljLCBwcmVjYWxjdWxhdGUgYmV0YSBhbmQgbGFtYmRhXG4gIHRoaXMuZW5kbyA9IHRoaXMuX2dldEVuZG9tb3JwaGlzbShjb25mKTtcbiAgdGhpcy5fZW5kb1duYWZUMSA9IG5ldyBBcnJheSg0KTtcbiAgdGhpcy5fZW5kb1duYWZUMiA9IG5ldyBBcnJheSg0KTtcbn1cbmluaGVyaXRzX2Jyb3dzZXIoU2hvcnRDdXJ2ZSwgYmFzZSk7XG52YXIgc2hvcnRfMSA9IFNob3J0Q3VydmU7XG5cblNob3J0Q3VydmUucHJvdG90eXBlLl9nZXRFbmRvbW9ycGhpc20gPSBmdW5jdGlvbiBfZ2V0RW5kb21vcnBoaXNtKGNvbmYpIHtcbiAgLy8gTm8gZWZmaWNpZW50IGVuZG9tb3JwaGlzbVxuICBpZiAoIXRoaXMuemVyb0EgfHwgIXRoaXMuZyB8fCAhdGhpcy5uIHx8IHRoaXMucC5tb2RuKDMpICE9PSAxKVxuICAgIHJldHVybjtcblxuICAvLyBDb21wdXRlIGJldGEgYW5kIGxhbWJkYSwgdGhhdCBsYW1iZGEgKiBQID0gKGJldGEgKiBQeDsgUHkpXG4gIHZhciBiZXRhO1xuICB2YXIgbGFtYmRhO1xuICBpZiAoY29uZi5iZXRhKSB7XG4gICAgYmV0YSA9IG5ldyBCTihjb25mLmJldGEsIDE2KS50b1JlZCh0aGlzLnJlZCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJldGFzID0gdGhpcy5fZ2V0RW5kb1Jvb3RzKHRoaXMucCk7XG4gICAgLy8gQ2hvb3NlIHRoZSBzbWFsbGVzdCBiZXRhXG4gICAgYmV0YSA9IGJldGFzWzBdLmNtcChiZXRhc1sxXSkgPCAwID8gYmV0YXNbMF0gOiBiZXRhc1sxXTtcbiAgICBiZXRhID0gYmV0YS50b1JlZCh0aGlzLnJlZCk7XG4gIH1cbiAgaWYgKGNvbmYubGFtYmRhKSB7XG4gICAgbGFtYmRhID0gbmV3IEJOKGNvbmYubGFtYmRhLCAxNik7XG4gIH0gZWxzZSB7XG4gICAgLy8gQ2hvb3NlIHRoZSBsYW1iZGEgdGhhdCBpcyBtYXRjaGluZyBzZWxlY3RlZCBiZXRhXG4gICAgdmFyIGxhbWJkYXMgPSB0aGlzLl9nZXRFbmRvUm9vdHModGhpcy5uKTtcbiAgICBpZiAodGhpcy5nLm11bChsYW1iZGFzWzBdKS54LmNtcCh0aGlzLmcueC5yZWRNdWwoYmV0YSkpID09PSAwKSB7XG4gICAgICBsYW1iZGEgPSBsYW1iZGFzWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICBsYW1iZGEgPSBsYW1iZGFzWzFdO1xuICAgICAgYXNzZXJ0JDIodGhpcy5nLm11bChsYW1iZGEpLnguY21wKHRoaXMuZy54LnJlZE11bChiZXRhKSkgPT09IDApO1xuICAgIH1cbiAgfVxuXG4gIC8vIEdldCBiYXNpcyB2ZWN0b3JzLCB1c2VkIGZvciBiYWxhbmNlZCBsZW5ndGgtdHdvIHJlcHJlc2VudGF0aW9uXG4gIHZhciBiYXNpcztcbiAgaWYgKGNvbmYuYmFzaXMpIHtcbiAgICBiYXNpcyA9IGNvbmYuYmFzaXMubWFwKGZ1bmN0aW9uKHZlYykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYTogbmV3IEJOKHZlYy5hLCAxNiksXG4gICAgICAgIGI6IG5ldyBCTih2ZWMuYiwgMTYpLFxuICAgICAgfTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBiYXNpcyA9IHRoaXMuX2dldEVuZG9CYXNpcyhsYW1iZGEpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBiZXRhOiBiZXRhLFxuICAgIGxhbWJkYTogbGFtYmRhLFxuICAgIGJhc2lzOiBiYXNpcyxcbiAgfTtcbn07XG5cblNob3J0Q3VydmUucHJvdG90eXBlLl9nZXRFbmRvUm9vdHMgPSBmdW5jdGlvbiBfZ2V0RW5kb1Jvb3RzKG51bSkge1xuICAvLyBGaW5kIHJvb3RzIG9mIGZvciB4XjIgKyB4ICsgMSBpbiBGXG4gIC8vIFJvb3QgPSAoLTEgKy0gU3FydCgtMykpIC8gMlxuICAvL1xuICB2YXIgcmVkID0gbnVtID09PSB0aGlzLnAgPyB0aGlzLnJlZCA6IEJOLm1vbnQobnVtKTtcbiAgdmFyIHRpbnYgPSBuZXcgQk4oMikudG9SZWQocmVkKS5yZWRJbnZtKCk7XG4gIHZhciBudGludiA9IHRpbnYucmVkTmVnKCk7XG5cbiAgdmFyIHMgPSBuZXcgQk4oMykudG9SZWQocmVkKS5yZWROZWcoKS5yZWRTcXJ0KCkucmVkTXVsKHRpbnYpO1xuXG4gIHZhciBsMSA9IG50aW52LnJlZEFkZChzKS5mcm9tUmVkKCk7XG4gIHZhciBsMiA9IG50aW52LnJlZFN1YihzKS5mcm9tUmVkKCk7XG4gIHJldHVybiBbIGwxLCBsMiBdO1xufTtcblxuU2hvcnRDdXJ2ZS5wcm90b3R5cGUuX2dldEVuZG9CYXNpcyA9IGZ1bmN0aW9uIF9nZXRFbmRvQmFzaXMobGFtYmRhKSB7XG4gIC8vIGFwcnhTcXJ0ID49IHNxcnQodGhpcy5uKVxuICB2YXIgYXByeFNxcnQgPSB0aGlzLm4udXNocm4oTWF0aC5mbG9vcih0aGlzLm4uYml0TGVuZ3RoKCkgLyAyKSk7XG5cbiAgLy8gMy43NFxuICAvLyBSdW4gRUdDRCwgdW50aWwgcihMICsgMSkgPCBhcHJ4U3FydFxuICB2YXIgdSA9IGxhbWJkYTtcbiAgdmFyIHYgPSB0aGlzLm4uY2xvbmUoKTtcbiAgdmFyIHgxID0gbmV3IEJOKDEpO1xuICB2YXIgeTEgPSBuZXcgQk4oMCk7XG4gIHZhciB4MiA9IG5ldyBCTigwKTtcbiAgdmFyIHkyID0gbmV3IEJOKDEpO1xuXG4gIC8vIE5PVEU6IGFsbCB2ZWN0b3JzIGFyZSByb290cyBvZjogYSArIGIgKiBsYW1iZGEgPSAwIChtb2QgbilcbiAgdmFyIGEwO1xuICB2YXIgYjA7XG4gIC8vIEZpcnN0IHZlY3RvclxuICB2YXIgYTE7XG4gIHZhciBiMTtcbiAgLy8gU2Vjb25kIHZlY3RvclxuICB2YXIgYTI7XG4gIHZhciBiMjtcblxuICB2YXIgcHJldlI7XG4gIHZhciBpID0gMDtcbiAgdmFyIHI7XG4gIHZhciB4O1xuICB3aGlsZSAodS5jbXBuKDApICE9PSAwKSB7XG4gICAgdmFyIHEgPSB2LmRpdih1KTtcbiAgICByID0gdi5zdWIocS5tdWwodSkpO1xuICAgIHggPSB4Mi5zdWIocS5tdWwoeDEpKTtcbiAgICB2YXIgeSA9IHkyLnN1YihxLm11bCh5MSkpO1xuXG4gICAgaWYgKCFhMSAmJiByLmNtcChhcHJ4U3FydCkgPCAwKSB7XG4gICAgICBhMCA9IHByZXZSLm5lZygpO1xuICAgICAgYjAgPSB4MTtcbiAgICAgIGExID0gci5uZWcoKTtcbiAgICAgIGIxID0geDtcbiAgICB9IGVsc2UgaWYgKGExICYmICsraSA9PT0gMikge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHByZXZSID0gcjtcblxuICAgIHYgPSB1O1xuICAgIHUgPSByO1xuICAgIHgyID0geDE7XG4gICAgeDEgPSB4O1xuICAgIHkyID0geTE7XG4gICAgeTEgPSB5O1xuICB9XG4gIGEyID0gci5uZWcoKTtcbiAgYjIgPSB4O1xuXG4gIHZhciBsZW4xID0gYTEuc3FyKCkuYWRkKGIxLnNxcigpKTtcbiAgdmFyIGxlbjIgPSBhMi5zcXIoKS5hZGQoYjIuc3FyKCkpO1xuICBpZiAobGVuMi5jbXAobGVuMSkgPj0gMCkge1xuICAgIGEyID0gYTA7XG4gICAgYjIgPSBiMDtcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSBzaWduc1xuICBpZiAoYTEubmVnYXRpdmUpIHtcbiAgICBhMSA9IGExLm5lZygpO1xuICAgIGIxID0gYjEubmVnKCk7XG4gIH1cbiAgaWYgKGEyLm5lZ2F0aXZlKSB7XG4gICAgYTIgPSBhMi5uZWcoKTtcbiAgICBiMiA9IGIyLm5lZygpO1xuICB9XG5cbiAgcmV0dXJuIFtcbiAgICB7IGE6IGExLCBiOiBiMSB9LFxuICAgIHsgYTogYTIsIGI6IGIyIH0sXG4gIF07XG59O1xuXG5TaG9ydEN1cnZlLnByb3RvdHlwZS5fZW5kb1NwbGl0ID0gZnVuY3Rpb24gX2VuZG9TcGxpdChrKSB7XG4gIHZhciBiYXNpcyA9IHRoaXMuZW5kby5iYXNpcztcbiAgdmFyIHYxID0gYmFzaXNbMF07XG4gIHZhciB2MiA9IGJhc2lzWzFdO1xuXG4gIHZhciBjMSA9IHYyLmIubXVsKGspLmRpdlJvdW5kKHRoaXMubik7XG4gIHZhciBjMiA9IHYxLmIubmVnKCkubXVsKGspLmRpdlJvdW5kKHRoaXMubik7XG5cbiAgdmFyIHAxID0gYzEubXVsKHYxLmEpO1xuICB2YXIgcDIgPSBjMi5tdWwodjIuYSk7XG4gIHZhciBxMSA9IGMxLm11bCh2MS5iKTtcbiAgdmFyIHEyID0gYzIubXVsKHYyLmIpO1xuXG4gIC8vIENhbGN1bGF0ZSBhbnN3ZXJcbiAgdmFyIGsxID0gay5zdWIocDEpLnN1YihwMik7XG4gIHZhciBrMiA9IHExLmFkZChxMikubmVnKCk7XG4gIHJldHVybiB7IGsxOiBrMSwgazI6IGsyIH07XG59O1xuXG5TaG9ydEN1cnZlLnByb3RvdHlwZS5wb2ludEZyb21YID0gZnVuY3Rpb24gcG9pbnRGcm9tWCh4LCBvZGQpIHtcbiAgeCA9IG5ldyBCTih4LCAxNik7XG4gIGlmICgheC5yZWQpXG4gICAgeCA9IHgudG9SZWQodGhpcy5yZWQpO1xuXG4gIHZhciB5MiA9IHgucmVkU3FyKCkucmVkTXVsKHgpLnJlZElBZGQoeC5yZWRNdWwodGhpcy5hKSkucmVkSUFkZCh0aGlzLmIpO1xuICB2YXIgeSA9IHkyLnJlZFNxcnQoKTtcbiAgaWYgKHkucmVkU3FyKCkucmVkU3ViKHkyKS5jbXAodGhpcy56ZXJvKSAhPT0gMClcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcG9pbnQnKTtcblxuICAvLyBYWFggSXMgdGhlcmUgYW55IHdheSB0byB0ZWxsIGlmIHRoZSBudW1iZXIgaXMgb2RkIHdpdGhvdXQgY29udmVydGluZyBpdFxuICAvLyB0byBub24tcmVkIGZvcm0/XG4gIHZhciBpc09kZCA9IHkuZnJvbVJlZCgpLmlzT2RkKCk7XG4gIGlmIChvZGQgJiYgIWlzT2RkIHx8ICFvZGQgJiYgaXNPZGQpXG4gICAgeSA9IHkucmVkTmVnKCk7XG5cbiAgcmV0dXJuIHRoaXMucG9pbnQoeCwgeSk7XG59O1xuXG5TaG9ydEN1cnZlLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uIHZhbGlkYXRlKHBvaW50KSB7XG4gIGlmIChwb2ludC5pbmYpXG4gICAgcmV0dXJuIHRydWU7XG5cbiAgdmFyIHggPSBwb2ludC54O1xuICB2YXIgeSA9IHBvaW50Lnk7XG5cbiAgdmFyIGF4ID0gdGhpcy5hLnJlZE11bCh4KTtcbiAgdmFyIHJocyA9IHgucmVkU3FyKCkucmVkTXVsKHgpLnJlZElBZGQoYXgpLnJlZElBZGQodGhpcy5iKTtcbiAgcmV0dXJuIHkucmVkU3FyKCkucmVkSVN1YihyaHMpLmNtcG4oMCkgPT09IDA7XG59O1xuXG5TaG9ydEN1cnZlLnByb3RvdHlwZS5fZW5kb1duYWZNdWxBZGQgPVxuICAgIGZ1bmN0aW9uIF9lbmRvV25hZk11bEFkZChwb2ludHMsIGNvZWZmcywgamFjb2JpYW5SZXN1bHQpIHtcbiAgICAgIHZhciBucG9pbnRzID0gdGhpcy5fZW5kb1duYWZUMTtcbiAgICAgIHZhciBuY29lZmZzID0gdGhpcy5fZW5kb1duYWZUMjtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzcGxpdCA9IHRoaXMuX2VuZG9TcGxpdChjb2VmZnNbaV0pO1xuICAgICAgICB2YXIgcCA9IHBvaW50c1tpXTtcbiAgICAgICAgdmFyIGJldGEgPSBwLl9nZXRCZXRhKCk7XG5cbiAgICAgICAgaWYgKHNwbGl0LmsxLm5lZ2F0aXZlKSB7XG4gICAgICAgICAgc3BsaXQuazEuaW5lZygpO1xuICAgICAgICAgIHAgPSBwLm5lZyh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3BsaXQuazIubmVnYXRpdmUpIHtcbiAgICAgICAgICBzcGxpdC5rMi5pbmVnKCk7XG4gICAgICAgICAgYmV0YSA9IGJldGEubmVnKHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgbnBvaW50c1tpICogMl0gPSBwO1xuICAgICAgICBucG9pbnRzW2kgKiAyICsgMV0gPSBiZXRhO1xuICAgICAgICBuY29lZmZzW2kgKiAyXSA9IHNwbGl0LmsxO1xuICAgICAgICBuY29lZmZzW2kgKiAyICsgMV0gPSBzcGxpdC5rMjtcbiAgICAgIH1cbiAgICAgIHZhciByZXMgPSB0aGlzLl93bmFmTXVsQWRkKDEsIG5wb2ludHMsIG5jb2VmZnMsIGkgKiAyLCBqYWNvYmlhblJlc3VsdCk7XG5cbiAgICAgIC8vIENsZWFuLXVwIHJlZmVyZW5jZXMgdG8gcG9pbnRzIGFuZCBjb2VmZmljaWVudHNcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaSAqIDI7IGorKykge1xuICAgICAgICBucG9pbnRzW2pdID0gbnVsbDtcbiAgICAgICAgbmNvZWZmc1tqXSA9IG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH07XG5cbmZ1bmN0aW9uIFBvaW50KGN1cnZlLCB4LCB5LCBpc1JlZCkge1xuICBiYXNlLkJhc2VQb2ludC5jYWxsKHRoaXMsIGN1cnZlLCAnYWZmaW5lJyk7XG4gIGlmICh4ID09PSBudWxsICYmIHkgPT09IG51bGwpIHtcbiAgICB0aGlzLnggPSBudWxsO1xuICAgIHRoaXMueSA9IG51bGw7XG4gICAgdGhpcy5pbmYgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHRoaXMueCA9IG5ldyBCTih4LCAxNik7XG4gICAgdGhpcy55ID0gbmV3IEJOKHksIDE2KTtcbiAgICAvLyBGb3JjZSByZWRnb21lcnkgcmVwcmVzZW50YXRpb24gd2hlbiBsb2FkaW5nIGZyb20gSlNPTlxuICAgIGlmIChpc1JlZCkge1xuICAgICAgdGhpcy54LmZvcmNlUmVkKHRoaXMuY3VydmUucmVkKTtcbiAgICAgIHRoaXMueS5mb3JjZVJlZCh0aGlzLmN1cnZlLnJlZCk7XG4gICAgfVxuICAgIGlmICghdGhpcy54LnJlZClcbiAgICAgIHRoaXMueCA9IHRoaXMueC50b1JlZCh0aGlzLmN1cnZlLnJlZCk7XG4gICAgaWYgKCF0aGlzLnkucmVkKVxuICAgICAgdGhpcy55ID0gdGhpcy55LnRvUmVkKHRoaXMuY3VydmUucmVkKTtcbiAgICB0aGlzLmluZiA9IGZhbHNlO1xuICB9XG59XG5pbmhlcml0c19icm93c2VyKFBvaW50LCBiYXNlLkJhc2VQb2ludCk7XG5cblNob3J0Q3VydmUucHJvdG90eXBlLnBvaW50ID0gZnVuY3Rpb24gcG9pbnQoeCwgeSwgaXNSZWQpIHtcbiAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLCB4LCB5LCBpc1JlZCk7XG59O1xuXG5TaG9ydEN1cnZlLnByb3RvdHlwZS5wb2ludEZyb21KU09OID0gZnVuY3Rpb24gcG9pbnRGcm9tSlNPTihvYmosIHJlZCkge1xuICByZXR1cm4gUG9pbnQuZnJvbUpTT04odGhpcywgb2JqLCByZWQpO1xufTtcblxuUG9pbnQucHJvdG90eXBlLl9nZXRCZXRhID0gZnVuY3Rpb24gX2dldEJldGEoKSB7XG4gIGlmICghdGhpcy5jdXJ2ZS5lbmRvKVxuICAgIHJldHVybjtcblxuICB2YXIgcHJlID0gdGhpcy5wcmVjb21wdXRlZDtcbiAgaWYgKHByZSAmJiBwcmUuYmV0YSlcbiAgICByZXR1cm4gcHJlLmJldGE7XG5cbiAgdmFyIGJldGEgPSB0aGlzLmN1cnZlLnBvaW50KHRoaXMueC5yZWRNdWwodGhpcy5jdXJ2ZS5lbmRvLmJldGEpLCB0aGlzLnkpO1xuICBpZiAocHJlKSB7XG4gICAgdmFyIGN1cnZlID0gdGhpcy5jdXJ2ZTtcbiAgICB2YXIgZW5kb011bCA9IGZ1bmN0aW9uKHApIHtcbiAgICAgIHJldHVybiBjdXJ2ZS5wb2ludChwLngucmVkTXVsKGN1cnZlLmVuZG8uYmV0YSksIHAueSk7XG4gICAgfTtcbiAgICBwcmUuYmV0YSA9IGJldGE7XG4gICAgYmV0YS5wcmVjb21wdXRlZCA9IHtcbiAgICAgIGJldGE6IG51bGwsXG4gICAgICBuYWY6IHByZS5uYWYgJiYge1xuICAgICAgICB3bmQ6IHByZS5uYWYud25kLFxuICAgICAgICBwb2ludHM6IHByZS5uYWYucG9pbnRzLm1hcChlbmRvTXVsKSxcbiAgICAgIH0sXG4gICAgICBkb3VibGVzOiBwcmUuZG91YmxlcyAmJiB7XG4gICAgICAgIHN0ZXA6IHByZS5kb3VibGVzLnN0ZXAsXG4gICAgICAgIHBvaW50czogcHJlLmRvdWJsZXMucG9pbnRzLm1hcChlbmRvTXVsKSxcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxuICByZXR1cm4gYmV0YTtcbn07XG5cblBvaW50LnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gIGlmICghdGhpcy5wcmVjb21wdXRlZClcbiAgICByZXR1cm4gWyB0aGlzLngsIHRoaXMueSBdO1xuXG4gIHJldHVybiBbIHRoaXMueCwgdGhpcy55LCB0aGlzLnByZWNvbXB1dGVkICYmIHtcbiAgICBkb3VibGVzOiB0aGlzLnByZWNvbXB1dGVkLmRvdWJsZXMgJiYge1xuICAgICAgc3RlcDogdGhpcy5wcmVjb21wdXRlZC5kb3VibGVzLnN0ZXAsXG4gICAgICBwb2ludHM6IHRoaXMucHJlY29tcHV0ZWQuZG91Ymxlcy5wb2ludHMuc2xpY2UoMSksXG4gICAgfSxcbiAgICBuYWY6IHRoaXMucHJlY29tcHV0ZWQubmFmICYmIHtcbiAgICAgIHduZDogdGhpcy5wcmVjb21wdXRlZC5uYWYud25kLFxuICAgICAgcG9pbnRzOiB0aGlzLnByZWNvbXB1dGVkLm5hZi5wb2ludHMuc2xpY2UoMSksXG4gICAgfSxcbiAgfSBdO1xufTtcblxuUG9pbnQuZnJvbUpTT04gPSBmdW5jdGlvbiBmcm9tSlNPTihjdXJ2ZSwgb2JqLCByZWQpIHtcbiAgaWYgKHR5cGVvZiBvYmogPT09ICdzdHJpbmcnKVxuICAgIG9iaiA9IEpTT04ucGFyc2Uob2JqKTtcbiAgdmFyIHJlcyA9IGN1cnZlLnBvaW50KG9ialswXSwgb2JqWzFdLCByZWQpO1xuICBpZiAoIW9ialsyXSlcbiAgICByZXR1cm4gcmVzO1xuXG4gIGZ1bmN0aW9uIG9iajJwb2ludChvYmopIHtcbiAgICByZXR1cm4gY3VydmUucG9pbnQob2JqWzBdLCBvYmpbMV0sIHJlZCk7XG4gIH1cblxuICB2YXIgcHJlID0gb2JqWzJdO1xuICByZXMucHJlY29tcHV0ZWQgPSB7XG4gICAgYmV0YTogbnVsbCxcbiAgICBkb3VibGVzOiBwcmUuZG91YmxlcyAmJiB7XG4gICAgICBzdGVwOiBwcmUuZG91Ymxlcy5zdGVwLFxuICAgICAgcG9pbnRzOiBbIHJlcyBdLmNvbmNhdChwcmUuZG91Ymxlcy5wb2ludHMubWFwKG9iajJwb2ludCkpLFxuICAgIH0sXG4gICAgbmFmOiBwcmUubmFmICYmIHtcbiAgICAgIHduZDogcHJlLm5hZi53bmQsXG4gICAgICBwb2ludHM6IFsgcmVzIF0uY29uY2F0KHByZS5uYWYucG9pbnRzLm1hcChvYmoycG9pbnQpKSxcbiAgICB9LFxuICB9O1xuICByZXR1cm4gcmVzO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0KCkge1xuICBpZiAodGhpcy5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuICc8RUMgUG9pbnQgSW5maW5pdHk+JztcbiAgcmV0dXJuICc8RUMgUG9pbnQgeDogJyArIHRoaXMueC5mcm9tUmVkKCkudG9TdHJpbmcoMTYsIDIpICtcbiAgICAgICcgeTogJyArIHRoaXMueS5mcm9tUmVkKCkudG9TdHJpbmcoMTYsIDIpICsgJz4nO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmlzSW5maW5pdHkgPSBmdW5jdGlvbiBpc0luZmluaXR5KCkge1xuICByZXR1cm4gdGhpcy5pbmY7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkKHApIHtcbiAgLy8gTyArIFAgPSBQXG4gIGlmICh0aGlzLmluZilcbiAgICByZXR1cm4gcDtcblxuICAvLyBQICsgTyA9IFBcbiAgaWYgKHAuaW5mKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIC8vIFAgKyBQID0gMlBcbiAgaWYgKHRoaXMuZXEocCkpXG4gICAgcmV0dXJuIHRoaXMuZGJsKCk7XG5cbiAgLy8gUCArICgtUCkgPSBPXG4gIGlmICh0aGlzLm5lZygpLmVxKHApKVxuICAgIHJldHVybiB0aGlzLmN1cnZlLnBvaW50KG51bGwsIG51bGwpO1xuXG4gIC8vIFAgKyBRID0gT1xuICBpZiAodGhpcy54LmNtcChwLngpID09PSAwKVxuICAgIHJldHVybiB0aGlzLmN1cnZlLnBvaW50KG51bGwsIG51bGwpO1xuXG4gIHZhciBjID0gdGhpcy55LnJlZFN1YihwLnkpO1xuICBpZiAoYy5jbXBuKDApICE9PSAwKVxuICAgIGMgPSBjLnJlZE11bCh0aGlzLngucmVkU3ViKHAueCkucmVkSW52bSgpKTtcbiAgdmFyIG54ID0gYy5yZWRTcXIoKS5yZWRJU3ViKHRoaXMueCkucmVkSVN1YihwLngpO1xuICB2YXIgbnkgPSBjLnJlZE11bCh0aGlzLngucmVkU3ViKG54KSkucmVkSVN1Yih0aGlzLnkpO1xuICByZXR1cm4gdGhpcy5jdXJ2ZS5wb2ludChueCwgbnkpO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmRibCA9IGZ1bmN0aW9uIGRibCgpIHtcbiAgaWYgKHRoaXMuaW5mKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIC8vIDJQID0gT1xuICB2YXIgeXMxID0gdGhpcy55LnJlZEFkZCh0aGlzLnkpO1xuICBpZiAoeXMxLmNtcG4oMCkgPT09IDApXG4gICAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQobnVsbCwgbnVsbCk7XG5cbiAgdmFyIGEgPSB0aGlzLmN1cnZlLmE7XG5cbiAgdmFyIHgyID0gdGhpcy54LnJlZFNxcigpO1xuICB2YXIgZHlpbnYgPSB5czEucmVkSW52bSgpO1xuICB2YXIgYyA9IHgyLnJlZEFkZCh4MikucmVkSUFkZCh4MikucmVkSUFkZChhKS5yZWRNdWwoZHlpbnYpO1xuXG4gIHZhciBueCA9IGMucmVkU3FyKCkucmVkSVN1Yih0aGlzLngucmVkQWRkKHRoaXMueCkpO1xuICB2YXIgbnkgPSBjLnJlZE11bCh0aGlzLngucmVkU3ViKG54KSkucmVkSVN1Yih0aGlzLnkpO1xuICByZXR1cm4gdGhpcy5jdXJ2ZS5wb2ludChueCwgbnkpO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmdldFggPSBmdW5jdGlvbiBnZXRYKCkge1xuICByZXR1cm4gdGhpcy54LmZyb21SZWQoKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5nZXRZID0gZnVuY3Rpb24gZ2V0WSgpIHtcbiAgcmV0dXJuIHRoaXMueS5mcm9tUmVkKCk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24gbXVsKGspIHtcbiAgayA9IG5ldyBCTihrLCAxNik7XG4gIGlmICh0aGlzLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4gdGhpcztcbiAgZWxzZSBpZiAodGhpcy5faGFzRG91YmxlcyhrKSlcbiAgICByZXR1cm4gdGhpcy5jdXJ2ZS5fZml4ZWROYWZNdWwodGhpcywgayk7XG4gIGVsc2UgaWYgKHRoaXMuY3VydmUuZW5kbylcbiAgICByZXR1cm4gdGhpcy5jdXJ2ZS5fZW5kb1duYWZNdWxBZGQoWyB0aGlzIF0sIFsgayBdKTtcbiAgZWxzZVxuICAgIHJldHVybiB0aGlzLmN1cnZlLl93bmFmTXVsKHRoaXMsIGspO1xufTtcblxuUG9pbnQucHJvdG90eXBlLm11bEFkZCA9IGZ1bmN0aW9uIG11bEFkZChrMSwgcDIsIGsyKSB7XG4gIHZhciBwb2ludHMgPSBbIHRoaXMsIHAyIF07XG4gIHZhciBjb2VmZnMgPSBbIGsxLCBrMiBdO1xuICBpZiAodGhpcy5jdXJ2ZS5lbmRvKVxuICAgIHJldHVybiB0aGlzLmN1cnZlLl9lbmRvV25hZk11bEFkZChwb2ludHMsIGNvZWZmcyk7XG4gIGVsc2VcbiAgICByZXR1cm4gdGhpcy5jdXJ2ZS5fd25hZk11bEFkZCgxLCBwb2ludHMsIGNvZWZmcywgMik7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuam11bEFkZCA9IGZ1bmN0aW9uIGptdWxBZGQoazEsIHAyLCBrMikge1xuICB2YXIgcG9pbnRzID0gWyB0aGlzLCBwMiBdO1xuICB2YXIgY29lZmZzID0gWyBrMSwgazIgXTtcbiAgaWYgKHRoaXMuY3VydmUuZW5kbylcbiAgICByZXR1cm4gdGhpcy5jdXJ2ZS5fZW5kb1duYWZNdWxBZGQocG9pbnRzLCBjb2VmZnMsIHRydWUpO1xuICBlbHNlXG4gICAgcmV0dXJuIHRoaXMuY3VydmUuX3duYWZNdWxBZGQoMSwgcG9pbnRzLCBjb2VmZnMsIDIsIHRydWUpO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmVxID0gZnVuY3Rpb24gZXEocCkge1xuICByZXR1cm4gdGhpcyA9PT0gcCB8fFxuICAgICAgICAgdGhpcy5pbmYgPT09IHAuaW5mICYmXG4gICAgICAgICAgICAgKHRoaXMuaW5mIHx8IHRoaXMueC5jbXAocC54KSA9PT0gMCAmJiB0aGlzLnkuY21wKHAueSkgPT09IDApO1xufTtcblxuUG9pbnQucHJvdG90eXBlLm5lZyA9IGZ1bmN0aW9uIG5lZyhfcHJlY29tcHV0ZSkge1xuICBpZiAodGhpcy5pbmYpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgdmFyIHJlcyA9IHRoaXMuY3VydmUucG9pbnQodGhpcy54LCB0aGlzLnkucmVkTmVnKCkpO1xuICBpZiAoX3ByZWNvbXB1dGUgJiYgdGhpcy5wcmVjb21wdXRlZCkge1xuICAgIHZhciBwcmUgPSB0aGlzLnByZWNvbXB1dGVkO1xuICAgIHZhciBuZWdhdGUgPSBmdW5jdGlvbihwKSB7XG4gICAgICByZXR1cm4gcC5uZWcoKTtcbiAgICB9O1xuICAgIHJlcy5wcmVjb21wdXRlZCA9IHtcbiAgICAgIG5hZjogcHJlLm5hZiAmJiB7XG4gICAgICAgIHduZDogcHJlLm5hZi53bmQsXG4gICAgICAgIHBvaW50czogcHJlLm5hZi5wb2ludHMubWFwKG5lZ2F0ZSksXG4gICAgICB9LFxuICAgICAgZG91YmxlczogcHJlLmRvdWJsZXMgJiYge1xuICAgICAgICBzdGVwOiBwcmUuZG91Ymxlcy5zdGVwLFxuICAgICAgICBwb2ludHM6IHByZS5kb3VibGVzLnBvaW50cy5tYXAobmVnYXRlKSxcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxuICByZXR1cm4gcmVzO1xufTtcblxuUG9pbnQucHJvdG90eXBlLnRvSiA9IGZ1bmN0aW9uIHRvSigpIHtcbiAgaWYgKHRoaXMuaW5mKVxuICAgIHJldHVybiB0aGlzLmN1cnZlLmpwb2ludChudWxsLCBudWxsLCBudWxsKTtcblxuICB2YXIgcmVzID0gdGhpcy5jdXJ2ZS5qcG9pbnQodGhpcy54LCB0aGlzLnksIHRoaXMuY3VydmUub25lKTtcbiAgcmV0dXJuIHJlcztcbn07XG5cbmZ1bmN0aW9uIEpQb2ludChjdXJ2ZSwgeCwgeSwgeikge1xuICBiYXNlLkJhc2VQb2ludC5jYWxsKHRoaXMsIGN1cnZlLCAnamFjb2JpYW4nKTtcbiAgaWYgKHggPT09IG51bGwgJiYgeSA9PT0gbnVsbCAmJiB6ID09PSBudWxsKSB7XG4gICAgdGhpcy54ID0gdGhpcy5jdXJ2ZS5vbmU7XG4gICAgdGhpcy55ID0gdGhpcy5jdXJ2ZS5vbmU7XG4gICAgdGhpcy56ID0gbmV3IEJOKDApO1xuICB9IGVsc2Uge1xuICAgIHRoaXMueCA9IG5ldyBCTih4LCAxNik7XG4gICAgdGhpcy55ID0gbmV3IEJOKHksIDE2KTtcbiAgICB0aGlzLnogPSBuZXcgQk4oeiwgMTYpO1xuICB9XG4gIGlmICghdGhpcy54LnJlZClcbiAgICB0aGlzLnggPSB0aGlzLngudG9SZWQodGhpcy5jdXJ2ZS5yZWQpO1xuICBpZiAoIXRoaXMueS5yZWQpXG4gICAgdGhpcy55ID0gdGhpcy55LnRvUmVkKHRoaXMuY3VydmUucmVkKTtcbiAgaWYgKCF0aGlzLnoucmVkKVxuICAgIHRoaXMueiA9IHRoaXMuei50b1JlZCh0aGlzLmN1cnZlLnJlZCk7XG5cbiAgdGhpcy56T25lID0gdGhpcy56ID09PSB0aGlzLmN1cnZlLm9uZTtcbn1cbmluaGVyaXRzX2Jyb3dzZXIoSlBvaW50LCBiYXNlLkJhc2VQb2ludCk7XG5cblNob3J0Q3VydmUucHJvdG90eXBlLmpwb2ludCA9IGZ1bmN0aW9uIGpwb2ludCh4LCB5LCB6KSB7XG4gIHJldHVybiBuZXcgSlBvaW50KHRoaXMsIHgsIHksIHopO1xufTtcblxuSlBvaW50LnByb3RvdHlwZS50b1AgPSBmdW5jdGlvbiB0b1AoKSB7XG4gIGlmICh0aGlzLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4gdGhpcy5jdXJ2ZS5wb2ludChudWxsLCBudWxsKTtcblxuICB2YXIgemludiA9IHRoaXMuei5yZWRJbnZtKCk7XG4gIHZhciB6aW52MiA9IHppbnYucmVkU3FyKCk7XG4gIHZhciBheCA9IHRoaXMueC5yZWRNdWwoemludjIpO1xuICB2YXIgYXkgPSB0aGlzLnkucmVkTXVsKHppbnYyKS5yZWRNdWwoemludik7XG5cbiAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQoYXgsIGF5KTtcbn07XG5cbkpQb2ludC5wcm90b3R5cGUubmVnID0gZnVuY3Rpb24gbmVnKCkge1xuICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQodGhpcy54LCB0aGlzLnkucmVkTmVnKCksIHRoaXMueik7XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZChwKSB7XG4gIC8vIE8gKyBQID0gUFxuICBpZiAodGhpcy5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuIHA7XG5cbiAgLy8gUCArIE8gPSBQXG4gIGlmIChwLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyAxMk0gKyA0UyArIDdBXG4gIHZhciBwejIgPSBwLnoucmVkU3FyKCk7XG4gIHZhciB6MiA9IHRoaXMuei5yZWRTcXIoKTtcbiAgdmFyIHUxID0gdGhpcy54LnJlZE11bChwejIpO1xuICB2YXIgdTIgPSBwLngucmVkTXVsKHoyKTtcbiAgdmFyIHMxID0gdGhpcy55LnJlZE11bChwejIucmVkTXVsKHAueikpO1xuICB2YXIgczIgPSBwLnkucmVkTXVsKHoyLnJlZE11bCh0aGlzLnopKTtcblxuICB2YXIgaCA9IHUxLnJlZFN1Yih1Mik7XG4gIHZhciByID0gczEucmVkU3ViKHMyKTtcbiAgaWYgKGguY21wbigwKSA9PT0gMCkge1xuICAgIGlmIChyLmNtcG4oMCkgIT09IDApXG4gICAgICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQobnVsbCwgbnVsbCwgbnVsbCk7XG4gICAgZWxzZVxuICAgICAgcmV0dXJuIHRoaXMuZGJsKCk7XG4gIH1cblxuICB2YXIgaDIgPSBoLnJlZFNxcigpO1xuICB2YXIgaDMgPSBoMi5yZWRNdWwoaCk7XG4gIHZhciB2ID0gdTEucmVkTXVsKGgyKTtcblxuICB2YXIgbnggPSByLnJlZFNxcigpLnJlZElBZGQoaDMpLnJlZElTdWIodikucmVkSVN1Yih2KTtcbiAgdmFyIG55ID0gci5yZWRNdWwodi5yZWRJU3ViKG54KSkucmVkSVN1YihzMS5yZWRNdWwoaDMpKTtcbiAgdmFyIG56ID0gdGhpcy56LnJlZE11bChwLnopLnJlZE11bChoKTtcblxuICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQobngsIG55LCBueik7XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLm1peGVkQWRkID0gZnVuY3Rpb24gbWl4ZWRBZGQocCkge1xuICAvLyBPICsgUCA9IFBcbiAgaWYgKHRoaXMuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiBwLnRvSigpO1xuXG4gIC8vIFAgKyBPID0gUFxuICBpZiAocC5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8gOE0gKyAzUyArIDdBXG4gIHZhciB6MiA9IHRoaXMuei5yZWRTcXIoKTtcbiAgdmFyIHUxID0gdGhpcy54O1xuICB2YXIgdTIgPSBwLngucmVkTXVsKHoyKTtcbiAgdmFyIHMxID0gdGhpcy55O1xuICB2YXIgczIgPSBwLnkucmVkTXVsKHoyKS5yZWRNdWwodGhpcy56KTtcblxuICB2YXIgaCA9IHUxLnJlZFN1Yih1Mik7XG4gIHZhciByID0gczEucmVkU3ViKHMyKTtcbiAgaWYgKGguY21wbigwKSA9PT0gMCkge1xuICAgIGlmIChyLmNtcG4oMCkgIT09IDApXG4gICAgICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQobnVsbCwgbnVsbCwgbnVsbCk7XG4gICAgZWxzZVxuICAgICAgcmV0dXJuIHRoaXMuZGJsKCk7XG4gIH1cblxuICB2YXIgaDIgPSBoLnJlZFNxcigpO1xuICB2YXIgaDMgPSBoMi5yZWRNdWwoaCk7XG4gIHZhciB2ID0gdTEucmVkTXVsKGgyKTtcblxuICB2YXIgbnggPSByLnJlZFNxcigpLnJlZElBZGQoaDMpLnJlZElTdWIodikucmVkSVN1Yih2KTtcbiAgdmFyIG55ID0gci5yZWRNdWwodi5yZWRJU3ViKG54KSkucmVkSVN1YihzMS5yZWRNdWwoaDMpKTtcbiAgdmFyIG56ID0gdGhpcy56LnJlZE11bChoKTtcblxuICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQobngsIG55LCBueik7XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLmRibHAgPSBmdW5jdGlvbiBkYmxwKHBvdykge1xuICBpZiAocG93ID09PSAwKVxuICAgIHJldHVybiB0aGlzO1xuICBpZiAodGhpcy5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuIHRoaXM7XG4gIGlmICghcG93KVxuICAgIHJldHVybiB0aGlzLmRibCgpO1xuXG4gIHZhciBpO1xuICBpZiAodGhpcy5jdXJ2ZS56ZXJvQSB8fCB0aGlzLmN1cnZlLnRocmVlQSkge1xuICAgIHZhciByID0gdGhpcztcbiAgICBmb3IgKGkgPSAwOyBpIDwgcG93OyBpKyspXG4gICAgICByID0gci5kYmwoKTtcbiAgICByZXR1cm4gcjtcbiAgfVxuXG4gIC8vIDFNICsgMlMgKyAxQSArIE4gKiAoNFMgKyA1TSArIDhBKVxuICAvLyBOID0gMSA9PiA2TSArIDZTICsgOUFcbiAgdmFyIGEgPSB0aGlzLmN1cnZlLmE7XG4gIHZhciB0aW52ID0gdGhpcy5jdXJ2ZS50aW52O1xuXG4gIHZhciBqeCA9IHRoaXMueDtcbiAgdmFyIGp5ID0gdGhpcy55O1xuICB2YXIganogPSB0aGlzLno7XG4gIHZhciBqejQgPSBqei5yZWRTcXIoKS5yZWRTcXIoKTtcblxuICAvLyBSZXVzZSByZXN1bHRzXG4gIHZhciBqeWQgPSBqeS5yZWRBZGQoankpO1xuICBmb3IgKGkgPSAwOyBpIDwgcG93OyBpKyspIHtcbiAgICB2YXIgangyID0gangucmVkU3FyKCk7XG4gICAgdmFyIGp5ZDIgPSBqeWQucmVkU3FyKCk7XG4gICAgdmFyIGp5ZDQgPSBqeWQyLnJlZFNxcigpO1xuICAgIHZhciBjID0gangyLnJlZEFkZChqeDIpLnJlZElBZGQoangyKS5yZWRJQWRkKGEucmVkTXVsKGp6NCkpO1xuXG4gICAgdmFyIHQxID0gangucmVkTXVsKGp5ZDIpO1xuICAgIHZhciBueCA9IGMucmVkU3FyKCkucmVkSVN1Yih0MS5yZWRBZGQodDEpKTtcbiAgICB2YXIgdDIgPSB0MS5yZWRJU3ViKG54KTtcbiAgICB2YXIgZG55ID0gYy5yZWRNdWwodDIpO1xuICAgIGRueSA9IGRueS5yZWRJQWRkKGRueSkucmVkSVN1YihqeWQ0KTtcbiAgICB2YXIgbnogPSBqeWQucmVkTXVsKGp6KTtcbiAgICBpZiAoaSArIDEgPCBwb3cpXG4gICAgICBqejQgPSBqejQucmVkTXVsKGp5ZDQpO1xuXG4gICAganggPSBueDtcbiAgICBqeiA9IG56O1xuICAgIGp5ZCA9IGRueTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmN1cnZlLmpwb2ludChqeCwganlkLnJlZE11bCh0aW52KSwganopO1xufTtcblxuSlBvaW50LnByb3RvdHlwZS5kYmwgPSBmdW5jdGlvbiBkYmwoKSB7XG4gIGlmICh0aGlzLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4gdGhpcztcblxuICBpZiAodGhpcy5jdXJ2ZS56ZXJvQSlcbiAgICByZXR1cm4gdGhpcy5femVyb0RibCgpO1xuICBlbHNlIGlmICh0aGlzLmN1cnZlLnRocmVlQSlcbiAgICByZXR1cm4gdGhpcy5fdGhyZWVEYmwoKTtcbiAgZWxzZVxuICAgIHJldHVybiB0aGlzLl9kYmwoKTtcbn07XG5cbkpQb2ludC5wcm90b3R5cGUuX3plcm9EYmwgPSBmdW5jdGlvbiBfemVyb0RibCgpIHtcbiAgdmFyIG54O1xuICB2YXIgbnk7XG4gIHZhciBuejtcbiAgLy8gWiA9IDFcbiAgaWYgKHRoaXMuek9uZSkge1xuICAgIC8vIGh5cGVyZWxsaXB0aWMub3JnL0VGRC9nMXAvYXV0by1zaG9ydHctamFjb2JpYW4tMC5odG1sXG4gICAgLy8gICAgICNkb3VibGluZy1tZGJsLTIwMDctYmxcbiAgICAvLyAxTSArIDVTICsgMTRBXG5cbiAgICAvLyBYWCA9IFgxXjJcbiAgICB2YXIgeHggPSB0aGlzLngucmVkU3FyKCk7XG4gICAgLy8gWVkgPSBZMV4yXG4gICAgdmFyIHl5ID0gdGhpcy55LnJlZFNxcigpO1xuICAgIC8vIFlZWVkgPSBZWV4yXG4gICAgdmFyIHl5eXkgPSB5eS5yZWRTcXIoKTtcbiAgICAvLyBTID0gMiAqICgoWDEgKyBZWSleMiAtIFhYIC0gWVlZWSlcbiAgICB2YXIgcyA9IHRoaXMueC5yZWRBZGQoeXkpLnJlZFNxcigpLnJlZElTdWIoeHgpLnJlZElTdWIoeXl5eSk7XG4gICAgcyA9IHMucmVkSUFkZChzKTtcbiAgICAvLyBNID0gMyAqIFhYICsgYTsgYSA9IDBcbiAgICB2YXIgbSA9IHh4LnJlZEFkZCh4eCkucmVkSUFkZCh4eCk7XG4gICAgLy8gVCA9IE0gXiAyIC0gMipTXG4gICAgdmFyIHQgPSBtLnJlZFNxcigpLnJlZElTdWIocykucmVkSVN1YihzKTtcblxuICAgIC8vIDggKiBZWVlZXG4gICAgdmFyIHl5eXk4ID0geXl5eS5yZWRJQWRkKHl5eXkpO1xuICAgIHl5eXk4ID0geXl5eTgucmVkSUFkZCh5eXl5OCk7XG4gICAgeXl5eTggPSB5eXl5OC5yZWRJQWRkKHl5eXk4KTtcblxuICAgIC8vIFgzID0gVFxuICAgIG54ID0gdDtcbiAgICAvLyBZMyA9IE0gKiAoUyAtIFQpIC0gOCAqIFlZWVlcbiAgICBueSA9IG0ucmVkTXVsKHMucmVkSVN1Yih0KSkucmVkSVN1Yih5eXl5OCk7XG4gICAgLy8gWjMgPSAyKlkxXG4gICAgbnogPSB0aGlzLnkucmVkQWRkKHRoaXMueSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gaHlwZXJlbGxpcHRpYy5vcmcvRUZEL2cxcC9hdXRvLXNob3J0dy1qYWNvYmlhbi0wLmh0bWxcbiAgICAvLyAgICAgI2RvdWJsaW5nLWRibC0yMDA5LWxcbiAgICAvLyAyTSArIDVTICsgMTNBXG5cbiAgICAvLyBBID0gWDFeMlxuICAgIHZhciBhID0gdGhpcy54LnJlZFNxcigpO1xuICAgIC8vIEIgPSBZMV4yXG4gICAgdmFyIGIgPSB0aGlzLnkucmVkU3FyKCk7XG4gICAgLy8gQyA9IEJeMlxuICAgIHZhciBjID0gYi5yZWRTcXIoKTtcbiAgICAvLyBEID0gMiAqICgoWDEgKyBCKV4yIC0gQSAtIEMpXG4gICAgdmFyIGQgPSB0aGlzLngucmVkQWRkKGIpLnJlZFNxcigpLnJlZElTdWIoYSkucmVkSVN1YihjKTtcbiAgICBkID0gZC5yZWRJQWRkKGQpO1xuICAgIC8vIEUgPSAzICogQVxuICAgIHZhciBlID0gYS5yZWRBZGQoYSkucmVkSUFkZChhKTtcbiAgICAvLyBGID0gRV4yXG4gICAgdmFyIGYgPSBlLnJlZFNxcigpO1xuXG4gICAgLy8gOCAqIENcbiAgICB2YXIgYzggPSBjLnJlZElBZGQoYyk7XG4gICAgYzggPSBjOC5yZWRJQWRkKGM4KTtcbiAgICBjOCA9IGM4LnJlZElBZGQoYzgpO1xuXG4gICAgLy8gWDMgPSBGIC0gMiAqIERcbiAgICBueCA9IGYucmVkSVN1YihkKS5yZWRJU3ViKGQpO1xuICAgIC8vIFkzID0gRSAqIChEIC0gWDMpIC0gOCAqIENcbiAgICBueSA9IGUucmVkTXVsKGQucmVkSVN1YihueCkpLnJlZElTdWIoYzgpO1xuICAgIC8vIFozID0gMiAqIFkxICogWjFcbiAgICBueiA9IHRoaXMueS5yZWRNdWwodGhpcy56KTtcbiAgICBueiA9IG56LnJlZElBZGQobnopO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KG54LCBueSwgbnopO1xufTtcblxuSlBvaW50LnByb3RvdHlwZS5fdGhyZWVEYmwgPSBmdW5jdGlvbiBfdGhyZWVEYmwoKSB7XG4gIHZhciBueDtcbiAgdmFyIG55O1xuICB2YXIgbno7XG4gIC8vIFogPSAxXG4gIGlmICh0aGlzLnpPbmUpIHtcbiAgICAvLyBoeXBlcmVsbGlwdGljLm9yZy9FRkQvZzFwL2F1dG8tc2hvcnR3LWphY29iaWFuLTMuaHRtbFxuICAgIC8vICAgICAjZG91YmxpbmctbWRibC0yMDA3LWJsXG4gICAgLy8gMU0gKyA1UyArIDE1QVxuXG4gICAgLy8gWFggPSBYMV4yXG4gICAgdmFyIHh4ID0gdGhpcy54LnJlZFNxcigpO1xuICAgIC8vIFlZID0gWTFeMlxuICAgIHZhciB5eSA9IHRoaXMueS5yZWRTcXIoKTtcbiAgICAvLyBZWVlZID0gWVleMlxuICAgIHZhciB5eXl5ID0geXkucmVkU3FyKCk7XG4gICAgLy8gUyA9IDIgKiAoKFgxICsgWVkpXjIgLSBYWCAtIFlZWVkpXG4gICAgdmFyIHMgPSB0aGlzLngucmVkQWRkKHl5KS5yZWRTcXIoKS5yZWRJU3ViKHh4KS5yZWRJU3ViKHl5eXkpO1xuICAgIHMgPSBzLnJlZElBZGQocyk7XG4gICAgLy8gTSA9IDMgKiBYWCArIGFcbiAgICB2YXIgbSA9IHh4LnJlZEFkZCh4eCkucmVkSUFkZCh4eCkucmVkSUFkZCh0aGlzLmN1cnZlLmEpO1xuICAgIC8vIFQgPSBNXjIgLSAyICogU1xuICAgIHZhciB0ID0gbS5yZWRTcXIoKS5yZWRJU3ViKHMpLnJlZElTdWIocyk7XG4gICAgLy8gWDMgPSBUXG4gICAgbnggPSB0O1xuICAgIC8vIFkzID0gTSAqIChTIC0gVCkgLSA4ICogWVlZWVxuICAgIHZhciB5eXl5OCA9IHl5eXkucmVkSUFkZCh5eXl5KTtcbiAgICB5eXl5OCA9IHl5eXk4LnJlZElBZGQoeXl5eTgpO1xuICAgIHl5eXk4ID0geXl5eTgucmVkSUFkZCh5eXl5OCk7XG4gICAgbnkgPSBtLnJlZE11bChzLnJlZElTdWIodCkpLnJlZElTdWIoeXl5eTgpO1xuICAgIC8vIFozID0gMiAqIFkxXG4gICAgbnogPSB0aGlzLnkucmVkQWRkKHRoaXMueSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gaHlwZXJlbGxpcHRpYy5vcmcvRUZEL2cxcC9hdXRvLXNob3J0dy1qYWNvYmlhbi0zLmh0bWwjZG91YmxpbmctZGJsLTIwMDEtYlxuICAgIC8vIDNNICsgNVNcblxuICAgIC8vIGRlbHRhID0gWjFeMlxuICAgIHZhciBkZWx0YSA9IHRoaXMuei5yZWRTcXIoKTtcbiAgICAvLyBnYW1tYSA9IFkxXjJcbiAgICB2YXIgZ2FtbWEgPSB0aGlzLnkucmVkU3FyKCk7XG4gICAgLy8gYmV0YSA9IFgxICogZ2FtbWFcbiAgICB2YXIgYmV0YSA9IHRoaXMueC5yZWRNdWwoZ2FtbWEpO1xuICAgIC8vIGFscGhhID0gMyAqIChYMSAtIGRlbHRhKSAqIChYMSArIGRlbHRhKVxuICAgIHZhciBhbHBoYSA9IHRoaXMueC5yZWRTdWIoZGVsdGEpLnJlZE11bCh0aGlzLngucmVkQWRkKGRlbHRhKSk7XG4gICAgYWxwaGEgPSBhbHBoYS5yZWRBZGQoYWxwaGEpLnJlZElBZGQoYWxwaGEpO1xuICAgIC8vIFgzID0gYWxwaGFeMiAtIDggKiBiZXRhXG4gICAgdmFyIGJldGE0ID0gYmV0YS5yZWRJQWRkKGJldGEpO1xuICAgIGJldGE0ID0gYmV0YTQucmVkSUFkZChiZXRhNCk7XG4gICAgdmFyIGJldGE4ID0gYmV0YTQucmVkQWRkKGJldGE0KTtcbiAgICBueCA9IGFscGhhLnJlZFNxcigpLnJlZElTdWIoYmV0YTgpO1xuICAgIC8vIFozID0gKFkxICsgWjEpXjIgLSBnYW1tYSAtIGRlbHRhXG4gICAgbnogPSB0aGlzLnkucmVkQWRkKHRoaXMueikucmVkU3FyKCkucmVkSVN1YihnYW1tYSkucmVkSVN1YihkZWx0YSk7XG4gICAgLy8gWTMgPSBhbHBoYSAqICg0ICogYmV0YSAtIFgzKSAtIDggKiBnYW1tYV4yXG4gICAgdmFyIGdnYW1tYTggPSBnYW1tYS5yZWRTcXIoKTtcbiAgICBnZ2FtbWE4ID0gZ2dhbW1hOC5yZWRJQWRkKGdnYW1tYTgpO1xuICAgIGdnYW1tYTggPSBnZ2FtbWE4LnJlZElBZGQoZ2dhbW1hOCk7XG4gICAgZ2dhbW1hOCA9IGdnYW1tYTgucmVkSUFkZChnZ2FtbWE4KTtcbiAgICBueSA9IGFscGhhLnJlZE11bChiZXRhNC5yZWRJU3ViKG54KSkucmVkSVN1YihnZ2FtbWE4KTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmN1cnZlLmpwb2ludChueCwgbnksIG56KTtcbn07XG5cbkpQb2ludC5wcm90b3R5cGUuX2RibCA9IGZ1bmN0aW9uIF9kYmwoKSB7XG4gIHZhciBhID0gdGhpcy5jdXJ2ZS5hO1xuXG4gIC8vIDRNICsgNlMgKyAxMEFcbiAgdmFyIGp4ID0gdGhpcy54O1xuICB2YXIgankgPSB0aGlzLnk7XG4gIHZhciBqeiA9IHRoaXMuejtcbiAgdmFyIGp6NCA9IGp6LnJlZFNxcigpLnJlZFNxcigpO1xuXG4gIHZhciBqeDIgPSBqeC5yZWRTcXIoKTtcbiAgdmFyIGp5MiA9IGp5LnJlZFNxcigpO1xuXG4gIHZhciBjID0gangyLnJlZEFkZChqeDIpLnJlZElBZGQoangyKS5yZWRJQWRkKGEucmVkTXVsKGp6NCkpO1xuXG4gIHZhciBqeGQ0ID0gangucmVkQWRkKGp4KTtcbiAganhkNCA9IGp4ZDQucmVkSUFkZChqeGQ0KTtcbiAgdmFyIHQxID0ganhkNC5yZWRNdWwoankyKTtcbiAgdmFyIG54ID0gYy5yZWRTcXIoKS5yZWRJU3ViKHQxLnJlZEFkZCh0MSkpO1xuICB2YXIgdDIgPSB0MS5yZWRJU3ViKG54KTtcblxuICB2YXIganlkOCA9IGp5Mi5yZWRTcXIoKTtcbiAganlkOCA9IGp5ZDgucmVkSUFkZChqeWQ4KTtcbiAganlkOCA9IGp5ZDgucmVkSUFkZChqeWQ4KTtcbiAganlkOCA9IGp5ZDgucmVkSUFkZChqeWQ4KTtcbiAgdmFyIG55ID0gYy5yZWRNdWwodDIpLnJlZElTdWIoanlkOCk7XG4gIHZhciBueiA9IGp5LnJlZEFkZChqeSkucmVkTXVsKGp6KTtcblxuICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQobngsIG55LCBueik7XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLnRycGwgPSBmdW5jdGlvbiB0cnBsKCkge1xuICBpZiAoIXRoaXMuY3VydmUuemVyb0EpXG4gICAgcmV0dXJuIHRoaXMuZGJsKCkuYWRkKHRoaXMpO1xuXG4gIC8vIGh5cGVyZWxsaXB0aWMub3JnL0VGRC9nMXAvYXV0by1zaG9ydHctamFjb2JpYW4tMC5odG1sI3RyaXBsaW5nLXRwbC0yMDA3LWJsXG4gIC8vIDVNICsgMTBTICsgLi4uXG5cbiAgLy8gWFggPSBYMV4yXG4gIHZhciB4eCA9IHRoaXMueC5yZWRTcXIoKTtcbiAgLy8gWVkgPSBZMV4yXG4gIHZhciB5eSA9IHRoaXMueS5yZWRTcXIoKTtcbiAgLy8gWlogPSBaMV4yXG4gIHZhciB6eiA9IHRoaXMuei5yZWRTcXIoKTtcbiAgLy8gWVlZWSA9IFlZXjJcbiAgdmFyIHl5eXkgPSB5eS5yZWRTcXIoKTtcbiAgLy8gTSA9IDMgKiBYWCArIGEgKiBaWjI7IGEgPSAwXG4gIHZhciBtID0geHgucmVkQWRkKHh4KS5yZWRJQWRkKHh4KTtcbiAgLy8gTU0gPSBNXjJcbiAgdmFyIG1tID0gbS5yZWRTcXIoKTtcbiAgLy8gRSA9IDYgKiAoKFgxICsgWVkpXjIgLSBYWCAtIFlZWVkpIC0gTU1cbiAgdmFyIGUgPSB0aGlzLngucmVkQWRkKHl5KS5yZWRTcXIoKS5yZWRJU3ViKHh4KS5yZWRJU3ViKHl5eXkpO1xuICBlID0gZS5yZWRJQWRkKGUpO1xuICBlID0gZS5yZWRBZGQoZSkucmVkSUFkZChlKTtcbiAgZSA9IGUucmVkSVN1YihtbSk7XG4gIC8vIEVFID0gRV4yXG4gIHZhciBlZSA9IGUucmVkU3FyKCk7XG4gIC8vIFQgPSAxNipZWVlZXG4gIHZhciB0ID0geXl5eS5yZWRJQWRkKHl5eXkpO1xuICB0ID0gdC5yZWRJQWRkKHQpO1xuICB0ID0gdC5yZWRJQWRkKHQpO1xuICB0ID0gdC5yZWRJQWRkKHQpO1xuICAvLyBVID0gKE0gKyBFKV4yIC0gTU0gLSBFRSAtIFRcbiAgdmFyIHUgPSBtLnJlZElBZGQoZSkucmVkU3FyKCkucmVkSVN1YihtbSkucmVkSVN1YihlZSkucmVkSVN1Yih0KTtcbiAgLy8gWDMgPSA0ICogKFgxICogRUUgLSA0ICogWVkgKiBVKVxuICB2YXIgeXl1NCA9IHl5LnJlZE11bCh1KTtcbiAgeXl1NCA9IHl5dTQucmVkSUFkZCh5eXU0KTtcbiAgeXl1NCA9IHl5dTQucmVkSUFkZCh5eXU0KTtcbiAgdmFyIG54ID0gdGhpcy54LnJlZE11bChlZSkucmVkSVN1Yih5eXU0KTtcbiAgbnggPSBueC5yZWRJQWRkKG54KTtcbiAgbnggPSBueC5yZWRJQWRkKG54KTtcbiAgLy8gWTMgPSA4ICogWTEgKiAoVSAqIChUIC0gVSkgLSBFICogRUUpXG4gIHZhciBueSA9IHRoaXMueS5yZWRNdWwodS5yZWRNdWwodC5yZWRJU3ViKHUpKS5yZWRJU3ViKGUucmVkTXVsKGVlKSkpO1xuICBueSA9IG55LnJlZElBZGQobnkpO1xuICBueSA9IG55LnJlZElBZGQobnkpO1xuICBueSA9IG55LnJlZElBZGQobnkpO1xuICAvLyBaMyA9IChaMSArIEUpXjIgLSBaWiAtIEVFXG4gIHZhciBueiA9IHRoaXMuei5yZWRBZGQoZSkucmVkU3FyKCkucmVkSVN1Yih6eikucmVkSVN1YihlZSk7XG5cbiAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KG54LCBueSwgbnopO1xufTtcblxuSlBvaW50LnByb3RvdHlwZS5tdWwgPSBmdW5jdGlvbiBtdWwoaywga2Jhc2UpIHtcbiAgayA9IG5ldyBCTihrLCBrYmFzZSk7XG5cbiAgcmV0dXJuIHRoaXMuY3VydmUuX3duYWZNdWwodGhpcywgayk7XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLmVxID0gZnVuY3Rpb24gZXEocCkge1xuICBpZiAocC50eXBlID09PSAnYWZmaW5lJylcbiAgICByZXR1cm4gdGhpcy5lcShwLnRvSigpKTtcblxuICBpZiAodGhpcyA9PT0gcClcbiAgICByZXR1cm4gdHJ1ZTtcblxuICAvLyB4MSAqIHoyXjIgPT0geDIgKiB6MV4yXG4gIHZhciB6MiA9IHRoaXMuei5yZWRTcXIoKTtcbiAgdmFyIHB6MiA9IHAuei5yZWRTcXIoKTtcbiAgaWYgKHRoaXMueC5yZWRNdWwocHoyKS5yZWRJU3ViKHAueC5yZWRNdWwoejIpKS5jbXBuKDApICE9PSAwKVxuICAgIHJldHVybiBmYWxzZTtcblxuICAvLyB5MSAqIHoyXjMgPT0geTIgKiB6MV4zXG4gIHZhciB6MyA9IHoyLnJlZE11bCh0aGlzLnopO1xuICB2YXIgcHozID0gcHoyLnJlZE11bChwLnopO1xuICByZXR1cm4gdGhpcy55LnJlZE11bChwejMpLnJlZElTdWIocC55LnJlZE11bCh6MykpLmNtcG4oMCkgPT09IDA7XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLmVxWFRvUCA9IGZ1bmN0aW9uIGVxWFRvUCh4KSB7XG4gIHZhciB6cyA9IHRoaXMuei5yZWRTcXIoKTtcbiAgdmFyIHJ4ID0geC50b1JlZCh0aGlzLmN1cnZlLnJlZCkucmVkTXVsKHpzKTtcbiAgaWYgKHRoaXMueC5jbXAocngpID09PSAwKVxuICAgIHJldHVybiB0cnVlO1xuXG4gIHZhciB4YyA9IHguY2xvbmUoKTtcbiAgdmFyIHQgPSB0aGlzLmN1cnZlLnJlZE4ucmVkTXVsKHpzKTtcbiAgZm9yICg7Oykge1xuICAgIHhjLmlhZGQodGhpcy5jdXJ2ZS5uKTtcbiAgICBpZiAoeGMuY21wKHRoaXMuY3VydmUucCkgPj0gMClcbiAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIHJ4LnJlZElBZGQodCk7XG4gICAgaWYgKHRoaXMueC5jbXAocngpID09PSAwKVxuICAgICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5cbkpQb2ludC5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QoKSB7XG4gIGlmICh0aGlzLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4gJzxFQyBKUG9pbnQgSW5maW5pdHk+JztcbiAgcmV0dXJuICc8RUMgSlBvaW50IHg6ICcgKyB0aGlzLngudG9TdHJpbmcoMTYsIDIpICtcbiAgICAgICcgeTogJyArIHRoaXMueS50b1N0cmluZygxNiwgMikgK1xuICAgICAgJyB6OiAnICsgdGhpcy56LnRvU3RyaW5nKDE2LCAyKSArICc+Jztcbn07XG5cbkpQb2ludC5wcm90b3R5cGUuaXNJbmZpbml0eSA9IGZ1bmN0aW9uIGlzSW5maW5pdHkoKSB7XG4gIC8vIFhYWCBUaGlzIGNvZGUgYXNzdW1lcyB0aGF0IHplcm8gaXMgYWx3YXlzIHplcm8gaW4gcmVkXG4gIHJldHVybiB0aGlzLnouY21wbigwKSA9PT0gMDtcbn07XG5cbnZhciBjdXJ2ZV8xID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY3VydmUgPSBleHBvcnRzO1xuXG5jdXJ2ZS5iYXNlID0gYmFzZTtcbmN1cnZlLnNob3J0ID0gc2hvcnRfMTtcbmN1cnZlLm1vbnQgPSAvKlJpY01vbzpldGhlcnM6cmVxdWlyZSguL21vbnQpKi8obnVsbCk7XG5jdXJ2ZS5lZHdhcmRzID0gLypSaWNNb286ZXRoZXJzOnJlcXVpcmUoLi9lZHdhcmRzKSovKG51bGwpO1xufSk7XG5cbnZhciBjdXJ2ZXNfMSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIGN1cnZlcyA9IGV4cG9ydHM7XG5cblxuXG5cblxudmFyIGFzc2VydCA9IHV0aWxzXzEkMS5hc3NlcnQ7XG5cbmZ1bmN0aW9uIFByZXNldEN1cnZlKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMudHlwZSA9PT0gJ3Nob3J0JylcbiAgICB0aGlzLmN1cnZlID0gbmV3IGN1cnZlXzEuc2hvcnQob3B0aW9ucyk7XG4gIGVsc2UgaWYgKG9wdGlvbnMudHlwZSA9PT0gJ2Vkd2FyZHMnKVxuICAgIHRoaXMuY3VydmUgPSBuZXcgY3VydmVfMS5lZHdhcmRzKG9wdGlvbnMpO1xuICBlbHNlXG4gICAgdGhpcy5jdXJ2ZSA9IG5ldyBjdXJ2ZV8xLm1vbnQob3B0aW9ucyk7XG4gIHRoaXMuZyA9IHRoaXMuY3VydmUuZztcbiAgdGhpcy5uID0gdGhpcy5jdXJ2ZS5uO1xuICB0aGlzLmhhc2ggPSBvcHRpb25zLmhhc2g7XG5cbiAgYXNzZXJ0KHRoaXMuZy52YWxpZGF0ZSgpLCAnSW52YWxpZCBjdXJ2ZScpO1xuICBhc3NlcnQodGhpcy5nLm11bCh0aGlzLm4pLmlzSW5maW5pdHkoKSwgJ0ludmFsaWQgY3VydmUsIEcqTiAhPSBPJyk7XG59XG5jdXJ2ZXMuUHJlc2V0Q3VydmUgPSBQcmVzZXRDdXJ2ZTtcblxuZnVuY3Rpb24gZGVmaW5lQ3VydmUobmFtZSwgb3B0aW9ucykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VydmVzLCBuYW1lLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjdXJ2ZSA9IG5ldyBQcmVzZXRDdXJ2ZShvcHRpb25zKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdXJ2ZXMsIG5hbWUsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogY3VydmUsXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBjdXJ2ZTtcbiAgICB9LFxuICB9KTtcbn1cblxuZGVmaW5lQ3VydmUoJ3AxOTInLCB7XG4gIHR5cGU6ICdzaG9ydCcsXG4gIHByaW1lOiAncDE5MicsXG4gIHA6ICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZSBmZmZmZmZmZiBmZmZmZmZmZicsXG4gIGE6ICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZSBmZmZmZmZmZiBmZmZmZmZmYycsXG4gIGI6ICc2NDIxMDUxOSBlNTljODBlNyAwZmE3ZTlhYiA3MjI0MzA0OSBmZWI4ZGVlYyBjMTQ2YjliMScsXG4gIG46ICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiA5OWRlZjgzNiAxNDZiYzliMSBiNGQyMjgzMScsXG4gIGhhc2g6IGhhc2guc2hhMjU2LFxuICBnUmVkOiBmYWxzZSxcbiAgZzogW1xuICAgICcxODhkYTgwZSBiMDMwOTBmNiA3Y2JmMjBlYiA0M2ExODgwMCBmNGZmMGFmZCA4MmZmMTAxMicsXG4gICAgJzA3MTkyYjk1IGZmYzhkYTc4IDYzMTAxMWVkIDZiMjRjZGQ1IDczZjk3N2ExIDFlNzk0ODExJyxcbiAgXSxcbn0pO1xuXG5kZWZpbmVDdXJ2ZSgncDIyNCcsIHtcbiAgdHlwZTogJ3Nob3J0JyxcbiAgcHJpbWU6ICdwMjI0JyxcbiAgcDogJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIDAwMDAwMDAwIDAwMDAwMDAwIDAwMDAwMDAxJyxcbiAgYTogJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZlIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZlJyxcbiAgYjogJ2I0MDUwYTg1IDBjMDRiM2FiIGY1NDEzMjU2IDUwNDRiMGI3IGQ3YmZkOGJhIDI3MGIzOTQzIDIzNTVmZmI0JyxcbiAgbjogJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmYxNmEyIGUwYjhmMDNlIDEzZGQyOTQ1IDVjNWMyYTNkJyxcbiAgaGFzaDogaGFzaC5zaGEyNTYsXG4gIGdSZWQ6IGZhbHNlLFxuICBnOiBbXG4gICAgJ2I3MGUwY2JkIDZiYjRiZjdmIDMyMTM5MGI5IDRhMDNjMWQzIDU2YzIxMTIyIDM0MzI4MGQ2IDExNWMxZDIxJyxcbiAgICAnYmQzNzYzODggYjVmNzIzZmIgNGMyMmRmZTYgY2Q0Mzc1YTAgNWEwNzQ3NjQgNDRkNTgxOTkgODUwMDdlMzQnLFxuICBdLFxufSk7XG5cbmRlZmluZUN1cnZlKCdwMjU2Jywge1xuICB0eXBlOiAnc2hvcnQnLFxuICBwcmltZTogbnVsbCxcbiAgcDogJ2ZmZmZmZmZmIDAwMDAwMDAxIDAwMDAwMDAwIDAwMDAwMDAwIDAwMDAwMDAwIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmJyxcbiAgYTogJ2ZmZmZmZmZmIDAwMDAwMDAxIDAwMDAwMDAwIDAwMDAwMDAwIDAwMDAwMDAwIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZjJyxcbiAgYjogJzVhYzYzNWQ4IGFhM2E5M2U3IGIzZWJiZDU1IDc2OTg4NmJjIDY1MWQwNmIwIGNjNTNiMGY2IDNiY2UzYzNlIDI3ZDI2MDRiJyxcbiAgbjogJ2ZmZmZmZmZmIDAwMDAwMDAwIGZmZmZmZmZmIGZmZmZmZmZmIGJjZTZmYWFkIGE3MTc5ZTg0IGYzYjljYWMyIGZjNjMyNTUxJyxcbiAgaGFzaDogaGFzaC5zaGEyNTYsXG4gIGdSZWQ6IGZhbHNlLFxuICBnOiBbXG4gICAgJzZiMTdkMWYyIGUxMmM0MjQ3IGY4YmNlNmU1IDYzYTQ0MGYyIDc3MDM3ZDgxIDJkZWIzM2EwIGY0YTEzOTQ1IGQ4OThjMjk2JyxcbiAgICAnNGZlMzQyZTIgZmUxYTdmOWIgOGVlN2ViNGEgN2MwZjllMTYgMmJjZTMzNTcgNmIzMTVlY2UgY2JiNjQwNjggMzdiZjUxZjUnLFxuICBdLFxufSk7XG5cbmRlZmluZUN1cnZlKCdwMzg0Jywge1xuICB0eXBlOiAnc2hvcnQnLFxuICBwcmltZTogbnVsbCxcbiAgcDogJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmICcgK1xuICAgICAnZmZmZmZmZmUgZmZmZmZmZmYgMDAwMDAwMDAgMDAwMDAwMDAgZmZmZmZmZmYnLFxuICBhOiAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgJyArXG4gICAgICdmZmZmZmZmZSBmZmZmZmZmZiAwMDAwMDAwMCAwMDAwMDAwMCBmZmZmZmZmYycsXG4gIGI6ICdiMzMxMmZhNyBlMjNlZTdlNCA5ODhlMDU2YiBlM2Y4MmQxOSAxODFkOWM2ZSBmZTgxNDExMiAwMzE0MDg4ZiAnICtcbiAgICAgJzUwMTM4NzVhIGM2NTYzOThkIDhhMmVkMTlkIDJhODVjOGVkIGQzZWMyYWVmJyxcbiAgbjogJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGM3NjM0ZDgxICcgK1xuICAgICAnZjQzNzJkZGYgNTgxYTBkYjIgNDhiMGE3N2EgZWNlYzE5NmEgY2NjNTI5NzMnLFxuICBoYXNoOiBoYXNoLnNoYTM4NCxcbiAgZ1JlZDogZmFsc2UsXG4gIGc6IFtcbiAgICAnYWE4N2NhMjIgYmU4YjA1MzcgOGViMWM3MWUgZjMyMGFkNzQgNmUxZDNiNjIgOGJhNzliOTggNTlmNzQxZTAgODI1NDJhMzggJyArXG4gICAgJzU1MDJmMjVkIGJmNTUyOTZjIDNhNTQ1ZTM4IDcyNzYwYWI3JyxcbiAgICAnMzYxN2RlNGEgOTYyNjJjNmYgNWQ5ZTk4YmYgOTI5MmRjMjkgZjhmNDFkYmQgMjg5YTE0N2MgZTlkYTMxMTMgYjVmMGI4YzAgJyArXG4gICAgJzBhNjBiMWNlIDFkN2U4MTlkIDdhNDMxZDdjIDkwZWEwZTVmJyxcbiAgXSxcbn0pO1xuXG5kZWZpbmVDdXJ2ZSgncDUyMScsIHtcbiAgdHlwZTogJ3Nob3J0JyxcbiAgcHJpbWU6IG51bGwsXG4gIHA6ICcwMDAwMDFmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiAnICtcbiAgICAgJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmICcgK1xuICAgICAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYnLFxuICBhOiAnMDAwMDAxZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgJyArXG4gICAgICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiAnICtcbiAgICAgJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZjJyxcbiAgYjogJzAwMDAwMDUxIDk1M2ViOTYxIDhlMWM5YTFmIDkyOWEyMWEwIGI2ODU0MGVlIGEyZGE3MjViICcgK1xuICAgICAnOTliMzE1ZjMgYjhiNDg5OTEgOGVmMTA5ZTEgNTYxOTM5NTEgZWM3ZTkzN2IgMTY1MmMwYmQgJyArXG4gICAgICczYmIxYmYwNyAzNTczZGY4OCAzZDJjMzRmMSBlZjQ1MWZkNCA2YjUwM2YwMCcsXG4gIG46ICcwMDAwMDFmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiAnICtcbiAgICAgJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZhIDUxODY4NzgzIGJmMmY5NjZiIDdmY2MwMTQ4ICcgK1xuICAgICAnZjcwOWE1ZDAgM2JiNWM5YjggODk5YzQ3YWUgYmI2ZmI3MWUgOTEzODY0MDknLFxuICBoYXNoOiBoYXNoLnNoYTUxMixcbiAgZ1JlZDogZmFsc2UsXG4gIGc6IFtcbiAgICAnMDAwMDAwYzYgODU4ZTA2YjcgMDQwNGU5Y2QgOWUzZWNiNjYgMjM5NWI0NDIgOWM2NDgxMzkgJyArXG4gICAgJzA1M2ZiNTIxIGY4MjhhZjYwIDZiNGQzZGJhIGExNGI1ZTc3IGVmZTc1OTI4IGZlMWRjMTI3ICcgK1xuICAgICdhMmZmYThkZSAzMzQ4YjNjMSA4NTZhNDI5YiBmOTdlN2UzMSBjMmU1YmQ2NicsXG4gICAgJzAwMDAwMTE4IDM5Mjk2YTc4IDlhM2JjMDA0IDVjOGE1ZmI0IDJjN2QxYmQ5IDk4ZjU0NDQ5ICcgK1xuICAgICc1NzliNDQ2OCAxN2FmYmQxNyAyNzNlNjYyYyA5N2VlNzI5OSA1ZWY0MjY0MCBjNTUwYjkwMSAnICtcbiAgICAnM2ZhZDA3NjEgMzUzYzcwODYgYTI3MmMyNDAgODhiZTk0NzYgOWZkMTY2NTAnLFxuICBdLFxufSk7XG5cbmRlZmluZUN1cnZlKCdjdXJ2ZTI1NTE5Jywge1xuICB0eXBlOiAnbW9udCcsXG4gIHByaW1lOiAncDI1NTE5JyxcbiAgcDogJzdmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZWQnLFxuICBhOiAnNzZkMDYnLFxuICBiOiAnMScsXG4gIG46ICcxMDAwMDAwMDAwMDAwMDAwIDAwMDAwMDAwMDAwMDAwMDAgMTRkZWY5ZGVhMmY3OWNkNiA1ODEyNjMxYTVjZjVkM2VkJyxcbiAgaGFzaDogaGFzaC5zaGEyNTYsXG4gIGdSZWQ6IGZhbHNlLFxuICBnOiBbXG4gICAgJzknLFxuICBdLFxufSk7XG5cbmRlZmluZUN1cnZlKCdlZDI1NTE5Jywge1xuICB0eXBlOiAnZWR3YXJkcycsXG4gIHByaW1lOiAncDI1NTE5JyxcbiAgcDogJzdmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZWQnLFxuICBhOiAnLTEnLFxuICBjOiAnMScsXG4gIC8vIC0xMjE2NjUgKiAoMTIxNjY2XigtMSkpIChtb2QgUClcbiAgZDogJzUyMDM2Y2VlMmI2ZmZlNzMgOGNjNzQwNzk3Nzc5ZTg5OCAwMDcwMGE0ZDQxNDFkOGFiIDc1ZWI0ZGNhMTM1OTc4YTMnLFxuICBuOiAnMTAwMDAwMDAwMDAwMDAwMCAwMDAwMDAwMDAwMDAwMDAwIDE0ZGVmOWRlYTJmNzljZDYgNTgxMjYzMWE1Y2Y1ZDNlZCcsXG4gIGhhc2g6IGhhc2guc2hhMjU2LFxuICBnUmVkOiBmYWxzZSxcbiAgZzogW1xuICAgICcyMTY5MzZkM2NkNmU1M2ZlYzBhNGUyMzFmZGQ2ZGM1YzY5MmNjNzYwOTUyNWE3YjJjOTU2MmQ2MDhmMjVkNTFhJyxcblxuICAgIC8vIDQvNVxuICAgICc2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjU4JyxcbiAgXSxcbn0pO1xuXG52YXIgcHJlO1xudHJ5IHtcbiAgcHJlID0gLypSaWNNb286ZXRoZXJzOnJlcXVpcmUoLi9wcmVjb21wdXRlZC9zZWNwMjU2azEpKi8obnVsbCkuY3Jhc2goKTtcbn0gY2F0Y2ggKGUpIHtcbiAgcHJlID0gdW5kZWZpbmVkO1xufVxuXG5kZWZpbmVDdXJ2ZSgnc2VjcDI1NmsxJywge1xuICB0eXBlOiAnc2hvcnQnLFxuICBwcmltZTogJ2syNTYnLFxuICBwOiAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUgZmZmZmZjMmYnLFxuICBhOiAnMCcsXG4gIGI6ICc3JyxcbiAgbjogJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZlIGJhYWVkY2U2IGFmNDhhMDNiIGJmZDI1ZThjIGQwMzY0MTQxJyxcbiAgaDogJzEnLFxuICBoYXNoOiBoYXNoLnNoYTI1NixcblxuICAvLyBQcmVjb21wdXRlZCBlbmRvbW9ycGhpc21cbiAgYmV0YTogJzdhZTk2YTJiNjU3YzA3MTA2ZTY0NDc5ZWFjMzQzNGU5OWNmMDQ5NzUxMmY1ODk5NWMxMzk2YzI4NzE5NTAxZWUnLFxuICBsYW1iZGE6ICc1MzYzYWQ0Y2MwNWMzMGUwYTUyNjFjMDI4ODEyNjQ1YTEyMmUyMmVhMjA4MTY2NzhkZjAyOTY3YzFiMjNiZDcyJyxcbiAgYmFzaXM6IFtcbiAgICB7XG4gICAgICBhOiAnMzA4NmQyMjFhN2Q0NmJjZGU4NmM5MGU0OTI4NGViMTUnLFxuICAgICAgYjogJy1lNDQzN2VkNjAxMGU4ODI4NmY1NDdmYTkwYWJmZTRjMycsXG4gICAgfSxcbiAgICB7XG4gICAgICBhOiAnMTE0Y2E1MGY3YThlMmYzZjY1N2MxMTA4ZDlkNDRjZmQ4JyxcbiAgICAgIGI6ICczMDg2ZDIyMWE3ZDQ2YmNkZTg2YzkwZTQ5Mjg0ZWIxNScsXG4gICAgfSxcbiAgXSxcblxuICBnUmVkOiBmYWxzZSxcbiAgZzogW1xuICAgICc3OWJlNjY3ZWY5ZGNiYmFjNTVhMDYyOTVjZTg3MGIwNzAyOWJmY2RiMmRjZTI4ZDk1OWYyODE1YjE2ZjgxNzk4JyxcbiAgICAnNDgzYWRhNzcyNmEzYzQ2NTVkYTRmYmZjMGUxMTA4YThmZDE3YjQ0OGE2ODU1NDE5OWM0N2QwOGZmYjEwZDRiOCcsXG4gICAgcHJlLFxuICBdLFxufSk7XG59KTtcblxuJ3VzZSBzdHJpY3QnO1xuXG5cblxuXG5cbmZ1bmN0aW9uIEhtYWNEUkJHKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEhtYWNEUkJHKSlcbiAgICByZXR1cm4gbmV3IEhtYWNEUkJHKG9wdGlvbnMpO1xuICB0aGlzLmhhc2ggPSBvcHRpb25zLmhhc2g7XG4gIHRoaXMucHJlZFJlc2lzdCA9ICEhb3B0aW9ucy5wcmVkUmVzaXN0O1xuXG4gIHRoaXMub3V0TGVuID0gdGhpcy5oYXNoLm91dFNpemU7XG4gIHRoaXMubWluRW50cm9weSA9IG9wdGlvbnMubWluRW50cm9weSB8fCB0aGlzLmhhc2guaG1hY1N0cmVuZ3RoO1xuXG4gIHRoaXMuX3Jlc2VlZCA9IG51bGw7XG4gIHRoaXMucmVzZWVkSW50ZXJ2YWwgPSBudWxsO1xuICB0aGlzLksgPSBudWxsO1xuICB0aGlzLlYgPSBudWxsO1xuXG4gIHZhciBlbnRyb3B5ID0gdXRpbHNfMS50b0FycmF5KG9wdGlvbnMuZW50cm9weSwgb3B0aW9ucy5lbnRyb3B5RW5jIHx8ICdoZXgnKTtcbiAgdmFyIG5vbmNlID0gdXRpbHNfMS50b0FycmF5KG9wdGlvbnMubm9uY2UsIG9wdGlvbnMubm9uY2VFbmMgfHwgJ2hleCcpO1xuICB2YXIgcGVycyA9IHV0aWxzXzEudG9BcnJheShvcHRpb25zLnBlcnMsIG9wdGlvbnMucGVyc0VuYyB8fCAnaGV4Jyk7XG4gIG1pbmltYWxpc3RpY0Fzc2VydChlbnRyb3B5Lmxlbmd0aCA+PSAodGhpcy5taW5FbnRyb3B5IC8gOCksXG4gICAgICAgICAnTm90IGVub3VnaCBlbnRyb3B5LiBNaW5pbXVtIGlzOiAnICsgdGhpcy5taW5FbnRyb3B5ICsgJyBiaXRzJyk7XG4gIHRoaXMuX2luaXQoZW50cm9weSwgbm9uY2UsIHBlcnMpO1xufVxudmFyIGhtYWNEcmJnID0gSG1hY0RSQkc7XG5cbkhtYWNEUkJHLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uIGluaXQoZW50cm9weSwgbm9uY2UsIHBlcnMpIHtcbiAgdmFyIHNlZWQgPSBlbnRyb3B5LmNvbmNhdChub25jZSkuY29uY2F0KHBlcnMpO1xuXG4gIHRoaXMuSyA9IG5ldyBBcnJheSh0aGlzLm91dExlbiAvIDgpO1xuICB0aGlzLlYgPSBuZXcgQXJyYXkodGhpcy5vdXRMZW4gLyA4KTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLlYubGVuZ3RoOyBpKyspIHtcbiAgICB0aGlzLktbaV0gPSAweDAwO1xuICAgIHRoaXMuVltpXSA9IDB4MDE7XG4gIH1cblxuICB0aGlzLl91cGRhdGUoc2VlZCk7XG4gIHRoaXMuX3Jlc2VlZCA9IDE7XG4gIHRoaXMucmVzZWVkSW50ZXJ2YWwgPSAweDEwMDAwMDAwMDAwMDA7ICAvLyAyXjQ4XG59O1xuXG5IbWFjRFJCRy5wcm90b3R5cGUuX2htYWMgPSBmdW5jdGlvbiBobWFjKCkge1xuICByZXR1cm4gbmV3IGhhc2guaG1hYyh0aGlzLmhhc2gsIHRoaXMuSyk7XG59O1xuXG5IbWFjRFJCRy5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZShzZWVkKSB7XG4gIHZhciBrbWFjID0gdGhpcy5faG1hYygpXG4gICAgICAgICAgICAgICAgIC51cGRhdGUodGhpcy5WKVxuICAgICAgICAgICAgICAgICAudXBkYXRlKFsgMHgwMCBdKTtcbiAgaWYgKHNlZWQpXG4gICAga21hYyA9IGttYWMudXBkYXRlKHNlZWQpO1xuICB0aGlzLksgPSBrbWFjLmRpZ2VzdCgpO1xuICB0aGlzLlYgPSB0aGlzLl9obWFjKCkudXBkYXRlKHRoaXMuVikuZGlnZXN0KCk7XG4gIGlmICghc2VlZClcbiAgICByZXR1cm47XG5cbiAgdGhpcy5LID0gdGhpcy5faG1hYygpXG4gICAgICAgICAgICAgICAudXBkYXRlKHRoaXMuVilcbiAgICAgICAgICAgICAgIC51cGRhdGUoWyAweDAxIF0pXG4gICAgICAgICAgICAgICAudXBkYXRlKHNlZWQpXG4gICAgICAgICAgICAgICAuZGlnZXN0KCk7XG4gIHRoaXMuViA9IHRoaXMuX2htYWMoKS51cGRhdGUodGhpcy5WKS5kaWdlc3QoKTtcbn07XG5cbkhtYWNEUkJHLnByb3RvdHlwZS5yZXNlZWQgPSBmdW5jdGlvbiByZXNlZWQoZW50cm9weSwgZW50cm9weUVuYywgYWRkLCBhZGRFbmMpIHtcbiAgLy8gT3B0aW9uYWwgZW50cm9weSBlbmNcbiAgaWYgKHR5cGVvZiBlbnRyb3B5RW5jICE9PSAnc3RyaW5nJykge1xuICAgIGFkZEVuYyA9IGFkZDtcbiAgICBhZGQgPSBlbnRyb3B5RW5jO1xuICAgIGVudHJvcHlFbmMgPSBudWxsO1xuICB9XG5cbiAgZW50cm9weSA9IHV0aWxzXzEudG9BcnJheShlbnRyb3B5LCBlbnRyb3B5RW5jKTtcbiAgYWRkID0gdXRpbHNfMS50b0FycmF5KGFkZCwgYWRkRW5jKTtcblxuICBtaW5pbWFsaXN0aWNBc3NlcnQoZW50cm9weS5sZW5ndGggPj0gKHRoaXMubWluRW50cm9weSAvIDgpLFxuICAgICAgICAgJ05vdCBlbm91Z2ggZW50cm9weS4gTWluaW11bSBpczogJyArIHRoaXMubWluRW50cm9weSArICcgYml0cycpO1xuXG4gIHRoaXMuX3VwZGF0ZShlbnRyb3B5LmNvbmNhdChhZGQgfHwgW10pKTtcbiAgdGhpcy5fcmVzZWVkID0gMTtcbn07XG5cbkhtYWNEUkJHLnByb3RvdHlwZS5nZW5lcmF0ZSA9IGZ1bmN0aW9uIGdlbmVyYXRlKGxlbiwgZW5jLCBhZGQsIGFkZEVuYykge1xuICBpZiAodGhpcy5fcmVzZWVkID4gdGhpcy5yZXNlZWRJbnRlcnZhbClcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jlc2VlZCBpcyByZXF1aXJlZCcpO1xuXG4gIC8vIE9wdGlvbmFsIGVuY29kaW5nXG4gIGlmICh0eXBlb2YgZW5jICE9PSAnc3RyaW5nJykge1xuICAgIGFkZEVuYyA9IGFkZDtcbiAgICBhZGQgPSBlbmM7XG4gICAgZW5jID0gbnVsbDtcbiAgfVxuXG4gIC8vIE9wdGlvbmFsIGFkZGl0aW9uYWwgZGF0YVxuICBpZiAoYWRkKSB7XG4gICAgYWRkID0gdXRpbHNfMS50b0FycmF5KGFkZCwgYWRkRW5jIHx8ICdoZXgnKTtcbiAgICB0aGlzLl91cGRhdGUoYWRkKTtcbiAgfVxuXG4gIHZhciB0ZW1wID0gW107XG4gIHdoaWxlICh0ZW1wLmxlbmd0aCA8IGxlbikge1xuICAgIHRoaXMuViA9IHRoaXMuX2htYWMoKS51cGRhdGUodGhpcy5WKS5kaWdlc3QoKTtcbiAgICB0ZW1wID0gdGVtcC5jb25jYXQodGhpcy5WKTtcbiAgfVxuXG4gIHZhciByZXMgPSB0ZW1wLnNsaWNlKDAsIGxlbik7XG4gIHRoaXMuX3VwZGF0ZShhZGQpO1xuICB0aGlzLl9yZXNlZWQrKztcbiAgcmV0dXJuIHV0aWxzXzEuZW5jb2RlKHJlcywgZW5jKTtcbn07XG5cbid1c2Ugc3RyaWN0JztcblxuXG5cbnZhciBhc3NlcnQkMyA9IHV0aWxzXzEkMS5hc3NlcnQ7XG5cbmZ1bmN0aW9uIEtleVBhaXIoZWMsIG9wdGlvbnMpIHtcbiAgdGhpcy5lYyA9IGVjO1xuICB0aGlzLnByaXYgPSBudWxsO1xuICB0aGlzLnB1YiA9IG51bGw7XG5cbiAgLy8gS2V5UGFpcihlYywgeyBwcml2OiAuLi4sIHB1YjogLi4uIH0pXG4gIGlmIChvcHRpb25zLnByaXYpXG4gICAgdGhpcy5faW1wb3J0UHJpdmF0ZShvcHRpb25zLnByaXYsIG9wdGlvbnMucHJpdkVuYyk7XG4gIGlmIChvcHRpb25zLnB1YilcbiAgICB0aGlzLl9pbXBvcnRQdWJsaWMob3B0aW9ucy5wdWIsIG9wdGlvbnMucHViRW5jKTtcbn1cbnZhciBrZXkgPSBLZXlQYWlyO1xuXG5LZXlQYWlyLmZyb21QdWJsaWMgPSBmdW5jdGlvbiBmcm9tUHVibGljKGVjLCBwdWIsIGVuYykge1xuICBpZiAocHViIGluc3RhbmNlb2YgS2V5UGFpcilcbiAgICByZXR1cm4gcHViO1xuXG4gIHJldHVybiBuZXcgS2V5UGFpcihlYywge1xuICAgIHB1YjogcHViLFxuICAgIHB1YkVuYzogZW5jLFxuICB9KTtcbn07XG5cbktleVBhaXIuZnJvbVByaXZhdGUgPSBmdW5jdGlvbiBmcm9tUHJpdmF0ZShlYywgcHJpdiwgZW5jKSB7XG4gIGlmIChwcml2IGluc3RhbmNlb2YgS2V5UGFpcilcbiAgICByZXR1cm4gcHJpdjtcblxuICByZXR1cm4gbmV3IEtleVBhaXIoZWMsIHtcbiAgICBwcml2OiBwcml2LFxuICAgIHByaXZFbmM6IGVuYyxcbiAgfSk7XG59O1xuXG5LZXlQYWlyLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uIHZhbGlkYXRlKCkge1xuICB2YXIgcHViID0gdGhpcy5nZXRQdWJsaWMoKTtcblxuICBpZiAocHViLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4geyByZXN1bHQ6IGZhbHNlLCByZWFzb246ICdJbnZhbGlkIHB1YmxpYyBrZXknIH07XG4gIGlmICghcHViLnZhbGlkYXRlKCkpXG4gICAgcmV0dXJuIHsgcmVzdWx0OiBmYWxzZSwgcmVhc29uOiAnUHVibGljIGtleSBpcyBub3QgYSBwb2ludCcgfTtcbiAgaWYgKCFwdWIubXVsKHRoaXMuZWMuY3VydmUubikuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiB7IHJlc3VsdDogZmFsc2UsIHJlYXNvbjogJ1B1YmxpYyBrZXkgKiBOICE9IE8nIH07XG5cbiAgcmV0dXJuIHsgcmVzdWx0OiB0cnVlLCByZWFzb246IG51bGwgfTtcbn07XG5cbktleVBhaXIucHJvdG90eXBlLmdldFB1YmxpYyA9IGZ1bmN0aW9uIGdldFB1YmxpYyhjb21wYWN0LCBlbmMpIHtcbiAgLy8gY29tcGFjdCBpcyBvcHRpb25hbCBhcmd1bWVudFxuICBpZiAodHlwZW9mIGNvbXBhY3QgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jID0gY29tcGFjdDtcbiAgICBjb21wYWN0ID0gbnVsbDtcbiAgfVxuXG4gIGlmICghdGhpcy5wdWIpXG4gICAgdGhpcy5wdWIgPSB0aGlzLmVjLmcubXVsKHRoaXMucHJpdik7XG5cbiAgaWYgKCFlbmMpXG4gICAgcmV0dXJuIHRoaXMucHViO1xuXG4gIHJldHVybiB0aGlzLnB1Yi5lbmNvZGUoZW5jLCBjb21wYWN0KTtcbn07XG5cbktleVBhaXIucHJvdG90eXBlLmdldFByaXZhdGUgPSBmdW5jdGlvbiBnZXRQcml2YXRlKGVuYykge1xuICBpZiAoZW5jID09PSAnaGV4JylcbiAgICByZXR1cm4gdGhpcy5wcml2LnRvU3RyaW5nKDE2LCAyKTtcbiAgZWxzZVxuICAgIHJldHVybiB0aGlzLnByaXY7XG59O1xuXG5LZXlQYWlyLnByb3RvdHlwZS5faW1wb3J0UHJpdmF0ZSA9IGZ1bmN0aW9uIF9pbXBvcnRQcml2YXRlKGtleSwgZW5jKSB7XG4gIHRoaXMucHJpdiA9IG5ldyBCTihrZXksIGVuYyB8fCAxNik7XG5cbiAgLy8gRW5zdXJlIHRoYXQgdGhlIHByaXYgd29uJ3QgYmUgYmlnZ2VyIHRoYW4gbiwgb3RoZXJ3aXNlIHdlIG1heSBmYWlsXG4gIC8vIGluIGZpeGVkIG11bHRpcGxpY2F0aW9uIG1ldGhvZFxuICB0aGlzLnByaXYgPSB0aGlzLnByaXYudW1vZCh0aGlzLmVjLmN1cnZlLm4pO1xufTtcblxuS2V5UGFpci5wcm90b3R5cGUuX2ltcG9ydFB1YmxpYyA9IGZ1bmN0aW9uIF9pbXBvcnRQdWJsaWMoa2V5LCBlbmMpIHtcbiAgaWYgKGtleS54IHx8IGtleS55KSB7XG4gICAgLy8gTW9udGdvbWVyeSBwb2ludHMgb25seSBoYXZlIGFuIGB4YCBjb29yZGluYXRlLlxuICAgIC8vIFdlaWVyc3RyYXNzL0Vkd2FyZHMgcG9pbnRzIG9uIHRoZSBvdGhlciBoYW5kIGhhdmUgYm90aCBgeGAgYW5kXG4gICAgLy8gYHlgIGNvb3JkaW5hdGVzLlxuICAgIGlmICh0aGlzLmVjLmN1cnZlLnR5cGUgPT09ICdtb250Jykge1xuICAgICAgYXNzZXJ0JDMoa2V5LngsICdOZWVkIHggY29vcmRpbmF0ZScpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5lYy5jdXJ2ZS50eXBlID09PSAnc2hvcnQnIHx8XG4gICAgICAgICAgICAgICB0aGlzLmVjLmN1cnZlLnR5cGUgPT09ICdlZHdhcmRzJykge1xuICAgICAgYXNzZXJ0JDMoa2V5LnggJiYga2V5LnksICdOZWVkIGJvdGggeCBhbmQgeSBjb29yZGluYXRlJyk7XG4gICAgfVxuICAgIHRoaXMucHViID0gdGhpcy5lYy5jdXJ2ZS5wb2ludChrZXkueCwga2V5LnkpO1xuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLnB1YiA9IHRoaXMuZWMuY3VydmUuZGVjb2RlUG9pbnQoa2V5LCBlbmMpO1xufTtcblxuLy8gRUNESFxuS2V5UGFpci5wcm90b3R5cGUuZGVyaXZlID0gZnVuY3Rpb24gZGVyaXZlKHB1Yikge1xuICBpZighcHViLnZhbGlkYXRlKCkpIHtcbiAgICBhc3NlcnQkMyhwdWIudmFsaWRhdGUoKSwgJ3B1YmxpYyBwb2ludCBub3QgdmFsaWRhdGVkJyk7XG4gIH1cbiAgcmV0dXJuIHB1Yi5tdWwodGhpcy5wcml2KS5nZXRYKCk7XG59O1xuXG4vLyBFQ0RTQVxuS2V5UGFpci5wcm90b3R5cGUuc2lnbiA9IGZ1bmN0aW9uIHNpZ24obXNnLCBlbmMsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHRoaXMuZWMuc2lnbihtc2csIHRoaXMsIGVuYywgb3B0aW9ucyk7XG59O1xuXG5LZXlQYWlyLnByb3RvdHlwZS52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobXNnLCBzaWduYXR1cmUpIHtcbiAgcmV0dXJuIHRoaXMuZWMudmVyaWZ5KG1zZywgc2lnbmF0dXJlLCB0aGlzKTtcbn07XG5cbktleVBhaXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0KCkge1xuICByZXR1cm4gJzxLZXkgcHJpdjogJyArICh0aGlzLnByaXYgJiYgdGhpcy5wcml2LnRvU3RyaW5nKDE2LCAyKSkgK1xuICAgICAgICAgJyBwdWI6ICcgKyAodGhpcy5wdWIgJiYgdGhpcy5wdWIuaW5zcGVjdCgpKSArICcgPic7XG59O1xuXG4ndXNlIHN0cmljdCc7XG5cblxuXG5cbnZhciBhc3NlcnQkNCA9IHV0aWxzXzEkMS5hc3NlcnQ7XG5cbmZ1bmN0aW9uIFNpZ25hdHVyZShvcHRpb25zLCBlbmMpIHtcbiAgaWYgKG9wdGlvbnMgaW5zdGFuY2VvZiBTaWduYXR1cmUpXG4gICAgcmV0dXJuIG9wdGlvbnM7XG5cbiAgaWYgKHRoaXMuX2ltcG9ydERFUihvcHRpb25zLCBlbmMpKVxuICAgIHJldHVybjtcblxuICBhc3NlcnQkNChvcHRpb25zLnIgJiYgb3B0aW9ucy5zLCAnU2lnbmF0dXJlIHdpdGhvdXQgciBvciBzJyk7XG4gIHRoaXMuciA9IG5ldyBCTihvcHRpb25zLnIsIDE2KTtcbiAgdGhpcy5zID0gbmV3IEJOKG9wdGlvbnMucywgMTYpO1xuICBpZiAob3B0aW9ucy5yZWNvdmVyeVBhcmFtID09PSB1bmRlZmluZWQpXG4gICAgdGhpcy5yZWNvdmVyeVBhcmFtID0gbnVsbDtcbiAgZWxzZVxuICAgIHRoaXMucmVjb3ZlcnlQYXJhbSA9IG9wdGlvbnMucmVjb3ZlcnlQYXJhbTtcbn1cbnZhciBzaWduYXR1cmUgPSBTaWduYXR1cmU7XG5cbmZ1bmN0aW9uIFBvc2l0aW9uKCkge1xuICB0aGlzLnBsYWNlID0gMDtcbn1cblxuZnVuY3Rpb24gZ2V0TGVuZ3RoKGJ1ZiwgcCkge1xuICB2YXIgaW5pdGlhbCA9IGJ1ZltwLnBsYWNlKytdO1xuICBpZiAoIShpbml0aWFsICYgMHg4MCkpIHtcbiAgICByZXR1cm4gaW5pdGlhbDtcbiAgfVxuICB2YXIgb2N0ZXRMZW4gPSBpbml0aWFsICYgMHhmO1xuXG4gIC8vIEluZGVmaW5pdGUgbGVuZ3RoIG9yIG92ZXJmbG93XG4gIGlmIChvY3RldExlbiA9PT0gMCB8fCBvY3RldExlbiA+IDQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgdmFsID0gMDtcbiAgZm9yICh2YXIgaSA9IDAsIG9mZiA9IHAucGxhY2U7IGkgPCBvY3RldExlbjsgaSsrLCBvZmYrKykge1xuICAgIHZhbCA8PD0gODtcbiAgICB2YWwgfD0gYnVmW29mZl07XG4gICAgdmFsID4+Pj0gMDtcbiAgfVxuXG4gIC8vIExlYWRpbmcgemVyb2VzXG4gIGlmICh2YWwgPD0gMHg3Zikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHAucGxhY2UgPSBvZmY7XG4gIHJldHVybiB2YWw7XG59XG5cbmZ1bmN0aW9uIHJtUGFkZGluZyhidWYpIHtcbiAgdmFyIGkgPSAwO1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aCAtIDE7XG4gIHdoaWxlICghYnVmW2ldICYmICEoYnVmW2kgKyAxXSAmIDB4ODApICYmIGkgPCBsZW4pIHtcbiAgICBpKys7XG4gIH1cbiAgaWYgKGkgPT09IDApIHtcbiAgICByZXR1cm4gYnVmO1xuICB9XG4gIHJldHVybiBidWYuc2xpY2UoaSk7XG59XG5cblNpZ25hdHVyZS5wcm90b3R5cGUuX2ltcG9ydERFUiA9IGZ1bmN0aW9uIF9pbXBvcnRERVIoZGF0YSwgZW5jKSB7XG4gIGRhdGEgPSB1dGlsc18xJDEudG9BcnJheShkYXRhLCBlbmMpO1xuICB2YXIgcCA9IG5ldyBQb3NpdGlvbigpO1xuICBpZiAoZGF0YVtwLnBsYWNlKytdICE9PSAweDMwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBsZW4gPSBnZXRMZW5ndGgoZGF0YSwgcCk7XG4gIGlmIChsZW4gPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICgobGVuICsgcC5wbGFjZSkgIT09IGRhdGEubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChkYXRhW3AucGxhY2UrK10gIT09IDB4MDIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHJsZW4gPSBnZXRMZW5ndGgoZGF0YSwgcCk7XG4gIGlmIChybGVuID09PSBmYWxzZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgciA9IGRhdGEuc2xpY2UocC5wbGFjZSwgcmxlbiArIHAucGxhY2UpO1xuICBwLnBsYWNlICs9IHJsZW47XG4gIGlmIChkYXRhW3AucGxhY2UrK10gIT09IDB4MDIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHNsZW4gPSBnZXRMZW5ndGgoZGF0YSwgcCk7XG4gIGlmIChzbGVuID09PSBmYWxzZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoZGF0YS5sZW5ndGggIT09IHNsZW4gKyBwLnBsYWNlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBzID0gZGF0YS5zbGljZShwLnBsYWNlLCBzbGVuICsgcC5wbGFjZSk7XG4gIGlmIChyWzBdID09PSAwKSB7XG4gICAgaWYgKHJbMV0gJiAweDgwKSB7XG4gICAgICByID0gci5zbGljZSgxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTGVhZGluZyB6ZXJvZXNcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgaWYgKHNbMF0gPT09IDApIHtcbiAgICBpZiAoc1sxXSAmIDB4ODApIHtcbiAgICAgIHMgPSBzLnNsaWNlKDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBMZWFkaW5nIHplcm9lc1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMuciA9IG5ldyBCTihyKTtcbiAgdGhpcy5zID0gbmV3IEJOKHMpO1xuICB0aGlzLnJlY292ZXJ5UGFyYW0gPSBudWxsO1xuXG4gIHJldHVybiB0cnVlO1xufTtcblxuZnVuY3Rpb24gY29uc3RydWN0TGVuZ3RoKGFyciwgbGVuKSB7XG4gIGlmIChsZW4gPCAweDgwKSB7XG4gICAgYXJyLnB1c2gobGVuKTtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG9jdGV0cyA9IDEgKyAoTWF0aC5sb2cobGVuKSAvIE1hdGguTE4yID4+PiAzKTtcbiAgYXJyLnB1c2gob2N0ZXRzIHwgMHg4MCk7XG4gIHdoaWxlICgtLW9jdGV0cykge1xuICAgIGFyci5wdXNoKChsZW4gPj4+IChvY3RldHMgPDwgMykpICYgMHhmZik7XG4gIH1cbiAgYXJyLnB1c2gobGVuKTtcbn1cblxuU2lnbmF0dXJlLnByb3RvdHlwZS50b0RFUiA9IGZ1bmN0aW9uIHRvREVSKGVuYykge1xuICB2YXIgciA9IHRoaXMuci50b0FycmF5KCk7XG4gIHZhciBzID0gdGhpcy5zLnRvQXJyYXkoKTtcblxuICAvLyBQYWQgdmFsdWVzXG4gIGlmIChyWzBdICYgMHg4MClcbiAgICByID0gWyAwIF0uY29uY2F0KHIpO1xuICAvLyBQYWQgdmFsdWVzXG4gIGlmIChzWzBdICYgMHg4MClcbiAgICBzID0gWyAwIF0uY29uY2F0KHMpO1xuXG4gIHIgPSBybVBhZGRpbmcocik7XG4gIHMgPSBybVBhZGRpbmcocyk7XG5cbiAgd2hpbGUgKCFzWzBdICYmICEoc1sxXSAmIDB4ODApKSB7XG4gICAgcyA9IHMuc2xpY2UoMSk7XG4gIH1cbiAgdmFyIGFyciA9IFsgMHgwMiBdO1xuICBjb25zdHJ1Y3RMZW5ndGgoYXJyLCByLmxlbmd0aCk7XG4gIGFyciA9IGFyci5jb25jYXQocik7XG4gIGFyci5wdXNoKDB4MDIpO1xuICBjb25zdHJ1Y3RMZW5ndGgoYXJyLCBzLmxlbmd0aCk7XG4gIHZhciBiYWNrSGFsZiA9IGFyci5jb25jYXQocyk7XG4gIHZhciByZXMgPSBbIDB4MzAgXTtcbiAgY29uc3RydWN0TGVuZ3RoKHJlcywgYmFja0hhbGYubGVuZ3RoKTtcbiAgcmVzID0gcmVzLmNvbmNhdChiYWNrSGFsZik7XG4gIHJldHVybiB1dGlsc18xJDEuZW5jb2RlKHJlcywgZW5jKTtcbn07XG5cbid1c2Ugc3RyaWN0JztcblxuXG5cblxuXG52YXIgcmFuZCA9IC8qUmljTW9vOmV0aGVyczpyZXF1aXJlKGJyb3JhbmQpKi8oZnVuY3Rpb24oKSB7IHRocm93IG5ldyBFcnJvcigndW5zdXBwb3J0ZWQnKTsgfSk7XG52YXIgYXNzZXJ0JDUgPSB1dGlsc18xJDEuYXNzZXJ0O1xuXG5cblxuXG5mdW5jdGlvbiBFQyhvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBFQykpXG4gICAgcmV0dXJuIG5ldyBFQyhvcHRpb25zKTtcblxuICAvLyBTaG9ydGN1dCBgZWxsaXB0aWMuZWMoY3VydmUtbmFtZSlgXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcbiAgICBhc3NlcnQkNShPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY3VydmVzXzEsIG9wdGlvbnMpLFxuICAgICAgJ1Vua25vd24gY3VydmUgJyArIG9wdGlvbnMpO1xuXG4gICAgb3B0aW9ucyA9IGN1cnZlc18xW29wdGlvbnNdO1xuICB9XG5cbiAgLy8gU2hvcnRjdXQgZm9yIGBlbGxpcHRpYy5lYyhlbGxpcHRpYy5jdXJ2ZXMuY3VydmVOYW1lKWBcbiAgaWYgKG9wdGlvbnMgaW5zdGFuY2VvZiBjdXJ2ZXNfMS5QcmVzZXRDdXJ2ZSlcbiAgICBvcHRpb25zID0geyBjdXJ2ZTogb3B0aW9ucyB9O1xuXG4gIHRoaXMuY3VydmUgPSBvcHRpb25zLmN1cnZlLmN1cnZlO1xuICB0aGlzLm4gPSB0aGlzLmN1cnZlLm47XG4gIHRoaXMubmggPSB0aGlzLm4udXNocm4oMSk7XG4gIHRoaXMuZyA9IHRoaXMuY3VydmUuZztcblxuICAvLyBQb2ludCBvbiBjdXJ2ZVxuICB0aGlzLmcgPSBvcHRpb25zLmN1cnZlLmc7XG4gIHRoaXMuZy5wcmVjb21wdXRlKG9wdGlvbnMuY3VydmUubi5iaXRMZW5ndGgoKSArIDEpO1xuXG4gIC8vIEhhc2ggZm9yIGZ1bmN0aW9uIGZvciBEUkJHXG4gIHRoaXMuaGFzaCA9IG9wdGlvbnMuaGFzaCB8fCBvcHRpb25zLmN1cnZlLmhhc2g7XG59XG52YXIgZWMgPSBFQztcblxuRUMucHJvdG90eXBlLmtleVBhaXIgPSBmdW5jdGlvbiBrZXlQYWlyKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBrZXkodGhpcywgb3B0aW9ucyk7XG59O1xuXG5FQy5wcm90b3R5cGUua2V5RnJvbVByaXZhdGUgPSBmdW5jdGlvbiBrZXlGcm9tUHJpdmF0ZShwcml2LCBlbmMpIHtcbiAgcmV0dXJuIGtleS5mcm9tUHJpdmF0ZSh0aGlzLCBwcml2LCBlbmMpO1xufTtcblxuRUMucHJvdG90eXBlLmtleUZyb21QdWJsaWMgPSBmdW5jdGlvbiBrZXlGcm9tUHVibGljKHB1YiwgZW5jKSB7XG4gIHJldHVybiBrZXkuZnJvbVB1YmxpYyh0aGlzLCBwdWIsIGVuYyk7XG59O1xuXG5FQy5wcm90b3R5cGUuZ2VuS2V5UGFpciA9IGZ1bmN0aW9uIGdlbktleVBhaXIob3B0aW9ucykge1xuICBpZiAoIW9wdGlvbnMpXG4gICAgb3B0aW9ucyA9IHt9O1xuXG4gIC8vIEluc3RhbnRpYXRlIEhtYWNfRFJCR1xuICB2YXIgZHJiZyA9IG5ldyBobWFjRHJiZyh7XG4gICAgaGFzaDogdGhpcy5oYXNoLFxuICAgIHBlcnM6IG9wdGlvbnMucGVycyxcbiAgICBwZXJzRW5jOiBvcHRpb25zLnBlcnNFbmMgfHwgJ3V0ZjgnLFxuICAgIGVudHJvcHk6IG9wdGlvbnMuZW50cm9weSB8fCByYW5kKHRoaXMuaGFzaC5obWFjU3RyZW5ndGgpLFxuICAgIGVudHJvcHlFbmM6IG9wdGlvbnMuZW50cm9weSAmJiBvcHRpb25zLmVudHJvcHlFbmMgfHwgJ3V0ZjgnLFxuICAgIG5vbmNlOiB0aGlzLm4udG9BcnJheSgpLFxuICB9KTtcblxuICB2YXIgYnl0ZXMgPSB0aGlzLm4uYnl0ZUxlbmd0aCgpO1xuICB2YXIgbnMyID0gdGhpcy5uLnN1YihuZXcgQk4oMikpO1xuICBmb3IgKDs7KSB7XG4gICAgdmFyIHByaXYgPSBuZXcgQk4oZHJiZy5nZW5lcmF0ZShieXRlcykpO1xuICAgIGlmIChwcml2LmNtcChuczIpID4gMClcbiAgICAgIGNvbnRpbnVlO1xuXG4gICAgcHJpdi5pYWRkbigxKTtcbiAgICByZXR1cm4gdGhpcy5rZXlGcm9tUHJpdmF0ZShwcml2KTtcbiAgfVxufTtcblxuRUMucHJvdG90eXBlLl90cnVuY2F0ZVRvTiA9IGZ1bmN0aW9uIF90cnVuY2F0ZVRvTihtc2csIHRydW5jT25seSkge1xuICB2YXIgZGVsdGEgPSBtc2cuYnl0ZUxlbmd0aCgpICogOCAtIHRoaXMubi5iaXRMZW5ndGgoKTtcbiAgaWYgKGRlbHRhID4gMClcbiAgICBtc2cgPSBtc2cudXNocm4oZGVsdGEpO1xuICBpZiAoIXRydW5jT25seSAmJiBtc2cuY21wKHRoaXMubikgPj0gMClcbiAgICByZXR1cm4gbXNnLnN1Yih0aGlzLm4pO1xuICBlbHNlXG4gICAgcmV0dXJuIG1zZztcbn07XG5cbkVDLnByb3RvdHlwZS5zaWduID0gZnVuY3Rpb24gc2lnbihtc2csIGtleSwgZW5jLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgZW5jID09PSAnb2JqZWN0Jykge1xuICAgIG9wdGlvbnMgPSBlbmM7XG4gICAgZW5jID0gbnVsbDtcbiAgfVxuICBpZiAoIW9wdGlvbnMpXG4gICAgb3B0aW9ucyA9IHt9O1xuXG4gIGtleSA9IHRoaXMua2V5RnJvbVByaXZhdGUoa2V5LCBlbmMpO1xuICBtc2cgPSB0aGlzLl90cnVuY2F0ZVRvTihuZXcgQk4obXNnLCAxNikpO1xuXG4gIC8vIFplcm8tZXh0ZW5kIGtleSB0byBwcm92aWRlIGVub3VnaCBlbnRyb3B5XG4gIHZhciBieXRlcyA9IHRoaXMubi5ieXRlTGVuZ3RoKCk7XG4gIHZhciBia2V5ID0ga2V5LmdldFByaXZhdGUoKS50b0FycmF5KCdiZScsIGJ5dGVzKTtcblxuICAvLyBaZXJvLWV4dGVuZCBub25jZSB0byBoYXZlIHRoZSBzYW1lIGJ5dGUgc2l6ZSBhcyBOXG4gIHZhciBub25jZSA9IG1zZy50b0FycmF5KCdiZScsIGJ5dGVzKTtcblxuICAvLyBJbnN0YW50aWF0ZSBIbWFjX0RSQkdcbiAgdmFyIGRyYmcgPSBuZXcgaG1hY0RyYmcoe1xuICAgIGhhc2g6IHRoaXMuaGFzaCxcbiAgICBlbnRyb3B5OiBia2V5LFxuICAgIG5vbmNlOiBub25jZSxcbiAgICBwZXJzOiBvcHRpb25zLnBlcnMsXG4gICAgcGVyc0VuYzogb3B0aW9ucy5wZXJzRW5jIHx8ICd1dGY4JyxcbiAgfSk7XG5cbiAgLy8gTnVtYmVyIG9mIGJ5dGVzIHRvIGdlbmVyYXRlXG4gIHZhciBuczEgPSB0aGlzLm4uc3ViKG5ldyBCTigxKSk7XG5cbiAgZm9yICh2YXIgaXRlciA9IDA7IDsgaXRlcisrKSB7XG4gICAgdmFyIGsgPSBvcHRpb25zLmsgP1xuICAgICAgb3B0aW9ucy5rKGl0ZXIpIDpcbiAgICAgIG5ldyBCTihkcmJnLmdlbmVyYXRlKHRoaXMubi5ieXRlTGVuZ3RoKCkpKTtcbiAgICBrID0gdGhpcy5fdHJ1bmNhdGVUb04oaywgdHJ1ZSk7XG4gICAgaWYgKGsuY21wbigxKSA8PSAwIHx8IGsuY21wKG5zMSkgPj0gMClcbiAgICAgIGNvbnRpbnVlO1xuXG4gICAgdmFyIGtwID0gdGhpcy5nLm11bChrKTtcbiAgICBpZiAoa3AuaXNJbmZpbml0eSgpKVxuICAgICAgY29udGludWU7XG5cbiAgICB2YXIga3BYID0ga3AuZ2V0WCgpO1xuICAgIHZhciByID0ga3BYLnVtb2QodGhpcy5uKTtcbiAgICBpZiAoci5jbXBuKDApID09PSAwKVxuICAgICAgY29udGludWU7XG5cbiAgICB2YXIgcyA9IGsuaW52bSh0aGlzLm4pLm11bChyLm11bChrZXkuZ2V0UHJpdmF0ZSgpKS5pYWRkKG1zZykpO1xuICAgIHMgPSBzLnVtb2QodGhpcy5uKTtcbiAgICBpZiAocy5jbXBuKDApID09PSAwKVxuICAgICAgY29udGludWU7XG5cbiAgICB2YXIgcmVjb3ZlcnlQYXJhbSA9IChrcC5nZXRZKCkuaXNPZGQoKSA/IDEgOiAwKSB8XG4gICAgICAgICAgICAgICAgICAgICAgICAoa3BYLmNtcChyKSAhPT0gMCA/IDIgOiAwKTtcblxuICAgIC8vIFVzZSBjb21wbGVtZW50IG9mIGBzYCwgaWYgaXQgaXMgPiBgbiAvIDJgXG4gICAgaWYgKG9wdGlvbnMuY2Fub25pY2FsICYmIHMuY21wKHRoaXMubmgpID4gMCkge1xuICAgICAgcyA9IHRoaXMubi5zdWIocyk7XG4gICAgICByZWNvdmVyeVBhcmFtIF49IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBzaWduYXR1cmUoeyByOiByLCBzOiBzLCByZWNvdmVyeVBhcmFtOiByZWNvdmVyeVBhcmFtIH0pO1xuICB9XG59O1xuXG5FQy5wcm90b3R5cGUudmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1zZywgc2lnbmF0dXJlJDEsIGtleSwgZW5jKSB7XG4gIG1zZyA9IHRoaXMuX3RydW5jYXRlVG9OKG5ldyBCTihtc2csIDE2KSk7XG4gIGtleSA9IHRoaXMua2V5RnJvbVB1YmxpYyhrZXksIGVuYyk7XG4gIHNpZ25hdHVyZSQxID0gbmV3IHNpZ25hdHVyZShzaWduYXR1cmUkMSwgJ2hleCcpO1xuXG4gIC8vIFBlcmZvcm0gcHJpbWl0aXZlIHZhbHVlcyB2YWxpZGF0aW9uXG4gIHZhciByID0gc2lnbmF0dXJlJDEucjtcbiAgdmFyIHMgPSBzaWduYXR1cmUkMS5zO1xuICBpZiAoci5jbXBuKDEpIDwgMCB8fCByLmNtcCh0aGlzLm4pID49IDApXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAocy5jbXBuKDEpIDwgMCB8fCBzLmNtcCh0aGlzLm4pID49IDApXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIFZhbGlkYXRlIHNpZ25hdHVyZVxuICB2YXIgc2ludiA9IHMuaW52bSh0aGlzLm4pO1xuICB2YXIgdTEgPSBzaW52Lm11bChtc2cpLnVtb2QodGhpcy5uKTtcbiAgdmFyIHUyID0gc2ludi5tdWwocikudW1vZCh0aGlzLm4pO1xuICB2YXIgcDtcblxuICBpZiAoIXRoaXMuY3VydmUuX21heHdlbGxUcmljaykge1xuICAgIHAgPSB0aGlzLmcubXVsQWRkKHUxLCBrZXkuZ2V0UHVibGljKCksIHUyKTtcbiAgICBpZiAocC5pc0luZmluaXR5KCkpXG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICByZXR1cm4gcC5nZXRYKCkudW1vZCh0aGlzLm4pLmNtcChyKSA9PT0gMDtcbiAgfVxuXG4gIC8vIE5PVEU6IEdyZWcgTWF4d2VsbCdzIHRyaWNrLCBpbnNwaXJlZCBieTpcbiAgLy8gaHR0cHM6Ly9naXQuaW8vdmFkM0tcblxuICBwID0gdGhpcy5nLmptdWxBZGQodTEsIGtleS5nZXRQdWJsaWMoKSwgdTIpO1xuICBpZiAocC5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIENvbXBhcmUgYHAueGAgb2YgSmFjb2JpYW4gcG9pbnQgd2l0aCBgcmAsXG4gIC8vIHRoaXMgd2lsbCBkbyBgcC54ID09IHIgKiBwLnpeMmAgaW5zdGVhZCBvZiBtdWx0aXBseWluZyBgcC54YCBieSB0aGVcbiAgLy8gaW52ZXJzZSBvZiBgcC56XjJgXG4gIHJldHVybiBwLmVxWFRvUChyKTtcbn07XG5cbkVDLnByb3RvdHlwZS5yZWNvdmVyUHViS2V5ID0gZnVuY3Rpb24obXNnLCBzaWduYXR1cmUkMSwgaiwgZW5jKSB7XG4gIGFzc2VydCQ1KCgzICYgaikgPT09IGosICdUaGUgcmVjb3ZlcnkgcGFyYW0gaXMgbW9yZSB0aGFuIHR3byBiaXRzJyk7XG4gIHNpZ25hdHVyZSQxID0gbmV3IHNpZ25hdHVyZShzaWduYXR1cmUkMSwgZW5jKTtcblxuICB2YXIgbiA9IHRoaXMubjtcbiAgdmFyIGUgPSBuZXcgQk4obXNnKTtcbiAgdmFyIHIgPSBzaWduYXR1cmUkMS5yO1xuICB2YXIgcyA9IHNpZ25hdHVyZSQxLnM7XG5cbiAgLy8gQSBzZXQgTFNCIHNpZ25pZmllcyB0aGF0IHRoZSB5LWNvb3JkaW5hdGUgaXMgb2RkXG4gIHZhciBpc1lPZGQgPSBqICYgMTtcbiAgdmFyIGlzU2Vjb25kS2V5ID0gaiA+PiAxO1xuICBpZiAoci5jbXAodGhpcy5jdXJ2ZS5wLnVtb2QodGhpcy5jdXJ2ZS5uKSkgPj0gMCAmJiBpc1NlY29uZEtleSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBmaW5kIHNlbmNvbmQga2V5IGNhbmRpbmF0ZScpO1xuXG4gIC8vIDEuMS4gTGV0IHggPSByICsgam4uXG4gIGlmIChpc1NlY29uZEtleSlcbiAgICByID0gdGhpcy5jdXJ2ZS5wb2ludEZyb21YKHIuYWRkKHRoaXMuY3VydmUubiksIGlzWU9kZCk7XG4gIGVsc2VcbiAgICByID0gdGhpcy5jdXJ2ZS5wb2ludEZyb21YKHIsIGlzWU9kZCk7XG5cbiAgdmFyIHJJbnYgPSBzaWduYXR1cmUkMS5yLmludm0obik7XG4gIHZhciBzMSA9IG4uc3ViKGUpLm11bChySW52KS51bW9kKG4pO1xuICB2YXIgczIgPSBzLm11bChySW52KS51bW9kKG4pO1xuXG4gIC8vIDEuNi4xIENvbXB1dGUgUSA9IHJeLTEgKHNSIC0gIGVHKVxuICAvLyAgICAgICAgICAgICAgIFEgPSByXi0xIChzUiArIC1lRylcbiAgcmV0dXJuIHRoaXMuZy5tdWxBZGQoczEsIHIsIHMyKTtcbn07XG5cbkVDLnByb3RvdHlwZS5nZXRLZXlSZWNvdmVyeVBhcmFtID0gZnVuY3Rpb24oZSwgc2lnbmF0dXJlJDEsIFEsIGVuYykge1xuICBzaWduYXR1cmUkMSA9IG5ldyBzaWduYXR1cmUoc2lnbmF0dXJlJDEsIGVuYyk7XG4gIGlmIChzaWduYXR1cmUkMS5yZWNvdmVyeVBhcmFtICE9PSBudWxsKVxuICAgIHJldHVybiBzaWduYXR1cmUkMS5yZWNvdmVyeVBhcmFtO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgdmFyIFFwcmltZTtcbiAgICB0cnkge1xuICAgICAgUXByaW1lID0gdGhpcy5yZWNvdmVyUHViS2V5KGUsIHNpZ25hdHVyZSQxLCBpKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoUXByaW1lLmVxKFEpKVxuICAgICAgcmV0dXJuIGk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZmluZCB2YWxpZCByZWNvdmVyeSBmYWN0b3InKTtcbn07XG5cbnZhciBlbGxpcHRpY18xID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZWxsaXB0aWMgPSBleHBvcnRzO1xuXG5lbGxpcHRpYy52ZXJzaW9uID0gLypSaWNNb286ZXRoZXJzKi97IHZlcnNpb246IFwiNi41LjRcIiB9LnZlcnNpb247XG5lbGxpcHRpYy51dGlscyA9IHV0aWxzXzEkMTtcbmVsbGlwdGljLnJhbmQgPSAvKlJpY01vbzpldGhlcnM6cmVxdWlyZShicm9yYW5kKSovKGZ1bmN0aW9uKCkgeyB0aHJvdyBuZXcgRXJyb3IoJ3Vuc3VwcG9ydGVkJyk7IH0pO1xuZWxsaXB0aWMuY3VydmUgPSBjdXJ2ZV8xO1xuZWxsaXB0aWMuY3VydmVzID0gY3VydmVzXzE7XG5cbi8vIFByb3RvY29sc1xuZWxsaXB0aWMuZWMgPSBlYztcbmVsbGlwdGljLmVkZHNhID0gLypSaWNNb286ZXRoZXJzOnJlcXVpcmUoLi9lbGxpcHRpYy9lZGRzYSkqLyhudWxsKTtcbn0pO1xuXG52YXIgRUMkMSA9IGVsbGlwdGljXzEuZWM7XG5cbmV4cG9ydCB7IEVDJDEgYXMgRUMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVsbGlwdGljLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ethersproject/signing-key/lib.esm/elliptic.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@ethersproject/signing-key/lib.esm/index.js":
/*!*******************************************************************!*\
  !*** ../node_modules/@ethersproject/signing-key/lib.esm/index.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SigningKey: () => (/* binding */ SigningKey),\n/* harmony export */   computePublicKey: () => (/* binding */ computePublicKey),\n/* harmony export */   recoverPublicKey: () => (/* binding */ recoverPublicKey)\n/* harmony export */ });\n/* harmony import */ var _elliptic__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./elliptic */ \"(ssr)/../node_modules/@ethersproject/signing-key/lib.esm/elliptic.js\");\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/../node_modules/@ethersproject/bytes/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/../node_modules/@ethersproject/properties/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/../node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(ssr)/../node_modules/@ethersproject/signing-key/lib.esm/_version.js\");\n\n\n\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\nlet _curve = null;\nfunction getCurve() {\n    if (!_curve) {\n        _curve = new _elliptic__WEBPACK_IMPORTED_MODULE_2__.EC(\"secp256k1\");\n    }\n    return _curve;\n}\nclass SigningKey {\n    constructor(privateKey) {\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"curve\", \"secp256k1\");\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"privateKey\", (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.hexlify)(privateKey));\n        if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.hexDataLength)(this.privateKey) !== 32) {\n            logger.throwArgumentError(\"invalid private key\", \"privateKey\", \"[[ REDACTED ]]\");\n        }\n        const keyPair = getCurve().keyFromPrivate((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.arrayify)(this.privateKey));\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"publicKey\", \"0x\" + keyPair.getPublic(false, \"hex\"));\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"compressedPublicKey\", \"0x\" + keyPair.getPublic(true, \"hex\"));\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"_isSigningKey\", true);\n    }\n    _addPoint(other) {\n        const p0 = getCurve().keyFromPublic((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.arrayify)(this.publicKey));\n        const p1 = getCurve().keyFromPublic((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.arrayify)(other));\n        return \"0x\" + p0.pub.add(p1.pub).encodeCompressed(\"hex\");\n    }\n    signDigest(digest) {\n        const keyPair = getCurve().keyFromPrivate((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.arrayify)(this.privateKey));\n        const digestBytes = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.arrayify)(digest);\n        if (digestBytes.length !== 32) {\n            logger.throwArgumentError(\"bad digest length\", \"digest\", digest);\n        }\n        const signature = keyPair.sign(digestBytes, { canonical: true });\n        return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.splitSignature)({\n            recoveryParam: signature.recoveryParam,\n            r: (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.hexZeroPad)(\"0x\" + signature.r.toString(16), 32),\n            s: (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.hexZeroPad)(\"0x\" + signature.s.toString(16), 32),\n        });\n    }\n    computeSharedSecret(otherKey) {\n        const keyPair = getCurve().keyFromPrivate((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.arrayify)(this.privateKey));\n        const otherKeyPair = getCurve().keyFromPublic((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.arrayify)(computePublicKey(otherKey)));\n        return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.hexZeroPad)(\"0x\" + keyPair.derive(otherKeyPair.getPublic()).toString(16), 32);\n    }\n    static isSigningKey(value) {\n        return !!(value && value._isSigningKey);\n    }\n}\nfunction recoverPublicKey(digest, signature) {\n    const sig = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.splitSignature)(signature);\n    const rs = { r: (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.arrayify)(sig.r), s: (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.arrayify)(sig.s) };\n    return \"0x\" + getCurve().recoverPubKey((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.arrayify)(digest), rs, sig.recoveryParam).encode(\"hex\", false);\n}\nfunction computePublicKey(key, compressed) {\n    const bytes = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.arrayify)(key);\n    if (bytes.length === 32) {\n        const signingKey = new SigningKey(bytes);\n        if (compressed) {\n            return \"0x\" + getCurve().keyFromPrivate(bytes).getPublic(true, \"hex\");\n        }\n        return signingKey.publicKey;\n    }\n    else if (bytes.length === 33) {\n        if (compressed) {\n            return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.hexlify)(bytes);\n        }\n        return \"0x\" + getCurve().keyFromPublic(bytes).getPublic(false, \"hex\");\n    }\n    else if (bytes.length === 65) {\n        if (!compressed) {\n            return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.hexlify)(bytes);\n        }\n        return \"0x\" + getCurve().keyFromPublic(bytes).getPublic(true, \"hex\");\n    }\n    return logger.throwArgumentError(\"invalid public or private key\", \"key\", \"[REDACTED]\");\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3NpZ25pbmcta2V5L2xpYi5lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBYTtBQUNtQjtBQUNvRTtBQUN6QztBQUNaO0FBQ1Y7QUFDckMsbUJBQW1CLHlEQUFNLENBQUMsNkNBQU87QUFDakM7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHlDQUFFO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxRQUFRLHlFQUFjO0FBQ3RCLFFBQVEseUVBQWMscUJBQXFCLDZEQUFPO0FBQ2xELFlBQVksbUVBQWE7QUFDekI7QUFDQTtBQUNBLGtEQUFrRCw4REFBUTtBQUMxRCxRQUFRLHlFQUFjO0FBQ3RCLFFBQVEseUVBQWM7QUFDdEIsUUFBUSx5RUFBYztBQUN0QjtBQUNBO0FBQ0EsNENBQTRDLDhEQUFRO0FBQ3BELDRDQUE0Qyw4REFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsOERBQVE7QUFDMUQsNEJBQTRCLDhEQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxpQkFBaUI7QUFDdkUsZUFBZSxvRUFBYztBQUM3QjtBQUNBLGVBQWUsZ0VBQVU7QUFDekIsZUFBZSxnRUFBVTtBQUN6QixTQUFTO0FBQ1Q7QUFDQTtBQUNBLGtEQUFrRCw4REFBUTtBQUMxRCxzREFBc0QsOERBQVE7QUFDOUQsZUFBZSxnRUFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxnQkFBZ0Isb0VBQWM7QUFDOUIsaUJBQWlCLEdBQUcsOERBQVEsWUFBWSw4REFBUTtBQUNoRCwyQ0FBMkMsOERBQVE7QUFDbkQ7QUFDTztBQUNQLGtCQUFrQiw4REFBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsNkRBQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw2REFBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sZWRnaXR5LXlpZWxkLWZyb250ZW5kLy4uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9zaWduaW5nLWtleS9saWIuZXNtL2luZGV4LmpzP2ZkYWUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgeyBFQyB9IGZyb20gXCIuL2VsbGlwdGljXCI7XG5pbXBvcnQgeyBhcnJheWlmeSwgaGV4RGF0YUxlbmd0aCwgaGV4bGlmeSwgaGV4WmVyb1BhZCwgc3BsaXRTaWduYXR1cmUgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYnl0ZXNcIjtcbmltcG9ydCB7IGRlZmluZVJlYWRPbmx5IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3Byb3BlcnRpZXNcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi9fdmVyc2lvblwiO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcih2ZXJzaW9uKTtcbmxldCBfY3VydmUgPSBudWxsO1xuZnVuY3Rpb24gZ2V0Q3VydmUoKSB7XG4gICAgaWYgKCFfY3VydmUpIHtcbiAgICAgICAgX2N1cnZlID0gbmV3IEVDKFwic2VjcDI1NmsxXCIpO1xuICAgIH1cbiAgICByZXR1cm4gX2N1cnZlO1xufVxuZXhwb3J0IGNsYXNzIFNpZ25pbmdLZXkge1xuICAgIGNvbnN0cnVjdG9yKHByaXZhdGVLZXkpIHtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJjdXJ2ZVwiLCBcInNlY3AyNTZrMVwiKTtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJwcml2YXRlS2V5XCIsIGhleGxpZnkocHJpdmF0ZUtleSkpO1xuICAgICAgICBpZiAoaGV4RGF0YUxlbmd0aCh0aGlzLnByaXZhdGVLZXkpICE9PSAzMikge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgcHJpdmF0ZSBrZXlcIiwgXCJwcml2YXRlS2V5XCIsIFwiW1sgUkVEQUNURUQgXV1cIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qga2V5UGFpciA9IGdldEN1cnZlKCkua2V5RnJvbVByaXZhdGUoYXJyYXlpZnkodGhpcy5wcml2YXRlS2V5KSk7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwicHVibGljS2V5XCIsIFwiMHhcIiArIGtleVBhaXIuZ2V0UHVibGljKGZhbHNlLCBcImhleFwiKSk7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiY29tcHJlc3NlZFB1YmxpY0tleVwiLCBcIjB4XCIgKyBrZXlQYWlyLmdldFB1YmxpYyh0cnVlLCBcImhleFwiKSk7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiX2lzU2lnbmluZ0tleVwiLCB0cnVlKTtcbiAgICB9XG4gICAgX2FkZFBvaW50KG90aGVyKSB7XG4gICAgICAgIGNvbnN0IHAwID0gZ2V0Q3VydmUoKS5rZXlGcm9tUHVibGljKGFycmF5aWZ5KHRoaXMucHVibGljS2V5KSk7XG4gICAgICAgIGNvbnN0IHAxID0gZ2V0Q3VydmUoKS5rZXlGcm9tUHVibGljKGFycmF5aWZ5KG90aGVyKSk7XG4gICAgICAgIHJldHVybiBcIjB4XCIgKyBwMC5wdWIuYWRkKHAxLnB1YikuZW5jb2RlQ29tcHJlc3NlZChcImhleFwiKTtcbiAgICB9XG4gICAgc2lnbkRpZ2VzdChkaWdlc3QpIHtcbiAgICAgICAgY29uc3Qga2V5UGFpciA9IGdldEN1cnZlKCkua2V5RnJvbVByaXZhdGUoYXJyYXlpZnkodGhpcy5wcml2YXRlS2V5KSk7XG4gICAgICAgIGNvbnN0IGRpZ2VzdEJ5dGVzID0gYXJyYXlpZnkoZGlnZXN0KTtcbiAgICAgICAgaWYgKGRpZ2VzdEJ5dGVzLmxlbmd0aCAhPT0gMzIpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJiYWQgZGlnZXN0IGxlbmd0aFwiLCBcImRpZ2VzdFwiLCBkaWdlc3QpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IGtleVBhaXIuc2lnbihkaWdlc3RCeXRlcywgeyBjYW5vbmljYWw6IHRydWUgfSk7XG4gICAgICAgIHJldHVybiBzcGxpdFNpZ25hdHVyZSh7XG4gICAgICAgICAgICByZWNvdmVyeVBhcmFtOiBzaWduYXR1cmUucmVjb3ZlcnlQYXJhbSxcbiAgICAgICAgICAgIHI6IGhleFplcm9QYWQoXCIweFwiICsgc2lnbmF0dXJlLnIudG9TdHJpbmcoMTYpLCAzMiksXG4gICAgICAgICAgICBzOiBoZXhaZXJvUGFkKFwiMHhcIiArIHNpZ25hdHVyZS5zLnRvU3RyaW5nKDE2KSwgMzIpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29tcHV0ZVNoYXJlZFNlY3JldChvdGhlcktleSkge1xuICAgICAgICBjb25zdCBrZXlQYWlyID0gZ2V0Q3VydmUoKS5rZXlGcm9tUHJpdmF0ZShhcnJheWlmeSh0aGlzLnByaXZhdGVLZXkpKTtcbiAgICAgICAgY29uc3Qgb3RoZXJLZXlQYWlyID0gZ2V0Q3VydmUoKS5rZXlGcm9tUHVibGljKGFycmF5aWZ5KGNvbXB1dGVQdWJsaWNLZXkob3RoZXJLZXkpKSk7XG4gICAgICAgIHJldHVybiBoZXhaZXJvUGFkKFwiMHhcIiArIGtleVBhaXIuZGVyaXZlKG90aGVyS2V5UGFpci5nZXRQdWJsaWMoKSkudG9TdHJpbmcoMTYpLCAzMik7XG4gICAgfVxuICAgIHN0YXRpYyBpc1NpZ25pbmdLZXkodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlLl9pc1NpZ25pbmdLZXkpO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiByZWNvdmVyUHVibGljS2V5KGRpZ2VzdCwgc2lnbmF0dXJlKSB7XG4gICAgY29uc3Qgc2lnID0gc3BsaXRTaWduYXR1cmUoc2lnbmF0dXJlKTtcbiAgICBjb25zdCBycyA9IHsgcjogYXJyYXlpZnkoc2lnLnIpLCBzOiBhcnJheWlmeShzaWcucykgfTtcbiAgICByZXR1cm4gXCIweFwiICsgZ2V0Q3VydmUoKS5yZWNvdmVyUHViS2V5KGFycmF5aWZ5KGRpZ2VzdCksIHJzLCBzaWcucmVjb3ZlcnlQYXJhbSkuZW5jb2RlKFwiaGV4XCIsIGZhbHNlKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlUHVibGljS2V5KGtleSwgY29tcHJlc3NlZCkge1xuICAgIGNvbnN0IGJ5dGVzID0gYXJyYXlpZnkoa2V5KTtcbiAgICBpZiAoYnl0ZXMubGVuZ3RoID09PSAzMikge1xuICAgICAgICBjb25zdCBzaWduaW5nS2V5ID0gbmV3IFNpZ25pbmdLZXkoYnl0ZXMpO1xuICAgICAgICBpZiAoY29tcHJlc3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiMHhcIiArIGdldEN1cnZlKCkua2V5RnJvbVByaXZhdGUoYnl0ZXMpLmdldFB1YmxpYyh0cnVlLCBcImhleFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2lnbmluZ0tleS5wdWJsaWNLZXk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGJ5dGVzLmxlbmd0aCA9PT0gMzMpIHtcbiAgICAgICAgaWYgKGNvbXByZXNzZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBoZXhsaWZ5KGJ5dGVzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCIweFwiICsgZ2V0Q3VydmUoKS5rZXlGcm9tUHVibGljKGJ5dGVzKS5nZXRQdWJsaWMoZmFsc2UsIFwiaGV4XCIpO1xuICAgIH1cbiAgICBlbHNlIGlmIChieXRlcy5sZW5ndGggPT09IDY1KSB7XG4gICAgICAgIGlmICghY29tcHJlc3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGhleGxpZnkoYnl0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIjB4XCIgKyBnZXRDdXJ2ZSgpLmtleUZyb21QdWJsaWMoYnl0ZXMpLmdldFB1YmxpYyh0cnVlLCBcImhleFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIHB1YmxpYyBvciBwcml2YXRlIGtleVwiLCBcImtleVwiLCBcIltSRURBQ1RFRF1cIik7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ethersproject/signing-key/lib.esm/index.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@ethersproject/strings/lib.esm/_version.js":
/*!******************************************************************!*\
  !*** ../node_modules/@ethersproject/strings/lib.esm/_version.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\nconst version = \"strings/5.7.0\";\n//# sourceMappingURL=_version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3N0cmluZ3MvbGliLmVzbS9fdmVyc2lvbi5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU87QUFDUCIsInNvdXJjZXMiOlsid2VicGFjazovL2xlZGdpdHkteWllbGQtZnJvbnRlbmQvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3N0cmluZ3MvbGliLmVzbS9fdmVyc2lvbi5qcz8xMTA0Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCB2ZXJzaW9uID0gXCJzdHJpbmdzLzUuNy4wXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdmVyc2lvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ethersproject/strings/lib.esm/_version.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@ethersproject/strings/lib.esm/utf8.js":
/*!**************************************************************!*\
  !*** ../node_modules/@ethersproject/strings/lib.esm/utf8.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   UnicodeNormalizationForm: () => (/* binding */ UnicodeNormalizationForm),\n/* harmony export */   Utf8ErrorFuncs: () => (/* binding */ Utf8ErrorFuncs),\n/* harmony export */   Utf8ErrorReason: () => (/* binding */ Utf8ErrorReason),\n/* harmony export */   _toEscapedUtf8String: () => (/* binding */ _toEscapedUtf8String),\n/* harmony export */   _toUtf8String: () => (/* binding */ _toUtf8String),\n/* harmony export */   toUtf8Bytes: () => (/* binding */ toUtf8Bytes),\n/* harmony export */   toUtf8CodePoints: () => (/* binding */ toUtf8CodePoints),\n/* harmony export */   toUtf8String: () => (/* binding */ toUtf8String)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/../node_modules/@ethersproject/bytes/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/../node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(ssr)/../node_modules/@ethersproject/strings/lib.esm/_version.js\");\n\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\n///////////////////////////////\nvar UnicodeNormalizationForm;\n(function (UnicodeNormalizationForm) {\n    UnicodeNormalizationForm[\"current\"] = \"\";\n    UnicodeNormalizationForm[\"NFC\"] = \"NFC\";\n    UnicodeNormalizationForm[\"NFD\"] = \"NFD\";\n    UnicodeNormalizationForm[\"NFKC\"] = \"NFKC\";\n    UnicodeNormalizationForm[\"NFKD\"] = \"NFKD\";\n})(UnicodeNormalizationForm || (UnicodeNormalizationForm = {}));\n;\nvar Utf8ErrorReason;\n(function (Utf8ErrorReason) {\n    // A continuation byte was present where there was nothing to continue\n    // - offset = the index the codepoint began in\n    Utf8ErrorReason[\"UNEXPECTED_CONTINUE\"] = \"unexpected continuation byte\";\n    // An invalid (non-continuation) byte to start a UTF-8 codepoint was found\n    // - offset = the index the codepoint began in\n    Utf8ErrorReason[\"BAD_PREFIX\"] = \"bad codepoint prefix\";\n    // The string is too short to process the expected codepoint\n    // - offset = the index the codepoint began in\n    Utf8ErrorReason[\"OVERRUN\"] = \"string overrun\";\n    // A missing continuation byte was expected but not found\n    // - offset = the index the continuation byte was expected at\n    Utf8ErrorReason[\"MISSING_CONTINUE\"] = \"missing continuation byte\";\n    // The computed code point is outside the range for UTF-8\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; outside the UTF-8 range\n    Utf8ErrorReason[\"OUT_OF_RANGE\"] = \"out of UTF-8 range\";\n    // UTF-8 strings may not contain UTF-16 surrogate pairs\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; inside the UTF-16 surrogate range\n    Utf8ErrorReason[\"UTF16_SURROGATE\"] = \"UTF-16 surrogate\";\n    // The string is an overlong representation\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; already bounds checked\n    Utf8ErrorReason[\"OVERLONG\"] = \"overlong representation\";\n})(Utf8ErrorReason || (Utf8ErrorReason = {}));\n;\nfunction errorFunc(reason, offset, bytes, output, badCodepoint) {\n    return logger.throwArgumentError(`invalid codepoint at offset ${offset}; ${reason}`, \"bytes\", bytes);\n}\nfunction ignoreFunc(reason, offset, bytes, output, badCodepoint) {\n    // If there is an invalid prefix (including stray continuation), skip any additional continuation bytes\n    if (reason === Utf8ErrorReason.BAD_PREFIX || reason === Utf8ErrorReason.UNEXPECTED_CONTINUE) {\n        let i = 0;\n        for (let o = offset + 1; o < bytes.length; o++) {\n            if (bytes[o] >> 6 !== 0x02) {\n                break;\n            }\n            i++;\n        }\n        return i;\n    }\n    // This byte runs us past the end of the string, so just jump to the end\n    // (but the first byte was read already read and therefore skipped)\n    if (reason === Utf8ErrorReason.OVERRUN) {\n        return bytes.length - offset - 1;\n    }\n    // Nothing to skip\n    return 0;\n}\nfunction replaceFunc(reason, offset, bytes, output, badCodepoint) {\n    // Overlong representations are otherwise \"valid\" code points; just non-deistingtished\n    if (reason === Utf8ErrorReason.OVERLONG) {\n        output.push(badCodepoint);\n        return 0;\n    }\n    // Put the replacement character into the output\n    output.push(0xfffd);\n    // Otherwise, process as if ignoring errors\n    return ignoreFunc(reason, offset, bytes, output, badCodepoint);\n}\n// Common error handing strategies\nconst Utf8ErrorFuncs = Object.freeze({\n    error: errorFunc,\n    ignore: ignoreFunc,\n    replace: replaceFunc\n});\n// http://stackoverflow.com/questions/13356493/decode-utf-8-with-javascript#13691499\nfunction getUtf8CodePoints(bytes, onError) {\n    if (onError == null) {\n        onError = Utf8ErrorFuncs.error;\n    }\n    bytes = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.arrayify)(bytes);\n    const result = [];\n    let i = 0;\n    // Invalid bytes are ignored\n    while (i < bytes.length) {\n        const c = bytes[i++];\n        // 0xxx xxxx\n        if (c >> 7 === 0) {\n            result.push(c);\n            continue;\n        }\n        // Multibyte; how many bytes left for this character?\n        let extraLength = null;\n        let overlongMask = null;\n        // 110x xxxx 10xx xxxx\n        if ((c & 0xe0) === 0xc0) {\n            extraLength = 1;\n            overlongMask = 0x7f;\n            // 1110 xxxx 10xx xxxx 10xx xxxx\n        }\n        else if ((c & 0xf0) === 0xe0) {\n            extraLength = 2;\n            overlongMask = 0x7ff;\n            // 1111 0xxx 10xx xxxx 10xx xxxx 10xx xxxx\n        }\n        else if ((c & 0xf8) === 0xf0) {\n            extraLength = 3;\n            overlongMask = 0xffff;\n        }\n        else {\n            if ((c & 0xc0) === 0x80) {\n                i += onError(Utf8ErrorReason.UNEXPECTED_CONTINUE, i - 1, bytes, result);\n            }\n            else {\n                i += onError(Utf8ErrorReason.BAD_PREFIX, i - 1, bytes, result);\n            }\n            continue;\n        }\n        // Do we have enough bytes in our data?\n        if (i - 1 + extraLength >= bytes.length) {\n            i += onError(Utf8ErrorReason.OVERRUN, i - 1, bytes, result);\n            continue;\n        }\n        // Remove the length prefix from the char\n        let res = c & ((1 << (8 - extraLength - 1)) - 1);\n        for (let j = 0; j < extraLength; j++) {\n            let nextChar = bytes[i];\n            // Invalid continuation byte\n            if ((nextChar & 0xc0) != 0x80) {\n                i += onError(Utf8ErrorReason.MISSING_CONTINUE, i, bytes, result);\n                res = null;\n                break;\n            }\n            ;\n            res = (res << 6) | (nextChar & 0x3f);\n            i++;\n        }\n        // See above loop for invalid continuation byte\n        if (res === null) {\n            continue;\n        }\n        // Maximum code point\n        if (res > 0x10ffff) {\n            i += onError(Utf8ErrorReason.OUT_OF_RANGE, i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n        // Reserved for UTF-16 surrogate halves\n        if (res >= 0xd800 && res <= 0xdfff) {\n            i += onError(Utf8ErrorReason.UTF16_SURROGATE, i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n        // Check for overlong sequences (more bytes than needed)\n        if (res <= overlongMask) {\n            i += onError(Utf8ErrorReason.OVERLONG, i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n        result.push(res);\n    }\n    return result;\n}\n// http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array\nfunction toUtf8Bytes(str, form = UnicodeNormalizationForm.current) {\n    if (form != UnicodeNormalizationForm.current) {\n        logger.checkNormalize();\n        str = str.normalize(form);\n    }\n    let result = [];\n    for (let i = 0; i < str.length; i++) {\n        const c = str.charCodeAt(i);\n        if (c < 0x80) {\n            result.push(c);\n        }\n        else if (c < 0x800) {\n            result.push((c >> 6) | 0xc0);\n            result.push((c & 0x3f) | 0x80);\n        }\n        else if ((c & 0xfc00) == 0xd800) {\n            i++;\n            const c2 = str.charCodeAt(i);\n            if (i >= str.length || (c2 & 0xfc00) !== 0xdc00) {\n                throw new Error(\"invalid utf-8 string\");\n            }\n            // Surrogate Pair\n            const pair = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);\n            result.push((pair >> 18) | 0xf0);\n            result.push(((pair >> 12) & 0x3f) | 0x80);\n            result.push(((pair >> 6) & 0x3f) | 0x80);\n            result.push((pair & 0x3f) | 0x80);\n        }\n        else {\n            result.push((c >> 12) | 0xe0);\n            result.push(((c >> 6) & 0x3f) | 0x80);\n            result.push((c & 0x3f) | 0x80);\n        }\n    }\n    return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.arrayify)(result);\n}\n;\nfunction escapeChar(value) {\n    const hex = (\"0000\" + value.toString(16));\n    return \"\\\\u\" + hex.substring(hex.length - 4);\n}\nfunction _toEscapedUtf8String(bytes, onError) {\n    return '\"' + getUtf8CodePoints(bytes, onError).map((codePoint) => {\n        if (codePoint < 256) {\n            switch (codePoint) {\n                case 8: return \"\\\\b\";\n                case 9: return \"\\\\t\";\n                case 10: return \"\\\\n\";\n                case 13: return \"\\\\r\";\n                case 34: return \"\\\\\\\"\";\n                case 92: return \"\\\\\\\\\";\n            }\n            if (codePoint >= 32 && codePoint < 127) {\n                return String.fromCharCode(codePoint);\n            }\n        }\n        if (codePoint <= 0xffff) {\n            return escapeChar(codePoint);\n        }\n        codePoint -= 0x10000;\n        return escapeChar(((codePoint >> 10) & 0x3ff) + 0xd800) + escapeChar((codePoint & 0x3ff) + 0xdc00);\n    }).join(\"\") + '\"';\n}\nfunction _toUtf8String(codePoints) {\n    return codePoints.map((codePoint) => {\n        if (codePoint <= 0xffff) {\n            return String.fromCharCode(codePoint);\n        }\n        codePoint -= 0x10000;\n        return String.fromCharCode((((codePoint >> 10) & 0x3ff) + 0xd800), ((codePoint & 0x3ff) + 0xdc00));\n    }).join(\"\");\n}\nfunction toUtf8String(bytes, onError) {\n    return _toUtf8String(getUtf8CodePoints(bytes, onError));\n}\nfunction toUtf8CodePoints(str, form = UnicodeNormalizationForm.current) {\n    return getUtf8CodePoints(toUtf8Bytes(str, form));\n}\n//# sourceMappingURL=utf8.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3N0cmluZ3MvbGliLmVzbS91dGY4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQWE7QUFDbUM7QUFDRDtBQUNWO0FBQ3JDLG1CQUFtQix5REFBTSxDQUFDLDZDQUFPO0FBQ2pDO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDREQUE0RDtBQUM3RDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQSxDQUFDLDBDQUEwQztBQUMzQztBQUNBO0FBQ0Esb0VBQW9FLFNBQVMsRUFBRSxPQUFPO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsa0JBQWtCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksOERBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDhEQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGVkZ2l0eS15aWVsZC1mcm9udGVuZC8uLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3Qvc3RyaW5ncy9saWIuZXNtL3V0ZjguanM/NGJlNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmltcG9ydCB7IGFycmF5aWZ5IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2J5dGVzXCI7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvbG9nZ2VyXCI7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4vX3ZlcnNpb25cIjtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIodmVyc2lvbik7XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5leHBvcnQgdmFyIFVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybTtcbihmdW5jdGlvbiAoVW5pY29kZU5vcm1hbGl6YXRpb25Gb3JtKSB7XG4gICAgVW5pY29kZU5vcm1hbGl6YXRpb25Gb3JtW1wiY3VycmVudFwiXSA9IFwiXCI7XG4gICAgVW5pY29kZU5vcm1hbGl6YXRpb25Gb3JtW1wiTkZDXCJdID0gXCJORkNcIjtcbiAgICBVbmljb2RlTm9ybWFsaXphdGlvbkZvcm1bXCJORkRcIl0gPSBcIk5GRFwiO1xuICAgIFVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybVtcIk5GS0NcIl0gPSBcIk5GS0NcIjtcbiAgICBVbmljb2RlTm9ybWFsaXphdGlvbkZvcm1bXCJORktEXCJdID0gXCJORktEXCI7XG59KShVbmljb2RlTm9ybWFsaXphdGlvbkZvcm0gfHwgKFVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybSA9IHt9KSk7XG47XG5leHBvcnQgdmFyIFV0ZjhFcnJvclJlYXNvbjtcbihmdW5jdGlvbiAoVXRmOEVycm9yUmVhc29uKSB7XG4gICAgLy8gQSBjb250aW51YXRpb24gYnl0ZSB3YXMgcHJlc2VudCB3aGVyZSB0aGVyZSB3YXMgbm90aGluZyB0byBjb250aW51ZVxuICAgIC8vIC0gb2Zmc2V0ID0gdGhlIGluZGV4IHRoZSBjb2RlcG9pbnQgYmVnYW4gaW5cbiAgICBVdGY4RXJyb3JSZWFzb25bXCJVTkVYUEVDVEVEX0NPTlRJTlVFXCJdID0gXCJ1bmV4cGVjdGVkIGNvbnRpbnVhdGlvbiBieXRlXCI7XG4gICAgLy8gQW4gaW52YWxpZCAobm9uLWNvbnRpbnVhdGlvbikgYnl0ZSB0byBzdGFydCBhIFVURi04IGNvZGVwb2ludCB3YXMgZm91bmRcbiAgICAvLyAtIG9mZnNldCA9IHRoZSBpbmRleCB0aGUgY29kZXBvaW50IGJlZ2FuIGluXG4gICAgVXRmOEVycm9yUmVhc29uW1wiQkFEX1BSRUZJWFwiXSA9IFwiYmFkIGNvZGVwb2ludCBwcmVmaXhcIjtcbiAgICAvLyBUaGUgc3RyaW5nIGlzIHRvbyBzaG9ydCB0byBwcm9jZXNzIHRoZSBleHBlY3RlZCBjb2RlcG9pbnRcbiAgICAvLyAtIG9mZnNldCA9IHRoZSBpbmRleCB0aGUgY29kZXBvaW50IGJlZ2FuIGluXG4gICAgVXRmOEVycm9yUmVhc29uW1wiT1ZFUlJVTlwiXSA9IFwic3RyaW5nIG92ZXJydW5cIjtcbiAgICAvLyBBIG1pc3NpbmcgY29udGludWF0aW9uIGJ5dGUgd2FzIGV4cGVjdGVkIGJ1dCBub3QgZm91bmRcbiAgICAvLyAtIG9mZnNldCA9IHRoZSBpbmRleCB0aGUgY29udGludWF0aW9uIGJ5dGUgd2FzIGV4cGVjdGVkIGF0XG4gICAgVXRmOEVycm9yUmVhc29uW1wiTUlTU0lOR19DT05USU5VRVwiXSA9IFwibWlzc2luZyBjb250aW51YXRpb24gYnl0ZVwiO1xuICAgIC8vIFRoZSBjb21wdXRlZCBjb2RlIHBvaW50IGlzIG91dHNpZGUgdGhlIHJhbmdlIGZvciBVVEYtOFxuICAgIC8vIC0gb2Zmc2V0ICAgICAgID0gc3RhcnQgb2YgdGhpcyBjb2RlcG9pbnRcbiAgICAvLyAtIGJhZENvZGVwb2ludCA9IHRoZSBjb21wdXRlZCBjb2RlcG9pbnQ7IG91dHNpZGUgdGhlIFVURi04IHJhbmdlXG4gICAgVXRmOEVycm9yUmVhc29uW1wiT1VUX09GX1JBTkdFXCJdID0gXCJvdXQgb2YgVVRGLTggcmFuZ2VcIjtcbiAgICAvLyBVVEYtOCBzdHJpbmdzIG1heSBub3QgY29udGFpbiBVVEYtMTYgc3Vycm9nYXRlIHBhaXJzXG4gICAgLy8gLSBvZmZzZXQgICAgICAgPSBzdGFydCBvZiB0aGlzIGNvZGVwb2ludFxuICAgIC8vIC0gYmFkQ29kZXBvaW50ID0gdGhlIGNvbXB1dGVkIGNvZGVwb2ludDsgaW5zaWRlIHRoZSBVVEYtMTYgc3Vycm9nYXRlIHJhbmdlXG4gICAgVXRmOEVycm9yUmVhc29uW1wiVVRGMTZfU1VSUk9HQVRFXCJdID0gXCJVVEYtMTYgc3Vycm9nYXRlXCI7XG4gICAgLy8gVGhlIHN0cmluZyBpcyBhbiBvdmVybG9uZyByZXByZXNlbnRhdGlvblxuICAgIC8vIC0gb2Zmc2V0ICAgICAgID0gc3RhcnQgb2YgdGhpcyBjb2RlcG9pbnRcbiAgICAvLyAtIGJhZENvZGVwb2ludCA9IHRoZSBjb21wdXRlZCBjb2RlcG9pbnQ7IGFscmVhZHkgYm91bmRzIGNoZWNrZWRcbiAgICBVdGY4RXJyb3JSZWFzb25bXCJPVkVSTE9OR1wiXSA9IFwib3ZlcmxvbmcgcmVwcmVzZW50YXRpb25cIjtcbn0pKFV0ZjhFcnJvclJlYXNvbiB8fCAoVXRmOEVycm9yUmVhc29uID0ge30pKTtcbjtcbmZ1bmN0aW9uIGVycm9yRnVuYyhyZWFzb24sIG9mZnNldCwgYnl0ZXMsIG91dHB1dCwgYmFkQ29kZXBvaW50KSB7XG4gICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoYGludmFsaWQgY29kZXBvaW50IGF0IG9mZnNldCAke29mZnNldH07ICR7cmVhc29ufWAsIFwiYnl0ZXNcIiwgYnl0ZXMpO1xufVxuZnVuY3Rpb24gaWdub3JlRnVuYyhyZWFzb24sIG9mZnNldCwgYnl0ZXMsIG91dHB1dCwgYmFkQ29kZXBvaW50KSB7XG4gICAgLy8gSWYgdGhlcmUgaXMgYW4gaW52YWxpZCBwcmVmaXggKGluY2x1ZGluZyBzdHJheSBjb250aW51YXRpb24pLCBza2lwIGFueSBhZGRpdGlvbmFsIGNvbnRpbnVhdGlvbiBieXRlc1xuICAgIGlmIChyZWFzb24gPT09IFV0ZjhFcnJvclJlYXNvbi5CQURfUFJFRklYIHx8IHJlYXNvbiA9PT0gVXRmOEVycm9yUmVhc29uLlVORVhQRUNURURfQ09OVElOVUUpIHtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICBmb3IgKGxldCBvID0gb2Zmc2V0ICsgMTsgbyA8IGJ5dGVzLmxlbmd0aDsgbysrKSB7XG4gICAgICAgICAgICBpZiAoYnl0ZXNbb10gPj4gNiAhPT0gMHgwMikge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgICAvLyBUaGlzIGJ5dGUgcnVucyB1cyBwYXN0IHRoZSBlbmQgb2YgdGhlIHN0cmluZywgc28ganVzdCBqdW1wIHRvIHRoZSBlbmRcbiAgICAvLyAoYnV0IHRoZSBmaXJzdCBieXRlIHdhcyByZWFkIGFscmVhZHkgcmVhZCBhbmQgdGhlcmVmb3JlIHNraXBwZWQpXG4gICAgaWYgKHJlYXNvbiA9PT0gVXRmOEVycm9yUmVhc29uLk9WRVJSVU4pIHtcbiAgICAgICAgcmV0dXJuIGJ5dGVzLmxlbmd0aCAtIG9mZnNldCAtIDE7XG4gICAgfVxuICAgIC8vIE5vdGhpbmcgdG8gc2tpcFxuICAgIHJldHVybiAwO1xufVxuZnVuY3Rpb24gcmVwbGFjZUZ1bmMocmVhc29uLCBvZmZzZXQsIGJ5dGVzLCBvdXRwdXQsIGJhZENvZGVwb2ludCkge1xuICAgIC8vIE92ZXJsb25nIHJlcHJlc2VudGF0aW9ucyBhcmUgb3RoZXJ3aXNlIFwidmFsaWRcIiBjb2RlIHBvaW50czsganVzdCBub24tZGVpc3Rpbmd0aXNoZWRcbiAgICBpZiAocmVhc29uID09PSBVdGY4RXJyb3JSZWFzb24uT1ZFUkxPTkcpIHtcbiAgICAgICAgb3V0cHV0LnB1c2goYmFkQ29kZXBvaW50KTtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIC8vIFB1dCB0aGUgcmVwbGFjZW1lbnQgY2hhcmFjdGVyIGludG8gdGhlIG91dHB1dFxuICAgIG91dHB1dC5wdXNoKDB4ZmZmZCk7XG4gICAgLy8gT3RoZXJ3aXNlLCBwcm9jZXNzIGFzIGlmIGlnbm9yaW5nIGVycm9yc1xuICAgIHJldHVybiBpZ25vcmVGdW5jKHJlYXNvbiwgb2Zmc2V0LCBieXRlcywgb3V0cHV0LCBiYWRDb2RlcG9pbnQpO1xufVxuLy8gQ29tbW9uIGVycm9yIGhhbmRpbmcgc3RyYXRlZ2llc1xuZXhwb3J0IGNvbnN0IFV0ZjhFcnJvckZ1bmNzID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgZXJyb3I6IGVycm9yRnVuYyxcbiAgICBpZ25vcmU6IGlnbm9yZUZ1bmMsXG4gICAgcmVwbGFjZTogcmVwbGFjZUZ1bmNcbn0pO1xuLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMzM1NjQ5My9kZWNvZGUtdXRmLTgtd2l0aC1qYXZhc2NyaXB0IzEzNjkxNDk5XG5mdW5jdGlvbiBnZXRVdGY4Q29kZVBvaW50cyhieXRlcywgb25FcnJvcikge1xuICAgIGlmIChvbkVycm9yID09IG51bGwpIHtcbiAgICAgICAgb25FcnJvciA9IFV0ZjhFcnJvckZ1bmNzLmVycm9yO1xuICAgIH1cbiAgICBieXRlcyA9IGFycmF5aWZ5KGJ5dGVzKTtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBsZXQgaSA9IDA7XG4gICAgLy8gSW52YWxpZCBieXRlcyBhcmUgaWdub3JlZFxuICAgIHdoaWxlIChpIDwgYnl0ZXMubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGMgPSBieXRlc1tpKytdO1xuICAgICAgICAvLyAweHh4IHh4eHhcbiAgICAgICAgaWYgKGMgPj4gNyA9PT0gMCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goYyk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBNdWx0aWJ5dGU7IGhvdyBtYW55IGJ5dGVzIGxlZnQgZm9yIHRoaXMgY2hhcmFjdGVyP1xuICAgICAgICBsZXQgZXh0cmFMZW5ndGggPSBudWxsO1xuICAgICAgICBsZXQgb3ZlcmxvbmdNYXNrID0gbnVsbDtcbiAgICAgICAgLy8gMTEweCB4eHh4IDEweHggeHh4eFxuICAgICAgICBpZiAoKGMgJiAweGUwKSA9PT0gMHhjMCkge1xuICAgICAgICAgICAgZXh0cmFMZW5ndGggPSAxO1xuICAgICAgICAgICAgb3ZlcmxvbmdNYXNrID0gMHg3ZjtcbiAgICAgICAgICAgIC8vIDExMTAgeHh4eCAxMHh4IHh4eHggMTB4eCB4eHh4XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKGMgJiAweGYwKSA9PT0gMHhlMCkge1xuICAgICAgICAgICAgZXh0cmFMZW5ndGggPSAyO1xuICAgICAgICAgICAgb3ZlcmxvbmdNYXNrID0gMHg3ZmY7XG4gICAgICAgICAgICAvLyAxMTExIDB4eHggMTB4eCB4eHh4IDEweHggeHh4eCAxMHh4IHh4eHhcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoYyAmIDB4ZjgpID09PSAweGYwKSB7XG4gICAgICAgICAgICBleHRyYUxlbmd0aCA9IDM7XG4gICAgICAgICAgICBvdmVybG9uZ01hc2sgPSAweGZmZmY7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoKGMgJiAweGMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgICAgIGkgKz0gb25FcnJvcihVdGY4RXJyb3JSZWFzb24uVU5FWFBFQ1RFRF9DT05USU5VRSwgaSAtIDEsIGJ5dGVzLCByZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaSArPSBvbkVycm9yKFV0ZjhFcnJvclJlYXNvbi5CQURfUFJFRklYLCBpIC0gMSwgYnl0ZXMsIHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBEbyB3ZSBoYXZlIGVub3VnaCBieXRlcyBpbiBvdXIgZGF0YT9cbiAgICAgICAgaWYgKGkgLSAxICsgZXh0cmFMZW5ndGggPj0gYnl0ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpICs9IG9uRXJyb3IoVXRmOEVycm9yUmVhc29uLk9WRVJSVU4sIGkgLSAxLCBieXRlcywgcmVzdWx0KTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlbW92ZSB0aGUgbGVuZ3RoIHByZWZpeCBmcm9tIHRoZSBjaGFyXG4gICAgICAgIGxldCByZXMgPSBjICYgKCgxIDw8ICg4IC0gZXh0cmFMZW5ndGggLSAxKSkgLSAxKTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBleHRyYUxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBsZXQgbmV4dENoYXIgPSBieXRlc1tpXTtcbiAgICAgICAgICAgIC8vIEludmFsaWQgY29udGludWF0aW9uIGJ5dGVcbiAgICAgICAgICAgIGlmICgobmV4dENoYXIgJiAweGMwKSAhPSAweDgwKSB7XG4gICAgICAgICAgICAgICAgaSArPSBvbkVycm9yKFV0ZjhFcnJvclJlYXNvbi5NSVNTSU5HX0NPTlRJTlVFLCBpLCBieXRlcywgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICByZXMgPSBudWxsO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgO1xuICAgICAgICAgICAgcmVzID0gKHJlcyA8PCA2KSB8IChuZXh0Q2hhciAmIDB4M2YpO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNlZSBhYm92ZSBsb29wIGZvciBpbnZhbGlkIGNvbnRpbnVhdGlvbiBieXRlXG4gICAgICAgIGlmIChyZXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIE1heGltdW0gY29kZSBwb2ludFxuICAgICAgICBpZiAocmVzID4gMHgxMGZmZmYpIHtcbiAgICAgICAgICAgIGkgKz0gb25FcnJvcihVdGY4RXJyb3JSZWFzb24uT1VUX09GX1JBTkdFLCBpIC0gMSAtIGV4dHJhTGVuZ3RoLCBieXRlcywgcmVzdWx0LCByZXMpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVzZXJ2ZWQgZm9yIFVURi0xNiBzdXJyb2dhdGUgaGFsdmVzXG4gICAgICAgIGlmIChyZXMgPj0gMHhkODAwICYmIHJlcyA8PSAweGRmZmYpIHtcbiAgICAgICAgICAgIGkgKz0gb25FcnJvcihVdGY4RXJyb3JSZWFzb24uVVRGMTZfU1VSUk9HQVRFLCBpIC0gMSAtIGV4dHJhTGVuZ3RoLCBieXRlcywgcmVzdWx0LCByZXMpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgZm9yIG92ZXJsb25nIHNlcXVlbmNlcyAobW9yZSBieXRlcyB0aGFuIG5lZWRlZClcbiAgICAgICAgaWYgKHJlcyA8PSBvdmVybG9uZ01hc2spIHtcbiAgICAgICAgICAgIGkgKz0gb25FcnJvcihVdGY4RXJyb3JSZWFzb24uT1ZFUkxPTkcsIGkgLSAxIC0gZXh0cmFMZW5ndGgsIGJ5dGVzLCByZXN1bHQsIHJlcyk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQucHVzaChyZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xODcyOTQwNS9ob3ctdG8tY29udmVydC11dGY4LXN0cmluZy10by1ieXRlLWFycmF5XG5leHBvcnQgZnVuY3Rpb24gdG9VdGY4Qnl0ZXMoc3RyLCBmb3JtID0gVW5pY29kZU5vcm1hbGl6YXRpb25Gb3JtLmN1cnJlbnQpIHtcbiAgICBpZiAoZm9ybSAhPSBVbmljb2RlTm9ybWFsaXphdGlvbkZvcm0uY3VycmVudCkge1xuICAgICAgICBsb2dnZXIuY2hlY2tOb3JtYWxpemUoKTtcbiAgICAgICAgc3RyID0gc3RyLm5vcm1hbGl6ZShmb3JtKTtcbiAgICB9XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGMgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGMgPCAweDgwKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChjKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjIDwgMHg4MDApIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKChjID4+IDYpIHwgMHhjMCk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgoYyAmIDB4M2YpIHwgMHg4MCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKGMgJiAweGZjMDApID09IDB4ZDgwMCkge1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgY29uc3QgYzIgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgIGlmIChpID49IHN0ci5sZW5ndGggfHwgKGMyICYgMHhmYzAwKSAhPT0gMHhkYzAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCB1dGYtOCBzdHJpbmdcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTdXJyb2dhdGUgUGFpclxuICAgICAgICAgICAgY29uc3QgcGFpciA9IDB4MTAwMDAgKyAoKGMgJiAweDAzZmYpIDw8IDEwKSArIChjMiAmIDB4MDNmZik7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgocGFpciA+PiAxOCkgfCAweGYwKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCgocGFpciA+PiAxMikgJiAweDNmKSB8IDB4ODApO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goKChwYWlyID4+IDYpICYgMHgzZikgfCAweDgwKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKChwYWlyICYgMHgzZikgfCAweDgwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKChjID4+IDEyKSB8IDB4ZTApO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goKChjID4+IDYpICYgMHgzZikgfCAweDgwKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKChjICYgMHgzZikgfCAweDgwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlpZnkocmVzdWx0KTtcbn1cbjtcbmZ1bmN0aW9uIGVzY2FwZUNoYXIodmFsdWUpIHtcbiAgICBjb25zdCBoZXggPSAoXCIwMDAwXCIgKyB2YWx1ZS50b1N0cmluZygxNikpO1xuICAgIHJldHVybiBcIlxcXFx1XCIgKyBoZXguc3Vic3RyaW5nKGhleC5sZW5ndGggLSA0KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBfdG9Fc2NhcGVkVXRmOFN0cmluZyhieXRlcywgb25FcnJvcikge1xuICAgIHJldHVybiAnXCInICsgZ2V0VXRmOENvZGVQb2ludHMoYnl0ZXMsIG9uRXJyb3IpLm1hcCgoY29kZVBvaW50KSA9PiB7XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPCAyNTYpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoY29kZVBvaW50KSB7XG4gICAgICAgICAgICAgICAgY2FzZSA4OiByZXR1cm4gXCJcXFxcYlwiO1xuICAgICAgICAgICAgICAgIGNhc2UgOTogcmV0dXJuIFwiXFxcXHRcIjtcbiAgICAgICAgICAgICAgICBjYXNlIDEwOiByZXR1cm4gXCJcXFxcblwiO1xuICAgICAgICAgICAgICAgIGNhc2UgMTM6IHJldHVybiBcIlxcXFxyXCI7XG4gICAgICAgICAgICAgICAgY2FzZSAzNDogcmV0dXJuIFwiXFxcXFxcXCJcIjtcbiAgICAgICAgICAgICAgICBjYXNlIDkyOiByZXR1cm4gXCJcXFxcXFxcXFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvZGVQb2ludCA+PSAzMiAmJiBjb2RlUG9pbnQgPCAxMjcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlUG9pbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPD0gMHhmZmZmKSB7XG4gICAgICAgICAgICByZXR1cm4gZXNjYXBlQ2hhcihjb2RlUG9pbnQpO1xuICAgICAgICB9XG4gICAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwO1xuICAgICAgICByZXR1cm4gZXNjYXBlQ2hhcigoKGNvZGVQb2ludCA+PiAxMCkgJiAweDNmZikgKyAweGQ4MDApICsgZXNjYXBlQ2hhcigoY29kZVBvaW50ICYgMHgzZmYpICsgMHhkYzAwKTtcbiAgICB9KS5qb2luKFwiXCIpICsgJ1wiJztcbn1cbmV4cG9ydCBmdW5jdGlvbiBfdG9VdGY4U3RyaW5nKGNvZGVQb2ludHMpIHtcbiAgICByZXR1cm4gY29kZVBvaW50cy5tYXAoKGNvZGVQb2ludCkgPT4ge1xuICAgICAgICBpZiAoY29kZVBvaW50IDw9IDB4ZmZmZikge1xuICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZVBvaW50KTtcbiAgICAgICAgfVxuICAgICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMDtcbiAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoKCgoY29kZVBvaW50ID4+IDEwKSAmIDB4M2ZmKSArIDB4ZDgwMCksICgoY29kZVBvaW50ICYgMHgzZmYpICsgMHhkYzAwKSk7XG4gICAgfSkuam9pbihcIlwiKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB0b1V0ZjhTdHJpbmcoYnl0ZXMsIG9uRXJyb3IpIHtcbiAgICByZXR1cm4gX3RvVXRmOFN0cmluZyhnZXRVdGY4Q29kZVBvaW50cyhieXRlcywgb25FcnJvcikpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHRvVXRmOENvZGVQb2ludHMoc3RyLCBmb3JtID0gVW5pY29kZU5vcm1hbGl6YXRpb25Gb3JtLmN1cnJlbnQpIHtcbiAgICByZXR1cm4gZ2V0VXRmOENvZGVQb2ludHModG9VdGY4Qnl0ZXMoc3RyLCBmb3JtKSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGY4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ethersproject/strings/lib.esm/utf8.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@ethersproject/transactions/lib.esm/_version.js":
/*!***********************************************************************!*\
  !*** ../node_modules/@ethersproject/transactions/lib.esm/_version.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\nconst version = \"transactions/5.7.0\";\n//# sourceMappingURL=_version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3RyYW5zYWN0aW9ucy9saWIuZXNtL192ZXJzaW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBTztBQUNQIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGVkZ2l0eS15aWVsZC1mcm9udGVuZC8uLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvdHJhbnNhY3Rpb25zL2xpYi5lc20vX3ZlcnNpb24uanM/MmM1MSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgdmVyc2lvbiA9IFwidHJhbnNhY3Rpb25zLzUuNy4wXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdmVyc2lvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ethersproject/transactions/lib.esm/_version.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@ethersproject/transactions/lib.esm/index.js":
/*!********************************************************************!*\
  !*** ../node_modules/@ethersproject/transactions/lib.esm/index.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TransactionTypes: () => (/* binding */ TransactionTypes),\n/* harmony export */   accessListify: () => (/* binding */ accessListify),\n/* harmony export */   computeAddress: () => (/* binding */ computeAddress),\n/* harmony export */   parse: () => (/* binding */ parse),\n/* harmony export */   recoverAddress: () => (/* binding */ recoverAddress),\n/* harmony export */   serialize: () => (/* binding */ serialize)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_address__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/address */ \"(ssr)/../node_modules/@ethersproject/address/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethersproject/bignumber */ \"(ssr)/../node_modules/@ethersproject/bignumber/lib.esm/bignumber.js\");\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/../node_modules/@ethersproject/bytes/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/constants */ \"(ssr)/../node_modules/@ethersproject/constants/lib.esm/bignumbers.js\");\n/* harmony import */ var _ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @ethersproject/keccak256 */ \"(ssr)/../node_modules/@ethersproject/keccak256/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/../node_modules/@ethersproject/properties/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_rlp__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @ethersproject/rlp */ \"(ssr)/../node_modules/@ethersproject/rlp/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_signing_key__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ethersproject/signing-key */ \"(ssr)/../node_modules/@ethersproject/signing-key/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/../node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(ssr)/../node_modules/@ethersproject/transactions/lib.esm/_version.js\");\n\n\n\n\n\n\n\n\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\nvar TransactionTypes;\n(function (TransactionTypes) {\n    TransactionTypes[TransactionTypes[\"legacy\"] = 0] = \"legacy\";\n    TransactionTypes[TransactionTypes[\"eip2930\"] = 1] = \"eip2930\";\n    TransactionTypes[TransactionTypes[\"eip1559\"] = 2] = \"eip1559\";\n})(TransactionTypes || (TransactionTypes = {}));\n;\n///////////////////////////////\nfunction handleAddress(value) {\n    if (value === \"0x\") {\n        return null;\n    }\n    return (0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_2__.getAddress)(value);\n}\nfunction handleNumber(value) {\n    if (value === \"0x\") {\n        return _ethersproject_constants__WEBPACK_IMPORTED_MODULE_3__.Zero;\n    }\n    return _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(value);\n}\n// Legacy Transaction Fields\nconst transactionFields = [\n    { name: \"nonce\", maxLength: 32, numeric: true },\n    { name: \"gasPrice\", maxLength: 32, numeric: true },\n    { name: \"gasLimit\", maxLength: 32, numeric: true },\n    { name: \"to\", length: 20 },\n    { name: \"value\", maxLength: 32, numeric: true },\n    { name: \"data\" },\n];\nconst allowedTransactionKeys = {\n    chainId: true, data: true, gasLimit: true, gasPrice: true, nonce: true, to: true, type: true, value: true\n};\nfunction computeAddress(key) {\n    const publicKey = (0,_ethersproject_signing_key__WEBPACK_IMPORTED_MODULE_5__.computePublicKey)(key);\n    return (0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_2__.getAddress)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexDataSlice)((0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_7__.keccak256)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexDataSlice)(publicKey, 1)), 12));\n}\nfunction recoverAddress(digest, signature) {\n    return computeAddress((0,_ethersproject_signing_key__WEBPACK_IMPORTED_MODULE_5__.recoverPublicKey)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.arrayify)(digest), signature));\n}\nfunction formatNumber(value, name) {\n    const result = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.stripZeros)(_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(value).toHexString());\n    if (result.length > 32) {\n        logger.throwArgumentError(\"invalid length for \" + name, (\"transaction:\" + name), value);\n    }\n    return result;\n}\nfunction accessSetify(addr, storageKeys) {\n    return {\n        address: (0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_2__.getAddress)(addr),\n        storageKeys: (storageKeys || []).map((storageKey, index) => {\n            if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexDataLength)(storageKey) !== 32) {\n                logger.throwArgumentError(\"invalid access list storageKey\", `accessList[${addr}:${index}]`, storageKey);\n            }\n            return storageKey.toLowerCase();\n        })\n    };\n}\nfunction accessListify(value) {\n    if (Array.isArray(value)) {\n        return value.map((set, index) => {\n            if (Array.isArray(set)) {\n                if (set.length > 2) {\n                    logger.throwArgumentError(\"access list expected to be [ address, storageKeys[] ]\", `value[${index}]`, set);\n                }\n                return accessSetify(set[0], set[1]);\n            }\n            return accessSetify(set.address, set.storageKeys);\n        });\n    }\n    const result = Object.keys(value).map((addr) => {\n        const storageKeys = value[addr].reduce((accum, storageKey) => {\n            accum[storageKey] = true;\n            return accum;\n        }, {});\n        return accessSetify(addr, Object.keys(storageKeys).sort());\n    });\n    result.sort((a, b) => (a.address.localeCompare(b.address)));\n    return result;\n}\nfunction formatAccessList(value) {\n    return accessListify(value).map((set) => [set.address, set.storageKeys]);\n}\nfunction _serializeEip1559(transaction, signature) {\n    // If there is an explicit gasPrice, make sure it matches the\n    // EIP-1559 fees; otherwise they may not understand what they\n    // think they are setting in terms of fee.\n    if (transaction.gasPrice != null) {\n        const gasPrice = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(transaction.gasPrice);\n        const maxFeePerGas = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(transaction.maxFeePerGas || 0);\n        if (!gasPrice.eq(maxFeePerGas)) {\n            logger.throwArgumentError(\"mismatch EIP-1559 gasPrice != maxFeePerGas\", \"tx\", {\n                gasPrice, maxFeePerGas\n            });\n        }\n    }\n    const fields = [\n        formatNumber(transaction.chainId || 0, \"chainId\"),\n        formatNumber(transaction.nonce || 0, \"nonce\"),\n        formatNumber(transaction.maxPriorityFeePerGas || 0, \"maxPriorityFeePerGas\"),\n        formatNumber(transaction.maxFeePerGas || 0, \"maxFeePerGas\"),\n        formatNumber(transaction.gasLimit || 0, \"gasLimit\"),\n        ((transaction.to != null) ? (0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_2__.getAddress)(transaction.to) : \"0x\"),\n        formatNumber(transaction.value || 0, \"value\"),\n        (transaction.data || \"0x\"),\n        (formatAccessList(transaction.accessList || []))\n    ];\n    if (signature) {\n        const sig = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.splitSignature)(signature);\n        fields.push(formatNumber(sig.recoveryParam, \"recoveryParam\"));\n        fields.push((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.stripZeros)(sig.r));\n        fields.push((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.stripZeros)(sig.s));\n    }\n    return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexConcat)([\"0x02\", _ethersproject_rlp__WEBPACK_IMPORTED_MODULE_8__.encode(fields)]);\n}\nfunction _serializeEip2930(transaction, signature) {\n    const fields = [\n        formatNumber(transaction.chainId || 0, \"chainId\"),\n        formatNumber(transaction.nonce || 0, \"nonce\"),\n        formatNumber(transaction.gasPrice || 0, \"gasPrice\"),\n        formatNumber(transaction.gasLimit || 0, \"gasLimit\"),\n        ((transaction.to != null) ? (0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_2__.getAddress)(transaction.to) : \"0x\"),\n        formatNumber(transaction.value || 0, \"value\"),\n        (transaction.data || \"0x\"),\n        (formatAccessList(transaction.accessList || []))\n    ];\n    if (signature) {\n        const sig = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.splitSignature)(signature);\n        fields.push(formatNumber(sig.recoveryParam, \"recoveryParam\"));\n        fields.push((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.stripZeros)(sig.r));\n        fields.push((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.stripZeros)(sig.s));\n    }\n    return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexConcat)([\"0x01\", _ethersproject_rlp__WEBPACK_IMPORTED_MODULE_8__.encode(fields)]);\n}\n// Legacy Transactions and EIP-155\nfunction _serialize(transaction, signature) {\n    (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_9__.checkProperties)(transaction, allowedTransactionKeys);\n    const raw = [];\n    transactionFields.forEach(function (fieldInfo) {\n        let value = transaction[fieldInfo.name] || ([]);\n        const options = {};\n        if (fieldInfo.numeric) {\n            options.hexPad = \"left\";\n        }\n        value = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.arrayify)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexlify)(value, options));\n        // Fixed-width field\n        if (fieldInfo.length && value.length !== fieldInfo.length && value.length > 0) {\n            logger.throwArgumentError(\"invalid length for \" + fieldInfo.name, (\"transaction:\" + fieldInfo.name), value);\n        }\n        // Variable-width (with a maximum)\n        if (fieldInfo.maxLength) {\n            value = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.stripZeros)(value);\n            if (value.length > fieldInfo.maxLength) {\n                logger.throwArgumentError(\"invalid length for \" + fieldInfo.name, (\"transaction:\" + fieldInfo.name), value);\n            }\n        }\n        raw.push((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexlify)(value));\n    });\n    let chainId = 0;\n    if (transaction.chainId != null) {\n        // A chainId was provided; if non-zero we'll use EIP-155\n        chainId = transaction.chainId;\n        if (typeof (chainId) !== \"number\") {\n            logger.throwArgumentError(\"invalid transaction.chainId\", \"transaction\", transaction);\n        }\n    }\n    else if (signature && !(0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.isBytesLike)(signature) && signature.v > 28) {\n        // No chainId provided, but the signature is signing with EIP-155; derive chainId\n        chainId = Math.floor((signature.v - 35) / 2);\n    }\n    // We have an EIP-155 transaction (chainId was specified and non-zero)\n    if (chainId !== 0) {\n        raw.push((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexlify)(chainId)); // @TODO: hexValue?\n        raw.push(\"0x\");\n        raw.push(\"0x\");\n    }\n    // Requesting an unsigned transaction\n    if (!signature) {\n        return _ethersproject_rlp__WEBPACK_IMPORTED_MODULE_8__.encode(raw);\n    }\n    // The splitSignature will ensure the transaction has a recoveryParam in the\n    // case that the signTransaction function only adds a v.\n    const sig = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.splitSignature)(signature);\n    // We pushed a chainId and null r, s on for hashing only; remove those\n    let v = 27 + sig.recoveryParam;\n    if (chainId !== 0) {\n        raw.pop();\n        raw.pop();\n        raw.pop();\n        v += chainId * 2 + 8;\n        // If an EIP-155 v (directly or indirectly; maybe _vs) was provided, check it!\n        if (sig.v > 28 && sig.v !== v) {\n            logger.throwArgumentError(\"transaction.chainId/signature.v mismatch\", \"signature\", signature);\n        }\n    }\n    else if (sig.v !== v) {\n        logger.throwArgumentError(\"transaction.chainId/signature.v mismatch\", \"signature\", signature);\n    }\n    raw.push((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexlify)(v));\n    raw.push((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.stripZeros)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.arrayify)(sig.r)));\n    raw.push((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.stripZeros)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.arrayify)(sig.s)));\n    return _ethersproject_rlp__WEBPACK_IMPORTED_MODULE_8__.encode(raw);\n}\nfunction serialize(transaction, signature) {\n    // Legacy and EIP-155 Transactions\n    if (transaction.type == null || transaction.type === 0) {\n        if (transaction.accessList != null) {\n            logger.throwArgumentError(\"untyped transactions do not support accessList; include type: 1\", \"transaction\", transaction);\n        }\n        return _serialize(transaction, signature);\n    }\n    // Typed Transactions (EIP-2718)\n    switch (transaction.type) {\n        case 1:\n            return _serializeEip2930(transaction, signature);\n        case 2:\n            return _serializeEip1559(transaction, signature);\n        default:\n            break;\n    }\n    return logger.throwError(`unsupported transaction type: ${transaction.type}`, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: \"serializeTransaction\",\n        transactionType: transaction.type\n    });\n}\nfunction _parseEipSignature(tx, fields, serialize) {\n    try {\n        const recid = handleNumber(fields[0]).toNumber();\n        if (recid !== 0 && recid !== 1) {\n            throw new Error(\"bad recid\");\n        }\n        tx.v = recid;\n    }\n    catch (error) {\n        logger.throwArgumentError(\"invalid v for transaction type: 1\", \"v\", fields[0]);\n    }\n    tx.r = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexZeroPad)(fields[1], 32);\n    tx.s = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexZeroPad)(fields[2], 32);\n    try {\n        const digest = (0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_7__.keccak256)(serialize(tx));\n        tx.from = recoverAddress(digest, { r: tx.r, s: tx.s, recoveryParam: tx.v });\n    }\n    catch (error) { }\n}\nfunction _parseEip1559(payload) {\n    const transaction = _ethersproject_rlp__WEBPACK_IMPORTED_MODULE_8__.decode(payload.slice(1));\n    if (transaction.length !== 9 && transaction.length !== 12) {\n        logger.throwArgumentError(\"invalid component count for transaction type: 2\", \"payload\", (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexlify)(payload));\n    }\n    const maxPriorityFeePerGas = handleNumber(transaction[2]);\n    const maxFeePerGas = handleNumber(transaction[3]);\n    const tx = {\n        type: 2,\n        chainId: handleNumber(transaction[0]).toNumber(),\n        nonce: handleNumber(transaction[1]).toNumber(),\n        maxPriorityFeePerGas: maxPriorityFeePerGas,\n        maxFeePerGas: maxFeePerGas,\n        gasPrice: null,\n        gasLimit: handleNumber(transaction[4]),\n        to: handleAddress(transaction[5]),\n        value: handleNumber(transaction[6]),\n        data: transaction[7],\n        accessList: accessListify(transaction[8]),\n    };\n    // Unsigned EIP-1559 Transaction\n    if (transaction.length === 9) {\n        return tx;\n    }\n    tx.hash = (0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_7__.keccak256)(payload);\n    _parseEipSignature(tx, transaction.slice(9), _serializeEip1559);\n    return tx;\n}\nfunction _parseEip2930(payload) {\n    const transaction = _ethersproject_rlp__WEBPACK_IMPORTED_MODULE_8__.decode(payload.slice(1));\n    if (transaction.length !== 8 && transaction.length !== 11) {\n        logger.throwArgumentError(\"invalid component count for transaction type: 1\", \"payload\", (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexlify)(payload));\n    }\n    const tx = {\n        type: 1,\n        chainId: handleNumber(transaction[0]).toNumber(),\n        nonce: handleNumber(transaction[1]).toNumber(),\n        gasPrice: handleNumber(transaction[2]),\n        gasLimit: handleNumber(transaction[3]),\n        to: handleAddress(transaction[4]),\n        value: handleNumber(transaction[5]),\n        data: transaction[6],\n        accessList: accessListify(transaction[7])\n    };\n    // Unsigned EIP-2930 Transaction\n    if (transaction.length === 8) {\n        return tx;\n    }\n    tx.hash = (0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_7__.keccak256)(payload);\n    _parseEipSignature(tx, transaction.slice(8), _serializeEip2930);\n    return tx;\n}\n// Legacy Transactions and EIP-155\nfunction _parse(rawTransaction) {\n    const transaction = _ethersproject_rlp__WEBPACK_IMPORTED_MODULE_8__.decode(rawTransaction);\n    if (transaction.length !== 9 && transaction.length !== 6) {\n        logger.throwArgumentError(\"invalid raw transaction\", \"rawTransaction\", rawTransaction);\n    }\n    const tx = {\n        nonce: handleNumber(transaction[0]).toNumber(),\n        gasPrice: handleNumber(transaction[1]),\n        gasLimit: handleNumber(transaction[2]),\n        to: handleAddress(transaction[3]),\n        value: handleNumber(transaction[4]),\n        data: transaction[5],\n        chainId: 0\n    };\n    // Legacy unsigned transaction\n    if (transaction.length === 6) {\n        return tx;\n    }\n    try {\n        tx.v = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(transaction[6]).toNumber();\n    }\n    catch (error) {\n        // @TODO: What makes snese to do? The v is too big\n        return tx;\n    }\n    tx.r = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexZeroPad)(transaction[7], 32);\n    tx.s = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexZeroPad)(transaction[8], 32);\n    if (_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(tx.r).isZero() && _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(tx.s).isZero()) {\n        // EIP-155 unsigned transaction\n        tx.chainId = tx.v;\n        tx.v = 0;\n    }\n    else {\n        // Signed Transaction\n        tx.chainId = Math.floor((tx.v - 35) / 2);\n        if (tx.chainId < 0) {\n            tx.chainId = 0;\n        }\n        let recoveryParam = tx.v - 27;\n        const raw = transaction.slice(0, 6);\n        if (tx.chainId !== 0) {\n            raw.push((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexlify)(tx.chainId));\n            raw.push(\"0x\");\n            raw.push(\"0x\");\n            recoveryParam -= tx.chainId * 2 + 8;\n        }\n        const digest = (0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_7__.keccak256)(_ethersproject_rlp__WEBPACK_IMPORTED_MODULE_8__.encode(raw));\n        try {\n            tx.from = recoverAddress(digest, { r: (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexlify)(tx.r), s: (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexlify)(tx.s), recoveryParam: recoveryParam });\n        }\n        catch (error) { }\n        tx.hash = (0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_7__.keccak256)(rawTransaction);\n    }\n    tx.type = null;\n    return tx;\n}\nfunction parse(rawTransaction) {\n    const payload = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.arrayify)(rawTransaction);\n    // Legacy and EIP-155 Transactions\n    if (payload[0] > 0x7f) {\n        return _parse(payload);\n    }\n    // Typed Transaction (EIP-2718)\n    switch (payload[0]) {\n        case 1:\n            return _parseEip2930(payload);\n        case 2:\n            return _parseEip1559(payload);\n        default:\n            break;\n    }\n    return logger.throwError(`unsupported transaction type: ${payload[0]}`, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: \"parseTransaction\",\n        transactionType: payload[0]\n    });\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3RyYW5zYWN0aW9ucy9saWIuZXNtL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBYTtBQUN1QztBQUNDO0FBQ2tHO0FBQ3ZHO0FBQ0s7QUFDTztBQUNsQjtBQUNzQztBQUNqQztBQUNWO0FBQ3JDLG1CQUFtQix5REFBTSxDQUFDLDZDQUFPO0FBQzFCO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDRDQUE0QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGtFQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMERBQUk7QUFDbkI7QUFDQSxXQUFXLCtEQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLE1BQU0sNkNBQTZDO0FBQ25ELE1BQU0sZ0RBQWdEO0FBQ3RELE1BQU0sZ0RBQWdEO0FBQ3RELE1BQU0sd0JBQXdCO0FBQzlCLE1BQU0sNkNBQTZDO0FBQ25ELE1BQU0sY0FBYztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1Asc0JBQXNCLDRFQUFnQjtBQUN0QyxXQUFXLGtFQUFVLENBQUMsa0VBQVksQ0FBQyxtRUFBUyxDQUFDLGtFQUFZO0FBQ3pEO0FBQ087QUFDUCwwQkFBMEIsNEVBQWdCLENBQUMsOERBQVE7QUFDbkQ7QUFDQTtBQUNBLG1CQUFtQixnRUFBVSxDQUFDLCtEQUFTO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGtFQUFVO0FBQzNCO0FBQ0EsZ0JBQWdCLG1FQUFhO0FBQzdCLDBGQUEwRixLQUFLLEdBQUcsTUFBTTtBQUN4RztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0hBQWdILE1BQU07QUFDdEg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsSUFBSTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLHlCQUF5QiwrREFBUztBQUNsQyw2QkFBNkIsK0RBQVM7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msa0VBQVU7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvRUFBYztBQUNsQztBQUNBLG9CQUFvQixnRUFBVTtBQUM5QixvQkFBb0IsZ0VBQVU7QUFDOUI7QUFDQSxXQUFXLCtEQUFTLFVBQVUsc0RBQVU7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msa0VBQVU7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvRUFBYztBQUNsQztBQUNBLG9CQUFvQixnRUFBVTtBQUM5QixvQkFBb0IsZ0VBQVU7QUFDOUI7QUFDQSxXQUFXLCtEQUFTLFVBQVUsc0RBQVU7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsSUFBSSwwRUFBZTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw4REFBUSxDQUFDLDZEQUFPO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnRUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw2REFBTztBQUN4QixLQUFLO0FBQ0w7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGlFQUFXO0FBQ3RDLDJFQUEyRTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw2REFBTyxZQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHNEQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixvRUFBYztBQUM5Qiw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSw2REFBTztBQUNwQixhQUFhLGdFQUFVLENBQUMsOERBQVE7QUFDaEMsYUFBYSxnRUFBVSxDQUFDLDhEQUFRO0FBQ2hDLFdBQVcsc0RBQVU7QUFDckI7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLHVGQUF1RjtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsaUJBQWlCLEdBQUcseURBQU07QUFDeEY7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdFQUFVO0FBQ3JCLFdBQVcsZ0VBQVU7QUFDckI7QUFDQSx1QkFBdUIsbUVBQVM7QUFDaEMsMkNBQTJDLHVDQUF1QztBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzREFBVTtBQUNsQztBQUNBLGdHQUFnRyw2REFBTztBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxtRUFBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzREFBVTtBQUNsQztBQUNBLGdHQUFnRyw2REFBTztBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsbUVBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzREFBVTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwrREFBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnRUFBVTtBQUNyQixXQUFXLGdFQUFVO0FBQ3JCLFFBQVEsK0RBQVMsd0JBQXdCLCtEQUFTO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDZEQUFPO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG1FQUFTLENBQUMsc0RBQVU7QUFDM0M7QUFDQSwrQ0FBK0MsR0FBRyw2REFBTyxXQUFXLDZEQUFPLHNDQUFzQztBQUNqSDtBQUNBO0FBQ0Esa0JBQWtCLG1FQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxvQkFBb0IsOERBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsV0FBVyxHQUFHLHlEQUFNO0FBQ2xGO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xlZGdpdHkteWllbGQtZnJvbnRlbmQvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3RyYW5zYWN0aW9ucy9saWIuZXNtL2luZGV4LmpzPzhlZmYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgeyBnZXRBZGRyZXNzIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2FkZHJlc3NcIjtcbmltcG9ydCB7IEJpZ051bWJlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9iaWdudW1iZXJcIjtcbmltcG9ydCB7IGFycmF5aWZ5LCBoZXhDb25jYXQsIGhleERhdGFMZW5ndGgsIGhleERhdGFTbGljZSwgaGV4bGlmeSwgaGV4WmVyb1BhZCwgaXNCeXRlc0xpa2UsIHNwbGl0U2lnbmF0dXJlLCBzdHJpcFplcm9zLCB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9ieXRlc1wiO1xuaW1wb3J0IHsgWmVybyB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9jb25zdGFudHNcIjtcbmltcG9ydCB7IGtlY2NhazI1NiB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9rZWNjYWsyNTZcIjtcbmltcG9ydCB7IGNoZWNrUHJvcGVydGllcyB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9wcm9wZXJ0aWVzXCI7XG5pbXBvcnQgKiBhcyBSTFAgZnJvbSBcIkBldGhlcnNwcm9qZWN0L3JscFwiO1xuaW1wb3J0IHsgY29tcHV0ZVB1YmxpY0tleSwgcmVjb3ZlclB1YmxpY0tleSB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9zaWduaW5nLWtleVwiO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2xvZ2dlclwiO1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gXCIuL192ZXJzaW9uXCI7XG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyKHZlcnNpb24pO1xuZXhwb3J0IHZhciBUcmFuc2FjdGlvblR5cGVzO1xuKGZ1bmN0aW9uIChUcmFuc2FjdGlvblR5cGVzKSB7XG4gICAgVHJhbnNhY3Rpb25UeXBlc1tUcmFuc2FjdGlvblR5cGVzW1wibGVnYWN5XCJdID0gMF0gPSBcImxlZ2FjeVwiO1xuICAgIFRyYW5zYWN0aW9uVHlwZXNbVHJhbnNhY3Rpb25UeXBlc1tcImVpcDI5MzBcIl0gPSAxXSA9IFwiZWlwMjkzMFwiO1xuICAgIFRyYW5zYWN0aW9uVHlwZXNbVHJhbnNhY3Rpb25UeXBlc1tcImVpcDE1NTlcIl0gPSAyXSA9IFwiZWlwMTU1OVwiO1xufSkoVHJhbnNhY3Rpb25UeXBlcyB8fCAoVHJhbnNhY3Rpb25UeXBlcyA9IHt9KSk7XG47XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5mdW5jdGlvbiBoYW5kbGVBZGRyZXNzKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSBcIjB4XCIpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBnZXRBZGRyZXNzKHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGhhbmRsZU51bWJlcih2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gXCIweFwiKSB7XG4gICAgICAgIHJldHVybiBaZXJvO1xuICAgIH1cbiAgICByZXR1cm4gQmlnTnVtYmVyLmZyb20odmFsdWUpO1xufVxuLy8gTGVnYWN5IFRyYW5zYWN0aW9uIEZpZWxkc1xuY29uc3QgdHJhbnNhY3Rpb25GaWVsZHMgPSBbXG4gICAgeyBuYW1lOiBcIm5vbmNlXCIsIG1heExlbmd0aDogMzIsIG51bWVyaWM6IHRydWUgfSxcbiAgICB7IG5hbWU6IFwiZ2FzUHJpY2VcIiwgbWF4TGVuZ3RoOiAzMiwgbnVtZXJpYzogdHJ1ZSB9LFxuICAgIHsgbmFtZTogXCJnYXNMaW1pdFwiLCBtYXhMZW5ndGg6IDMyLCBudW1lcmljOiB0cnVlIH0sXG4gICAgeyBuYW1lOiBcInRvXCIsIGxlbmd0aDogMjAgfSxcbiAgICB7IG5hbWU6IFwidmFsdWVcIiwgbWF4TGVuZ3RoOiAzMiwgbnVtZXJpYzogdHJ1ZSB9LFxuICAgIHsgbmFtZTogXCJkYXRhXCIgfSxcbl07XG5jb25zdCBhbGxvd2VkVHJhbnNhY3Rpb25LZXlzID0ge1xuICAgIGNoYWluSWQ6IHRydWUsIGRhdGE6IHRydWUsIGdhc0xpbWl0OiB0cnVlLCBnYXNQcmljZTogdHJ1ZSwgbm9uY2U6IHRydWUsIHRvOiB0cnVlLCB0eXBlOiB0cnVlLCB2YWx1ZTogdHJ1ZVxufTtcbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlQWRkcmVzcyhrZXkpIHtcbiAgICBjb25zdCBwdWJsaWNLZXkgPSBjb21wdXRlUHVibGljS2V5KGtleSk7XG4gICAgcmV0dXJuIGdldEFkZHJlc3MoaGV4RGF0YVNsaWNlKGtlY2NhazI1NihoZXhEYXRhU2xpY2UocHVibGljS2V5LCAxKSksIDEyKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gcmVjb3ZlckFkZHJlc3MoZGlnZXN0LCBzaWduYXR1cmUpIHtcbiAgICByZXR1cm4gY29tcHV0ZUFkZHJlc3MocmVjb3ZlclB1YmxpY0tleShhcnJheWlmeShkaWdlc3QpLCBzaWduYXR1cmUpKTtcbn1cbmZ1bmN0aW9uIGZvcm1hdE51bWJlcih2YWx1ZSwgbmFtZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHN0cmlwWmVyb3MoQmlnTnVtYmVyLmZyb20odmFsdWUpLnRvSGV4U3RyaW5nKCkpO1xuICAgIGlmIChyZXN1bHQubGVuZ3RoID4gMzIpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgbGVuZ3RoIGZvciBcIiArIG5hbWUsIChcInRyYW5zYWN0aW9uOlwiICsgbmFtZSksIHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGFjY2Vzc1NldGlmeShhZGRyLCBzdG9yYWdlS2V5cykge1xuICAgIHJldHVybiB7XG4gICAgICAgIGFkZHJlc3M6IGdldEFkZHJlc3MoYWRkciksXG4gICAgICAgIHN0b3JhZ2VLZXlzOiAoc3RvcmFnZUtleXMgfHwgW10pLm1hcCgoc3RvcmFnZUtleSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGlmIChoZXhEYXRhTGVuZ3RoKHN0b3JhZ2VLZXkpICE9PSAzMikge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGFjY2VzcyBsaXN0IHN0b3JhZ2VLZXlcIiwgYGFjY2Vzc0xpc3RbJHthZGRyfToke2luZGV4fV1gLCBzdG9yYWdlS2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdG9yYWdlS2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH0pXG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBhY2Nlc3NMaXN0aWZ5KHZhbHVlKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5tYXAoKHNldCwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNldCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2V0Lmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImFjY2VzcyBsaXN0IGV4cGVjdGVkIHRvIGJlIFsgYWRkcmVzcywgc3RvcmFnZUtleXNbXSBdXCIsIGB2YWx1ZVske2luZGV4fV1gLCBzZXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjZXNzU2V0aWZ5KHNldFswXSwgc2V0WzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhY2Nlc3NTZXRpZnkoc2V0LmFkZHJlc3MsIHNldC5zdG9yYWdlS2V5cyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBPYmplY3Qua2V5cyh2YWx1ZSkubWFwKChhZGRyKSA9PiB7XG4gICAgICAgIGNvbnN0IHN0b3JhZ2VLZXlzID0gdmFsdWVbYWRkcl0ucmVkdWNlKChhY2N1bSwgc3RvcmFnZUtleSkgPT4ge1xuICAgICAgICAgICAgYWNjdW1bc3RvcmFnZUtleV0gPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIGFjY3VtO1xuICAgICAgICB9LCB7fSk7XG4gICAgICAgIHJldHVybiBhY2Nlc3NTZXRpZnkoYWRkciwgT2JqZWN0LmtleXMoc3RvcmFnZUtleXMpLnNvcnQoKSk7XG4gICAgfSk7XG4gICAgcmVzdWx0LnNvcnQoKGEsIGIpID0+IChhLmFkZHJlc3MubG9jYWxlQ29tcGFyZShiLmFkZHJlc3MpKSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGZvcm1hdEFjY2Vzc0xpc3QodmFsdWUpIHtcbiAgICByZXR1cm4gYWNjZXNzTGlzdGlmeSh2YWx1ZSkubWFwKChzZXQpID0+IFtzZXQuYWRkcmVzcywgc2V0LnN0b3JhZ2VLZXlzXSk7XG59XG5mdW5jdGlvbiBfc2VyaWFsaXplRWlwMTU1OSh0cmFuc2FjdGlvbiwgc2lnbmF0dXJlKSB7XG4gICAgLy8gSWYgdGhlcmUgaXMgYW4gZXhwbGljaXQgZ2FzUHJpY2UsIG1ha2Ugc3VyZSBpdCBtYXRjaGVzIHRoZVxuICAgIC8vIEVJUC0xNTU5IGZlZXM7IG90aGVyd2lzZSB0aGV5IG1heSBub3QgdW5kZXJzdGFuZCB3aGF0IHRoZXlcbiAgICAvLyB0aGluayB0aGV5IGFyZSBzZXR0aW5nIGluIHRlcm1zIG9mIGZlZS5cbiAgICBpZiAodHJhbnNhY3Rpb24uZ2FzUHJpY2UgIT0gbnVsbCkge1xuICAgICAgICBjb25zdCBnYXNQcmljZSA9IEJpZ051bWJlci5mcm9tKHRyYW5zYWN0aW9uLmdhc1ByaWNlKTtcbiAgICAgICAgY29uc3QgbWF4RmVlUGVyR2FzID0gQmlnTnVtYmVyLmZyb20odHJhbnNhY3Rpb24ubWF4RmVlUGVyR2FzIHx8IDApO1xuICAgICAgICBpZiAoIWdhc1ByaWNlLmVxKG1heEZlZVBlckdhcykpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJtaXNtYXRjaCBFSVAtMTU1OSBnYXNQcmljZSAhPSBtYXhGZWVQZXJHYXNcIiwgXCJ0eFwiLCB7XG4gICAgICAgICAgICAgICAgZ2FzUHJpY2UsIG1heEZlZVBlckdhc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZmllbGRzID0gW1xuICAgICAgICBmb3JtYXROdW1iZXIodHJhbnNhY3Rpb24uY2hhaW5JZCB8fCAwLCBcImNoYWluSWRcIiksXG4gICAgICAgIGZvcm1hdE51bWJlcih0cmFuc2FjdGlvbi5ub25jZSB8fCAwLCBcIm5vbmNlXCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHJhbnNhY3Rpb24ubWF4UHJpb3JpdHlGZWVQZXJHYXMgfHwgMCwgXCJtYXhQcmlvcml0eUZlZVBlckdhc1wiKSxcbiAgICAgICAgZm9ybWF0TnVtYmVyKHRyYW5zYWN0aW9uLm1heEZlZVBlckdhcyB8fCAwLCBcIm1heEZlZVBlckdhc1wiKSxcbiAgICAgICAgZm9ybWF0TnVtYmVyKHRyYW5zYWN0aW9uLmdhc0xpbWl0IHx8IDAsIFwiZ2FzTGltaXRcIiksXG4gICAgICAgICgodHJhbnNhY3Rpb24udG8gIT0gbnVsbCkgPyBnZXRBZGRyZXNzKHRyYW5zYWN0aW9uLnRvKSA6IFwiMHhcIiksXG4gICAgICAgIGZvcm1hdE51bWJlcih0cmFuc2FjdGlvbi52YWx1ZSB8fCAwLCBcInZhbHVlXCIpLFxuICAgICAgICAodHJhbnNhY3Rpb24uZGF0YSB8fCBcIjB4XCIpLFxuICAgICAgICAoZm9ybWF0QWNjZXNzTGlzdCh0cmFuc2FjdGlvbi5hY2Nlc3NMaXN0IHx8IFtdKSlcbiAgICBdO1xuICAgIGlmIChzaWduYXR1cmUpIHtcbiAgICAgICAgY29uc3Qgc2lnID0gc3BsaXRTaWduYXR1cmUoc2lnbmF0dXJlKTtcbiAgICAgICAgZmllbGRzLnB1c2goZm9ybWF0TnVtYmVyKHNpZy5yZWNvdmVyeVBhcmFtLCBcInJlY292ZXJ5UGFyYW1cIikpO1xuICAgICAgICBmaWVsZHMucHVzaChzdHJpcFplcm9zKHNpZy5yKSk7XG4gICAgICAgIGZpZWxkcy5wdXNoKHN0cmlwWmVyb3Moc2lnLnMpKTtcbiAgICB9XG4gICAgcmV0dXJuIGhleENvbmNhdChbXCIweDAyXCIsIFJMUC5lbmNvZGUoZmllbGRzKV0pO1xufVxuZnVuY3Rpb24gX3NlcmlhbGl6ZUVpcDI5MzAodHJhbnNhY3Rpb24sIHNpZ25hdHVyZSkge1xuICAgIGNvbnN0IGZpZWxkcyA9IFtcbiAgICAgICAgZm9ybWF0TnVtYmVyKHRyYW5zYWN0aW9uLmNoYWluSWQgfHwgMCwgXCJjaGFpbklkXCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHJhbnNhY3Rpb24ubm9uY2UgfHwgMCwgXCJub25jZVwiKSxcbiAgICAgICAgZm9ybWF0TnVtYmVyKHRyYW5zYWN0aW9uLmdhc1ByaWNlIHx8IDAsIFwiZ2FzUHJpY2VcIiksXG4gICAgICAgIGZvcm1hdE51bWJlcih0cmFuc2FjdGlvbi5nYXNMaW1pdCB8fCAwLCBcImdhc0xpbWl0XCIpLFxuICAgICAgICAoKHRyYW5zYWN0aW9uLnRvICE9IG51bGwpID8gZ2V0QWRkcmVzcyh0cmFuc2FjdGlvbi50bykgOiBcIjB4XCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHJhbnNhY3Rpb24udmFsdWUgfHwgMCwgXCJ2YWx1ZVwiKSxcbiAgICAgICAgKHRyYW5zYWN0aW9uLmRhdGEgfHwgXCIweFwiKSxcbiAgICAgICAgKGZvcm1hdEFjY2Vzc0xpc3QodHJhbnNhY3Rpb24uYWNjZXNzTGlzdCB8fCBbXSkpXG4gICAgXTtcbiAgICBpZiAoc2lnbmF0dXJlKSB7XG4gICAgICAgIGNvbnN0IHNpZyA9IHNwbGl0U2lnbmF0dXJlKHNpZ25hdHVyZSk7XG4gICAgICAgIGZpZWxkcy5wdXNoKGZvcm1hdE51bWJlcihzaWcucmVjb3ZlcnlQYXJhbSwgXCJyZWNvdmVyeVBhcmFtXCIpKTtcbiAgICAgICAgZmllbGRzLnB1c2goc3RyaXBaZXJvcyhzaWcucikpO1xuICAgICAgICBmaWVsZHMucHVzaChzdHJpcFplcm9zKHNpZy5zKSk7XG4gICAgfVxuICAgIHJldHVybiBoZXhDb25jYXQoW1wiMHgwMVwiLCBSTFAuZW5jb2RlKGZpZWxkcyldKTtcbn1cbi8vIExlZ2FjeSBUcmFuc2FjdGlvbnMgYW5kIEVJUC0xNTVcbmZ1bmN0aW9uIF9zZXJpYWxpemUodHJhbnNhY3Rpb24sIHNpZ25hdHVyZSkge1xuICAgIGNoZWNrUHJvcGVydGllcyh0cmFuc2FjdGlvbiwgYWxsb3dlZFRyYW5zYWN0aW9uS2V5cyk7XG4gICAgY29uc3QgcmF3ID0gW107XG4gICAgdHJhbnNhY3Rpb25GaWVsZHMuZm9yRWFjaChmdW5jdGlvbiAoZmllbGRJbmZvKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IHRyYW5zYWN0aW9uW2ZpZWxkSW5mby5uYW1lXSB8fCAoW10pO1xuICAgICAgICBjb25zdCBvcHRpb25zID0ge307XG4gICAgICAgIGlmIChmaWVsZEluZm8ubnVtZXJpYykge1xuICAgICAgICAgICAgb3B0aW9ucy5oZXhQYWQgPSBcImxlZnRcIjtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZSA9IGFycmF5aWZ5KGhleGxpZnkodmFsdWUsIG9wdGlvbnMpKTtcbiAgICAgICAgLy8gRml4ZWQtd2lkdGggZmllbGRcbiAgICAgICAgaWYgKGZpZWxkSW5mby5sZW5ndGggJiYgdmFsdWUubGVuZ3RoICE9PSBmaWVsZEluZm8ubGVuZ3RoICYmIHZhbHVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGxlbmd0aCBmb3IgXCIgKyBmaWVsZEluZm8ubmFtZSwgKFwidHJhbnNhY3Rpb246XCIgKyBmaWVsZEluZm8ubmFtZSksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBWYXJpYWJsZS13aWR0aCAod2l0aCBhIG1heGltdW0pXG4gICAgICAgIGlmIChmaWVsZEluZm8ubWF4TGVuZ3RoKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHN0cmlwWmVyb3ModmFsdWUpO1xuICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA+IGZpZWxkSW5mby5tYXhMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBsZW5ndGggZm9yIFwiICsgZmllbGRJbmZvLm5hbWUsIChcInRyYW5zYWN0aW9uOlwiICsgZmllbGRJbmZvLm5hbWUpLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmF3LnB1c2goaGV4bGlmeSh2YWx1ZSkpO1xuICAgIH0pO1xuICAgIGxldCBjaGFpbklkID0gMDtcbiAgICBpZiAodHJhbnNhY3Rpb24uY2hhaW5JZCAhPSBudWxsKSB7XG4gICAgICAgIC8vIEEgY2hhaW5JZCB3YXMgcHJvdmlkZWQ7IGlmIG5vbi16ZXJvIHdlJ2xsIHVzZSBFSVAtMTU1XG4gICAgICAgIGNoYWluSWQgPSB0cmFuc2FjdGlvbi5jaGFpbklkO1xuICAgICAgICBpZiAodHlwZW9mIChjaGFpbklkKSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgdHJhbnNhY3Rpb24uY2hhaW5JZFwiLCBcInRyYW5zYWN0aW9uXCIsIHRyYW5zYWN0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChzaWduYXR1cmUgJiYgIWlzQnl0ZXNMaWtlKHNpZ25hdHVyZSkgJiYgc2lnbmF0dXJlLnYgPiAyOCkge1xuICAgICAgICAvLyBObyBjaGFpbklkIHByb3ZpZGVkLCBidXQgdGhlIHNpZ25hdHVyZSBpcyBzaWduaW5nIHdpdGggRUlQLTE1NTsgZGVyaXZlIGNoYWluSWRcbiAgICAgICAgY2hhaW5JZCA9IE1hdGguZmxvb3IoKHNpZ25hdHVyZS52IC0gMzUpIC8gMik7XG4gICAgfVxuICAgIC8vIFdlIGhhdmUgYW4gRUlQLTE1NSB0cmFuc2FjdGlvbiAoY2hhaW5JZCB3YXMgc3BlY2lmaWVkIGFuZCBub24temVybylcbiAgICBpZiAoY2hhaW5JZCAhPT0gMCkge1xuICAgICAgICByYXcucHVzaChoZXhsaWZ5KGNoYWluSWQpKTsgLy8gQFRPRE86IGhleFZhbHVlP1xuICAgICAgICByYXcucHVzaChcIjB4XCIpO1xuICAgICAgICByYXcucHVzaChcIjB4XCIpO1xuICAgIH1cbiAgICAvLyBSZXF1ZXN0aW5nIGFuIHVuc2lnbmVkIHRyYW5zYWN0aW9uXG4gICAgaWYgKCFzaWduYXR1cmUpIHtcbiAgICAgICAgcmV0dXJuIFJMUC5lbmNvZGUocmF3KTtcbiAgICB9XG4gICAgLy8gVGhlIHNwbGl0U2lnbmF0dXJlIHdpbGwgZW5zdXJlIHRoZSB0cmFuc2FjdGlvbiBoYXMgYSByZWNvdmVyeVBhcmFtIGluIHRoZVxuICAgIC8vIGNhc2UgdGhhdCB0aGUgc2lnblRyYW5zYWN0aW9uIGZ1bmN0aW9uIG9ubHkgYWRkcyBhIHYuXG4gICAgY29uc3Qgc2lnID0gc3BsaXRTaWduYXR1cmUoc2lnbmF0dXJlKTtcbiAgICAvLyBXZSBwdXNoZWQgYSBjaGFpbklkIGFuZCBudWxsIHIsIHMgb24gZm9yIGhhc2hpbmcgb25seTsgcmVtb3ZlIHRob3NlXG4gICAgbGV0IHYgPSAyNyArIHNpZy5yZWNvdmVyeVBhcmFtO1xuICAgIGlmIChjaGFpbklkICE9PSAwKSB7XG4gICAgICAgIHJhdy5wb3AoKTtcbiAgICAgICAgcmF3LnBvcCgpO1xuICAgICAgICByYXcucG9wKCk7XG4gICAgICAgIHYgKz0gY2hhaW5JZCAqIDIgKyA4O1xuICAgICAgICAvLyBJZiBhbiBFSVAtMTU1IHYgKGRpcmVjdGx5IG9yIGluZGlyZWN0bHk7IG1heWJlIF92cykgd2FzIHByb3ZpZGVkLCBjaGVjayBpdCFcbiAgICAgICAgaWYgKHNpZy52ID4gMjggJiYgc2lnLnYgIT09IHYpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ0cmFuc2FjdGlvbi5jaGFpbklkL3NpZ25hdHVyZS52IG1pc21hdGNoXCIsIFwic2lnbmF0dXJlXCIsIHNpZ25hdHVyZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoc2lnLnYgIT09IHYpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInRyYW5zYWN0aW9uLmNoYWluSWQvc2lnbmF0dXJlLnYgbWlzbWF0Y2hcIiwgXCJzaWduYXR1cmVcIiwgc2lnbmF0dXJlKTtcbiAgICB9XG4gICAgcmF3LnB1c2goaGV4bGlmeSh2KSk7XG4gICAgcmF3LnB1c2goc3RyaXBaZXJvcyhhcnJheWlmeShzaWcucikpKTtcbiAgICByYXcucHVzaChzdHJpcFplcm9zKGFycmF5aWZ5KHNpZy5zKSkpO1xuICAgIHJldHVybiBSTFAuZW5jb2RlKHJhdyk7XG59XG5leHBvcnQgZnVuY3Rpb24gc2VyaWFsaXplKHRyYW5zYWN0aW9uLCBzaWduYXR1cmUpIHtcbiAgICAvLyBMZWdhY3kgYW5kIEVJUC0xNTUgVHJhbnNhY3Rpb25zXG4gICAgaWYgKHRyYW5zYWN0aW9uLnR5cGUgPT0gbnVsbCB8fCB0cmFuc2FjdGlvbi50eXBlID09PSAwKSB7XG4gICAgICAgIGlmICh0cmFuc2FjdGlvbi5hY2Nlc3NMaXN0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ1bnR5cGVkIHRyYW5zYWN0aW9ucyBkbyBub3Qgc3VwcG9ydCBhY2Nlc3NMaXN0OyBpbmNsdWRlIHR5cGU6IDFcIiwgXCJ0cmFuc2FjdGlvblwiLCB0cmFuc2FjdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9zZXJpYWxpemUodHJhbnNhY3Rpb24sIHNpZ25hdHVyZSk7XG4gICAgfVxuICAgIC8vIFR5cGVkIFRyYW5zYWN0aW9ucyAoRUlQLTI3MTgpXG4gICAgc3dpdGNoICh0cmFuc2FjdGlvbi50eXBlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHJldHVybiBfc2VyaWFsaXplRWlwMjkzMCh0cmFuc2FjdGlvbiwgc2lnbmF0dXJlKTtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgcmV0dXJuIF9zZXJpYWxpemVFaXAxNTU5KHRyYW5zYWN0aW9uLCBzaWduYXR1cmUpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBsb2dnZXIudGhyb3dFcnJvcihgdW5zdXBwb3J0ZWQgdHJhbnNhY3Rpb24gdHlwZTogJHt0cmFuc2FjdGlvbi50eXBlfWAsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgIG9wZXJhdGlvbjogXCJzZXJpYWxpemVUcmFuc2FjdGlvblwiLFxuICAgICAgICB0cmFuc2FjdGlvblR5cGU6IHRyYW5zYWN0aW9uLnR5cGVcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIF9wYXJzZUVpcFNpZ25hdHVyZSh0eCwgZmllbGRzLCBzZXJpYWxpemUpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZWNpZCA9IGhhbmRsZU51bWJlcihmaWVsZHNbMF0pLnRvTnVtYmVyKCk7XG4gICAgICAgIGlmIChyZWNpZCAhPT0gMCAmJiByZWNpZCAhPT0gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYmFkIHJlY2lkXCIpO1xuICAgICAgICB9XG4gICAgICAgIHR4LnYgPSByZWNpZDtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIHYgZm9yIHRyYW5zYWN0aW9uIHR5cGU6IDFcIiwgXCJ2XCIsIGZpZWxkc1swXSk7XG4gICAgfVxuICAgIHR4LnIgPSBoZXhaZXJvUGFkKGZpZWxkc1sxXSwgMzIpO1xuICAgIHR4LnMgPSBoZXhaZXJvUGFkKGZpZWxkc1syXSwgMzIpO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGRpZ2VzdCA9IGtlY2NhazI1NihzZXJpYWxpemUodHgpKTtcbiAgICAgICAgdHguZnJvbSA9IHJlY292ZXJBZGRyZXNzKGRpZ2VzdCwgeyByOiB0eC5yLCBzOiB0eC5zLCByZWNvdmVyeVBhcmFtOiB0eC52IH0pO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgfVxufVxuZnVuY3Rpb24gX3BhcnNlRWlwMTU1OShwYXlsb2FkKSB7XG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSBSTFAuZGVjb2RlKHBheWxvYWQuc2xpY2UoMSkpO1xuICAgIGlmICh0cmFuc2FjdGlvbi5sZW5ndGggIT09IDkgJiYgdHJhbnNhY3Rpb24ubGVuZ3RoICE9PSAxMikge1xuICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBjb21wb25lbnQgY291bnQgZm9yIHRyYW5zYWN0aW9uIHR5cGU6IDJcIiwgXCJwYXlsb2FkXCIsIGhleGxpZnkocGF5bG9hZCkpO1xuICAgIH1cbiAgICBjb25zdCBtYXhQcmlvcml0eUZlZVBlckdhcyA9IGhhbmRsZU51bWJlcih0cmFuc2FjdGlvblsyXSk7XG4gICAgY29uc3QgbWF4RmVlUGVyR2FzID0gaGFuZGxlTnVtYmVyKHRyYW5zYWN0aW9uWzNdKTtcbiAgICBjb25zdCB0eCA9IHtcbiAgICAgICAgdHlwZTogMixcbiAgICAgICAgY2hhaW5JZDogaGFuZGxlTnVtYmVyKHRyYW5zYWN0aW9uWzBdKS50b051bWJlcigpLFxuICAgICAgICBub25jZTogaGFuZGxlTnVtYmVyKHRyYW5zYWN0aW9uWzFdKS50b051bWJlcigpLFxuICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhczogbWF4UHJpb3JpdHlGZWVQZXJHYXMsXG4gICAgICAgIG1heEZlZVBlckdhczogbWF4RmVlUGVyR2FzLFxuICAgICAgICBnYXNQcmljZTogbnVsbCxcbiAgICAgICAgZ2FzTGltaXQ6IGhhbmRsZU51bWJlcih0cmFuc2FjdGlvbls0XSksXG4gICAgICAgIHRvOiBoYW5kbGVBZGRyZXNzKHRyYW5zYWN0aW9uWzVdKSxcbiAgICAgICAgdmFsdWU6IGhhbmRsZU51bWJlcih0cmFuc2FjdGlvbls2XSksXG4gICAgICAgIGRhdGE6IHRyYW5zYWN0aW9uWzddLFxuICAgICAgICBhY2Nlc3NMaXN0OiBhY2Nlc3NMaXN0aWZ5KHRyYW5zYWN0aW9uWzhdKSxcbiAgICB9O1xuICAgIC8vIFVuc2lnbmVkIEVJUC0xNTU5IFRyYW5zYWN0aW9uXG4gICAgaWYgKHRyYW5zYWN0aW9uLmxlbmd0aCA9PT0gOSkge1xuICAgICAgICByZXR1cm4gdHg7XG4gICAgfVxuICAgIHR4Lmhhc2ggPSBrZWNjYWsyNTYocGF5bG9hZCk7XG4gICAgX3BhcnNlRWlwU2lnbmF0dXJlKHR4LCB0cmFuc2FjdGlvbi5zbGljZSg5KSwgX3NlcmlhbGl6ZUVpcDE1NTkpO1xuICAgIHJldHVybiB0eDtcbn1cbmZ1bmN0aW9uIF9wYXJzZUVpcDI5MzAocGF5bG9hZCkge1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gUkxQLmRlY29kZShwYXlsb2FkLnNsaWNlKDEpKTtcbiAgICBpZiAodHJhbnNhY3Rpb24ubGVuZ3RoICE9PSA4ICYmIHRyYW5zYWN0aW9uLmxlbmd0aCAhPT0gMTEpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgY29tcG9uZW50IGNvdW50IGZvciB0cmFuc2FjdGlvbiB0eXBlOiAxXCIsIFwicGF5bG9hZFwiLCBoZXhsaWZ5KHBheWxvYWQpKTtcbiAgICB9XG4gICAgY29uc3QgdHggPSB7XG4gICAgICAgIHR5cGU6IDEsXG4gICAgICAgIGNoYWluSWQ6IGhhbmRsZU51bWJlcih0cmFuc2FjdGlvblswXSkudG9OdW1iZXIoKSxcbiAgICAgICAgbm9uY2U6IGhhbmRsZU51bWJlcih0cmFuc2FjdGlvblsxXSkudG9OdW1iZXIoKSxcbiAgICAgICAgZ2FzUHJpY2U6IGhhbmRsZU51bWJlcih0cmFuc2FjdGlvblsyXSksXG4gICAgICAgIGdhc0xpbWl0OiBoYW5kbGVOdW1iZXIodHJhbnNhY3Rpb25bM10pLFxuICAgICAgICB0bzogaGFuZGxlQWRkcmVzcyh0cmFuc2FjdGlvbls0XSksXG4gICAgICAgIHZhbHVlOiBoYW5kbGVOdW1iZXIodHJhbnNhY3Rpb25bNV0pLFxuICAgICAgICBkYXRhOiB0cmFuc2FjdGlvbls2XSxcbiAgICAgICAgYWNjZXNzTGlzdDogYWNjZXNzTGlzdGlmeSh0cmFuc2FjdGlvbls3XSlcbiAgICB9O1xuICAgIC8vIFVuc2lnbmVkIEVJUC0yOTMwIFRyYW5zYWN0aW9uXG4gICAgaWYgKHRyYW5zYWN0aW9uLmxlbmd0aCA9PT0gOCkge1xuICAgICAgICByZXR1cm4gdHg7XG4gICAgfVxuICAgIHR4Lmhhc2ggPSBrZWNjYWsyNTYocGF5bG9hZCk7XG4gICAgX3BhcnNlRWlwU2lnbmF0dXJlKHR4LCB0cmFuc2FjdGlvbi5zbGljZSg4KSwgX3NlcmlhbGl6ZUVpcDI5MzApO1xuICAgIHJldHVybiB0eDtcbn1cbi8vIExlZ2FjeSBUcmFuc2FjdGlvbnMgYW5kIEVJUC0xNTVcbmZ1bmN0aW9uIF9wYXJzZShyYXdUcmFuc2FjdGlvbikge1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gUkxQLmRlY29kZShyYXdUcmFuc2FjdGlvbik7XG4gICAgaWYgKHRyYW5zYWN0aW9uLmxlbmd0aCAhPT0gOSAmJiB0cmFuc2FjdGlvbi5sZW5ndGggIT09IDYpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgcmF3IHRyYW5zYWN0aW9uXCIsIFwicmF3VHJhbnNhY3Rpb25cIiwgcmF3VHJhbnNhY3Rpb24pO1xuICAgIH1cbiAgICBjb25zdCB0eCA9IHtcbiAgICAgICAgbm9uY2U6IGhhbmRsZU51bWJlcih0cmFuc2FjdGlvblswXSkudG9OdW1iZXIoKSxcbiAgICAgICAgZ2FzUHJpY2U6IGhhbmRsZU51bWJlcih0cmFuc2FjdGlvblsxXSksXG4gICAgICAgIGdhc0xpbWl0OiBoYW5kbGVOdW1iZXIodHJhbnNhY3Rpb25bMl0pLFxuICAgICAgICB0bzogaGFuZGxlQWRkcmVzcyh0cmFuc2FjdGlvblszXSksXG4gICAgICAgIHZhbHVlOiBoYW5kbGVOdW1iZXIodHJhbnNhY3Rpb25bNF0pLFxuICAgICAgICBkYXRhOiB0cmFuc2FjdGlvbls1XSxcbiAgICAgICAgY2hhaW5JZDogMFxuICAgIH07XG4gICAgLy8gTGVnYWN5IHVuc2lnbmVkIHRyYW5zYWN0aW9uXG4gICAgaWYgKHRyYW5zYWN0aW9uLmxlbmd0aCA9PT0gNikge1xuICAgICAgICByZXR1cm4gdHg7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIHR4LnYgPSBCaWdOdW1iZXIuZnJvbSh0cmFuc2FjdGlvbls2XSkudG9OdW1iZXIoKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIC8vIEBUT0RPOiBXaGF0IG1ha2VzIHNuZXNlIHRvIGRvPyBUaGUgdiBpcyB0b28gYmlnXG4gICAgICAgIHJldHVybiB0eDtcbiAgICB9XG4gICAgdHguciA9IGhleFplcm9QYWQodHJhbnNhY3Rpb25bN10sIDMyKTtcbiAgICB0eC5zID0gaGV4WmVyb1BhZCh0cmFuc2FjdGlvbls4XSwgMzIpO1xuICAgIGlmIChCaWdOdW1iZXIuZnJvbSh0eC5yKS5pc1plcm8oKSAmJiBCaWdOdW1iZXIuZnJvbSh0eC5zKS5pc1plcm8oKSkge1xuICAgICAgICAvLyBFSVAtMTU1IHVuc2lnbmVkIHRyYW5zYWN0aW9uXG4gICAgICAgIHR4LmNoYWluSWQgPSB0eC52O1xuICAgICAgICB0eC52ID0gMDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIFNpZ25lZCBUcmFuc2FjdGlvblxuICAgICAgICB0eC5jaGFpbklkID0gTWF0aC5mbG9vcigodHgudiAtIDM1KSAvIDIpO1xuICAgICAgICBpZiAodHguY2hhaW5JZCA8IDApIHtcbiAgICAgICAgICAgIHR4LmNoYWluSWQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZWNvdmVyeVBhcmFtID0gdHgudiAtIDI3O1xuICAgICAgICBjb25zdCByYXcgPSB0cmFuc2FjdGlvbi5zbGljZSgwLCA2KTtcbiAgICAgICAgaWYgKHR4LmNoYWluSWQgIT09IDApIHtcbiAgICAgICAgICAgIHJhdy5wdXNoKGhleGxpZnkodHguY2hhaW5JZCkpO1xuICAgICAgICAgICAgcmF3LnB1c2goXCIweFwiKTtcbiAgICAgICAgICAgIHJhdy5wdXNoKFwiMHhcIik7XG4gICAgICAgICAgICByZWNvdmVyeVBhcmFtIC09IHR4LmNoYWluSWQgKiAyICsgODtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkaWdlc3QgPSBrZWNjYWsyNTYoUkxQLmVuY29kZShyYXcpKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHR4LmZyb20gPSByZWNvdmVyQWRkcmVzcyhkaWdlc3QsIHsgcjogaGV4bGlmeSh0eC5yKSwgczogaGV4bGlmeSh0eC5zKSwgcmVjb3ZlcnlQYXJhbTogcmVjb3ZlcnlQYXJhbSB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICB0eC5oYXNoID0ga2VjY2FrMjU2KHJhd1RyYW5zYWN0aW9uKTtcbiAgICB9XG4gICAgdHgudHlwZSA9IG51bGw7XG4gICAgcmV0dXJuIHR4O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlKHJhd1RyYW5zYWN0aW9uKSB7XG4gICAgY29uc3QgcGF5bG9hZCA9IGFycmF5aWZ5KHJhd1RyYW5zYWN0aW9uKTtcbiAgICAvLyBMZWdhY3kgYW5kIEVJUC0xNTUgVHJhbnNhY3Rpb25zXG4gICAgaWYgKHBheWxvYWRbMF0gPiAweDdmKSB7XG4gICAgICAgIHJldHVybiBfcGFyc2UocGF5bG9hZCk7XG4gICAgfVxuICAgIC8vIFR5cGVkIFRyYW5zYWN0aW9uIChFSVAtMjcxOClcbiAgICBzd2l0Y2ggKHBheWxvYWRbMF0pIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgcmV0dXJuIF9wYXJzZUVpcDI5MzAocGF5bG9hZCk7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHJldHVybiBfcGFyc2VFaXAxNTU5KHBheWxvYWQpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBsb2dnZXIudGhyb3dFcnJvcihgdW5zdXBwb3J0ZWQgdHJhbnNhY3Rpb24gdHlwZTogJHtwYXlsb2FkWzBdfWAsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgIG9wZXJhdGlvbjogXCJwYXJzZVRyYW5zYWN0aW9uXCIsXG4gICAgICAgIHRyYW5zYWN0aW9uVHlwZTogcGF5bG9hZFswXVxuICAgIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ethersproject/transactions/lib.esm/index.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@ethersproject/units/lib.esm/_version.js":
/*!****************************************************************!*\
  !*** ../node_modules/@ethersproject/units/lib.esm/_version.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\nconst version = \"units/5.7.0\";\n//# sourceMappingURL=_version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3VuaXRzL2xpYi5lc20vX3ZlcnNpb24uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFPO0FBQ1AiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sZWRnaXR5LXlpZWxkLWZyb250ZW5kLy4uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC91bml0cy9saWIuZXNtL192ZXJzaW9uLmpzPzJkNjMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IHZlcnNpb24gPSBcInVuaXRzLzUuNy4wXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdmVyc2lvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ethersproject/units/lib.esm/_version.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@ethersproject/units/lib.esm/index.js":
/*!*************************************************************!*\
  !*** ../node_modules/@ethersproject/units/lib.esm/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   commify: () => (/* binding */ commify),\n/* harmony export */   formatEther: () => (/* binding */ formatEther),\n/* harmony export */   formatUnits: () => (/* binding */ formatUnits),\n/* harmony export */   parseEther: () => (/* binding */ parseEther),\n/* harmony export */   parseUnits: () => (/* binding */ parseUnits)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/bignumber */ \"(ssr)/../node_modules/@ethersproject/bignumber/lib.esm/fixednumber.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/../node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(ssr)/../node_modules/@ethersproject/units/lib.esm/_version.js\");\n\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\nconst names = [\n    \"wei\",\n    \"kwei\",\n    \"mwei\",\n    \"gwei\",\n    \"szabo\",\n    \"finney\",\n    \"ether\",\n];\n// Some environments have issues with RegEx that contain back-tracking, so we cannot\n// use them.\nfunction commify(value) {\n    const comps = String(value).split(\".\");\n    if (comps.length > 2 || !comps[0].match(/^-?[0-9]*$/) || (comps[1] && !comps[1].match(/^[0-9]*$/)) || value === \".\" || value === \"-.\") {\n        logger.throwArgumentError(\"invalid value\", \"value\", value);\n    }\n    // Make sure we have at least one whole digit (0 if none)\n    let whole = comps[0];\n    let negative = \"\";\n    if (whole.substring(0, 1) === \"-\") {\n        negative = \"-\";\n        whole = whole.substring(1);\n    }\n    // Make sure we have at least 1 whole digit with no leading zeros\n    while (whole.substring(0, 1) === \"0\") {\n        whole = whole.substring(1);\n    }\n    if (whole === \"\") {\n        whole = \"0\";\n    }\n    let suffix = \"\";\n    if (comps.length === 2) {\n        suffix = \".\" + (comps[1] || \"0\");\n    }\n    while (suffix.length > 2 && suffix[suffix.length - 1] === \"0\") {\n        suffix = suffix.substring(0, suffix.length - 1);\n    }\n    const formatted = [];\n    while (whole.length) {\n        if (whole.length <= 3) {\n            formatted.unshift(whole);\n            break;\n        }\n        else {\n            const index = whole.length - 3;\n            formatted.unshift(whole.substring(index));\n            whole = whole.substring(0, index);\n        }\n    }\n    return negative + formatted.join(\",\") + suffix;\n}\nfunction formatUnits(value, unitName) {\n    if (typeof (unitName) === \"string\") {\n        const index = names.indexOf(unitName);\n        if (index !== -1) {\n            unitName = 3 * index;\n        }\n    }\n    return (0,_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_2__.formatFixed)(value, (unitName != null) ? unitName : 18);\n}\nfunction parseUnits(value, unitName) {\n    if (typeof (value) !== \"string\") {\n        logger.throwArgumentError(\"value must be a string\", \"value\", value);\n    }\n    if (typeof (unitName) === \"string\") {\n        const index = names.indexOf(unitName);\n        if (index !== -1) {\n            unitName = 3 * index;\n        }\n    }\n    return (0,_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_2__.parseFixed)(value, (unitName != null) ? unitName : 18);\n}\nfunction formatEther(wei) {\n    return formatUnits(wei, 18);\n}\nfunction parseEther(ether) {\n    return parseUnits(ether, 18);\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3VuaXRzL2xpYi5lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBYTtBQUNzRDtBQUNwQjtBQUNWO0FBQ3JDLG1CQUFtQix5REFBTSxDQUFDLDZDQUFPO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxxRUFBVztBQUN0QjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxvRUFBVTtBQUNyQjtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGVkZ2l0eS15aWVsZC1mcm9udGVuZC8uLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvdW5pdHMvbGliLmVzbS9pbmRleC5qcz9hNjM0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuaW1wb3J0IHsgZm9ybWF0Rml4ZWQsIHBhcnNlRml4ZWQgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYmlnbnVtYmVyXCI7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvbG9nZ2VyXCI7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4vX3ZlcnNpb25cIjtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIodmVyc2lvbik7XG5jb25zdCBuYW1lcyA9IFtcbiAgICBcIndlaVwiLFxuICAgIFwia3dlaVwiLFxuICAgIFwibXdlaVwiLFxuICAgIFwiZ3dlaVwiLFxuICAgIFwic3phYm9cIixcbiAgICBcImZpbm5leVwiLFxuICAgIFwiZXRoZXJcIixcbl07XG4vLyBTb21lIGVudmlyb25tZW50cyBoYXZlIGlzc3VlcyB3aXRoIFJlZ0V4IHRoYXQgY29udGFpbiBiYWNrLXRyYWNraW5nLCBzbyB3ZSBjYW5ub3Rcbi8vIHVzZSB0aGVtLlxuZXhwb3J0IGZ1bmN0aW9uIGNvbW1pZnkodmFsdWUpIHtcbiAgICBjb25zdCBjb21wcyA9IFN0cmluZyh2YWx1ZSkuc3BsaXQoXCIuXCIpO1xuICAgIGlmIChjb21wcy5sZW5ndGggPiAyIHx8ICFjb21wc1swXS5tYXRjaCgvXi0/WzAtOV0qJC8pIHx8IChjb21wc1sxXSAmJiAhY29tcHNbMV0ubWF0Y2goL15bMC05XSokLykpIHx8IHZhbHVlID09PSBcIi5cIiB8fCB2YWx1ZSA9PT0gXCItLlwiKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIHZhbHVlXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgIH1cbiAgICAvLyBNYWtlIHN1cmUgd2UgaGF2ZSBhdCBsZWFzdCBvbmUgd2hvbGUgZGlnaXQgKDAgaWYgbm9uZSlcbiAgICBsZXQgd2hvbGUgPSBjb21wc1swXTtcbiAgICBsZXQgbmVnYXRpdmUgPSBcIlwiO1xuICAgIGlmICh3aG9sZS5zdWJzdHJpbmcoMCwgMSkgPT09IFwiLVwiKSB7XG4gICAgICAgIG5lZ2F0aXZlID0gXCItXCI7XG4gICAgICAgIHdob2xlID0gd2hvbGUuc3Vic3RyaW5nKDEpO1xuICAgIH1cbiAgICAvLyBNYWtlIHN1cmUgd2UgaGF2ZSBhdCBsZWFzdCAxIHdob2xlIGRpZ2l0IHdpdGggbm8gbGVhZGluZyB6ZXJvc1xuICAgIHdoaWxlICh3aG9sZS5zdWJzdHJpbmcoMCwgMSkgPT09IFwiMFwiKSB7XG4gICAgICAgIHdob2xlID0gd2hvbGUuc3Vic3RyaW5nKDEpO1xuICAgIH1cbiAgICBpZiAod2hvbGUgPT09IFwiXCIpIHtcbiAgICAgICAgd2hvbGUgPSBcIjBcIjtcbiAgICB9XG4gICAgbGV0IHN1ZmZpeCA9IFwiXCI7XG4gICAgaWYgKGNvbXBzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICBzdWZmaXggPSBcIi5cIiArIChjb21wc1sxXSB8fCBcIjBcIik7XG4gICAgfVxuICAgIHdoaWxlIChzdWZmaXgubGVuZ3RoID4gMiAmJiBzdWZmaXhbc3VmZml4Lmxlbmd0aCAtIDFdID09PSBcIjBcIikge1xuICAgICAgICBzdWZmaXggPSBzdWZmaXguc3Vic3RyaW5nKDAsIHN1ZmZpeC5sZW5ndGggLSAxKTtcbiAgICB9XG4gICAgY29uc3QgZm9ybWF0dGVkID0gW107XG4gICAgd2hpbGUgKHdob2xlLmxlbmd0aCkge1xuICAgICAgICBpZiAod2hvbGUubGVuZ3RoIDw9IDMpIHtcbiAgICAgICAgICAgIGZvcm1hdHRlZC51bnNoaWZ0KHdob2xlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSB3aG9sZS5sZW5ndGggLSAzO1xuICAgICAgICAgICAgZm9ybWF0dGVkLnVuc2hpZnQod2hvbGUuc3Vic3RyaW5nKGluZGV4KSk7XG4gICAgICAgICAgICB3aG9sZSA9IHdob2xlLnN1YnN0cmluZygwLCBpbmRleCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5lZ2F0aXZlICsgZm9ybWF0dGVkLmpvaW4oXCIsXCIpICsgc3VmZml4O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdFVuaXRzKHZhbHVlLCB1bml0TmFtZSkge1xuICAgIGlmICh0eXBlb2YgKHVuaXROYW1lKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBjb25zdCBpbmRleCA9IG5hbWVzLmluZGV4T2YodW5pdE5hbWUpO1xuICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICB1bml0TmFtZSA9IDMgKiBpbmRleDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZm9ybWF0Rml4ZWQodmFsdWUsICh1bml0TmFtZSAhPSBudWxsKSA/IHVuaXROYW1lIDogMTgpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlVW5pdHModmFsdWUsIHVuaXROYW1lKSB7XG4gICAgaWYgKHR5cGVvZiAodmFsdWUpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ2YWx1ZSBtdXN0IGJlIGEgc3RyaW5nXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mICh1bml0TmFtZSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBuYW1lcy5pbmRleE9mKHVuaXROYW1lKTtcbiAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgdW5pdE5hbWUgPSAzICogaW5kZXg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlRml4ZWQodmFsdWUsICh1bml0TmFtZSAhPSBudWxsKSA/IHVuaXROYW1lIDogMTgpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdEV0aGVyKHdlaSkge1xuICAgIHJldHVybiBmb3JtYXRVbml0cyh3ZWksIDE4KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUV0aGVyKGV0aGVyKSB7XG4gICAgcmV0dXJuIHBhcnNlVW5pdHMoZXRoZXIsIDE4KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ethersproject/units/lib.esm/index.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@ethersproject/web/lib.esm/_version.js":
/*!**************************************************************!*\
  !*** ../node_modules/@ethersproject/web/lib.esm/_version.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\nconst version = \"web/5.7.1\";\n//# sourceMappingURL=_version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3dlYi9saWIuZXNtL192ZXJzaW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBTztBQUNQIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGVkZ2l0eS15aWVsZC1mcm9udGVuZC8uLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3Qvd2ViL2xpYi5lc20vX3ZlcnNpb24uanM/ODg3YSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgdmVyc2lvbiA9IFwid2ViLzUuNy4xXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdmVyc2lvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ethersproject/web/lib.esm/_version.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@ethersproject/web/lib.esm/geturl.js":
/*!************************************************************!*\
  !*** ../node_modules/@ethersproject/web/lib.esm/geturl.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getUrl: () => (/* binding */ getUrl)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/../node_modules/@ethersproject/bytes/lib.esm/index.js\");\n\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\nfunction getUrl(href, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (options == null) {\n            options = {};\n        }\n        const request = {\n            method: (options.method || \"GET\"),\n            headers: (options.headers || {}),\n            body: (options.body || undefined),\n        };\n        if (options.skipFetchSetup !== true) {\n            request.mode = \"cors\"; // no-cors, cors, *same-origin\n            request.cache = \"no-cache\"; // *default, no-cache, reload, force-cache, only-if-cached\n            request.credentials = \"same-origin\"; // include, *same-origin, omit\n            request.redirect = \"follow\"; // manual, *follow, error\n            request.referrer = \"client\"; // no-referrer, *client\n        }\n        ;\n        if (options.fetchOptions != null) {\n            const opts = options.fetchOptions;\n            if (opts.mode) {\n                request.mode = (opts.mode);\n            }\n            if (opts.cache) {\n                request.cache = (opts.cache);\n            }\n            if (opts.credentials) {\n                request.credentials = (opts.credentials);\n            }\n            if (opts.redirect) {\n                request.redirect = (opts.redirect);\n            }\n            if (opts.referrer) {\n                request.referrer = opts.referrer;\n            }\n        }\n        const response = yield fetch(href, request);\n        const body = yield response.arrayBuffer();\n        const headers = {};\n        if (response.headers.forEach) {\n            response.headers.forEach((value, key) => {\n                headers[key.toLowerCase()] = value;\n            });\n        }\n        else {\n            ((response.headers).keys)().forEach((key) => {\n                headers[key.toLowerCase()] = response.headers.get(key);\n            });\n        }\n        return {\n            headers: headers,\n            statusCode: response.status,\n            statusMessage: response.statusText,\n            body: (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__.arrayify)(new Uint8Array(body)),\n        };\n    });\n}\n//# sourceMappingURL=geturl.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3dlYi9saWIuZXNtL2dldHVybC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFhO0FBQ2IsaUJBQWlCLFNBQUksSUFBSSxTQUFJO0FBQzdCLDRCQUE0QiwrREFBK0QsaUJBQWlCO0FBQzVHO0FBQ0Esb0NBQW9DLE1BQU0sK0JBQStCLFlBQVk7QUFDckYsbUNBQW1DLE1BQU0sbUNBQW1DLFlBQVk7QUFDeEYsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMO0FBQ2dEO0FBQ3pDO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQyx3Q0FBd0M7QUFDeEMsaURBQWlEO0FBQ2pELHlDQUF5QztBQUN6Qyx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDhEQUFRO0FBQzFCO0FBQ0EsS0FBSztBQUNMO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sZWRnaXR5LXlpZWxkLWZyb250ZW5kLy4uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC93ZWIvbGliLmVzbS9nZXR1cmwuanM/ZGJmYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuaW1wb3J0IHsgYXJyYXlpZnkgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYnl0ZXNcIjtcbmV4cG9ydCBmdW5jdGlvbiBnZXRVcmwoaHJlZiwgb3B0aW9ucykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09IG51bGwpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXF1ZXN0ID0ge1xuICAgICAgICAgICAgbWV0aG9kOiAob3B0aW9ucy5tZXRob2QgfHwgXCJHRVRcIiksXG4gICAgICAgICAgICBoZWFkZXJzOiAob3B0aW9ucy5oZWFkZXJzIHx8IHt9KSxcbiAgICAgICAgICAgIGJvZHk6IChvcHRpb25zLmJvZHkgfHwgdW5kZWZpbmVkKSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG9wdGlvbnMuc2tpcEZldGNoU2V0dXAgIT09IHRydWUpIHtcbiAgICAgICAgICAgIHJlcXVlc3QubW9kZSA9IFwiY29yc1wiOyAvLyBuby1jb3JzLCBjb3JzLCAqc2FtZS1vcmlnaW5cbiAgICAgICAgICAgIHJlcXVlc3QuY2FjaGUgPSBcIm5vLWNhY2hlXCI7IC8vICpkZWZhdWx0LCBuby1jYWNoZSwgcmVsb2FkLCBmb3JjZS1jYWNoZSwgb25seS1pZi1jYWNoZWRcbiAgICAgICAgICAgIHJlcXVlc3QuY3JlZGVudGlhbHMgPSBcInNhbWUtb3JpZ2luXCI7IC8vIGluY2x1ZGUsICpzYW1lLW9yaWdpbiwgb21pdFxuICAgICAgICAgICAgcmVxdWVzdC5yZWRpcmVjdCA9IFwiZm9sbG93XCI7IC8vIG1hbnVhbCwgKmZvbGxvdywgZXJyb3JcbiAgICAgICAgICAgIHJlcXVlc3QucmVmZXJyZXIgPSBcImNsaWVudFwiOyAvLyBuby1yZWZlcnJlciwgKmNsaWVudFxuICAgICAgICB9XG4gICAgICAgIDtcbiAgICAgICAgaWYgKG9wdGlvbnMuZmV0Y2hPcHRpb25zICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IG9wdHMgPSBvcHRpb25zLmZldGNoT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChvcHRzLm1vZGUpIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0Lm1vZGUgPSAob3B0cy5tb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRzLmNhY2hlKSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5jYWNoZSA9IChvcHRzLmNhY2hlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRzLmNyZWRlbnRpYWxzKSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5jcmVkZW50aWFscyA9IChvcHRzLmNyZWRlbnRpYWxzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRzLnJlZGlyZWN0KSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5yZWRpcmVjdCA9IChvcHRzLnJlZGlyZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRzLnJlZmVycmVyKSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5yZWZlcnJlciA9IG9wdHMucmVmZXJyZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCBmZXRjaChocmVmLCByZXF1ZXN0KTtcbiAgICAgICAgY29uc3QgYm9keSA9IHlpZWxkIHJlc3BvbnNlLmFycmF5QnVmZmVyKCk7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB7fTtcbiAgICAgICAgaWYgKHJlc3BvbnNlLmhlYWRlcnMuZm9yRWFjaCkge1xuICAgICAgICAgICAgcmVzcG9uc2UuaGVhZGVycy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgaGVhZGVyc1trZXkudG9Mb3dlckNhc2UoKV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgKChyZXNwb25zZS5oZWFkZXJzKS5rZXlzKSgpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIGhlYWRlcnNba2V5LnRvTG93ZXJDYXNlKCldID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoa2V5KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJzLFxuICAgICAgICAgICAgc3RhdHVzQ29kZTogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICAgICAgc3RhdHVzTWVzc2FnZTogcmVzcG9uc2Uuc3RhdHVzVGV4dCxcbiAgICAgICAgICAgIGJvZHk6IGFycmF5aWZ5KG5ldyBVaW50OEFycmF5KGJvZHkpKSxcbiAgICAgICAgfTtcbiAgICB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldHVybC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ethersproject/web/lib.esm/geturl.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@ethersproject/web/lib.esm/index.js":
/*!***********************************************************!*\
  !*** ../node_modules/@ethersproject/web/lib.esm/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _fetchData: () => (/* binding */ _fetchData),\n/* harmony export */   fetchJson: () => (/* binding */ fetchJson),\n/* harmony export */   poll: () => (/* binding */ poll)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_base64__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethersproject/base64 */ \"(ssr)/../node_modules/@ethersproject/base64/lib.esm/base64.js\");\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/../node_modules/@ethersproject/bytes/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/../node_modules/@ethersproject/properties/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_strings__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/strings */ \"(ssr)/../node_modules/@ethersproject/strings/lib.esm/utf8.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/../node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(ssr)/../node_modules/@ethersproject/web/lib.esm/_version.js\");\n/* harmony import */ var _geturl__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./geturl */ \"(ssr)/../node_modules/@ethersproject/web/lib.esm/geturl.js\");\n\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\n\nfunction staller(duration) {\n    return new Promise((resolve) => {\n        setTimeout(resolve, duration);\n    });\n}\nfunction bodyify(value, type) {\n    if (value == null) {\n        return null;\n    }\n    if (typeof (value) === \"string\") {\n        return value;\n    }\n    if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.isBytesLike)(value)) {\n        if (type && (type.split(\"/\")[0] === \"text\" || type.split(\";\")[0].trim() === \"application/json\")) {\n            try {\n                return (0,_ethersproject_strings__WEBPACK_IMPORTED_MODULE_3__.toUtf8String)(value);\n            }\n            catch (error) { }\n            ;\n        }\n        return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.hexlify)(value);\n    }\n    return value;\n}\nfunction unpercent(value) {\n    return (0,_ethersproject_strings__WEBPACK_IMPORTED_MODULE_3__.toUtf8Bytes)(value.replace(/%([0-9a-f][0-9a-f])/gi, (all, code) => {\n        return String.fromCharCode(parseInt(code, 16));\n    }));\n}\n// This API is still a work in progress; the future changes will likely be:\n// - ConnectionInfo => FetchDataRequest<T = any>\n// - FetchDataRequest.body? = string | Uint8Array | { contentType: string, data: string | Uint8Array }\n//   - If string => text/plain, Uint8Array => application/octet-stream (if content-type unspecified)\n// - FetchDataRequest.processFunc = (body: Uint8Array, response: FetchDataResponse) => T\n// For this reason, it should be considered internal until the API is finalized\nfunction _fetchData(connection, body, processFunc) {\n    // How many times to retry in the event of a throttle\n    const attemptLimit = (typeof (connection) === \"object\" && connection.throttleLimit != null) ? connection.throttleLimit : 12;\n    logger.assertArgument((attemptLimit > 0 && (attemptLimit % 1) === 0), \"invalid connection throttle limit\", \"connection.throttleLimit\", attemptLimit);\n    const throttleCallback = ((typeof (connection) === \"object\") ? connection.throttleCallback : null);\n    const throttleSlotInterval = ((typeof (connection) === \"object\" && typeof (connection.throttleSlotInterval) === \"number\") ? connection.throttleSlotInterval : 100);\n    logger.assertArgument((throttleSlotInterval > 0 && (throttleSlotInterval % 1) === 0), \"invalid connection throttle slot interval\", \"connection.throttleSlotInterval\", throttleSlotInterval);\n    const errorPassThrough = ((typeof (connection) === \"object\") ? !!(connection.errorPassThrough) : false);\n    const headers = {};\n    let url = null;\n    // @TODO: Allow ConnectionInfo to override some of these values\n    const options = {\n        method: \"GET\",\n    };\n    let allow304 = false;\n    let timeout = 2 * 60 * 1000;\n    if (typeof (connection) === \"string\") {\n        url = connection;\n    }\n    else if (typeof (connection) === \"object\") {\n        if (connection == null || connection.url == null) {\n            logger.throwArgumentError(\"missing URL\", \"connection.url\", connection);\n        }\n        url = connection.url;\n        if (typeof (connection.timeout) === \"number\" && connection.timeout > 0) {\n            timeout = connection.timeout;\n        }\n        if (connection.headers) {\n            for (const key in connection.headers) {\n                headers[key.toLowerCase()] = { key: key, value: String(connection.headers[key]) };\n                if ([\"if-none-match\", \"if-modified-since\"].indexOf(key.toLowerCase()) >= 0) {\n                    allow304 = true;\n                }\n            }\n        }\n        options.allowGzip = !!connection.allowGzip;\n        if (connection.user != null && connection.password != null) {\n            if (url.substring(0, 6) !== \"https:\" && connection.allowInsecureAuthentication !== true) {\n                logger.throwError(\"basic authentication requires a secure https url\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.INVALID_ARGUMENT, { argument: \"url\", url: url, user: connection.user, password: \"[REDACTED]\" });\n            }\n            const authorization = connection.user + \":\" + connection.password;\n            headers[\"authorization\"] = {\n                key: \"Authorization\",\n                value: \"Basic \" + (0,_ethersproject_base64__WEBPACK_IMPORTED_MODULE_4__.encode)((0,_ethersproject_strings__WEBPACK_IMPORTED_MODULE_3__.toUtf8Bytes)(authorization))\n            };\n        }\n        if (connection.skipFetchSetup != null) {\n            options.skipFetchSetup = !!connection.skipFetchSetup;\n        }\n        if (connection.fetchOptions != null) {\n            options.fetchOptions = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.shallowCopy)(connection.fetchOptions);\n        }\n    }\n    const reData = new RegExp(\"^data:([^;:]*)?(;base64)?,(.*)$\", \"i\");\n    const dataMatch = ((url) ? url.match(reData) : null);\n    if (dataMatch) {\n        try {\n            const response = {\n                statusCode: 200,\n                statusMessage: \"OK\",\n                headers: { \"content-type\": (dataMatch[1] || \"text/plain\") },\n                body: (dataMatch[2] ? (0,_ethersproject_base64__WEBPACK_IMPORTED_MODULE_4__.decode)(dataMatch[3]) : unpercent(dataMatch[3]))\n            };\n            let result = response.body;\n            if (processFunc) {\n                result = processFunc(response.body, response);\n            }\n            return Promise.resolve(result);\n        }\n        catch (error) {\n            logger.throwError(\"processing response error\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.SERVER_ERROR, {\n                body: bodyify(dataMatch[1], dataMatch[2]),\n                error: error,\n                requestBody: null,\n                requestMethod: \"GET\",\n                url: url\n            });\n        }\n    }\n    if (body) {\n        options.method = \"POST\";\n        options.body = body;\n        if (headers[\"content-type\"] == null) {\n            headers[\"content-type\"] = { key: \"Content-Type\", value: \"application/octet-stream\" };\n        }\n        if (headers[\"content-length\"] == null) {\n            headers[\"content-length\"] = { key: \"Content-Length\", value: String(body.length) };\n        }\n    }\n    const flatHeaders = {};\n    Object.keys(headers).forEach((key) => {\n        const header = headers[key];\n        flatHeaders[header.key] = header.value;\n    });\n    options.headers = flatHeaders;\n    const runningTimeout = (function () {\n        let timer = null;\n        const promise = new Promise(function (resolve, reject) {\n            if (timeout) {\n                timer = setTimeout(() => {\n                    if (timer == null) {\n                        return;\n                    }\n                    timer = null;\n                    reject(logger.makeError(\"timeout\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.TIMEOUT, {\n                        requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n                        requestMethod: options.method,\n                        timeout: timeout,\n                        url: url\n                    }));\n                }, timeout);\n            }\n        });\n        const cancel = function () {\n            if (timer == null) {\n                return;\n            }\n            clearTimeout(timer);\n            timer = null;\n        };\n        return { promise, cancel };\n    })();\n    const runningFetch = (function () {\n        return __awaiter(this, void 0, void 0, function* () {\n            for (let attempt = 0; attempt < attemptLimit; attempt++) {\n                let response = null;\n                try {\n                    response = yield (0,_geturl__WEBPACK_IMPORTED_MODULE_6__.getUrl)(url, options);\n                    if (attempt < attemptLimit) {\n                        if (response.statusCode === 301 || response.statusCode === 302) {\n                            // Redirection; for now we only support absolute locataions\n                            const location = response.headers.location || \"\";\n                            if (options.method === \"GET\" && location.match(/^https:/)) {\n                                url = response.headers.location;\n                                continue;\n                            }\n                        }\n                        else if (response.statusCode === 429) {\n                            // Exponential back-off throttling\n                            let tryAgain = true;\n                            if (throttleCallback) {\n                                tryAgain = yield throttleCallback(attempt, url);\n                            }\n                            if (tryAgain) {\n                                let stall = 0;\n                                const retryAfter = response.headers[\"retry-after\"];\n                                if (typeof (retryAfter) === \"string\" && retryAfter.match(/^[1-9][0-9]*$/)) {\n                                    stall = parseInt(retryAfter) * 1000;\n                                }\n                                else {\n                                    stall = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));\n                                }\n                                //console.log(\"Stalling 429\");\n                                yield staller(stall);\n                                continue;\n                            }\n                        }\n                    }\n                }\n                catch (error) {\n                    response = error.response;\n                    if (response == null) {\n                        runningTimeout.cancel();\n                        logger.throwError(\"missing response\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.SERVER_ERROR, {\n                            requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n                            requestMethod: options.method,\n                            serverError: error,\n                            url: url\n                        });\n                    }\n                }\n                let body = response.body;\n                if (allow304 && response.statusCode === 304) {\n                    body = null;\n                }\n                else if (!errorPassThrough && (response.statusCode < 200 || response.statusCode >= 300)) {\n                    runningTimeout.cancel();\n                    logger.throwError(\"bad response\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.SERVER_ERROR, {\n                        status: response.statusCode,\n                        headers: response.headers,\n                        body: bodyify(body, ((response.headers) ? response.headers[\"content-type\"] : null)),\n                        requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n                        requestMethod: options.method,\n                        url: url\n                    });\n                }\n                if (processFunc) {\n                    try {\n                        const result = yield processFunc(body, response);\n                        runningTimeout.cancel();\n                        return result;\n                    }\n                    catch (error) {\n                        // Allow the processFunc to trigger a throttle\n                        if (error.throttleRetry && attempt < attemptLimit) {\n                            let tryAgain = true;\n                            if (throttleCallback) {\n                                tryAgain = yield throttleCallback(attempt, url);\n                            }\n                            if (tryAgain) {\n                                const timeout = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));\n                                //console.log(\"Stalling callback\");\n                                yield staller(timeout);\n                                continue;\n                            }\n                        }\n                        runningTimeout.cancel();\n                        logger.throwError(\"processing response error\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.SERVER_ERROR, {\n                            body: bodyify(body, ((response.headers) ? response.headers[\"content-type\"] : null)),\n                            error: error,\n                            requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n                            requestMethod: options.method,\n                            url: url\n                        });\n                    }\n                }\n                runningTimeout.cancel();\n                // If we had a processFunc, it either returned a T or threw above.\n                // The \"body\" is now a Uint8Array.\n                return body;\n            }\n            return logger.throwError(\"failed response\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.SERVER_ERROR, {\n                requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n                requestMethod: options.method,\n                url: url\n            });\n        });\n    })();\n    return Promise.race([runningTimeout.promise, runningFetch]);\n}\nfunction fetchJson(connection, json, processFunc) {\n    let processJsonFunc = (value, response) => {\n        let result = null;\n        if (value != null) {\n            try {\n                result = JSON.parse((0,_ethersproject_strings__WEBPACK_IMPORTED_MODULE_3__.toUtf8String)(value));\n            }\n            catch (error) {\n                logger.throwError(\"invalid JSON\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.SERVER_ERROR, {\n                    body: value,\n                    error: error\n                });\n            }\n        }\n        if (processFunc) {\n            result = processFunc(result, response);\n        }\n        return result;\n    };\n    // If we have json to send, we must\n    // - add content-type of application/json (unless already overridden)\n    // - convert the json to bytes\n    let body = null;\n    if (json != null) {\n        body = (0,_ethersproject_strings__WEBPACK_IMPORTED_MODULE_3__.toUtf8Bytes)(json);\n        // Create a connection with the content-type set for JSON\n        const updated = (typeof (connection) === \"string\") ? ({ url: connection }) : (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.shallowCopy)(connection);\n        if (updated.headers) {\n            const hasContentType = (Object.keys(updated.headers).filter((k) => (k.toLowerCase() === \"content-type\")).length) !== 0;\n            if (!hasContentType) {\n                updated.headers = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.shallowCopy)(updated.headers);\n                updated.headers[\"content-type\"] = \"application/json\";\n            }\n        }\n        else {\n            updated.headers = { \"content-type\": \"application/json\" };\n        }\n        connection = updated;\n    }\n    return _fetchData(connection, body, processJsonFunc);\n}\nfunction poll(func, options) {\n    if (!options) {\n        options = {};\n    }\n    options = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.shallowCopy)(options);\n    if (options.floor == null) {\n        options.floor = 0;\n    }\n    if (options.ceiling == null) {\n        options.ceiling = 10000;\n    }\n    if (options.interval == null) {\n        options.interval = 250;\n    }\n    return new Promise(function (resolve, reject) {\n        let timer = null;\n        let done = false;\n        // Returns true if cancel was successful. Unsuccessful cancel means we're already done.\n        const cancel = () => {\n            if (done) {\n                return false;\n            }\n            done = true;\n            if (timer) {\n                clearTimeout(timer);\n            }\n            return true;\n        };\n        if (options.timeout) {\n            timer = setTimeout(() => {\n                if (cancel()) {\n                    reject(new Error(\"timeout\"));\n                }\n            }, options.timeout);\n        }\n        const retryLimit = options.retryLimit;\n        let attempt = 0;\n        function check() {\n            return func().then(function (result) {\n                // If we have a result, or are allowed null then we're done\n                if (result !== undefined) {\n                    if (cancel()) {\n                        resolve(result);\n                    }\n                }\n                else if (options.oncePoll) {\n                    options.oncePoll.once(\"poll\", check);\n                }\n                else if (options.onceBlock) {\n                    options.onceBlock.once(\"block\", check);\n                    // Otherwise, exponential back-off (up to 10s) our next request\n                }\n                else if (!done) {\n                    attempt++;\n                    if (attempt > retryLimit) {\n                        if (cancel()) {\n                            reject(new Error(\"retry limit reached\"));\n                        }\n                        return;\n                    }\n                    let timeout = options.interval * parseInt(String(Math.random() * Math.pow(2, attempt)));\n                    if (timeout < options.floor) {\n                        timeout = options.floor;\n                    }\n                    if (timeout > options.ceiling) {\n                        timeout = options.ceiling;\n                    }\n                    setTimeout(check, timeout);\n                }\n                return null;\n            }, function (error) {\n                if (cancel()) {\n                    reject(error);\n                }\n            });\n        }\n        check();\n    });\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3dlYi9saWIuZXNtL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBYTtBQUNiLGlCQUFpQixTQUFJLElBQUksU0FBSTtBQUM3Qiw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUN1RjtBQUMzQjtBQUNKO0FBQ1c7QUFDcEI7QUFDVjtBQUNyQyxtQkFBbUIseURBQU0sQ0FBQyw2Q0FBTztBQUNDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxpRUFBVztBQUNuQixtRUFBbUU7QUFDbkU7QUFDQSx1QkFBdUIsb0VBQVk7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDZEQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtRUFBVztBQUN0QjtBQUNBLEtBQUs7QUFDTDtBQUNBLHlDQUF5QztBQUN6QztBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRkFBc0YseURBQU0sNEJBQTRCLDBFQUEwRTtBQUNsTTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyw2REFBWSxDQUFDLG1FQUFXO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sZWRnaXR5LXlpZWxkLWZyb250ZW5kLy4uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC93ZWIvbGliLmVzbS9pbmRleC5qcz8xYzNhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5pbXBvcnQgeyBkZWNvZGUgYXMgYmFzZTY0RGVjb2RlLCBlbmNvZGUgYXMgYmFzZTY0RW5jb2RlIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2Jhc2U2NFwiO1xuaW1wb3J0IHsgaGV4bGlmeSwgaXNCeXRlc0xpa2UgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYnl0ZXNcIjtcbmltcG9ydCB7IHNoYWxsb3dDb3B5IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3Byb3BlcnRpZXNcIjtcbmltcG9ydCB7IHRvVXRmOEJ5dGVzLCB0b1V0ZjhTdHJpbmcgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3Qvc3RyaW5nc1wiO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2xvZ2dlclwiO1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gXCIuL192ZXJzaW9uXCI7XG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyKHZlcnNpb24pO1xuaW1wb3J0IHsgZ2V0VXJsIH0gZnJvbSBcIi4vZ2V0dXJsXCI7XG5mdW5jdGlvbiBzdGFsbGVyKGR1cmF0aW9uKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIHNldFRpbWVvdXQocmVzb2x2ZSwgZHVyYXRpb24pO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gYm9keWlmeSh2YWx1ZSwgdHlwZSkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBpZiAoaXNCeXRlc0xpa2UodmFsdWUpKSB7XG4gICAgICAgIGlmICh0eXBlICYmICh0eXBlLnNwbGl0KFwiL1wiKVswXSA9PT0gXCJ0ZXh0XCIgfHwgdHlwZS5zcGxpdChcIjtcIilbMF0udHJpbSgpID09PSBcImFwcGxpY2F0aW9uL2pzb25cIikpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvVXRmOFN0cmluZyh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICAgICAgO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoZXhsaWZ5KHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gdW5wZXJjZW50KHZhbHVlKSB7XG4gICAgcmV0dXJuIHRvVXRmOEJ5dGVzKHZhbHVlLnJlcGxhY2UoLyUoWzAtOWEtZl1bMC05YS1mXSkvZ2ksIChhbGwsIGNvZGUpID0+IHtcbiAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQoY29kZSwgMTYpKTtcbiAgICB9KSk7XG59XG4vLyBUaGlzIEFQSSBpcyBzdGlsbCBhIHdvcmsgaW4gcHJvZ3Jlc3M7IHRoZSBmdXR1cmUgY2hhbmdlcyB3aWxsIGxpa2VseSBiZTpcbi8vIC0gQ29ubmVjdGlvbkluZm8gPT4gRmV0Y2hEYXRhUmVxdWVzdDxUID0gYW55PlxuLy8gLSBGZXRjaERhdGFSZXF1ZXN0LmJvZHk/ID0gc3RyaW5nIHwgVWludDhBcnJheSB8IHsgY29udGVudFR5cGU6IHN0cmluZywgZGF0YTogc3RyaW5nIHwgVWludDhBcnJheSB9XG4vLyAgIC0gSWYgc3RyaW5nID0+IHRleHQvcGxhaW4sIFVpbnQ4QXJyYXkgPT4gYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtIChpZiBjb250ZW50LXR5cGUgdW5zcGVjaWZpZWQpXG4vLyAtIEZldGNoRGF0YVJlcXVlc3QucHJvY2Vzc0Z1bmMgPSAoYm9keTogVWludDhBcnJheSwgcmVzcG9uc2U6IEZldGNoRGF0YVJlc3BvbnNlKSA9PiBUXG4vLyBGb3IgdGhpcyByZWFzb24sIGl0IHNob3VsZCBiZSBjb25zaWRlcmVkIGludGVybmFsIHVudGlsIHRoZSBBUEkgaXMgZmluYWxpemVkXG5leHBvcnQgZnVuY3Rpb24gX2ZldGNoRGF0YShjb25uZWN0aW9uLCBib2R5LCBwcm9jZXNzRnVuYykge1xuICAgIC8vIEhvdyBtYW55IHRpbWVzIHRvIHJldHJ5IGluIHRoZSBldmVudCBvZiBhIHRocm90dGxlXG4gICAgY29uc3QgYXR0ZW1wdExpbWl0ID0gKHR5cGVvZiAoY29ubmVjdGlvbikgPT09IFwib2JqZWN0XCIgJiYgY29ubmVjdGlvbi50aHJvdHRsZUxpbWl0ICE9IG51bGwpID8gY29ubmVjdGlvbi50aHJvdHRsZUxpbWl0IDogMTI7XG4gICAgbG9nZ2VyLmFzc2VydEFyZ3VtZW50KChhdHRlbXB0TGltaXQgPiAwICYmIChhdHRlbXB0TGltaXQgJSAxKSA9PT0gMCksIFwiaW52YWxpZCBjb25uZWN0aW9uIHRocm90dGxlIGxpbWl0XCIsIFwiY29ubmVjdGlvbi50aHJvdHRsZUxpbWl0XCIsIGF0dGVtcHRMaW1pdCk7XG4gICAgY29uc3QgdGhyb3R0bGVDYWxsYmFjayA9ICgodHlwZW9mIChjb25uZWN0aW9uKSA9PT0gXCJvYmplY3RcIikgPyBjb25uZWN0aW9uLnRocm90dGxlQ2FsbGJhY2sgOiBudWxsKTtcbiAgICBjb25zdCB0aHJvdHRsZVNsb3RJbnRlcnZhbCA9ICgodHlwZW9mIChjb25uZWN0aW9uKSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgKGNvbm5lY3Rpb24udGhyb3R0bGVTbG90SW50ZXJ2YWwpID09PSBcIm51bWJlclwiKSA/IGNvbm5lY3Rpb24udGhyb3R0bGVTbG90SW50ZXJ2YWwgOiAxMDApO1xuICAgIGxvZ2dlci5hc3NlcnRBcmd1bWVudCgodGhyb3R0bGVTbG90SW50ZXJ2YWwgPiAwICYmICh0aHJvdHRsZVNsb3RJbnRlcnZhbCAlIDEpID09PSAwKSwgXCJpbnZhbGlkIGNvbm5lY3Rpb24gdGhyb3R0bGUgc2xvdCBpbnRlcnZhbFwiLCBcImNvbm5lY3Rpb24udGhyb3R0bGVTbG90SW50ZXJ2YWxcIiwgdGhyb3R0bGVTbG90SW50ZXJ2YWwpO1xuICAgIGNvbnN0IGVycm9yUGFzc1Rocm91Z2ggPSAoKHR5cGVvZiAoY29ubmVjdGlvbikgPT09IFwib2JqZWN0XCIpID8gISEoY29ubmVjdGlvbi5lcnJvclBhc3NUaHJvdWdoKSA6IGZhbHNlKTtcbiAgICBjb25zdCBoZWFkZXJzID0ge307XG4gICAgbGV0IHVybCA9IG51bGw7XG4gICAgLy8gQFRPRE86IEFsbG93IENvbm5lY3Rpb25JbmZvIHRvIG92ZXJyaWRlIHNvbWUgb2YgdGhlc2UgdmFsdWVzXG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgIH07XG4gICAgbGV0IGFsbG93MzA0ID0gZmFsc2U7XG4gICAgbGV0IHRpbWVvdXQgPSAyICogNjAgKiAxMDAwO1xuICAgIGlmICh0eXBlb2YgKGNvbm5lY3Rpb24pID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHVybCA9IGNvbm5lY3Rpb247XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiAoY29ubmVjdGlvbikgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgaWYgKGNvbm5lY3Rpb24gPT0gbnVsbCB8fCBjb25uZWN0aW9uLnVybCA9PSBudWxsKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwibWlzc2luZyBVUkxcIiwgXCJjb25uZWN0aW9uLnVybFwiLCBjb25uZWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICB1cmwgPSBjb25uZWN0aW9uLnVybDtcbiAgICAgICAgaWYgKHR5cGVvZiAoY29ubmVjdGlvbi50aW1lb3V0KSA9PT0gXCJudW1iZXJcIiAmJiBjb25uZWN0aW9uLnRpbWVvdXQgPiAwKSB7XG4gICAgICAgICAgICB0aW1lb3V0ID0gY29ubmVjdGlvbi50aW1lb3V0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25uZWN0aW9uLmhlYWRlcnMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIGNvbm5lY3Rpb24uaGVhZGVycykge1xuICAgICAgICAgICAgICAgIGhlYWRlcnNba2V5LnRvTG93ZXJDYXNlKCldID0geyBrZXk6IGtleSwgdmFsdWU6IFN0cmluZyhjb25uZWN0aW9uLmhlYWRlcnNba2V5XSkgfTtcbiAgICAgICAgICAgICAgICBpZiAoW1wiaWYtbm9uZS1tYXRjaFwiLCBcImlmLW1vZGlmaWVkLXNpbmNlXCJdLmluZGV4T2Yoa2V5LnRvTG93ZXJDYXNlKCkpID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYWxsb3czMDQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBvcHRpb25zLmFsbG93R3ppcCA9ICEhY29ubmVjdGlvbi5hbGxvd0d6aXA7XG4gICAgICAgIGlmIChjb25uZWN0aW9uLnVzZXIgIT0gbnVsbCAmJiBjb25uZWN0aW9uLnBhc3N3b3JkICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh1cmwuc3Vic3RyaW5nKDAsIDYpICE9PSBcImh0dHBzOlwiICYmIGNvbm5lY3Rpb24uYWxsb3dJbnNlY3VyZUF1dGhlbnRpY2F0aW9uICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJiYXNpYyBhdXRoZW50aWNhdGlvbiByZXF1aXJlcyBhIHNlY3VyZSBodHRwcyB1cmxcIiwgTG9nZ2VyLmVycm9ycy5JTlZBTElEX0FSR1VNRU5ULCB7IGFyZ3VtZW50OiBcInVybFwiLCB1cmw6IHVybCwgdXNlcjogY29ubmVjdGlvbi51c2VyLCBwYXNzd29yZDogXCJbUkVEQUNURURdXCIgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhdXRob3JpemF0aW9uID0gY29ubmVjdGlvbi51c2VyICsgXCI6XCIgKyBjb25uZWN0aW9uLnBhc3N3b3JkO1xuICAgICAgICAgICAgaGVhZGVyc1tcImF1dGhvcml6YXRpb25cIl0gPSB7XG4gICAgICAgICAgICAgICAga2V5OiBcIkF1dGhvcml6YXRpb25cIixcbiAgICAgICAgICAgICAgICB2YWx1ZTogXCJCYXNpYyBcIiArIGJhc2U2NEVuY29kZSh0b1V0ZjhCeXRlcyhhdXRob3JpemF0aW9uKSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbm5lY3Rpb24uc2tpcEZldGNoU2V0dXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgb3B0aW9ucy5za2lwRmV0Y2hTZXR1cCA9ICEhY29ubmVjdGlvbi5za2lwRmV0Y2hTZXR1cDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29ubmVjdGlvbi5mZXRjaE9wdGlvbnMgIT0gbnVsbCkge1xuICAgICAgICAgICAgb3B0aW9ucy5mZXRjaE9wdGlvbnMgPSBzaGFsbG93Q29weShjb25uZWN0aW9uLmZldGNoT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcmVEYXRhID0gbmV3IFJlZ0V4cChcIl5kYXRhOihbXjs6XSopPyg7YmFzZTY0KT8sKC4qKSRcIiwgXCJpXCIpO1xuICAgIGNvbnN0IGRhdGFNYXRjaCA9ICgodXJsKSA/IHVybC5tYXRjaChyZURhdGEpIDogbnVsbCk7XG4gICAgaWYgKGRhdGFNYXRjaCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgc3RhdHVzQ29kZTogMjAwLFxuICAgICAgICAgICAgICAgIHN0YXR1c01lc3NhZ2U6IFwiT0tcIixcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7IFwiY29udGVudC10eXBlXCI6IChkYXRhTWF0Y2hbMV0gfHwgXCJ0ZXh0L3BsYWluXCIpIH0sXG4gICAgICAgICAgICAgICAgYm9keTogKGRhdGFNYXRjaFsyXSA/IGJhc2U2NERlY29kZShkYXRhTWF0Y2hbM10pIDogdW5wZXJjZW50KGRhdGFNYXRjaFszXSkpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHJlc3BvbnNlLmJvZHk7XG4gICAgICAgICAgICBpZiAocHJvY2Vzc0Z1bmMpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBwcm9jZXNzRnVuYyhyZXNwb25zZS5ib2R5LCByZXNwb25zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcInByb2Nlc3NpbmcgcmVzcG9uc2UgZXJyb3JcIiwgTG9nZ2VyLmVycm9ycy5TRVJWRVJfRVJST1IsIHtcbiAgICAgICAgICAgICAgICBib2R5OiBib2R5aWZ5KGRhdGFNYXRjaFsxXSwgZGF0YU1hdGNoWzJdKSxcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgICAgICAgICAgcmVxdWVzdEJvZHk6IG51bGwsXG4gICAgICAgICAgICAgICAgcmVxdWVzdE1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgICAgICAgICB1cmw6IHVybFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGJvZHkpIHtcbiAgICAgICAgb3B0aW9ucy5tZXRob2QgPSBcIlBPU1RcIjtcbiAgICAgICAgb3B0aW9ucy5ib2R5ID0gYm9keTtcbiAgICAgICAgaWYgKGhlYWRlcnNbXCJjb250ZW50LXR5cGVcIl0gPT0gbnVsbCkge1xuICAgICAgICAgICAgaGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXSA9IHsga2V5OiBcIkNvbnRlbnQtVHlwZVwiLCB2YWx1ZTogXCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIiB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChoZWFkZXJzW1wiY29udGVudC1sZW5ndGhcIl0gPT0gbnVsbCkge1xuICAgICAgICAgICAgaGVhZGVyc1tcImNvbnRlbnQtbGVuZ3RoXCJdID0geyBrZXk6IFwiQ29udGVudC1MZW5ndGhcIiwgdmFsdWU6IFN0cmluZyhib2R5Lmxlbmd0aCkgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBmbGF0SGVhZGVycyA9IHt9O1xuICAgIE9iamVjdC5rZXlzKGhlYWRlcnMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICBjb25zdCBoZWFkZXIgPSBoZWFkZXJzW2tleV07XG4gICAgICAgIGZsYXRIZWFkZXJzW2hlYWRlci5rZXldID0gaGVhZGVyLnZhbHVlO1xuICAgIH0pO1xuICAgIG9wdGlvbnMuaGVhZGVycyA9IGZsYXRIZWFkZXJzO1xuICAgIGNvbnN0IHJ1bm5pbmdUaW1lb3V0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbGV0IHRpbWVyID0gbnVsbDtcbiAgICAgICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWVyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aW1lciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChsb2dnZXIubWFrZUVycm9yKFwidGltZW91dFwiLCBMb2dnZXIuZXJyb3JzLlRJTUVPVVQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RCb2R5OiBib2R5aWZ5KG9wdGlvbnMuYm9keSwgZmxhdEhlYWRlcnNbXCJjb250ZW50LXR5cGVcIl0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdE1ldGhvZDogb3B0aW9ucy5tZXRob2QsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lb3V0OiB0aW1lb3V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiB1cmxcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgY2FuY2VsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRpbWVyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICAgICAgdGltZXIgPSBudWxsO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4geyBwcm9taXNlLCBjYW5jZWwgfTtcbiAgICB9KSgpO1xuICAgIGNvbnN0IHJ1bm5pbmdGZXRjaCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBhdHRlbXB0ID0gMDsgYXR0ZW1wdCA8IGF0dGVtcHRMaW1pdDsgYXR0ZW1wdCsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJlc3BvbnNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IHlpZWxkIGdldFVybCh1cmwsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXR0ZW1wdCA8IGF0dGVtcHRMaW1pdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IDMwMSB8fCByZXNwb25zZS5zdGF0dXNDb2RlID09PSAzMDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZWRpcmVjdGlvbjsgZm9yIG5vdyB3ZSBvbmx5IHN1cHBvcnQgYWJzb2x1dGUgbG9jYXRhaW9uc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvY2F0aW9uID0gcmVzcG9uc2UuaGVhZGVycy5sb2NhdGlvbiB8fCBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLm1ldGhvZCA9PT0gXCJHRVRcIiAmJiBsb2NhdGlvbi5tYXRjaCgvXmh0dHBzOi8pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9IHJlc3BvbnNlLmhlYWRlcnMubG9jYXRpb247XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IDQyOSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEV4cG9uZW50aWFsIGJhY2stb2ZmIHRocm90dGxpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdHJ5QWdhaW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aHJvdHRsZUNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeUFnYWluID0geWllbGQgdGhyb3R0bGVDYWxsYmFjayhhdHRlbXB0LCB1cmwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHJ5QWdhaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHN0YWxsID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmV0cnlBZnRlciA9IHJlc3BvbnNlLmhlYWRlcnNbXCJyZXRyeS1hZnRlclwiXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAocmV0cnlBZnRlcikgPT09IFwic3RyaW5nXCIgJiYgcmV0cnlBZnRlci5tYXRjaCgvXlsxLTldWzAtOV0qJC8pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFsbCA9IHBhcnNlSW50KHJldHJ5QWZ0ZXIpICogMTAwMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWxsID0gdGhyb3R0bGVTbG90SW50ZXJ2YWwgKiBwYXJzZUludChTdHJpbmcoTWF0aC5yYW5kb20oKSAqIE1hdGgucG93KDIsIGF0dGVtcHQpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIlN0YWxsaW5nIDQyOVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgc3RhbGxlcihzdGFsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBlcnJvci5yZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bm5pbmdUaW1lb3V0LmNhbmNlbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJtaXNzaW5nIHJlc3BvbnNlXCIsIExvZ2dlci5lcnJvcnMuU0VSVkVSX0VSUk9SLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdEJvZHk6IGJvZHlpZnkob3B0aW9ucy5ib2R5LCBmbGF0SGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdE1ldGhvZDogb3B0aW9ucy5tZXRob2QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VydmVyRXJyb3I6IGVycm9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogdXJsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgYm9keSA9IHJlc3BvbnNlLmJvZHk7XG4gICAgICAgICAgICAgICAgaWYgKGFsbG93MzA0ICYmIHJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IDMwNCkge1xuICAgICAgICAgICAgICAgICAgICBib2R5ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIWVycm9yUGFzc1Rocm91Z2ggJiYgKHJlc3BvbnNlLnN0YXR1c0NvZGUgPCAyMDAgfHwgcmVzcG9uc2Uuc3RhdHVzQ29kZSA+PSAzMDApKSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bm5pbmdUaW1lb3V0LmNhbmNlbCgpO1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImJhZCByZXNwb25zZVwiLCBMb2dnZXIuZXJyb3JzLlNFUlZFUl9FUlJPUiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiByZXNwb25zZS5zdGF0dXNDb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogcmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IGJvZHlpZnkoYm9keSwgKChyZXNwb25zZS5oZWFkZXJzKSA/IHJlc3BvbnNlLmhlYWRlcnNbXCJjb250ZW50LXR5cGVcIl0gOiBudWxsKSksXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0Qm9keTogYm9keWlmeShvcHRpb25zLmJvZHksIGZsYXRIZWFkZXJzW1wiY29udGVudC10eXBlXCJdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RNZXRob2Q6IG9wdGlvbnMubWV0aG9kLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiB1cmxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzRnVuYykge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geWllbGQgcHJvY2Vzc0Z1bmMoYm9keSwgcmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcnVubmluZ1RpbWVvdXQuY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWxsb3cgdGhlIHByb2Nlc3NGdW5jIHRvIHRyaWdnZXIgYSB0aHJvdHRsZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yLnRocm90dGxlUmV0cnkgJiYgYXR0ZW1wdCA8IGF0dGVtcHRMaW1pdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0cnlBZ2FpbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRocm90dGxlQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5QWdhaW4gPSB5aWVsZCB0aHJvdHRsZUNhbGxiYWNrKGF0dGVtcHQsIHVybCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0cnlBZ2Fpbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0aW1lb3V0ID0gdGhyb3R0bGVTbG90SW50ZXJ2YWwgKiBwYXJzZUludChTdHJpbmcoTWF0aC5yYW5kb20oKSAqIE1hdGgucG93KDIsIGF0dGVtcHQpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJTdGFsbGluZyBjYWxsYmFja1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgc3RhbGxlcih0aW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcnVubmluZ1RpbWVvdXQuY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcInByb2Nlc3NpbmcgcmVzcG9uc2UgZXJyb3JcIiwgTG9nZ2VyLmVycm9ycy5TRVJWRVJfRVJST1IsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBib2R5aWZ5KGJvZHksICgocmVzcG9uc2UuaGVhZGVycykgPyByZXNwb25zZS5oZWFkZXJzW1wiY29udGVudC10eXBlXCJdIDogbnVsbCkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0Qm9keTogYm9keWlmeShvcHRpb25zLmJvZHksIGZsYXRIZWFkZXJzW1wiY29udGVudC10eXBlXCJdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0TWV0aG9kOiBvcHRpb25zLm1ldGhvZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IHVybFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcnVubmluZ1RpbWVvdXQuY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgaGFkIGEgcHJvY2Vzc0Z1bmMsIGl0IGVpdGhlciByZXR1cm5lZCBhIFQgb3IgdGhyZXcgYWJvdmUuXG4gICAgICAgICAgICAgICAgLy8gVGhlIFwiYm9keVwiIGlzIG5vdyBhIFVpbnQ4QXJyYXkuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJvZHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93RXJyb3IoXCJmYWlsZWQgcmVzcG9uc2VcIiwgTG9nZ2VyLmVycm9ycy5TRVJWRVJfRVJST1IsIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0Qm9keTogYm9keWlmeShvcHRpb25zLmJvZHksIGZsYXRIZWFkZXJzW1wiY29udGVudC10eXBlXCJdKSxcbiAgICAgICAgICAgICAgICByZXF1ZXN0TWV0aG9kOiBvcHRpb25zLm1ldGhvZCxcbiAgICAgICAgICAgICAgICB1cmw6IHVybFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0pKCk7XG4gICAgcmV0dXJuIFByb21pc2UucmFjZShbcnVubmluZ1RpbWVvdXQucHJvbWlzZSwgcnVubmluZ0ZldGNoXSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZmV0Y2hKc29uKGNvbm5lY3Rpb24sIGpzb24sIHByb2Nlc3NGdW5jKSB7XG4gICAgbGV0IHByb2Nlc3NKc29uRnVuYyA9ICh2YWx1ZSwgcmVzcG9uc2UpID0+IHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IG51bGw7XG4gICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IEpTT04ucGFyc2UodG9VdGY4U3RyaW5nKHZhbHVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImludmFsaWQgSlNPTlwiLCBMb2dnZXIuZXJyb3JzLlNFUlZFUl9FUlJPUiwge1xuICAgICAgICAgICAgICAgICAgICBib2R5OiB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb2Nlc3NGdW5jKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBwcm9jZXNzRnVuYyhyZXN1bHQsIHJlc3BvbnNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgLy8gSWYgd2UgaGF2ZSBqc29uIHRvIHNlbmQsIHdlIG11c3RcbiAgICAvLyAtIGFkZCBjb250ZW50LXR5cGUgb2YgYXBwbGljYXRpb24vanNvbiAodW5sZXNzIGFscmVhZHkgb3ZlcnJpZGRlbilcbiAgICAvLyAtIGNvbnZlcnQgdGhlIGpzb24gdG8gYnl0ZXNcbiAgICBsZXQgYm9keSA9IG51bGw7XG4gICAgaWYgKGpzb24gIT0gbnVsbCkge1xuICAgICAgICBib2R5ID0gdG9VdGY4Qnl0ZXMoanNvbik7XG4gICAgICAgIC8vIENyZWF0ZSBhIGNvbm5lY3Rpb24gd2l0aCB0aGUgY29udGVudC10eXBlIHNldCBmb3IgSlNPTlxuICAgICAgICBjb25zdCB1cGRhdGVkID0gKHR5cGVvZiAoY29ubmVjdGlvbikgPT09IFwic3RyaW5nXCIpID8gKHsgdXJsOiBjb25uZWN0aW9uIH0pIDogc2hhbGxvd0NvcHkoY29ubmVjdGlvbik7XG4gICAgICAgIGlmICh1cGRhdGVkLmhlYWRlcnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGhhc0NvbnRlbnRUeXBlID0gKE9iamVjdC5rZXlzKHVwZGF0ZWQuaGVhZGVycykuZmlsdGVyKChrKSA9PiAoay50b0xvd2VyQ2FzZSgpID09PSBcImNvbnRlbnQtdHlwZVwiKSkubGVuZ3RoKSAhPT0gMDtcbiAgICAgICAgICAgIGlmICghaGFzQ29udGVudFR5cGUpIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVkLmhlYWRlcnMgPSBzaGFsbG93Q29weSh1cGRhdGVkLmhlYWRlcnMpO1xuICAgICAgICAgICAgICAgIHVwZGF0ZWQuaGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXSA9IFwiYXBwbGljYXRpb24vanNvblwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdXBkYXRlZC5oZWFkZXJzID0geyBcImNvbnRlbnQtdHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbm5lY3Rpb24gPSB1cGRhdGVkO1xuICAgIH1cbiAgICByZXR1cm4gX2ZldGNoRGF0YShjb25uZWN0aW9uLCBib2R5LCBwcm9jZXNzSnNvbkZ1bmMpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHBvbGwoZnVuYywgb3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0ge307XG4gICAgfVxuICAgIG9wdGlvbnMgPSBzaGFsbG93Q29weShvcHRpb25zKTtcbiAgICBpZiAob3B0aW9ucy5mbG9vciA9PSBudWxsKSB7XG4gICAgICAgIG9wdGlvbnMuZmxvb3IgPSAwO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5jZWlsaW5nID09IG51bGwpIHtcbiAgICAgICAgb3B0aW9ucy5jZWlsaW5nID0gMTAwMDA7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmludGVydmFsID09IG51bGwpIHtcbiAgICAgICAgb3B0aW9ucy5pbnRlcnZhbCA9IDI1MDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgbGV0IHRpbWVyID0gbnVsbDtcbiAgICAgICAgbGV0IGRvbmUgPSBmYWxzZTtcbiAgICAgICAgLy8gUmV0dXJucyB0cnVlIGlmIGNhbmNlbCB3YXMgc3VjY2Vzc2Z1bC4gVW5zdWNjZXNzZnVsIGNhbmNlbCBtZWFucyB3ZSdyZSBhbHJlYWR5IGRvbmUuXG4gICAgICAgIGNvbnN0IGNhbmNlbCA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICBpZiAodGltZXIpIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChvcHRpb25zLnRpbWVvdXQpIHtcbiAgICAgICAgICAgIHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGNhbmNlbCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJ0aW1lb3V0XCIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBvcHRpb25zLnRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJldHJ5TGltaXQgPSBvcHRpb25zLnJldHJ5TGltaXQ7XG4gICAgICAgIGxldCBhdHRlbXB0ID0gMDtcbiAgICAgICAgZnVuY3Rpb24gY2hlY2soKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuYygpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgYSByZXN1bHQsIG9yIGFyZSBhbGxvd2VkIG51bGwgdGhlbiB3ZSdyZSBkb25lXG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjYW5jZWwoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9wdGlvbnMub25jZVBvbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5vbmNlUG9sbC5vbmNlKFwicG9sbFwiLCBjaGVjayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9wdGlvbnMub25jZUJsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMub25jZUJsb2NrLm9uY2UoXCJibG9ja1wiLCBjaGVjayk7XG4gICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgZXhwb25lbnRpYWwgYmFjay1vZmYgKHVwIHRvIDEwcykgb3VyIG5leHQgcmVxdWVzdFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICBhdHRlbXB0Kys7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhdHRlbXB0ID4gcmV0cnlMaW1pdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhbmNlbCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcInJldHJ5IGxpbWl0IHJlYWNoZWRcIikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxldCB0aW1lb3V0ID0gb3B0aW9ucy5pbnRlcnZhbCAqIHBhcnNlSW50KFN0cmluZyhNYXRoLnJhbmRvbSgpICogTWF0aC5wb3coMiwgYXR0ZW1wdCkpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWVvdXQgPCBvcHRpb25zLmZsb29yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lb3V0ID0gb3B0aW9ucy5mbG9vcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodGltZW91dCA+IG9wdGlvbnMuY2VpbGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGltZW91dCA9IG9wdGlvbnMuY2VpbGluZztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGNoZWNrLCB0aW1lb3V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2FuY2VsKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjaGVjaygpO1xuICAgIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ethersproject/web/lib.esm/index.js\n");

/***/ })

};
;