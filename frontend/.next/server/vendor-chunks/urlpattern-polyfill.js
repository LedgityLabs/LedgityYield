/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/urlpattern-polyfill";
exports.ids = ["vendor-chunks/urlpattern-polyfill"];
exports.modules = {

/***/ "(ssr)/../node_modules/urlpattern-polyfill/dist/urlpattern.cjs":
/*!***************************************************************!*\
  !*** ../node_modules/urlpattern-polyfill/dist/urlpattern.cjs ***!
  \***************************************************************/
/***/ ((module) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n// src/url-pattern.ts\nvar url_pattern_exports = {};\n__export(url_pattern_exports, {\n  URLPattern: () => URLPattern\n});\nmodule.exports = __toCommonJS(url_pattern_exports);\n\n// src/path-to-regex-modified.ts\nvar Part = class {\n  constructor(type, name, prefix, value, suffix, modifier) {\n    this.type = 3 /* kFixed */;\n    this.name = \"\";\n    this.prefix = \"\";\n    this.value = \"\";\n    this.suffix = \"\";\n    this.modifier = 3 /* kNone */;\n    this.type = type;\n    this.name = name;\n    this.prefix = prefix;\n    this.value = value;\n    this.suffix = suffix;\n    this.modifier = modifier;\n  }\n  hasCustomName() {\n    return this.name !== \"\" && typeof this.name !== \"number\";\n  }\n};\nvar regexIdentifierStart = /[$_\\p{ID_Start}]/u;\nvar regexIdentifierPart = /[$_\\u200C\\u200D\\p{ID_Continue}]/u;\nvar kFullWildcardRegex = \".*\";\nfunction isASCII(str, extended) {\n  return (extended ? /^[\\x00-\\xFF]*$/ : /^[\\x00-\\x7F]*$/).test(str);\n}\nfunction lexer(str, lenient = false) {\n  const tokens = [];\n  let i = 0;\n  while (i < str.length) {\n    const char = str[i];\n    const ErrorOrInvalid = function(msg) {\n      if (!lenient)\n        throw new TypeError(msg);\n      tokens.push({ type: \"INVALID_CHAR\", index: i, value: str[i++] });\n    };\n    if (char === \"*\") {\n      tokens.push({ type: \"ASTERISK\", index: i, value: str[i++] });\n      continue;\n    }\n    if (char === \"+\" || char === \"?\") {\n      tokens.push({ type: \"OTHER_MODIFIER\", index: i, value: str[i++] });\n      continue;\n    }\n    if (char === \"\\\\\") {\n      tokens.push({ type: \"ESCAPED_CHAR\", index: i++, value: str[i++] });\n      continue;\n    }\n    if (char === \"{\") {\n      tokens.push({ type: \"OPEN\", index: i, value: str[i++] });\n      continue;\n    }\n    if (char === \"}\") {\n      tokens.push({ type: \"CLOSE\", index: i, value: str[i++] });\n      continue;\n    }\n    if (char === \":\") {\n      let name = \"\";\n      let j = i + 1;\n      while (j < str.length) {\n        const code = str.substr(j, 1);\n        if (j === i + 1 && regexIdentifierStart.test(code) || j !== i + 1 && regexIdentifierPart.test(code)) {\n          name += str[j++];\n          continue;\n        }\n        break;\n      }\n      if (!name) {\n        ErrorOrInvalid(`Missing parameter name at ${i}`);\n        continue;\n      }\n      tokens.push({ type: \"NAME\", index: i, value: name });\n      i = j;\n      continue;\n    }\n    if (char === \"(\") {\n      let count = 1;\n      let pattern = \"\";\n      let j = i + 1;\n      let error = false;\n      if (str[j] === \"?\") {\n        ErrorOrInvalid(`Pattern cannot start with \"?\" at ${j}`);\n        continue;\n      }\n      while (j < str.length) {\n        if (!isASCII(str[j], false)) {\n          ErrorOrInvalid(`Invalid character '${str[j]}' at ${j}.`);\n          error = true;\n          break;\n        }\n        if (str[j] === \"\\\\\") {\n          pattern += str[j++] + str[j++];\n          continue;\n        }\n        if (str[j] === \")\") {\n          count--;\n          if (count === 0) {\n            j++;\n            break;\n          }\n        } else if (str[j] === \"(\") {\n          count++;\n          if (str[j + 1] !== \"?\") {\n            ErrorOrInvalid(`Capturing groups are not allowed at ${j}`);\n            error = true;\n            break;\n          }\n        }\n        pattern += str[j++];\n      }\n      if (error) {\n        continue;\n      }\n      if (count) {\n        ErrorOrInvalid(`Unbalanced pattern at ${i}`);\n        continue;\n      }\n      if (!pattern) {\n        ErrorOrInvalid(`Missing pattern at ${i}`);\n        continue;\n      }\n      tokens.push({ type: \"REGEX\", index: i, value: pattern });\n      i = j;\n      continue;\n    }\n    tokens.push({ type: \"CHAR\", index: i, value: str[i++] });\n  }\n  tokens.push({ type: \"END\", index: i, value: \"\" });\n  return tokens;\n}\nfunction parse(str, options = {}) {\n  const tokens = lexer(str);\n  options.delimiter ?? (options.delimiter = \"/#?\");\n  options.prefixes ?? (options.prefixes = \"./\");\n  const segmentWildcardRegex = `[^${escapeString(options.delimiter)}]+?`;\n  const result = [];\n  let key = 0;\n  let i = 0;\n  let path = \"\";\n  let nameSet = /* @__PURE__ */ new Set();\n  const tryConsume = (type) => {\n    if (i < tokens.length && tokens[i].type === type)\n      return tokens[i++].value;\n  };\n  const tryConsumeModifier = () => {\n    return tryConsume(\"OTHER_MODIFIER\") ?? tryConsume(\"ASTERISK\");\n  };\n  const mustConsume = (type) => {\n    const value = tryConsume(type);\n    if (value !== void 0)\n      return value;\n    const { type: nextType, index } = tokens[i];\n    throw new TypeError(`Unexpected ${nextType} at ${index}, expected ${type}`);\n  };\n  const consumeText = () => {\n    let result2 = \"\";\n    let value;\n    while (value = tryConsume(\"CHAR\") ?? tryConsume(\"ESCAPED_CHAR\")) {\n      result2 += value;\n    }\n    return result2;\n  };\n  const DefaultEncodePart = (value) => {\n    return value;\n  };\n  const encodePart = options.encodePart || DefaultEncodePart;\n  let pendingFixedValue = \"\";\n  const appendToPendingFixedValue = (value) => {\n    pendingFixedValue += value;\n  };\n  const maybeAddPartFromPendingFixedValue = () => {\n    if (!pendingFixedValue.length) {\n      return;\n    }\n    result.push(new Part(3 /* kFixed */, \"\", \"\", encodePart(pendingFixedValue), \"\", 3 /* kNone */));\n    pendingFixedValue = \"\";\n  };\n  const addPart = (prefix, nameToken, regexOrWildcardToken, suffix, modifierToken) => {\n    let modifier = 3 /* kNone */;\n    switch (modifierToken) {\n      case \"?\":\n        modifier = 1 /* kOptional */;\n        break;\n      case \"*\":\n        modifier = 0 /* kZeroOrMore */;\n        break;\n      case \"+\":\n        modifier = 2 /* kOneOrMore */;\n        break;\n    }\n    if (!nameToken && !regexOrWildcardToken && modifier === 3 /* kNone */) {\n      appendToPendingFixedValue(prefix);\n      return;\n    }\n    maybeAddPartFromPendingFixedValue();\n    if (!nameToken && !regexOrWildcardToken) {\n      if (!prefix) {\n        return;\n      }\n      result.push(new Part(3 /* kFixed */, \"\", \"\", encodePart(prefix), \"\", modifier));\n      return;\n    }\n    let regexValue;\n    if (!regexOrWildcardToken) {\n      regexValue = segmentWildcardRegex;\n    } else if (regexOrWildcardToken === \"*\") {\n      regexValue = kFullWildcardRegex;\n    } else {\n      regexValue = regexOrWildcardToken;\n    }\n    let type = 2 /* kRegex */;\n    if (regexValue === segmentWildcardRegex) {\n      type = 1 /* kSegmentWildcard */;\n      regexValue = \"\";\n    } else if (regexValue === kFullWildcardRegex) {\n      type = 0 /* kFullWildcard */;\n      regexValue = \"\";\n    }\n    let name;\n    if (nameToken) {\n      name = nameToken;\n    } else if (regexOrWildcardToken) {\n      name = key++;\n    }\n    if (nameSet.has(name)) {\n      throw new TypeError(`Duplicate name '${name}'.`);\n    }\n    nameSet.add(name);\n    result.push(new Part(type, name, encodePart(prefix), regexValue, encodePart(suffix), modifier));\n  };\n  while (i < tokens.length) {\n    const charToken = tryConsume(\"CHAR\");\n    const nameToken = tryConsume(\"NAME\");\n    let regexOrWildcardToken = tryConsume(\"REGEX\");\n    if (!nameToken && !regexOrWildcardToken) {\n      regexOrWildcardToken = tryConsume(\"ASTERISK\");\n    }\n    if (nameToken || regexOrWildcardToken) {\n      let prefix = charToken ?? \"\";\n      if (options.prefixes.indexOf(prefix) === -1) {\n        appendToPendingFixedValue(prefix);\n        prefix = \"\";\n      }\n      maybeAddPartFromPendingFixedValue();\n      let modifierToken = tryConsumeModifier();\n      addPart(prefix, nameToken, regexOrWildcardToken, \"\", modifierToken);\n      continue;\n    }\n    const value = charToken ?? tryConsume(\"ESCAPED_CHAR\");\n    if (value) {\n      appendToPendingFixedValue(value);\n      continue;\n    }\n    const openToken = tryConsume(\"OPEN\");\n    if (openToken) {\n      const prefix = consumeText();\n      const nameToken2 = tryConsume(\"NAME\");\n      let regexOrWildcardToken2 = tryConsume(\"REGEX\");\n      if (!nameToken2 && !regexOrWildcardToken2) {\n        regexOrWildcardToken2 = tryConsume(\"ASTERISK\");\n      }\n      const suffix = consumeText();\n      mustConsume(\"CLOSE\");\n      const modifierToken = tryConsumeModifier();\n      addPart(prefix, nameToken2, regexOrWildcardToken2, suffix, modifierToken);\n      continue;\n    }\n    maybeAddPartFromPendingFixedValue();\n    mustConsume(\"END\");\n  }\n  return result;\n}\nfunction escapeString(str) {\n  return str.replace(/([.+*?^${}()[\\]|/\\\\])/g, \"\\\\$1\");\n}\nfunction flags(options) {\n  return options && options.ignoreCase ? \"ui\" : \"u\";\n}\nfunction stringToRegexp(path, names, options) {\n  return partsToRegexp(parse(path, options), names, options);\n}\nfunction modifierToString(modifier) {\n  switch (modifier) {\n    case 0 /* kZeroOrMore */:\n      return \"*\";\n    case 1 /* kOptional */:\n      return \"?\";\n    case 2 /* kOneOrMore */:\n      return \"+\";\n    case 3 /* kNone */:\n      return \"\";\n  }\n}\nfunction partsToRegexp(parts, names, options = {}) {\n  options.delimiter ?? (options.delimiter = \"/#?\");\n  options.prefixes ?? (options.prefixes = \"./\");\n  options.sensitive ?? (options.sensitive = false);\n  options.strict ?? (options.strict = false);\n  options.end ?? (options.end = true);\n  options.start ?? (options.start = true);\n  options.endsWith = \"\";\n  let result = options.start ? \"^\" : \"\";\n  for (const part of parts) {\n    if (part.type === 3 /* kFixed */) {\n      if (part.modifier === 3 /* kNone */) {\n        result += escapeString(part.value);\n      } else {\n        result += `(?:${escapeString(part.value)})${modifierToString(part.modifier)}`;\n      }\n      continue;\n    }\n    if (names)\n      names.push(part.name);\n    const segmentWildcardRegex = `[^${escapeString(options.delimiter)}]+?`;\n    let regexValue = part.value;\n    if (part.type === 1 /* kSegmentWildcard */)\n      regexValue = segmentWildcardRegex;\n    else if (part.type === 0 /* kFullWildcard */)\n      regexValue = kFullWildcardRegex;\n    if (!part.prefix.length && !part.suffix.length) {\n      if (part.modifier === 3 /* kNone */ || part.modifier === 1 /* kOptional */) {\n        result += `(${regexValue})${modifierToString(part.modifier)}`;\n      } else {\n        result += `((?:${regexValue})${modifierToString(part.modifier)})`;\n      }\n      continue;\n    }\n    if (part.modifier === 3 /* kNone */ || part.modifier === 1 /* kOptional */) {\n      result += `(?:${escapeString(part.prefix)}(${regexValue})${escapeString(part.suffix)})`;\n      result += modifierToString(part.modifier);\n      continue;\n    }\n    result += `(?:${escapeString(part.prefix)}`;\n    result += `((?:${regexValue})(?:`;\n    result += escapeString(part.suffix);\n    result += escapeString(part.prefix);\n    result += `(?:${regexValue}))*)${escapeString(part.suffix)})`;\n    if (part.modifier === 0 /* kZeroOrMore */) {\n      result += \"?\";\n    }\n  }\n  const endsWith = `[${escapeString(options.endsWith)}]|$`;\n  const delimiter = `[${escapeString(options.delimiter)}]`;\n  if (options.end) {\n    if (!options.strict) {\n      result += `${delimiter}?`;\n    }\n    if (!options.endsWith.length) {\n      result += \"$\";\n    } else {\n      result += `(?=${endsWith})`;\n    }\n    return new RegExp(result, flags(options));\n  }\n  if (!options.strict) {\n    result += `(?:${delimiter}(?=${endsWith}))?`;\n  }\n  let isEndDelimited = false;\n  if (parts.length) {\n    const lastPart = parts[parts.length - 1];\n    if (lastPart.type === 3 /* kFixed */ && lastPart.modifier === 3 /* kNone */) {\n      isEndDelimited = options.delimiter.indexOf(lastPart) > -1;\n    }\n  }\n  if (!isEndDelimited) {\n    result += `(?=${delimiter}|${endsWith})`;\n  }\n  return new RegExp(result, flags(options));\n}\n\n// src/url-utils.ts\nvar DEFAULT_OPTIONS = {\n  delimiter: \"\",\n  prefixes: \"\",\n  sensitive: true,\n  strict: true\n};\nvar HOSTNAME_OPTIONS = {\n  delimiter: \".\",\n  prefixes: \"\",\n  sensitive: true,\n  strict: true\n};\nvar PATHNAME_OPTIONS = {\n  delimiter: \"/\",\n  prefixes: \"/\",\n  sensitive: true,\n  strict: true\n};\nfunction isAbsolutePathname(pathname, isPattern) {\n  if (!pathname.length) {\n    return false;\n  }\n  if (pathname[0] === \"/\") {\n    return true;\n  }\n  if (!isPattern) {\n    return false;\n  }\n  if (pathname.length < 2) {\n    return false;\n  }\n  if ((pathname[0] == \"\\\\\" || pathname[0] == \"{\") && pathname[1] == \"/\") {\n    return true;\n  }\n  return false;\n}\nfunction maybeStripPrefix(value, prefix) {\n  if (value.startsWith(prefix)) {\n    return value.substring(prefix.length, value.length);\n  }\n  return value;\n}\nfunction maybeStripSuffix(value, suffix) {\n  if (value.endsWith(suffix)) {\n    return value.substr(0, value.length - suffix.length);\n  }\n  return value;\n}\nfunction treatAsIPv6Hostname(value) {\n  if (!value || value.length < 2) {\n    return false;\n  }\n  if (value[0] === \"[\") {\n    return true;\n  }\n  if ((value[0] === \"\\\\\" || value[0] === \"{\") && value[1] === \"[\") {\n    return true;\n  }\n  return false;\n}\nvar SPECIAL_SCHEMES = [\n  \"ftp\",\n  \"file\",\n  \"http\",\n  \"https\",\n  \"ws\",\n  \"wss\"\n];\nfunction isSpecialScheme(protocol_regexp) {\n  if (!protocol_regexp) {\n    return true;\n  }\n  for (const scheme of SPECIAL_SCHEMES) {\n    if (protocol_regexp.test(scheme)) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction canonicalizeHash(hash, isPattern) {\n  hash = maybeStripPrefix(hash, \"#\");\n  if (isPattern || hash === \"\") {\n    return hash;\n  }\n  const url = new URL(\"https://example.com\");\n  url.hash = hash;\n  return url.hash ? url.hash.substring(1, url.hash.length) : \"\";\n}\nfunction canonicalizeSearch(search, isPattern) {\n  search = maybeStripPrefix(search, \"?\");\n  if (isPattern || search === \"\") {\n    return search;\n  }\n  const url = new URL(\"https://example.com\");\n  url.search = search;\n  return url.search ? url.search.substring(1, url.search.length) : \"\";\n}\nfunction canonicalizeHostname(hostname, isPattern) {\n  if (isPattern || hostname === \"\") {\n    return hostname;\n  }\n  if (treatAsIPv6Hostname(hostname)) {\n    return ipv6HostnameEncodeCallback(hostname);\n  } else {\n    return hostnameEncodeCallback(hostname);\n  }\n}\nfunction canonicalizePassword(password, isPattern) {\n  if (isPattern || password === \"\") {\n    return password;\n  }\n  const url = new URL(\"https://example.com\");\n  url.password = password;\n  return url.password;\n}\nfunction canonicalizeUsername(username, isPattern) {\n  if (isPattern || username === \"\") {\n    return username;\n  }\n  const url = new URL(\"https://example.com\");\n  url.username = username;\n  return url.username;\n}\nfunction canonicalizePathname(pathname, protocol, isPattern) {\n  if (isPattern || pathname === \"\") {\n    return pathname;\n  }\n  if (protocol && !SPECIAL_SCHEMES.includes(protocol)) {\n    const url = new URL(`${protocol}:${pathname}`);\n    return url.pathname;\n  }\n  const leadingSlash = pathname[0] == \"/\";\n  pathname = new URL(\n    !leadingSlash ? \"/-\" + pathname : pathname,\n    \"https://example.com\"\n  ).pathname;\n  if (!leadingSlash) {\n    pathname = pathname.substring(2, pathname.length);\n  }\n  return pathname;\n}\nfunction canonicalizePort(port, protocol, isPattern) {\n  if (defaultPortForProtocol(protocol) === port) {\n    port = \"\";\n  }\n  if (isPattern || port === \"\") {\n    return port;\n  }\n  return portEncodeCallback(port);\n}\nfunction canonicalizeProtocol(protocol, isPattern) {\n  protocol = maybeStripSuffix(protocol, \":\");\n  if (isPattern || protocol === \"\") {\n    return protocol;\n  }\n  return protocolEncodeCallback(protocol);\n}\nfunction defaultPortForProtocol(protocol) {\n  switch (protocol) {\n    case \"ws\":\n    case \"http\":\n      return \"80\";\n    case \"wws\":\n    case \"https\":\n      return \"443\";\n    case \"ftp\":\n      return \"21\";\n    default:\n      return \"\";\n  }\n}\nfunction protocolEncodeCallback(input) {\n  if (input === \"\") {\n    return input;\n  }\n  if (/^[-+.A-Za-z0-9]*$/.test(input))\n    return input.toLowerCase();\n  throw new TypeError(`Invalid protocol '${input}'.`);\n}\nfunction usernameEncodeCallback(input) {\n  if (input === \"\") {\n    return input;\n  }\n  const url = new URL(\"https://example.com\");\n  url.username = input;\n  return url.username;\n}\nfunction passwordEncodeCallback(input) {\n  if (input === \"\") {\n    return input;\n  }\n  const url = new URL(\"https://example.com\");\n  url.password = input;\n  return url.password;\n}\nfunction hostnameEncodeCallback(input) {\n  if (input === \"\") {\n    return input;\n  }\n  if (/[\\t\\n\\r #%/:<>?@[\\]^\\\\|]/g.test(input)) {\n    throw new TypeError(`Invalid hostname '${input}'`);\n  }\n  const url = new URL(\"https://example.com\");\n  url.hostname = input;\n  return url.hostname;\n}\nfunction ipv6HostnameEncodeCallback(input) {\n  if (input === \"\") {\n    return input;\n  }\n  if (/[^0-9a-fA-F[\\]:]/g.test(input)) {\n    throw new TypeError(`Invalid IPv6 hostname '${input}'`);\n  }\n  return input.toLowerCase();\n}\nfunction portEncodeCallback(input) {\n  if (input === \"\") {\n    return input;\n  }\n  if (/^[0-9]*$/.test(input) && parseInt(input) <= 65535) {\n    return input;\n  }\n  throw new TypeError(`Invalid port '${input}'.`);\n}\nfunction standardURLPathnameEncodeCallback(input) {\n  if (input === \"\") {\n    return input;\n  }\n  const url = new URL(\"https://example.com\");\n  url.pathname = input[0] !== \"/\" ? \"/-\" + input : input;\n  if (input[0] !== \"/\") {\n    return url.pathname.substring(2, url.pathname.length);\n  }\n  return url.pathname;\n}\nfunction pathURLPathnameEncodeCallback(input) {\n  if (input === \"\") {\n    return input;\n  }\n  const url = new URL(`data:${input}`);\n  return url.pathname;\n}\nfunction searchEncodeCallback(input) {\n  if (input === \"\") {\n    return input;\n  }\n  const url = new URL(\"https://example.com\");\n  url.search = input;\n  return url.search.substring(1, url.search.length);\n}\nfunction hashEncodeCallback(input) {\n  if (input === \"\") {\n    return input;\n  }\n  const url = new URL(\"https://example.com\");\n  url.hash = input;\n  return url.hash.substring(1, url.hash.length);\n}\n\n// src/url-pattern-parser.ts\nvar Parser = class {\n  constructor(input) {\n    // The list of `LexToken`s produced by the path-to-regexp `lexer()` function\n    // when passed `input` with lenient mode enabled.\n    this.tokenList = [];\n    // As we parse the input string we populate a `URLPatternInit` dictionary\n    // with each component pattern.  This is then the final result of the parse.\n    this.internalResult = {};\n    // The index of the current `LexToken` being considered.\n    this.tokenIndex = 0;\n    // The value to add to `tokenIndex` on each turn through the parse loop.\n    // While typically this is `1`, it is also set to `0` at times for things\n    // like state transitions, etc.  It is automatically reset back to `1` at\n    // the top of the parse loop.\n    this.tokenIncrement = 1;\n    // The index of the first `LexToken` to include in the component string.\n    this.componentStart = 0;\n    // The current parse state.  This should only be changed via `changeState()`\n    // or `rewindAndSetState()`.\n    this.state = 0 /* INIT */;\n    // The current nest depth of `{ }` pattern groupings.\n    this.groupDepth = 0;\n    // The current nesting depth of `[ ]` in hostname patterns.\n    this.hostnameIPv6BracketDepth = 0;\n    // True if we should apply parse rules as if this is a \"standard\" URL.  If\n    // false then this is treated as a \"not a base URL\".\n    this.shouldTreatAsStandardURL = false;\n    this.input = input;\n  }\n  // Return the parse result.  The result is only available after the\n  // `parse()` method completes.\n  get result() {\n    return this.internalResult;\n  }\n  // Attempt to parse the input string used to construct the Parser object.\n  // This method may only be called once.  Any errors will be thrown as an\n  // exception.  Retrieve the parse result by accessing the `Parser.result`\n  // property getter.\n  parse() {\n    this.tokenList = lexer(\n      this.input,\n      /*lenient=*/\n      true\n    );\n    for (; this.tokenIndex < this.tokenList.length; this.tokenIndex += this.tokenIncrement) {\n      this.tokenIncrement = 1;\n      if (this.tokenList[this.tokenIndex].type === \"END\") {\n        if (this.state === 0 /* INIT */) {\n          this.rewind();\n          if (this.isHashPrefix()) {\n            this.changeState(\n              9 /* HASH */,\n              /*skip=*/\n              1\n            );\n          } else if (this.isSearchPrefix()) {\n            this.changeState(\n              8 /* SEARCH */,\n              /*skip=*/\n              1\n            );\n            this.internalResult.hash = \"\";\n          } else {\n            this.changeState(\n              7 /* PATHNAME */,\n              /*skip=*/\n              0\n            );\n            this.internalResult.search = \"\";\n            this.internalResult.hash = \"\";\n          }\n          continue;\n        } else if (this.state === 2 /* AUTHORITY */) {\n          this.rewindAndSetState(5 /* HOSTNAME */);\n          continue;\n        }\n        this.changeState(\n          10 /* DONE */,\n          /*skip=*/\n          0\n        );\n        break;\n      }\n      if (this.groupDepth > 0) {\n        if (this.isGroupClose()) {\n          this.groupDepth -= 1;\n        } else {\n          continue;\n        }\n      }\n      if (this.isGroupOpen()) {\n        this.groupDepth += 1;\n        continue;\n      }\n      switch (this.state) {\n        case 0 /* INIT */:\n          if (this.isProtocolSuffix()) {\n            this.internalResult.username = \"\";\n            this.internalResult.password = \"\";\n            this.internalResult.hostname = \"\";\n            this.internalResult.port = \"\";\n            this.internalResult.pathname = \"\";\n            this.internalResult.search = \"\";\n            this.internalResult.hash = \"\";\n            this.rewindAndSetState(1 /* PROTOCOL */);\n          }\n          break;\n        case 1 /* PROTOCOL */:\n          if (this.isProtocolSuffix()) {\n            this.computeShouldTreatAsStandardURL();\n            let nextState = 7 /* PATHNAME */;\n            let skip = 1;\n            if (this.shouldTreatAsStandardURL) {\n              this.internalResult.pathname = \"/\";\n            }\n            if (this.nextIsAuthoritySlashes()) {\n              nextState = 2 /* AUTHORITY */;\n              skip = 3;\n            } else if (this.shouldTreatAsStandardURL) {\n              nextState = 2 /* AUTHORITY */;\n            }\n            this.changeState(nextState, skip);\n          }\n          break;\n        case 2 /* AUTHORITY */:\n          if (this.isIdentityTerminator()) {\n            this.rewindAndSetState(3 /* USERNAME */);\n          } else if (this.isPathnameStart() || this.isSearchPrefix() || this.isHashPrefix()) {\n            this.rewindAndSetState(5 /* HOSTNAME */);\n          }\n          break;\n        case 3 /* USERNAME */:\n          if (this.isPasswordPrefix()) {\n            this.changeState(\n              4 /* PASSWORD */,\n              /*skip=*/\n              1\n            );\n          } else if (this.isIdentityTerminator()) {\n            this.changeState(\n              5 /* HOSTNAME */,\n              /*skip=*/\n              1\n            );\n          }\n          break;\n        case 4 /* PASSWORD */:\n          if (this.isIdentityTerminator()) {\n            this.changeState(\n              5 /* HOSTNAME */,\n              /*skip=*/\n              1\n            );\n          }\n          break;\n        case 5 /* HOSTNAME */:\n          if (this.isIPv6Open()) {\n            this.hostnameIPv6BracketDepth += 1;\n          } else if (this.isIPv6Close()) {\n            this.hostnameIPv6BracketDepth -= 1;\n          }\n          if (this.isPortPrefix() && !this.hostnameIPv6BracketDepth) {\n            this.changeState(\n              6 /* PORT */,\n              /*skip=*/\n              1\n            );\n          } else if (this.isPathnameStart()) {\n            this.changeState(\n              7 /* PATHNAME */,\n              /*skip=*/\n              0\n            );\n          } else if (this.isSearchPrefix()) {\n            this.changeState(\n              8 /* SEARCH */,\n              /*skip=*/\n              1\n            );\n          } else if (this.isHashPrefix()) {\n            this.changeState(\n              9 /* HASH */,\n              /*skip=*/\n              1\n            );\n          }\n          break;\n        case 6 /* PORT */:\n          if (this.isPathnameStart()) {\n            this.changeState(\n              7 /* PATHNAME */,\n              /*skip=*/\n              0\n            );\n          } else if (this.isSearchPrefix()) {\n            this.changeState(\n              8 /* SEARCH */,\n              /*skip=*/\n              1\n            );\n          } else if (this.isHashPrefix()) {\n            this.changeState(\n              9 /* HASH */,\n              /*skip=*/\n              1\n            );\n          }\n          break;\n        case 7 /* PATHNAME */:\n          if (this.isSearchPrefix()) {\n            this.changeState(\n              8 /* SEARCH */,\n              /*skip=*/\n              1\n            );\n          } else if (this.isHashPrefix()) {\n            this.changeState(\n              9 /* HASH */,\n              /*skip=*/\n              1\n            );\n          }\n          break;\n        case 8 /* SEARCH */:\n          if (this.isHashPrefix()) {\n            this.changeState(\n              9 /* HASH */,\n              /*skip=*/\n              1\n            );\n          }\n          break;\n        case 9 /* HASH */:\n          break;\n        case 10 /* DONE */:\n          break;\n      }\n    }\n  }\n  changeState(newState, skip) {\n    switch (this.state) {\n      case 0 /* INIT */:\n        break;\n      case 1 /* PROTOCOL */:\n        this.internalResult.protocol = this.makeComponentString();\n        break;\n      case 2 /* AUTHORITY */:\n        break;\n      case 3 /* USERNAME */:\n        this.internalResult.username = this.makeComponentString();\n        break;\n      case 4 /* PASSWORD */:\n        this.internalResult.password = this.makeComponentString();\n        break;\n      case 5 /* HOSTNAME */:\n        this.internalResult.hostname = this.makeComponentString();\n        break;\n      case 6 /* PORT */:\n        this.internalResult.port = this.makeComponentString();\n        break;\n      case 7 /* PATHNAME */:\n        this.internalResult.pathname = this.makeComponentString();\n        break;\n      case 8 /* SEARCH */:\n        this.internalResult.search = this.makeComponentString();\n        break;\n      case 9 /* HASH */:\n        this.internalResult.hash = this.makeComponentString();\n        break;\n      case 10 /* DONE */:\n        break;\n    }\n    this.changeStateWithoutSettingComponent(newState, skip);\n  }\n  changeStateWithoutSettingComponent(newState, skip) {\n    this.state = newState;\n    this.componentStart = this.tokenIndex + skip;\n    this.tokenIndex += skip;\n    this.tokenIncrement = 0;\n  }\n  rewind() {\n    this.tokenIndex = this.componentStart;\n    this.tokenIncrement = 0;\n  }\n  rewindAndSetState(newState) {\n    this.rewind();\n    this.state = newState;\n  }\n  safeToken(index) {\n    if (index < 0) {\n      index = this.tokenList.length - index;\n    }\n    if (index < this.tokenList.length) {\n      return this.tokenList[index];\n    }\n    return this.tokenList[this.tokenList.length - 1];\n  }\n  isNonSpecialPatternChar(index, value) {\n    const token = this.safeToken(index);\n    return token.value === value && (token.type === \"CHAR\" || token.type === \"ESCAPED_CHAR\" || token.type === \"INVALID_CHAR\");\n  }\n  isProtocolSuffix() {\n    return this.isNonSpecialPatternChar(this.tokenIndex, \":\");\n  }\n  nextIsAuthoritySlashes() {\n    return this.isNonSpecialPatternChar(this.tokenIndex + 1, \"/\") && this.isNonSpecialPatternChar(this.tokenIndex + 2, \"/\");\n  }\n  isIdentityTerminator() {\n    return this.isNonSpecialPatternChar(this.tokenIndex, \"@\");\n  }\n  isPasswordPrefix() {\n    return this.isNonSpecialPatternChar(this.tokenIndex, \":\");\n  }\n  isPortPrefix() {\n    return this.isNonSpecialPatternChar(this.tokenIndex, \":\");\n  }\n  isPathnameStart() {\n    return this.isNonSpecialPatternChar(this.tokenIndex, \"/\");\n  }\n  isSearchPrefix() {\n    if (this.isNonSpecialPatternChar(this.tokenIndex, \"?\")) {\n      return true;\n    }\n    if (this.tokenList[this.tokenIndex].value !== \"?\") {\n      return false;\n    }\n    const previousToken = this.safeToken(this.tokenIndex - 1);\n    return previousToken.type !== \"NAME\" && previousToken.type !== \"REGEX\" && previousToken.type !== \"CLOSE\" && previousToken.type !== \"ASTERISK\";\n  }\n  isHashPrefix() {\n    return this.isNonSpecialPatternChar(this.tokenIndex, \"#\");\n  }\n  isGroupOpen() {\n    return this.tokenList[this.tokenIndex].type == \"OPEN\";\n  }\n  isGroupClose() {\n    return this.tokenList[this.tokenIndex].type == \"CLOSE\";\n  }\n  isIPv6Open() {\n    return this.isNonSpecialPatternChar(this.tokenIndex, \"[\");\n  }\n  isIPv6Close() {\n    return this.isNonSpecialPatternChar(this.tokenIndex, \"]\");\n  }\n  makeComponentString() {\n    const token = this.tokenList[this.tokenIndex];\n    const componentCharStart = this.safeToken(this.componentStart).index;\n    return this.input.substring(componentCharStart, token.index);\n  }\n  computeShouldTreatAsStandardURL() {\n    const options = {};\n    Object.assign(options, DEFAULT_OPTIONS);\n    options.encodePart = protocolEncodeCallback;\n    const regexp = stringToRegexp(\n      this.makeComponentString(),\n      /*keys=*/\n      void 0,\n      options\n    );\n    this.shouldTreatAsStandardURL = isSpecialScheme(regexp);\n  }\n};\n\n// src/url-pattern.ts\nvar COMPONENTS = [\n  \"protocol\",\n  \"username\",\n  \"password\",\n  \"hostname\",\n  \"port\",\n  \"pathname\",\n  \"search\",\n  \"hash\"\n];\nvar DEFAULT_PATTERN = \"*\";\nfunction extractValues(url, baseURL) {\n  if (typeof url !== \"string\") {\n    throw new TypeError(`parameter 1 is not of type 'string'.`);\n  }\n  const o = new URL(url, baseURL);\n  return {\n    protocol: o.protocol.substring(0, o.protocol.length - 1),\n    username: o.username,\n    password: o.password,\n    hostname: o.hostname,\n    port: o.port,\n    pathname: o.pathname,\n    search: o.search !== \"\" ? o.search.substring(1, o.search.length) : void 0,\n    hash: o.hash !== \"\" ? o.hash.substring(1, o.hash.length) : void 0\n  };\n}\nfunction processBaseURLString(input, isPattern) {\n  if (!isPattern) {\n    return input;\n  }\n  return escapePatternString(input);\n}\nfunction applyInit(o, init, isPattern) {\n  let baseURL;\n  if (typeof init.baseURL === \"string\") {\n    try {\n      baseURL = new URL(init.baseURL);\n      o.protocol = processBaseURLString(baseURL.protocol.substring(0, baseURL.protocol.length - 1), isPattern);\n      o.username = processBaseURLString(baseURL.username, isPattern);\n      o.password = processBaseURLString(baseURL.password, isPattern);\n      o.hostname = processBaseURLString(baseURL.hostname, isPattern);\n      o.port = processBaseURLString(baseURL.port, isPattern);\n      o.pathname = processBaseURLString(baseURL.pathname, isPattern);\n      o.search = processBaseURLString(baseURL.search.substring(1, baseURL.search.length), isPattern);\n      o.hash = processBaseURLString(baseURL.hash.substring(1, baseURL.hash.length), isPattern);\n    } catch {\n      throw new TypeError(`invalid baseURL '${init.baseURL}'.`);\n    }\n  }\n  if (typeof init.protocol === \"string\") {\n    o.protocol = canonicalizeProtocol(init.protocol, isPattern);\n  }\n  if (typeof init.username === \"string\") {\n    o.username = canonicalizeUsername(init.username, isPattern);\n  }\n  if (typeof init.password === \"string\") {\n    o.password = canonicalizePassword(init.password, isPattern);\n  }\n  if (typeof init.hostname === \"string\") {\n    o.hostname = canonicalizeHostname(init.hostname, isPattern);\n  }\n  if (typeof init.port === \"string\") {\n    o.port = canonicalizePort(init.port, o.protocol, isPattern);\n  }\n  if (typeof init.pathname === \"string\") {\n    o.pathname = init.pathname;\n    if (baseURL && !isAbsolutePathname(o.pathname, isPattern)) {\n      const slashIndex = baseURL.pathname.lastIndexOf(\"/\");\n      if (slashIndex >= 0) {\n        o.pathname = processBaseURLString(baseURL.pathname.substring(0, slashIndex + 1), isPattern) + o.pathname;\n      }\n    }\n    o.pathname = canonicalizePathname(o.pathname, o.protocol, isPattern);\n  }\n  if (typeof init.search === \"string\") {\n    o.search = canonicalizeSearch(init.search, isPattern);\n  }\n  if (typeof init.hash === \"string\") {\n    o.hash = canonicalizeHash(init.hash, isPattern);\n  }\n  return o;\n}\nfunction escapePatternString(value) {\n  return value.replace(/([+*?:{}()\\\\])/g, \"\\\\$1\");\n}\nfunction escapeRegexpString(value) {\n  return value.replace(/([.+*?^${}()[\\]|/\\\\])/g, \"\\\\$1\");\n}\nfunction partsToPattern(parts, options) {\n  options.delimiter ?? (options.delimiter = \"/#?\");\n  options.prefixes ?? (options.prefixes = \"./\");\n  options.sensitive ?? (options.sensitive = false);\n  options.strict ?? (options.strict = false);\n  options.end ?? (options.end = true);\n  options.start ?? (options.start = true);\n  options.endsWith = \"\";\n  const kFullWildcardRegex2 = \".*\";\n  const segmentWildcardRegex = `[^${escapeRegexpString(options.delimiter)}]+?`;\n  const regexIdentifierPart2 = /[$_\\u200C\\u200D\\p{ID_Continue}]/u;\n  let result = \"\";\n  for (let i = 0; i < parts.length; ++i) {\n    const part = parts[i];\n    if (part.type === 3 /* kFixed */) {\n      if (part.modifier === 3 /* kNone */) {\n        result += escapePatternString(part.value);\n        continue;\n      }\n      result += `{${escapePatternString(part.value)}}${modifierToString(part.modifier)}`;\n      continue;\n    }\n    const customName = part.hasCustomName();\n    let needsGrouping = !!part.suffix.length || !!part.prefix.length && (part.prefix.length !== 1 || !options.prefixes.includes(part.prefix));\n    const lastPart = i > 0 ? parts[i - 1] : null;\n    const nextPart = i < parts.length - 1 ? parts[i + 1] : null;\n    if (!needsGrouping && customName && part.type === 1 /* kSegmentWildcard */ && part.modifier === 3 /* kNone */ && nextPart && !nextPart.prefix.length && !nextPart.suffix.length) {\n      if (nextPart.type === 3 /* kFixed */) {\n        const code = nextPart.value.length > 0 ? nextPart.value[0] : \"\";\n        needsGrouping = regexIdentifierPart2.test(code);\n      } else {\n        needsGrouping = !nextPart.hasCustomName();\n      }\n    }\n    if (!needsGrouping && !part.prefix.length && lastPart && lastPart.type === 3 /* kFixed */) {\n      const code = lastPart.value[lastPart.value.length - 1];\n      needsGrouping = options.prefixes.includes(code);\n    }\n    if (needsGrouping) {\n      result += \"{\";\n    }\n    result += escapePatternString(part.prefix);\n    if (customName) {\n      result += `:${part.name}`;\n    }\n    if (part.type === 2 /* kRegex */) {\n      result += `(${part.value})`;\n    } else if (part.type === 1 /* kSegmentWildcard */) {\n      if (!customName) {\n        result += `(${segmentWildcardRegex})`;\n      }\n    } else if (part.type === 0 /* kFullWildcard */) {\n      if (!customName && (!lastPart || lastPart.type === 3 /* kFixed */ || lastPart.modifier !== 3 /* kNone */ || needsGrouping || part.prefix !== \"\")) {\n        result += \"*\";\n      } else {\n        result += `(${kFullWildcardRegex2})`;\n      }\n    }\n    if (part.type === 1 /* kSegmentWildcard */ && customName && !!part.suffix.length) {\n      if (regexIdentifierPart2.test(part.suffix[0])) {\n        result += \"\\\\\";\n      }\n    }\n    result += escapePatternString(part.suffix);\n    if (needsGrouping) {\n      result += \"}\";\n    }\n    if (part.modifier !== 3 /* kNone */) {\n      result += modifierToString(part.modifier);\n    }\n  }\n  return result;\n}\nvar URLPattern = class {\n  constructor(init = {}, baseURLOrOptions, options) {\n    this.regexp = {};\n    this.names = {};\n    this.component_pattern = {};\n    this.parts = {};\n    try {\n      let baseURL = void 0;\n      if (typeof baseURLOrOptions === \"string\") {\n        baseURL = baseURLOrOptions;\n      } else {\n        options = baseURLOrOptions;\n      }\n      if (typeof init === \"string\") {\n        const parser = new Parser(init);\n        parser.parse();\n        init = parser.result;\n        if (baseURL === void 0 && typeof init.protocol !== \"string\") {\n          throw new TypeError(`A base URL must be provided for a relative constructor string.`);\n        }\n        init.baseURL = baseURL;\n      } else {\n        if (!init || typeof init !== \"object\") {\n          throw new TypeError(`parameter 1 is not of type 'string' and cannot convert to dictionary.`);\n        }\n        if (baseURL) {\n          throw new TypeError(`parameter 1 is not of type 'string'.`);\n        }\n      }\n      if (typeof options === \"undefined\") {\n        options = { ignoreCase: false };\n      }\n      const ignoreCaseOptions = { ignoreCase: options.ignoreCase === true };\n      const defaults = {\n        pathname: DEFAULT_PATTERN,\n        protocol: DEFAULT_PATTERN,\n        username: DEFAULT_PATTERN,\n        password: DEFAULT_PATTERN,\n        hostname: DEFAULT_PATTERN,\n        port: DEFAULT_PATTERN,\n        search: DEFAULT_PATTERN,\n        hash: DEFAULT_PATTERN\n      };\n      this.pattern = applyInit(defaults, init, true);\n      if (defaultPortForProtocol(this.pattern.protocol) === this.pattern.port) {\n        this.pattern.port = \"\";\n      }\n      let component;\n      for (component of COMPONENTS) {\n        if (!(component in this.pattern))\n          continue;\n        const options2 = {};\n        const pattern = this.pattern[component];\n        this.names[component] = [];\n        switch (component) {\n          case \"protocol\":\n            Object.assign(options2, DEFAULT_OPTIONS);\n            options2.encodePart = protocolEncodeCallback;\n            break;\n          case \"username\":\n            Object.assign(options2, DEFAULT_OPTIONS);\n            options2.encodePart = usernameEncodeCallback;\n            break;\n          case \"password\":\n            Object.assign(options2, DEFAULT_OPTIONS);\n            options2.encodePart = passwordEncodeCallback;\n            break;\n          case \"hostname\":\n            Object.assign(options2, HOSTNAME_OPTIONS);\n            if (treatAsIPv6Hostname(pattern)) {\n              options2.encodePart = ipv6HostnameEncodeCallback;\n            } else {\n              options2.encodePart = hostnameEncodeCallback;\n            }\n            break;\n          case \"port\":\n            Object.assign(options2, DEFAULT_OPTIONS);\n            options2.encodePart = portEncodeCallback;\n            break;\n          case \"pathname\":\n            if (isSpecialScheme(this.regexp.protocol)) {\n              Object.assign(options2, PATHNAME_OPTIONS, ignoreCaseOptions);\n              options2.encodePart = standardURLPathnameEncodeCallback;\n            } else {\n              Object.assign(options2, DEFAULT_OPTIONS, ignoreCaseOptions);\n              options2.encodePart = pathURLPathnameEncodeCallback;\n            }\n            break;\n          case \"search\":\n            Object.assign(options2, DEFAULT_OPTIONS, ignoreCaseOptions);\n            options2.encodePart = searchEncodeCallback;\n            break;\n          case \"hash\":\n            Object.assign(options2, DEFAULT_OPTIONS, ignoreCaseOptions);\n            options2.encodePart = hashEncodeCallback;\n            break;\n        }\n        try {\n          this.parts[component] = parse(pattern, options2);\n          this.regexp[component] = partsToRegexp(\n            this.parts[component],\n            /* out */\n            this.names[component],\n            options2\n          );\n          this.component_pattern[component] = partsToPattern(this.parts[component], options2);\n        } catch (err) {\n          throw new TypeError(`invalid ${component} pattern '${this.pattern[component]}'.`);\n        }\n      }\n    } catch (err) {\n      throw new TypeError(`Failed to construct 'URLPattern': ${err.message}`);\n    }\n  }\n  test(input = {}, baseURL) {\n    let values = {\n      pathname: \"\",\n      protocol: \"\",\n      username: \"\",\n      password: \"\",\n      hostname: \"\",\n      port: \"\",\n      search: \"\",\n      hash: \"\"\n    };\n    if (typeof input !== \"string\" && baseURL) {\n      throw new TypeError(`parameter 1 is not of type 'string'.`);\n    }\n    if (typeof input === \"undefined\") {\n      return false;\n    }\n    try {\n      if (typeof input === \"object\") {\n        values = applyInit(values, input, false);\n      } else {\n        values = applyInit(values, extractValues(input, baseURL), false);\n      }\n    } catch (err) {\n      return false;\n    }\n    let component;\n    for (component of COMPONENTS) {\n      if (!this.regexp[component].exec(values[component])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  exec(input = {}, baseURL) {\n    let values = {\n      pathname: \"\",\n      protocol: \"\",\n      username: \"\",\n      password: \"\",\n      hostname: \"\",\n      port: \"\",\n      search: \"\",\n      hash: \"\"\n    };\n    if (typeof input !== \"string\" && baseURL) {\n      throw new TypeError(`parameter 1 is not of type 'string'.`);\n    }\n    if (typeof input === \"undefined\") {\n      return;\n    }\n    try {\n      if (typeof input === \"object\") {\n        values = applyInit(values, input, false);\n      } else {\n        values = applyInit(values, extractValues(input, baseURL), false);\n      }\n    } catch (err) {\n      return null;\n    }\n    let result = {};\n    if (baseURL) {\n      result.inputs = [input, baseURL];\n    } else {\n      result.inputs = [input];\n    }\n    let component;\n    for (component of COMPONENTS) {\n      let match = this.regexp[component].exec(values[component]);\n      if (!match) {\n        return null;\n      }\n      let groups = {};\n      for (let [i, name] of this.names[component].entries()) {\n        if (typeof name === \"string\" || typeof name === \"number\") {\n          let value = match[i + 1];\n          groups[name] = value;\n        }\n      }\n      result[component] = {\n        input: values[component] ?? \"\",\n        groups\n      };\n    }\n    return result;\n  }\n  static compareComponent(component, left, right) {\n    const comparePart = (left2, right2) => {\n      for (let attr of [\"type\", \"modifier\", \"prefix\", \"value\", \"suffix\"]) {\n        if (left2[attr] < right2[attr])\n          return -1;\n        else if (left2[attr] === right2[attr])\n          continue;\n        else\n          return 1;\n      }\n      return 0;\n    };\n    const emptyFixedPart = new Part(3 /* kFixed */, \"\", \"\", \"\", \"\", 3 /* kNone */);\n    const wildcardOnlyPart = new Part(0 /* kFullWildcard */, \"\", \"\", \"\", \"\", 3 /* kNone */);\n    const comparePartList = (left2, right2) => {\n      let i = 0;\n      for (; i < Math.min(left2.length, right2.length); ++i) {\n        let result = comparePart(left2[i], right2[i]);\n        if (result)\n          return result;\n      }\n      if (left2.length === right2.length) {\n        return 0;\n      }\n      return comparePart(left2[i] ?? emptyFixedPart, right2[i] ?? emptyFixedPart);\n    };\n    if (!left.component_pattern[component] && !right.component_pattern[component]) {\n      return 0;\n    }\n    if (left.component_pattern[component] && !right.component_pattern[component]) {\n      return comparePartList(left.parts[component], [wildcardOnlyPart]);\n    }\n    if (!left.component_pattern[component] && right.component_pattern[component]) {\n      return comparePartList([wildcardOnlyPart], right.parts[component]);\n    }\n    return comparePartList(left.parts[component], right.parts[component]);\n  }\n  get protocol() {\n    return this.component_pattern.protocol;\n  }\n  get username() {\n    return this.component_pattern.username;\n  }\n  get password() {\n    return this.component_pattern.password;\n  }\n  get hostname() {\n    return this.component_pattern.hostname;\n  }\n  get port() {\n    return this.component_pattern.port;\n  }\n  get pathname() {\n    return this.component_pattern.pathname;\n  }\n  get search() {\n    return this.component_pattern.search;\n  }\n  get hash() {\n    return this.component_pattern.hash;\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3VybHBhdHRlcm4tcG9seWZpbGwvZGlzdC91cmxwYXR0ZXJuLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw0RkFBNEY7QUFDekg7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGtCQUFrQixhQUFhOztBQUVuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFNBQVM7QUFDM0MsNkNBQTZDLFlBQVk7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlEQUFpRDtBQUNyRTtBQUNBO0FBQ0Esb0JBQW9CLDZDQUE2QztBQUNqRTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbURBQW1EO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtREFBbUQ7QUFDdkU7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixvQkFBb0IseUNBQXlDO0FBQzdEO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsb0JBQW9CLDBDQUEwQztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELEVBQUU7QUFDdEQ7QUFDQTtBQUNBLG9CQUFvQixxQ0FBcUM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELEVBQUU7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsT0FBTyxPQUFPLEVBQUU7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLGtFQUFrRSxFQUFFO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELEVBQUU7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLEVBQUU7QUFDL0M7QUFDQTtBQUNBLG9CQUFvQix5Q0FBeUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHlDQUF5QztBQUMzRDtBQUNBLGdCQUFnQixrQ0FBa0M7QUFDbEQ7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsZ0NBQWdDO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx3QkFBd0I7QUFDcEMsc0NBQXNDLFVBQVUsS0FBSyxNQUFNLGFBQWEsS0FBSztBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxLQUFLO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLHdCQUF3Qix5QkFBeUIsR0FBRyxnQ0FBZ0M7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxnQ0FBZ0M7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsV0FBVyxHQUFHLGdDQUFnQztBQUNwRSxRQUFRO0FBQ1IseUJBQXlCLFdBQVcsR0FBRyxnQ0FBZ0M7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMEJBQTBCLEdBQUcsV0FBVyxHQUFHLDBCQUEwQjtBQUMzRjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMEJBQTBCO0FBQzlDLHFCQUFxQixXQUFXO0FBQ2hDO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVyxNQUFNLDBCQUEwQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwrQkFBK0I7QUFDdEQsd0JBQXdCLGdDQUFnQztBQUN4RDtBQUNBO0FBQ0EsbUJBQW1CLFVBQVU7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVUsS0FBSyxTQUFTO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVLEdBQUcsU0FBUztBQUMxQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFNBQVMsR0FBRyxTQUFTO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxNQUFNO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLE1BQU07QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsTUFBTTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxNQUFNO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLE1BQU07QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx5Q0FBeUM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTiw4Q0FBOEMsYUFBYTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxzQ0FBc0M7QUFDMUUsa0RBQWtELFlBQVk7QUFDOUQ7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixFQUFFLGlDQUFpQyxFQUFFLGdDQUFnQztBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVztBQUMvQixNQUFNO0FBQ047QUFDQSxzQkFBc0IscUJBQXFCO0FBQzNDO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1Isc0JBQXNCLG9CQUFvQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLHlDQUF5QyxXQUFXLFdBQVcsd0JBQXdCO0FBQ3ZGO0FBQ0E7QUFDQSxNQUFNO0FBQ04sK0RBQStELFlBQVk7QUFDM0U7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSwyQ0FBMkM7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGVkZ2l0eS15aWVsZC1mcm9udGVuZC8uLi9ub2RlX21vZHVsZXMvdXJscGF0dGVybi1wb2x5ZmlsbC9kaXN0L3VybHBhdHRlcm4uY2pzPzkzN2EiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbnZhciBfX2NvcHlQcm9wcyA9ICh0bywgZnJvbSwgZXhjZXB0LCBkZXNjKSA9PiB7XG4gIGlmIChmcm9tICYmIHR5cGVvZiBmcm9tID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBmcm9tID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMoZnJvbSkpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRvLCBrZXkpICYmIGtleSAhPT0gZXhjZXB0KVxuICAgICAgICBfX2RlZlByb3AodG8sIGtleSwgeyBnZXQ6ICgpID0+IGZyb21ba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhmcm9tLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRvO1xufTtcbnZhciBfX3RvQ29tbW9uSlMgPSAobW9kKSA9PiBfX2NvcHlQcm9wcyhfX2RlZlByb3Aoe30sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pLCBtb2QpO1xuXG4vLyBzcmMvdXJsLXBhdHRlcm4udHNcbnZhciB1cmxfcGF0dGVybl9leHBvcnRzID0ge307XG5fX2V4cG9ydCh1cmxfcGF0dGVybl9leHBvcnRzLCB7XG4gIFVSTFBhdHRlcm46ICgpID0+IFVSTFBhdHRlcm5cbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBfX3RvQ29tbW9uSlModXJsX3BhdHRlcm5fZXhwb3J0cyk7XG5cbi8vIHNyYy9wYXRoLXRvLXJlZ2V4LW1vZGlmaWVkLnRzXG52YXIgUGFydCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IodHlwZSwgbmFtZSwgcHJlZml4LCB2YWx1ZSwgc3VmZml4LCBtb2RpZmllcikge1xuICAgIHRoaXMudHlwZSA9IDMgLyoga0ZpeGVkICovO1xuICAgIHRoaXMubmFtZSA9IFwiXCI7XG4gICAgdGhpcy5wcmVmaXggPSBcIlwiO1xuICAgIHRoaXMudmFsdWUgPSBcIlwiO1xuICAgIHRoaXMuc3VmZml4ID0gXCJcIjtcbiAgICB0aGlzLm1vZGlmaWVyID0gMyAvKiBrTm9uZSAqLztcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5wcmVmaXggPSBwcmVmaXg7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMuc3VmZml4ID0gc3VmZml4O1xuICAgIHRoaXMubW9kaWZpZXIgPSBtb2RpZmllcjtcbiAgfVxuICBoYXNDdXN0b21OYW1lKCkge1xuICAgIHJldHVybiB0aGlzLm5hbWUgIT09IFwiXCIgJiYgdHlwZW9mIHRoaXMubmFtZSAhPT0gXCJudW1iZXJcIjtcbiAgfVxufTtcbnZhciByZWdleElkZW50aWZpZXJTdGFydCA9IC9bJF9cXHB7SURfU3RhcnR9XS91O1xudmFyIHJlZ2V4SWRlbnRpZmllclBhcnQgPSAvWyRfXFx1MjAwQ1xcdTIwMERcXHB7SURfQ29udGludWV9XS91O1xudmFyIGtGdWxsV2lsZGNhcmRSZWdleCA9IFwiLipcIjtcbmZ1bmN0aW9uIGlzQVNDSUkoc3RyLCBleHRlbmRlZCkge1xuICByZXR1cm4gKGV4dGVuZGVkID8gL15bXFx4MDAtXFx4RkZdKiQvIDogL15bXFx4MDAtXFx4N0ZdKiQvKS50ZXN0KHN0cik7XG59XG5mdW5jdGlvbiBsZXhlcihzdHIsIGxlbmllbnQgPSBmYWxzZSkge1xuICBjb25zdCB0b2tlbnMgPSBbXTtcbiAgbGV0IGkgPSAwO1xuICB3aGlsZSAoaSA8IHN0ci5sZW5ndGgpIHtcbiAgICBjb25zdCBjaGFyID0gc3RyW2ldO1xuICAgIGNvbnN0IEVycm9yT3JJbnZhbGlkID0gZnVuY3Rpb24obXNnKSB7XG4gICAgICBpZiAoIWxlbmllbnQpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IobXNnKTtcbiAgICAgIHRva2Vucy5wdXNoKHsgdHlwZTogXCJJTlZBTElEX0NIQVJcIiwgaW5kZXg6IGksIHZhbHVlOiBzdHJbaSsrXSB9KTtcbiAgICB9O1xuICAgIGlmIChjaGFyID09PSBcIipcIikge1xuICAgICAgdG9rZW5zLnB1c2goeyB0eXBlOiBcIkFTVEVSSVNLXCIsIGluZGV4OiBpLCB2YWx1ZTogc3RyW2krK10gfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGNoYXIgPT09IFwiK1wiIHx8IGNoYXIgPT09IFwiP1wiKSB7XG4gICAgICB0b2tlbnMucHVzaCh7IHR5cGU6IFwiT1RIRVJfTU9ESUZJRVJcIiwgaW5kZXg6IGksIHZhbHVlOiBzdHJbaSsrXSB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoY2hhciA9PT0gXCJcXFxcXCIpIHtcbiAgICAgIHRva2Vucy5wdXNoKHsgdHlwZTogXCJFU0NBUEVEX0NIQVJcIiwgaW5kZXg6IGkrKywgdmFsdWU6IHN0cltpKytdIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChjaGFyID09PSBcIntcIikge1xuICAgICAgdG9rZW5zLnB1c2goeyB0eXBlOiBcIk9QRU5cIiwgaW5kZXg6IGksIHZhbHVlOiBzdHJbaSsrXSB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoY2hhciA9PT0gXCJ9XCIpIHtcbiAgICAgIHRva2Vucy5wdXNoKHsgdHlwZTogXCJDTE9TRVwiLCBpbmRleDogaSwgdmFsdWU6IHN0cltpKytdIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChjaGFyID09PSBcIjpcIikge1xuICAgICAgbGV0IG5hbWUgPSBcIlwiO1xuICAgICAgbGV0IGogPSBpICsgMTtcbiAgICAgIHdoaWxlIChqIDwgc3RyLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBjb2RlID0gc3RyLnN1YnN0cihqLCAxKTtcbiAgICAgICAgaWYgKGogPT09IGkgKyAxICYmIHJlZ2V4SWRlbnRpZmllclN0YXJ0LnRlc3QoY29kZSkgfHwgaiAhPT0gaSArIDEgJiYgcmVnZXhJZGVudGlmaWVyUGFydC50ZXN0KGNvZGUpKSB7XG4gICAgICAgICAgbmFtZSArPSBzdHJbaisrXTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmICghbmFtZSkge1xuICAgICAgICBFcnJvck9ySW52YWxpZChgTWlzc2luZyBwYXJhbWV0ZXIgbmFtZSBhdCAke2l9YCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdG9rZW5zLnB1c2goeyB0eXBlOiBcIk5BTUVcIiwgaW5kZXg6IGksIHZhbHVlOiBuYW1lIH0pO1xuICAgICAgaSA9IGo7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGNoYXIgPT09IFwiKFwiKSB7XG4gICAgICBsZXQgY291bnQgPSAxO1xuICAgICAgbGV0IHBhdHRlcm4gPSBcIlwiO1xuICAgICAgbGV0IGogPSBpICsgMTtcbiAgICAgIGxldCBlcnJvciA9IGZhbHNlO1xuICAgICAgaWYgKHN0cltqXSA9PT0gXCI/XCIpIHtcbiAgICAgICAgRXJyb3JPckludmFsaWQoYFBhdHRlcm4gY2Fubm90IHN0YXJ0IHdpdGggXCI/XCIgYXQgJHtqfWApO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChqIDwgc3RyLmxlbmd0aCkge1xuICAgICAgICBpZiAoIWlzQVNDSUkoc3RyW2pdLCBmYWxzZSkpIHtcbiAgICAgICAgICBFcnJvck9ySW52YWxpZChgSW52YWxpZCBjaGFyYWN0ZXIgJyR7c3RyW2pdfScgYXQgJHtqfS5gKTtcbiAgICAgICAgICBlcnJvciA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0cltqXSA9PT0gXCJcXFxcXCIpIHtcbiAgICAgICAgICBwYXR0ZXJuICs9IHN0cltqKytdICsgc3RyW2orK107XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0cltqXSA9PT0gXCIpXCIpIHtcbiAgICAgICAgICBjb3VudC0tO1xuICAgICAgICAgIGlmIChjb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgaisrO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHN0cltqXSA9PT0gXCIoXCIpIHtcbiAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgIGlmIChzdHJbaiArIDFdICE9PSBcIj9cIikge1xuICAgICAgICAgICAgRXJyb3JPckludmFsaWQoYENhcHR1cmluZyBncm91cHMgYXJlIG5vdCBhbGxvd2VkIGF0ICR7an1gKTtcbiAgICAgICAgICAgIGVycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwYXR0ZXJuICs9IHN0cltqKytdO1xuICAgICAgfVxuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKGNvdW50KSB7XG4gICAgICAgIEVycm9yT3JJbnZhbGlkKGBVbmJhbGFuY2VkIHBhdHRlcm4gYXQgJHtpfWApO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICghcGF0dGVybikge1xuICAgICAgICBFcnJvck9ySW52YWxpZChgTWlzc2luZyBwYXR0ZXJuIGF0ICR7aX1gKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB0b2tlbnMucHVzaCh7IHR5cGU6IFwiUkVHRVhcIiwgaW5kZXg6IGksIHZhbHVlOiBwYXR0ZXJuIH0pO1xuICAgICAgaSA9IGo7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdG9rZW5zLnB1c2goeyB0eXBlOiBcIkNIQVJcIiwgaW5kZXg6IGksIHZhbHVlOiBzdHJbaSsrXSB9KTtcbiAgfVxuICB0b2tlbnMucHVzaCh7IHR5cGU6IFwiRU5EXCIsIGluZGV4OiBpLCB2YWx1ZTogXCJcIiB9KTtcbiAgcmV0dXJuIHRva2Vucztcbn1cbmZ1bmN0aW9uIHBhcnNlKHN0ciwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHRva2VucyA9IGxleGVyKHN0cik7XG4gIG9wdGlvbnMuZGVsaW1pdGVyID8/IChvcHRpb25zLmRlbGltaXRlciA9IFwiLyM/XCIpO1xuICBvcHRpb25zLnByZWZpeGVzID8/IChvcHRpb25zLnByZWZpeGVzID0gXCIuL1wiKTtcbiAgY29uc3Qgc2VnbWVudFdpbGRjYXJkUmVnZXggPSBgW14ke2VzY2FwZVN0cmluZyhvcHRpb25zLmRlbGltaXRlcil9XSs/YDtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGxldCBrZXkgPSAwO1xuICBsZXQgaSA9IDA7XG4gIGxldCBwYXRoID0gXCJcIjtcbiAgbGV0IG5hbWVTZXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBjb25zdCB0cnlDb25zdW1lID0gKHR5cGUpID0+IHtcbiAgICBpZiAoaSA8IHRva2Vucy5sZW5ndGggJiYgdG9rZW5zW2ldLnR5cGUgPT09IHR5cGUpXG4gICAgICByZXR1cm4gdG9rZW5zW2krK10udmFsdWU7XG4gIH07XG4gIGNvbnN0IHRyeUNvbnN1bWVNb2RpZmllciA9ICgpID0+IHtcbiAgICByZXR1cm4gdHJ5Q29uc3VtZShcIk9USEVSX01PRElGSUVSXCIpID8/IHRyeUNvbnN1bWUoXCJBU1RFUklTS1wiKTtcbiAgfTtcbiAgY29uc3QgbXVzdENvbnN1bWUgPSAodHlwZSkgPT4ge1xuICAgIGNvbnN0IHZhbHVlID0gdHJ5Q29uc3VtZSh0eXBlKTtcbiAgICBpZiAodmFsdWUgIT09IHZvaWQgMClcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICBjb25zdCB7IHR5cGU6IG5leHRUeXBlLCBpbmRleCB9ID0gdG9rZW5zW2ldO1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFVuZXhwZWN0ZWQgJHtuZXh0VHlwZX0gYXQgJHtpbmRleH0sIGV4cGVjdGVkICR7dHlwZX1gKTtcbiAgfTtcbiAgY29uc3QgY29uc3VtZVRleHQgPSAoKSA9PiB7XG4gICAgbGV0IHJlc3VsdDIgPSBcIlwiO1xuICAgIGxldCB2YWx1ZTtcbiAgICB3aGlsZSAodmFsdWUgPSB0cnlDb25zdW1lKFwiQ0hBUlwiKSA/PyB0cnlDb25zdW1lKFwiRVNDQVBFRF9DSEFSXCIpKSB7XG4gICAgICByZXN1bHQyICs9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0MjtcbiAgfTtcbiAgY29uc3QgRGVmYXVsdEVuY29kZVBhcnQgPSAodmFsdWUpID0+IHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG4gIGNvbnN0IGVuY29kZVBhcnQgPSBvcHRpb25zLmVuY29kZVBhcnQgfHwgRGVmYXVsdEVuY29kZVBhcnQ7XG4gIGxldCBwZW5kaW5nRml4ZWRWYWx1ZSA9IFwiXCI7XG4gIGNvbnN0IGFwcGVuZFRvUGVuZGluZ0ZpeGVkVmFsdWUgPSAodmFsdWUpID0+IHtcbiAgICBwZW5kaW5nRml4ZWRWYWx1ZSArPSB2YWx1ZTtcbiAgfTtcbiAgY29uc3QgbWF5YmVBZGRQYXJ0RnJvbVBlbmRpbmdGaXhlZFZhbHVlID0gKCkgPT4ge1xuICAgIGlmICghcGVuZGluZ0ZpeGVkVmFsdWUubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJlc3VsdC5wdXNoKG5ldyBQYXJ0KDMgLyoga0ZpeGVkICovLCBcIlwiLCBcIlwiLCBlbmNvZGVQYXJ0KHBlbmRpbmdGaXhlZFZhbHVlKSwgXCJcIiwgMyAvKiBrTm9uZSAqLykpO1xuICAgIHBlbmRpbmdGaXhlZFZhbHVlID0gXCJcIjtcbiAgfTtcbiAgY29uc3QgYWRkUGFydCA9IChwcmVmaXgsIG5hbWVUb2tlbiwgcmVnZXhPcldpbGRjYXJkVG9rZW4sIHN1ZmZpeCwgbW9kaWZpZXJUb2tlbikgPT4ge1xuICAgIGxldCBtb2RpZmllciA9IDMgLyoga05vbmUgKi87XG4gICAgc3dpdGNoIChtb2RpZmllclRva2VuKSB7XG4gICAgICBjYXNlIFwiP1wiOlxuICAgICAgICBtb2RpZmllciA9IDEgLyoga09wdGlvbmFsICovO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCIqXCI6XG4gICAgICAgIG1vZGlmaWVyID0gMCAvKiBrWmVyb09yTW9yZSAqLztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiK1wiOlxuICAgICAgICBtb2RpZmllciA9IDIgLyoga09uZU9yTW9yZSAqLztcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmICghbmFtZVRva2VuICYmICFyZWdleE9yV2lsZGNhcmRUb2tlbiAmJiBtb2RpZmllciA9PT0gMyAvKiBrTm9uZSAqLykge1xuICAgICAgYXBwZW5kVG9QZW5kaW5nRml4ZWRWYWx1ZShwcmVmaXgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBtYXliZUFkZFBhcnRGcm9tUGVuZGluZ0ZpeGVkVmFsdWUoKTtcbiAgICBpZiAoIW5hbWVUb2tlbiAmJiAhcmVnZXhPcldpbGRjYXJkVG9rZW4pIHtcbiAgICAgIGlmICghcHJlZml4KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5wdXNoKG5ldyBQYXJ0KDMgLyoga0ZpeGVkICovLCBcIlwiLCBcIlwiLCBlbmNvZGVQYXJ0KHByZWZpeCksIFwiXCIsIG1vZGlmaWVyKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCByZWdleFZhbHVlO1xuICAgIGlmICghcmVnZXhPcldpbGRjYXJkVG9rZW4pIHtcbiAgICAgIHJlZ2V4VmFsdWUgPSBzZWdtZW50V2lsZGNhcmRSZWdleDtcbiAgICB9IGVsc2UgaWYgKHJlZ2V4T3JXaWxkY2FyZFRva2VuID09PSBcIipcIikge1xuICAgICAgcmVnZXhWYWx1ZSA9IGtGdWxsV2lsZGNhcmRSZWdleDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVnZXhWYWx1ZSA9IHJlZ2V4T3JXaWxkY2FyZFRva2VuO1xuICAgIH1cbiAgICBsZXQgdHlwZSA9IDIgLyoga1JlZ2V4ICovO1xuICAgIGlmIChyZWdleFZhbHVlID09PSBzZWdtZW50V2lsZGNhcmRSZWdleCkge1xuICAgICAgdHlwZSA9IDEgLyoga1NlZ21lbnRXaWxkY2FyZCAqLztcbiAgICAgIHJlZ2V4VmFsdWUgPSBcIlwiO1xuICAgIH0gZWxzZSBpZiAocmVnZXhWYWx1ZSA9PT0ga0Z1bGxXaWxkY2FyZFJlZ2V4KSB7XG4gICAgICB0eXBlID0gMCAvKiBrRnVsbFdpbGRjYXJkICovO1xuICAgICAgcmVnZXhWYWx1ZSA9IFwiXCI7XG4gICAgfVxuICAgIGxldCBuYW1lO1xuICAgIGlmIChuYW1lVG9rZW4pIHtcbiAgICAgIG5hbWUgPSBuYW1lVG9rZW47XG4gICAgfSBlbHNlIGlmIChyZWdleE9yV2lsZGNhcmRUb2tlbikge1xuICAgICAgbmFtZSA9IGtleSsrO1xuICAgIH1cbiAgICBpZiAobmFtZVNldC5oYXMobmFtZSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYER1cGxpY2F0ZSBuYW1lICcke25hbWV9Jy5gKTtcbiAgICB9XG4gICAgbmFtZVNldC5hZGQobmFtZSk7XG4gICAgcmVzdWx0LnB1c2gobmV3IFBhcnQodHlwZSwgbmFtZSwgZW5jb2RlUGFydChwcmVmaXgpLCByZWdleFZhbHVlLCBlbmNvZGVQYXJ0KHN1ZmZpeCksIG1vZGlmaWVyKSk7XG4gIH07XG4gIHdoaWxlIChpIDwgdG9rZW5zLmxlbmd0aCkge1xuICAgIGNvbnN0IGNoYXJUb2tlbiA9IHRyeUNvbnN1bWUoXCJDSEFSXCIpO1xuICAgIGNvbnN0IG5hbWVUb2tlbiA9IHRyeUNvbnN1bWUoXCJOQU1FXCIpO1xuICAgIGxldCByZWdleE9yV2lsZGNhcmRUb2tlbiA9IHRyeUNvbnN1bWUoXCJSRUdFWFwiKTtcbiAgICBpZiAoIW5hbWVUb2tlbiAmJiAhcmVnZXhPcldpbGRjYXJkVG9rZW4pIHtcbiAgICAgIHJlZ2V4T3JXaWxkY2FyZFRva2VuID0gdHJ5Q29uc3VtZShcIkFTVEVSSVNLXCIpO1xuICAgIH1cbiAgICBpZiAobmFtZVRva2VuIHx8IHJlZ2V4T3JXaWxkY2FyZFRva2VuKSB7XG4gICAgICBsZXQgcHJlZml4ID0gY2hhclRva2VuID8/IFwiXCI7XG4gICAgICBpZiAob3B0aW9ucy5wcmVmaXhlcy5pbmRleE9mKHByZWZpeCkgPT09IC0xKSB7XG4gICAgICAgIGFwcGVuZFRvUGVuZGluZ0ZpeGVkVmFsdWUocHJlZml4KTtcbiAgICAgICAgcHJlZml4ID0gXCJcIjtcbiAgICAgIH1cbiAgICAgIG1heWJlQWRkUGFydEZyb21QZW5kaW5nRml4ZWRWYWx1ZSgpO1xuICAgICAgbGV0IG1vZGlmaWVyVG9rZW4gPSB0cnlDb25zdW1lTW9kaWZpZXIoKTtcbiAgICAgIGFkZFBhcnQocHJlZml4LCBuYW1lVG9rZW4sIHJlZ2V4T3JXaWxkY2FyZFRva2VuLCBcIlwiLCBtb2RpZmllclRva2VuKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZSA9IGNoYXJUb2tlbiA/PyB0cnlDb25zdW1lKFwiRVNDQVBFRF9DSEFSXCIpO1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgYXBwZW5kVG9QZW5kaW5nRml4ZWRWYWx1ZSh2YWx1ZSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3Qgb3BlblRva2VuID0gdHJ5Q29uc3VtZShcIk9QRU5cIik7XG4gICAgaWYgKG9wZW5Ub2tlbikge1xuICAgICAgY29uc3QgcHJlZml4ID0gY29uc3VtZVRleHQoKTtcbiAgICAgIGNvbnN0IG5hbWVUb2tlbjIgPSB0cnlDb25zdW1lKFwiTkFNRVwiKTtcbiAgICAgIGxldCByZWdleE9yV2lsZGNhcmRUb2tlbjIgPSB0cnlDb25zdW1lKFwiUkVHRVhcIik7XG4gICAgICBpZiAoIW5hbWVUb2tlbjIgJiYgIXJlZ2V4T3JXaWxkY2FyZFRva2VuMikge1xuICAgICAgICByZWdleE9yV2lsZGNhcmRUb2tlbjIgPSB0cnlDb25zdW1lKFwiQVNURVJJU0tcIik7XG4gICAgICB9XG4gICAgICBjb25zdCBzdWZmaXggPSBjb25zdW1lVGV4dCgpO1xuICAgICAgbXVzdENvbnN1bWUoXCJDTE9TRVwiKTtcbiAgICAgIGNvbnN0IG1vZGlmaWVyVG9rZW4gPSB0cnlDb25zdW1lTW9kaWZpZXIoKTtcbiAgICAgIGFkZFBhcnQocHJlZml4LCBuYW1lVG9rZW4yLCByZWdleE9yV2lsZGNhcmRUb2tlbjIsIHN1ZmZpeCwgbW9kaWZpZXJUb2tlbik7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgbWF5YmVBZGRQYXJ0RnJvbVBlbmRpbmdGaXhlZFZhbHVlKCk7XG4gICAgbXVzdENvbnN1bWUoXCJFTkRcIik7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGVzY2FwZVN0cmluZyhzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC8oWy4rKj9eJHt9KClbXFxdfC9cXFxcXSkvZywgXCJcXFxcJDFcIik7XG59XG5mdW5jdGlvbiBmbGFncyhvcHRpb25zKSB7XG4gIHJldHVybiBvcHRpb25zICYmIG9wdGlvbnMuaWdub3JlQ2FzZSA/IFwidWlcIiA6IFwidVwiO1xufVxuZnVuY3Rpb24gc3RyaW5nVG9SZWdleHAocGF0aCwgbmFtZXMsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHBhcnRzVG9SZWdleHAocGFyc2UocGF0aCwgb3B0aW9ucyksIG5hbWVzLCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIG1vZGlmaWVyVG9TdHJpbmcobW9kaWZpZXIpIHtcbiAgc3dpdGNoIChtb2RpZmllcikge1xuICAgIGNhc2UgMCAvKiBrWmVyb09yTW9yZSAqLzpcbiAgICAgIHJldHVybiBcIipcIjtcbiAgICBjYXNlIDEgLyoga09wdGlvbmFsICovOlxuICAgICAgcmV0dXJuIFwiP1wiO1xuICAgIGNhc2UgMiAvKiBrT25lT3JNb3JlICovOlxuICAgICAgcmV0dXJuIFwiK1wiO1xuICAgIGNhc2UgMyAvKiBrTm9uZSAqLzpcbiAgICAgIHJldHVybiBcIlwiO1xuICB9XG59XG5mdW5jdGlvbiBwYXJ0c1RvUmVnZXhwKHBhcnRzLCBuYW1lcywgb3B0aW9ucyA9IHt9KSB7XG4gIG9wdGlvbnMuZGVsaW1pdGVyID8/IChvcHRpb25zLmRlbGltaXRlciA9IFwiLyM/XCIpO1xuICBvcHRpb25zLnByZWZpeGVzID8/IChvcHRpb25zLnByZWZpeGVzID0gXCIuL1wiKTtcbiAgb3B0aW9ucy5zZW5zaXRpdmUgPz8gKG9wdGlvbnMuc2Vuc2l0aXZlID0gZmFsc2UpO1xuICBvcHRpb25zLnN0cmljdCA/PyAob3B0aW9ucy5zdHJpY3QgPSBmYWxzZSk7XG4gIG9wdGlvbnMuZW5kID8/IChvcHRpb25zLmVuZCA9IHRydWUpO1xuICBvcHRpb25zLnN0YXJ0ID8/IChvcHRpb25zLnN0YXJ0ID0gdHJ1ZSk7XG4gIG9wdGlvbnMuZW5kc1dpdGggPSBcIlwiO1xuICBsZXQgcmVzdWx0ID0gb3B0aW9ucy5zdGFydCA/IFwiXlwiIDogXCJcIjtcbiAgZm9yIChjb25zdCBwYXJ0IG9mIHBhcnRzKSB7XG4gICAgaWYgKHBhcnQudHlwZSA9PT0gMyAvKiBrRml4ZWQgKi8pIHtcbiAgICAgIGlmIChwYXJ0Lm1vZGlmaWVyID09PSAzIC8qIGtOb25lICovKSB7XG4gICAgICAgIHJlc3VsdCArPSBlc2NhcGVTdHJpbmcocGFydC52YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgKz0gYCg/OiR7ZXNjYXBlU3RyaW5nKHBhcnQudmFsdWUpfSkke21vZGlmaWVyVG9TdHJpbmcocGFydC5tb2RpZmllcil9YDtcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAobmFtZXMpXG4gICAgICBuYW1lcy5wdXNoKHBhcnQubmFtZSk7XG4gICAgY29uc3Qgc2VnbWVudFdpbGRjYXJkUmVnZXggPSBgW14ke2VzY2FwZVN0cmluZyhvcHRpb25zLmRlbGltaXRlcil9XSs/YDtcbiAgICBsZXQgcmVnZXhWYWx1ZSA9IHBhcnQudmFsdWU7XG4gICAgaWYgKHBhcnQudHlwZSA9PT0gMSAvKiBrU2VnbWVudFdpbGRjYXJkICovKVxuICAgICAgcmVnZXhWYWx1ZSA9IHNlZ21lbnRXaWxkY2FyZFJlZ2V4O1xuICAgIGVsc2UgaWYgKHBhcnQudHlwZSA9PT0gMCAvKiBrRnVsbFdpbGRjYXJkICovKVxuICAgICAgcmVnZXhWYWx1ZSA9IGtGdWxsV2lsZGNhcmRSZWdleDtcbiAgICBpZiAoIXBhcnQucHJlZml4Lmxlbmd0aCAmJiAhcGFydC5zdWZmaXgubGVuZ3RoKSB7XG4gICAgICBpZiAocGFydC5tb2RpZmllciA9PT0gMyAvKiBrTm9uZSAqLyB8fCBwYXJ0Lm1vZGlmaWVyID09PSAxIC8qIGtPcHRpb25hbCAqLykge1xuICAgICAgICByZXN1bHQgKz0gYCgke3JlZ2V4VmFsdWV9KSR7bW9kaWZpZXJUb1N0cmluZyhwYXJ0Lm1vZGlmaWVyKX1gO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ICs9IGAoKD86JHtyZWdleFZhbHVlfSkke21vZGlmaWVyVG9TdHJpbmcocGFydC5tb2RpZmllcil9KWA7XG4gICAgICB9XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHBhcnQubW9kaWZpZXIgPT09IDMgLyoga05vbmUgKi8gfHwgcGFydC5tb2RpZmllciA9PT0gMSAvKiBrT3B0aW9uYWwgKi8pIHtcbiAgICAgIHJlc3VsdCArPSBgKD86JHtlc2NhcGVTdHJpbmcocGFydC5wcmVmaXgpfSgke3JlZ2V4VmFsdWV9KSR7ZXNjYXBlU3RyaW5nKHBhcnQuc3VmZml4KX0pYDtcbiAgICAgIHJlc3VsdCArPSBtb2RpZmllclRvU3RyaW5nKHBhcnQubW9kaWZpZXIpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHJlc3VsdCArPSBgKD86JHtlc2NhcGVTdHJpbmcocGFydC5wcmVmaXgpfWA7XG4gICAgcmVzdWx0ICs9IGAoKD86JHtyZWdleFZhbHVlfSkoPzpgO1xuICAgIHJlc3VsdCArPSBlc2NhcGVTdHJpbmcocGFydC5zdWZmaXgpO1xuICAgIHJlc3VsdCArPSBlc2NhcGVTdHJpbmcocGFydC5wcmVmaXgpO1xuICAgIHJlc3VsdCArPSBgKD86JHtyZWdleFZhbHVlfSkpKikke2VzY2FwZVN0cmluZyhwYXJ0LnN1ZmZpeCl9KWA7XG4gICAgaWYgKHBhcnQubW9kaWZpZXIgPT09IDAgLyoga1plcm9Pck1vcmUgKi8pIHtcbiAgICAgIHJlc3VsdCArPSBcIj9cIjtcbiAgICB9XG4gIH1cbiAgY29uc3QgZW5kc1dpdGggPSBgWyR7ZXNjYXBlU3RyaW5nKG9wdGlvbnMuZW5kc1dpdGgpfV18JGA7XG4gIGNvbnN0IGRlbGltaXRlciA9IGBbJHtlc2NhcGVTdHJpbmcob3B0aW9ucy5kZWxpbWl0ZXIpfV1gO1xuICBpZiAob3B0aW9ucy5lbmQpIHtcbiAgICBpZiAoIW9wdGlvbnMuc3RyaWN0KSB7XG4gICAgICByZXN1bHQgKz0gYCR7ZGVsaW1pdGVyfT9gO1xuICAgIH1cbiAgICBpZiAoIW9wdGlvbnMuZW5kc1dpdGgubGVuZ3RoKSB7XG4gICAgICByZXN1bHQgKz0gXCIkXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCArPSBgKD89JHtlbmRzV2l0aH0pYDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAocmVzdWx0LCBmbGFncyhvcHRpb25zKSk7XG4gIH1cbiAgaWYgKCFvcHRpb25zLnN0cmljdCkge1xuICAgIHJlc3VsdCArPSBgKD86JHtkZWxpbWl0ZXJ9KD89JHtlbmRzV2l0aH0pKT9gO1xuICB9XG4gIGxldCBpc0VuZERlbGltaXRlZCA9IGZhbHNlO1xuICBpZiAocGFydHMubGVuZ3RoKSB7XG4gICAgY29uc3QgbGFzdFBhcnQgPSBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXTtcbiAgICBpZiAobGFzdFBhcnQudHlwZSA9PT0gMyAvKiBrRml4ZWQgKi8gJiYgbGFzdFBhcnQubW9kaWZpZXIgPT09IDMgLyoga05vbmUgKi8pIHtcbiAgICAgIGlzRW5kRGVsaW1pdGVkID0gb3B0aW9ucy5kZWxpbWl0ZXIuaW5kZXhPZihsYXN0UGFydCkgPiAtMTtcbiAgICB9XG4gIH1cbiAgaWYgKCFpc0VuZERlbGltaXRlZCkge1xuICAgIHJlc3VsdCArPSBgKD89JHtkZWxpbWl0ZXJ9fCR7ZW5kc1dpdGh9KWA7XG4gIH1cbiAgcmV0dXJuIG5ldyBSZWdFeHAocmVzdWx0LCBmbGFncyhvcHRpb25zKSk7XG59XG5cbi8vIHNyYy91cmwtdXRpbHMudHNcbnZhciBERUZBVUxUX09QVElPTlMgPSB7XG4gIGRlbGltaXRlcjogXCJcIixcbiAgcHJlZml4ZXM6IFwiXCIsXG4gIHNlbnNpdGl2ZTogdHJ1ZSxcbiAgc3RyaWN0OiB0cnVlXG59O1xudmFyIEhPU1ROQU1FX09QVElPTlMgPSB7XG4gIGRlbGltaXRlcjogXCIuXCIsXG4gIHByZWZpeGVzOiBcIlwiLFxuICBzZW5zaXRpdmU6IHRydWUsXG4gIHN0cmljdDogdHJ1ZVxufTtcbnZhciBQQVRITkFNRV9PUFRJT05TID0ge1xuICBkZWxpbWl0ZXI6IFwiL1wiLFxuICBwcmVmaXhlczogXCIvXCIsXG4gIHNlbnNpdGl2ZTogdHJ1ZSxcbiAgc3RyaWN0OiB0cnVlXG59O1xuZnVuY3Rpb24gaXNBYnNvbHV0ZVBhdGhuYW1lKHBhdGhuYW1lLCBpc1BhdHRlcm4pIHtcbiAgaWYgKCFwYXRobmFtZS5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHBhdGhuYW1lWzBdID09PSBcIi9cIikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICghaXNQYXR0ZXJuKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChwYXRobmFtZS5sZW5ndGggPCAyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICgocGF0aG5hbWVbMF0gPT0gXCJcXFxcXCIgfHwgcGF0aG5hbWVbMF0gPT0gXCJ7XCIpICYmIHBhdGhuYW1lWzFdID09IFwiL1wiKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gbWF5YmVTdHJpcFByZWZpeCh2YWx1ZSwgcHJlZml4KSB7XG4gIGlmICh2YWx1ZS5zdGFydHNXaXRoKHByZWZpeCkpIHtcbiAgICByZXR1cm4gdmFsdWUuc3Vic3RyaW5nKHByZWZpeC5sZW5ndGgsIHZhbHVlLmxlbmd0aCk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gbWF5YmVTdHJpcFN1ZmZpeCh2YWx1ZSwgc3VmZml4KSB7XG4gIGlmICh2YWx1ZS5lbmRzV2l0aChzdWZmaXgpKSB7XG4gICAgcmV0dXJuIHZhbHVlLnN1YnN0cigwLCB2YWx1ZS5sZW5ndGggLSBzdWZmaXgubGVuZ3RoKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiB0cmVhdEFzSVB2Nkhvc3RuYW1lKHZhbHVlKSB7XG4gIGlmICghdmFsdWUgfHwgdmFsdWUubGVuZ3RoIDwgMikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodmFsdWVbMF0gPT09IFwiW1wiKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKCh2YWx1ZVswXSA9PT0gXCJcXFxcXCIgfHwgdmFsdWVbMF0gPT09IFwie1wiKSAmJiB2YWx1ZVsxXSA9PT0gXCJbXCIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG52YXIgU1BFQ0lBTF9TQ0hFTUVTID0gW1xuICBcImZ0cFwiLFxuICBcImZpbGVcIixcbiAgXCJodHRwXCIsXG4gIFwiaHR0cHNcIixcbiAgXCJ3c1wiLFxuICBcIndzc1wiXG5dO1xuZnVuY3Rpb24gaXNTcGVjaWFsU2NoZW1lKHByb3RvY29sX3JlZ2V4cCkge1xuICBpZiAoIXByb3RvY29sX3JlZ2V4cCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGZvciAoY29uc3Qgc2NoZW1lIG9mIFNQRUNJQUxfU0NIRU1FUykge1xuICAgIGlmIChwcm90b2NvbF9yZWdleHAudGVzdChzY2hlbWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gY2Fub25pY2FsaXplSGFzaChoYXNoLCBpc1BhdHRlcm4pIHtcbiAgaGFzaCA9IG1heWJlU3RyaXBQcmVmaXgoaGFzaCwgXCIjXCIpO1xuICBpZiAoaXNQYXR0ZXJuIHx8IGhhc2ggPT09IFwiXCIpIHtcbiAgICByZXR1cm4gaGFzaDtcbiAgfVxuICBjb25zdCB1cmwgPSBuZXcgVVJMKFwiaHR0cHM6Ly9leGFtcGxlLmNvbVwiKTtcbiAgdXJsLmhhc2ggPSBoYXNoO1xuICByZXR1cm4gdXJsLmhhc2ggPyB1cmwuaGFzaC5zdWJzdHJpbmcoMSwgdXJsLmhhc2gubGVuZ3RoKSA6IFwiXCI7XG59XG5mdW5jdGlvbiBjYW5vbmljYWxpemVTZWFyY2goc2VhcmNoLCBpc1BhdHRlcm4pIHtcbiAgc2VhcmNoID0gbWF5YmVTdHJpcFByZWZpeChzZWFyY2gsIFwiP1wiKTtcbiAgaWYgKGlzUGF0dGVybiB8fCBzZWFyY2ggPT09IFwiXCIpIHtcbiAgICByZXR1cm4gc2VhcmNoO1xuICB9XG4gIGNvbnN0IHVybCA9IG5ldyBVUkwoXCJodHRwczovL2V4YW1wbGUuY29tXCIpO1xuICB1cmwuc2VhcmNoID0gc2VhcmNoO1xuICByZXR1cm4gdXJsLnNlYXJjaCA/IHVybC5zZWFyY2guc3Vic3RyaW5nKDEsIHVybC5zZWFyY2gubGVuZ3RoKSA6IFwiXCI7XG59XG5mdW5jdGlvbiBjYW5vbmljYWxpemVIb3N0bmFtZShob3N0bmFtZSwgaXNQYXR0ZXJuKSB7XG4gIGlmIChpc1BhdHRlcm4gfHwgaG9zdG5hbWUgPT09IFwiXCIpIHtcbiAgICByZXR1cm4gaG9zdG5hbWU7XG4gIH1cbiAgaWYgKHRyZWF0QXNJUHY2SG9zdG5hbWUoaG9zdG5hbWUpKSB7XG4gICAgcmV0dXJuIGlwdjZIb3N0bmFtZUVuY29kZUNhbGxiYWNrKGhvc3RuYW1lKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gaG9zdG5hbWVFbmNvZGVDYWxsYmFjayhob3N0bmFtZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNhbm9uaWNhbGl6ZVBhc3N3b3JkKHBhc3N3b3JkLCBpc1BhdHRlcm4pIHtcbiAgaWYgKGlzUGF0dGVybiB8fCBwYXNzd29yZCA9PT0gXCJcIikge1xuICAgIHJldHVybiBwYXNzd29yZDtcbiAgfVxuICBjb25zdCB1cmwgPSBuZXcgVVJMKFwiaHR0cHM6Ly9leGFtcGxlLmNvbVwiKTtcbiAgdXJsLnBhc3N3b3JkID0gcGFzc3dvcmQ7XG4gIHJldHVybiB1cmwucGFzc3dvcmQ7XG59XG5mdW5jdGlvbiBjYW5vbmljYWxpemVVc2VybmFtZSh1c2VybmFtZSwgaXNQYXR0ZXJuKSB7XG4gIGlmIChpc1BhdHRlcm4gfHwgdXNlcm5hbWUgPT09IFwiXCIpIHtcbiAgICByZXR1cm4gdXNlcm5hbWU7XG4gIH1cbiAgY29uc3QgdXJsID0gbmV3IFVSTChcImh0dHBzOi8vZXhhbXBsZS5jb21cIik7XG4gIHVybC51c2VybmFtZSA9IHVzZXJuYW1lO1xuICByZXR1cm4gdXJsLnVzZXJuYW1lO1xufVxuZnVuY3Rpb24gY2Fub25pY2FsaXplUGF0aG5hbWUocGF0aG5hbWUsIHByb3RvY29sLCBpc1BhdHRlcm4pIHtcbiAgaWYgKGlzUGF0dGVybiB8fCBwYXRobmFtZSA9PT0gXCJcIikge1xuICAgIHJldHVybiBwYXRobmFtZTtcbiAgfVxuICBpZiAocHJvdG9jb2wgJiYgIVNQRUNJQUxfU0NIRU1FUy5pbmNsdWRlcyhwcm90b2NvbCkpIHtcbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKGAke3Byb3RvY29sfToke3BhdGhuYW1lfWApO1xuICAgIHJldHVybiB1cmwucGF0aG5hbWU7XG4gIH1cbiAgY29uc3QgbGVhZGluZ1NsYXNoID0gcGF0aG5hbWVbMF0gPT0gXCIvXCI7XG4gIHBhdGhuYW1lID0gbmV3IFVSTChcbiAgICAhbGVhZGluZ1NsYXNoID8gXCIvLVwiICsgcGF0aG5hbWUgOiBwYXRobmFtZSxcbiAgICBcImh0dHBzOi8vZXhhbXBsZS5jb21cIlxuICApLnBhdGhuYW1lO1xuICBpZiAoIWxlYWRpbmdTbGFzaCkge1xuICAgIHBhdGhuYW1lID0gcGF0aG5hbWUuc3Vic3RyaW5nKDIsIHBhdGhuYW1lLmxlbmd0aCk7XG4gIH1cbiAgcmV0dXJuIHBhdGhuYW1lO1xufVxuZnVuY3Rpb24gY2Fub25pY2FsaXplUG9ydChwb3J0LCBwcm90b2NvbCwgaXNQYXR0ZXJuKSB7XG4gIGlmIChkZWZhdWx0UG9ydEZvclByb3RvY29sKHByb3RvY29sKSA9PT0gcG9ydCkge1xuICAgIHBvcnQgPSBcIlwiO1xuICB9XG4gIGlmIChpc1BhdHRlcm4gfHwgcG9ydCA9PT0gXCJcIikge1xuICAgIHJldHVybiBwb3J0O1xuICB9XG4gIHJldHVybiBwb3J0RW5jb2RlQ2FsbGJhY2socG9ydCk7XG59XG5mdW5jdGlvbiBjYW5vbmljYWxpemVQcm90b2NvbChwcm90b2NvbCwgaXNQYXR0ZXJuKSB7XG4gIHByb3RvY29sID0gbWF5YmVTdHJpcFN1ZmZpeChwcm90b2NvbCwgXCI6XCIpO1xuICBpZiAoaXNQYXR0ZXJuIHx8IHByb3RvY29sID09PSBcIlwiKSB7XG4gICAgcmV0dXJuIHByb3RvY29sO1xuICB9XG4gIHJldHVybiBwcm90b2NvbEVuY29kZUNhbGxiYWNrKHByb3RvY29sKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRQb3J0Rm9yUHJvdG9jb2wocHJvdG9jb2wpIHtcbiAgc3dpdGNoIChwcm90b2NvbCkge1xuICAgIGNhc2UgXCJ3c1wiOlxuICAgIGNhc2UgXCJodHRwXCI6XG4gICAgICByZXR1cm4gXCI4MFwiO1xuICAgIGNhc2UgXCJ3d3NcIjpcbiAgICBjYXNlIFwiaHR0cHNcIjpcbiAgICAgIHJldHVybiBcIjQ0M1wiO1xuICAgIGNhc2UgXCJmdHBcIjpcbiAgICAgIHJldHVybiBcIjIxXCI7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBcIlwiO1xuICB9XG59XG5mdW5jdGlvbiBwcm90b2NvbEVuY29kZUNhbGxiYWNrKGlucHV0KSB7XG4gIGlmIChpbnB1dCA9PT0gXCJcIikge1xuICAgIHJldHVybiBpbnB1dDtcbiAgfVxuICBpZiAoL15bLSsuQS1aYS16MC05XSokLy50ZXN0KGlucHV0KSlcbiAgICByZXR1cm4gaW5wdXQudG9Mb3dlckNhc2UoKTtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBwcm90b2NvbCAnJHtpbnB1dH0nLmApO1xufVxuZnVuY3Rpb24gdXNlcm5hbWVFbmNvZGVDYWxsYmFjayhpbnB1dCkge1xuICBpZiAoaW5wdXQgPT09IFwiXCIpIHtcbiAgICByZXR1cm4gaW5wdXQ7XG4gIH1cbiAgY29uc3QgdXJsID0gbmV3IFVSTChcImh0dHBzOi8vZXhhbXBsZS5jb21cIik7XG4gIHVybC51c2VybmFtZSA9IGlucHV0O1xuICByZXR1cm4gdXJsLnVzZXJuYW1lO1xufVxuZnVuY3Rpb24gcGFzc3dvcmRFbmNvZGVDYWxsYmFjayhpbnB1dCkge1xuICBpZiAoaW5wdXQgPT09IFwiXCIpIHtcbiAgICByZXR1cm4gaW5wdXQ7XG4gIH1cbiAgY29uc3QgdXJsID0gbmV3IFVSTChcImh0dHBzOi8vZXhhbXBsZS5jb21cIik7XG4gIHVybC5wYXNzd29yZCA9IGlucHV0O1xuICByZXR1cm4gdXJsLnBhc3N3b3JkO1xufVxuZnVuY3Rpb24gaG9zdG5hbWVFbmNvZGVDYWxsYmFjayhpbnB1dCkge1xuICBpZiAoaW5wdXQgPT09IFwiXCIpIHtcbiAgICByZXR1cm4gaW5wdXQ7XG4gIH1cbiAgaWYgKC9bXFx0XFxuXFxyICMlLzo8Pj9AW1xcXV5cXFxcfF0vZy50ZXN0KGlucHV0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgaG9zdG5hbWUgJyR7aW5wdXR9J2ApO1xuICB9XG4gIGNvbnN0IHVybCA9IG5ldyBVUkwoXCJodHRwczovL2V4YW1wbGUuY29tXCIpO1xuICB1cmwuaG9zdG5hbWUgPSBpbnB1dDtcbiAgcmV0dXJuIHVybC5ob3N0bmFtZTtcbn1cbmZ1bmN0aW9uIGlwdjZIb3N0bmFtZUVuY29kZUNhbGxiYWNrKGlucHV0KSB7XG4gIGlmIChpbnB1dCA9PT0gXCJcIikge1xuICAgIHJldHVybiBpbnB1dDtcbiAgfVxuICBpZiAoL1teMC05YS1mQS1GW1xcXTpdL2cudGVzdChpbnB1dCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIElQdjYgaG9zdG5hbWUgJyR7aW5wdXR9J2ApO1xuICB9XG4gIHJldHVybiBpbnB1dC50b0xvd2VyQ2FzZSgpO1xufVxuZnVuY3Rpb24gcG9ydEVuY29kZUNhbGxiYWNrKGlucHV0KSB7XG4gIGlmIChpbnB1dCA9PT0gXCJcIikge1xuICAgIHJldHVybiBpbnB1dDtcbiAgfVxuICBpZiAoL15bMC05XSokLy50ZXN0KGlucHV0KSAmJiBwYXJzZUludChpbnB1dCkgPD0gNjU1MzUpIHtcbiAgICByZXR1cm4gaW5wdXQ7XG4gIH1cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBwb3J0ICcke2lucHV0fScuYCk7XG59XG5mdW5jdGlvbiBzdGFuZGFyZFVSTFBhdGhuYW1lRW5jb2RlQ2FsbGJhY2soaW5wdXQpIHtcbiAgaWYgKGlucHV0ID09PSBcIlwiKSB7XG4gICAgcmV0dXJuIGlucHV0O1xuICB9XG4gIGNvbnN0IHVybCA9IG5ldyBVUkwoXCJodHRwczovL2V4YW1wbGUuY29tXCIpO1xuICB1cmwucGF0aG5hbWUgPSBpbnB1dFswXSAhPT0gXCIvXCIgPyBcIi8tXCIgKyBpbnB1dCA6IGlucHV0O1xuICBpZiAoaW5wdXRbMF0gIT09IFwiL1wiKSB7XG4gICAgcmV0dXJuIHVybC5wYXRobmFtZS5zdWJzdHJpbmcoMiwgdXJsLnBhdGhuYW1lLmxlbmd0aCk7XG4gIH1cbiAgcmV0dXJuIHVybC5wYXRobmFtZTtcbn1cbmZ1bmN0aW9uIHBhdGhVUkxQYXRobmFtZUVuY29kZUNhbGxiYWNrKGlucHV0KSB7XG4gIGlmIChpbnB1dCA9PT0gXCJcIikge1xuICAgIHJldHVybiBpbnB1dDtcbiAgfVxuICBjb25zdCB1cmwgPSBuZXcgVVJMKGBkYXRhOiR7aW5wdXR9YCk7XG4gIHJldHVybiB1cmwucGF0aG5hbWU7XG59XG5mdW5jdGlvbiBzZWFyY2hFbmNvZGVDYWxsYmFjayhpbnB1dCkge1xuICBpZiAoaW5wdXQgPT09IFwiXCIpIHtcbiAgICByZXR1cm4gaW5wdXQ7XG4gIH1cbiAgY29uc3QgdXJsID0gbmV3IFVSTChcImh0dHBzOi8vZXhhbXBsZS5jb21cIik7XG4gIHVybC5zZWFyY2ggPSBpbnB1dDtcbiAgcmV0dXJuIHVybC5zZWFyY2guc3Vic3RyaW5nKDEsIHVybC5zZWFyY2gubGVuZ3RoKTtcbn1cbmZ1bmN0aW9uIGhhc2hFbmNvZGVDYWxsYmFjayhpbnB1dCkge1xuICBpZiAoaW5wdXQgPT09IFwiXCIpIHtcbiAgICByZXR1cm4gaW5wdXQ7XG4gIH1cbiAgY29uc3QgdXJsID0gbmV3IFVSTChcImh0dHBzOi8vZXhhbXBsZS5jb21cIik7XG4gIHVybC5oYXNoID0gaW5wdXQ7XG4gIHJldHVybiB1cmwuaGFzaC5zdWJzdHJpbmcoMSwgdXJsLmhhc2gubGVuZ3RoKTtcbn1cblxuLy8gc3JjL3VybC1wYXR0ZXJuLXBhcnNlci50c1xudmFyIFBhcnNlciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoaW5wdXQpIHtcbiAgICAvLyBUaGUgbGlzdCBvZiBgTGV4VG9rZW5gcyBwcm9kdWNlZCBieSB0aGUgcGF0aC10by1yZWdleHAgYGxleGVyKClgIGZ1bmN0aW9uXG4gICAgLy8gd2hlbiBwYXNzZWQgYGlucHV0YCB3aXRoIGxlbmllbnQgbW9kZSBlbmFibGVkLlxuICAgIHRoaXMudG9rZW5MaXN0ID0gW107XG4gICAgLy8gQXMgd2UgcGFyc2UgdGhlIGlucHV0IHN0cmluZyB3ZSBwb3B1bGF0ZSBhIGBVUkxQYXR0ZXJuSW5pdGAgZGljdGlvbmFyeVxuICAgIC8vIHdpdGggZWFjaCBjb21wb25lbnQgcGF0dGVybi4gIFRoaXMgaXMgdGhlbiB0aGUgZmluYWwgcmVzdWx0IG9mIHRoZSBwYXJzZS5cbiAgICB0aGlzLmludGVybmFsUmVzdWx0ID0ge307XG4gICAgLy8gVGhlIGluZGV4IG9mIHRoZSBjdXJyZW50IGBMZXhUb2tlbmAgYmVpbmcgY29uc2lkZXJlZC5cbiAgICB0aGlzLnRva2VuSW5kZXggPSAwO1xuICAgIC8vIFRoZSB2YWx1ZSB0byBhZGQgdG8gYHRva2VuSW5kZXhgIG9uIGVhY2ggdHVybiB0aHJvdWdoIHRoZSBwYXJzZSBsb29wLlxuICAgIC8vIFdoaWxlIHR5cGljYWxseSB0aGlzIGlzIGAxYCwgaXQgaXMgYWxzbyBzZXQgdG8gYDBgIGF0IHRpbWVzIGZvciB0aGluZ3NcbiAgICAvLyBsaWtlIHN0YXRlIHRyYW5zaXRpb25zLCBldGMuICBJdCBpcyBhdXRvbWF0aWNhbGx5IHJlc2V0IGJhY2sgdG8gYDFgIGF0XG4gICAgLy8gdGhlIHRvcCBvZiB0aGUgcGFyc2UgbG9vcC5cbiAgICB0aGlzLnRva2VuSW5jcmVtZW50ID0gMTtcbiAgICAvLyBUaGUgaW5kZXggb2YgdGhlIGZpcnN0IGBMZXhUb2tlbmAgdG8gaW5jbHVkZSBpbiB0aGUgY29tcG9uZW50IHN0cmluZy5cbiAgICB0aGlzLmNvbXBvbmVudFN0YXJ0ID0gMDtcbiAgICAvLyBUaGUgY3VycmVudCBwYXJzZSBzdGF0ZS4gIFRoaXMgc2hvdWxkIG9ubHkgYmUgY2hhbmdlZCB2aWEgYGNoYW5nZVN0YXRlKClgXG4gICAgLy8gb3IgYHJld2luZEFuZFNldFN0YXRlKClgLlxuICAgIHRoaXMuc3RhdGUgPSAwIC8qIElOSVQgKi87XG4gICAgLy8gVGhlIGN1cnJlbnQgbmVzdCBkZXB0aCBvZiBgeyB9YCBwYXR0ZXJuIGdyb3VwaW5ncy5cbiAgICB0aGlzLmdyb3VwRGVwdGggPSAwO1xuICAgIC8vIFRoZSBjdXJyZW50IG5lc3RpbmcgZGVwdGggb2YgYFsgXWAgaW4gaG9zdG5hbWUgcGF0dGVybnMuXG4gICAgdGhpcy5ob3N0bmFtZUlQdjZCcmFja2V0RGVwdGggPSAwO1xuICAgIC8vIFRydWUgaWYgd2Ugc2hvdWxkIGFwcGx5IHBhcnNlIHJ1bGVzIGFzIGlmIHRoaXMgaXMgYSBcInN0YW5kYXJkXCIgVVJMLiAgSWZcbiAgICAvLyBmYWxzZSB0aGVuIHRoaXMgaXMgdHJlYXRlZCBhcyBhIFwibm90IGEgYmFzZSBVUkxcIi5cbiAgICB0aGlzLnNob3VsZFRyZWF0QXNTdGFuZGFyZFVSTCA9IGZhbHNlO1xuICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgfVxuICAvLyBSZXR1cm4gdGhlIHBhcnNlIHJlc3VsdC4gIFRoZSByZXN1bHQgaXMgb25seSBhdmFpbGFibGUgYWZ0ZXIgdGhlXG4gIC8vIGBwYXJzZSgpYCBtZXRob2QgY29tcGxldGVzLlxuICBnZXQgcmVzdWx0KCkge1xuICAgIHJldHVybiB0aGlzLmludGVybmFsUmVzdWx0O1xuICB9XG4gIC8vIEF0dGVtcHQgdG8gcGFyc2UgdGhlIGlucHV0IHN0cmluZyB1c2VkIHRvIGNvbnN0cnVjdCB0aGUgUGFyc2VyIG9iamVjdC5cbiAgLy8gVGhpcyBtZXRob2QgbWF5IG9ubHkgYmUgY2FsbGVkIG9uY2UuICBBbnkgZXJyb3JzIHdpbGwgYmUgdGhyb3duIGFzIGFuXG4gIC8vIGV4Y2VwdGlvbi4gIFJldHJpZXZlIHRoZSBwYXJzZSByZXN1bHQgYnkgYWNjZXNzaW5nIHRoZSBgUGFyc2VyLnJlc3VsdGBcbiAgLy8gcHJvcGVydHkgZ2V0dGVyLlxuICBwYXJzZSgpIHtcbiAgICB0aGlzLnRva2VuTGlzdCA9IGxleGVyKFxuICAgICAgdGhpcy5pbnB1dCxcbiAgICAgIC8qbGVuaWVudD0qL1xuICAgICAgdHJ1ZVxuICAgICk7XG4gICAgZm9yICg7IHRoaXMudG9rZW5JbmRleCA8IHRoaXMudG9rZW5MaXN0Lmxlbmd0aDsgdGhpcy50b2tlbkluZGV4ICs9IHRoaXMudG9rZW5JbmNyZW1lbnQpIHtcbiAgICAgIHRoaXMudG9rZW5JbmNyZW1lbnQgPSAxO1xuICAgICAgaWYgKHRoaXMudG9rZW5MaXN0W3RoaXMudG9rZW5JbmRleF0udHlwZSA9PT0gXCJFTkRcIikge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gMCAvKiBJTklUICovKSB7XG4gICAgICAgICAgdGhpcy5yZXdpbmQoKTtcbiAgICAgICAgICBpZiAodGhpcy5pc0hhc2hQcmVmaXgoKSkge1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VTdGF0ZShcbiAgICAgICAgICAgICAgOSAvKiBIQVNIICovLFxuICAgICAgICAgICAgICAvKnNraXA9Ki9cbiAgICAgICAgICAgICAgMVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaXNTZWFyY2hQcmVmaXgoKSkge1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VTdGF0ZShcbiAgICAgICAgICAgICAgOCAvKiBTRUFSQ0ggKi8sXG4gICAgICAgICAgICAgIC8qc2tpcD0qL1xuICAgICAgICAgICAgICAxXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy5pbnRlcm5hbFJlc3VsdC5oYXNoID0gXCJcIjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VTdGF0ZShcbiAgICAgICAgICAgICAgNyAvKiBQQVRITkFNRSAqLyxcbiAgICAgICAgICAgICAgLypza2lwPSovXG4gICAgICAgICAgICAgIDBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0aGlzLmludGVybmFsUmVzdWx0LnNlYXJjaCA9IFwiXCI7XG4gICAgICAgICAgICB0aGlzLmludGVybmFsUmVzdWx0Lmhhc2ggPSBcIlwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnN0YXRlID09PSAyIC8qIEFVVEhPUklUWSAqLykge1xuICAgICAgICAgIHRoaXMucmV3aW5kQW5kU2V0U3RhdGUoNSAvKiBIT1NUTkFNRSAqLyk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaGFuZ2VTdGF0ZShcbiAgICAgICAgICAxMCAvKiBET05FICovLFxuICAgICAgICAgIC8qc2tpcD0qL1xuICAgICAgICAgIDBcbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5ncm91cERlcHRoID4gMCkge1xuICAgICAgICBpZiAodGhpcy5pc0dyb3VwQ2xvc2UoKSkge1xuICAgICAgICAgIHRoaXMuZ3JvdXBEZXB0aCAtPSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5pc0dyb3VwT3BlbigpKSB7XG4gICAgICAgIHRoaXMuZ3JvdXBEZXB0aCArPSAxO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAodGhpcy5zdGF0ZSkge1xuICAgICAgICBjYXNlIDAgLyogSU5JVCAqLzpcbiAgICAgICAgICBpZiAodGhpcy5pc1Byb3RvY29sU3VmZml4KCkpIHtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJuYWxSZXN1bHQudXNlcm5hbWUgPSBcIlwiO1xuICAgICAgICAgICAgdGhpcy5pbnRlcm5hbFJlc3VsdC5wYXNzd29yZCA9IFwiXCI7XG4gICAgICAgICAgICB0aGlzLmludGVybmFsUmVzdWx0Lmhvc3RuYW1lID0gXCJcIjtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJuYWxSZXN1bHQucG9ydCA9IFwiXCI7XG4gICAgICAgICAgICB0aGlzLmludGVybmFsUmVzdWx0LnBhdGhuYW1lID0gXCJcIjtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJuYWxSZXN1bHQuc2VhcmNoID0gXCJcIjtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJuYWxSZXN1bHQuaGFzaCA9IFwiXCI7XG4gICAgICAgICAgICB0aGlzLnJld2luZEFuZFNldFN0YXRlKDEgLyogUFJPVE9DT0wgKi8pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxIC8qIFBST1RPQ09MICovOlxuICAgICAgICAgIGlmICh0aGlzLmlzUHJvdG9jb2xTdWZmaXgoKSkge1xuICAgICAgICAgICAgdGhpcy5jb21wdXRlU2hvdWxkVHJlYXRBc1N0YW5kYXJkVVJMKCk7XG4gICAgICAgICAgICBsZXQgbmV4dFN0YXRlID0gNyAvKiBQQVRITkFNRSAqLztcbiAgICAgICAgICAgIGxldCBza2lwID0gMTtcbiAgICAgICAgICAgIGlmICh0aGlzLnNob3VsZFRyZWF0QXNTdGFuZGFyZFVSTCkge1xuICAgICAgICAgICAgICB0aGlzLmludGVybmFsUmVzdWx0LnBhdGhuYW1lID0gXCIvXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5uZXh0SXNBdXRob3JpdHlTbGFzaGVzKCkpIHtcbiAgICAgICAgICAgICAgbmV4dFN0YXRlID0gMiAvKiBBVVRIT1JJVFkgKi87XG4gICAgICAgICAgICAgIHNraXAgPSAzO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnNob3VsZFRyZWF0QXNTdGFuZGFyZFVSTCkge1xuICAgICAgICAgICAgICBuZXh0U3RhdGUgPSAyIC8qIEFVVEhPUklUWSAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY2hhbmdlU3RhdGUobmV4dFN0YXRlLCBza2lwKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMiAvKiBBVVRIT1JJVFkgKi86XG4gICAgICAgICAgaWYgKHRoaXMuaXNJZGVudGl0eVRlcm1pbmF0b3IoKSkge1xuICAgICAgICAgICAgdGhpcy5yZXdpbmRBbmRTZXRTdGF0ZSgzIC8qIFVTRVJOQU1FICovKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaXNQYXRobmFtZVN0YXJ0KCkgfHwgdGhpcy5pc1NlYXJjaFByZWZpeCgpIHx8IHRoaXMuaXNIYXNoUHJlZml4KCkpIHtcbiAgICAgICAgICAgIHRoaXMucmV3aW5kQW5kU2V0U3RhdGUoNSAvKiBIT1NUTkFNRSAqLyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDMgLyogVVNFUk5BTUUgKi86XG4gICAgICAgICAgaWYgKHRoaXMuaXNQYXNzd29yZFByZWZpeCgpKSB7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZVN0YXRlKFxuICAgICAgICAgICAgICA0IC8qIFBBU1NXT1JEICovLFxuICAgICAgICAgICAgICAvKnNraXA9Ki9cbiAgICAgICAgICAgICAgMVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaXNJZGVudGl0eVRlcm1pbmF0b3IoKSkge1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VTdGF0ZShcbiAgICAgICAgICAgICAgNSAvKiBIT1NUTkFNRSAqLyxcbiAgICAgICAgICAgICAgLypza2lwPSovXG4gICAgICAgICAgICAgIDFcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDQgLyogUEFTU1dPUkQgKi86XG4gICAgICAgICAgaWYgKHRoaXMuaXNJZGVudGl0eVRlcm1pbmF0b3IoKSkge1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VTdGF0ZShcbiAgICAgICAgICAgICAgNSAvKiBIT1NUTkFNRSAqLyxcbiAgICAgICAgICAgICAgLypza2lwPSovXG4gICAgICAgICAgICAgIDFcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDUgLyogSE9TVE5BTUUgKi86XG4gICAgICAgICAgaWYgKHRoaXMuaXNJUHY2T3BlbigpKSB7XG4gICAgICAgICAgICB0aGlzLmhvc3RuYW1lSVB2NkJyYWNrZXREZXB0aCArPSAxO1xuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5pc0lQdjZDbG9zZSgpKSB7XG4gICAgICAgICAgICB0aGlzLmhvc3RuYW1lSVB2NkJyYWNrZXREZXB0aCAtPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5pc1BvcnRQcmVmaXgoKSAmJiAhdGhpcy5ob3N0bmFtZUlQdjZCcmFja2V0RGVwdGgpIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlU3RhdGUoXG4gICAgICAgICAgICAgIDYgLyogUE9SVCAqLyxcbiAgICAgICAgICAgICAgLypza2lwPSovXG4gICAgICAgICAgICAgIDFcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmlzUGF0aG5hbWVTdGFydCgpKSB7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZVN0YXRlKFxuICAgICAgICAgICAgICA3IC8qIFBBVEhOQU1FICovLFxuICAgICAgICAgICAgICAvKnNraXA9Ki9cbiAgICAgICAgICAgICAgMFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaXNTZWFyY2hQcmVmaXgoKSkge1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VTdGF0ZShcbiAgICAgICAgICAgICAgOCAvKiBTRUFSQ0ggKi8sXG4gICAgICAgICAgICAgIC8qc2tpcD0qL1xuICAgICAgICAgICAgICAxXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5pc0hhc2hQcmVmaXgoKSkge1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VTdGF0ZShcbiAgICAgICAgICAgICAgOSAvKiBIQVNIICovLFxuICAgICAgICAgICAgICAvKnNraXA9Ki9cbiAgICAgICAgICAgICAgMVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNiAvKiBQT1JUICovOlxuICAgICAgICAgIGlmICh0aGlzLmlzUGF0aG5hbWVTdGFydCgpKSB7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZVN0YXRlKFxuICAgICAgICAgICAgICA3IC8qIFBBVEhOQU1FICovLFxuICAgICAgICAgICAgICAvKnNraXA9Ki9cbiAgICAgICAgICAgICAgMFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaXNTZWFyY2hQcmVmaXgoKSkge1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VTdGF0ZShcbiAgICAgICAgICAgICAgOCAvKiBTRUFSQ0ggKi8sXG4gICAgICAgICAgICAgIC8qc2tpcD0qL1xuICAgICAgICAgICAgICAxXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5pc0hhc2hQcmVmaXgoKSkge1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VTdGF0ZShcbiAgICAgICAgICAgICAgOSAvKiBIQVNIICovLFxuICAgICAgICAgICAgICAvKnNraXA9Ki9cbiAgICAgICAgICAgICAgMVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNyAvKiBQQVRITkFNRSAqLzpcbiAgICAgICAgICBpZiAodGhpcy5pc1NlYXJjaFByZWZpeCgpKSB7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZVN0YXRlKFxuICAgICAgICAgICAgICA4IC8qIFNFQVJDSCAqLyxcbiAgICAgICAgICAgICAgLypza2lwPSovXG4gICAgICAgICAgICAgIDFcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmlzSGFzaFByZWZpeCgpKSB7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZVN0YXRlKFxuICAgICAgICAgICAgICA5IC8qIEhBU0ggKi8sXG4gICAgICAgICAgICAgIC8qc2tpcD0qL1xuICAgICAgICAgICAgICAxXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA4IC8qIFNFQVJDSCAqLzpcbiAgICAgICAgICBpZiAodGhpcy5pc0hhc2hQcmVmaXgoKSkge1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VTdGF0ZShcbiAgICAgICAgICAgICAgOSAvKiBIQVNIICovLFxuICAgICAgICAgICAgICAvKnNraXA9Ki9cbiAgICAgICAgICAgICAgMVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgOSAvKiBIQVNIICovOlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDEwIC8qIERPTkUgKi86XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNoYW5nZVN0YXRlKG5ld1N0YXRlLCBza2lwKSB7XG4gICAgc3dpdGNoICh0aGlzLnN0YXRlKSB7XG4gICAgICBjYXNlIDAgLyogSU5JVCAqLzpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDEgLyogUFJPVE9DT0wgKi86XG4gICAgICAgIHRoaXMuaW50ZXJuYWxSZXN1bHQucHJvdG9jb2wgPSB0aGlzLm1ha2VDb21wb25lbnRTdHJpbmcoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDIgLyogQVVUSE9SSVRZICovOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMyAvKiBVU0VSTkFNRSAqLzpcbiAgICAgICAgdGhpcy5pbnRlcm5hbFJlc3VsdC51c2VybmFtZSA9IHRoaXMubWFrZUNvbXBvbmVudFN0cmluZygpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgNCAvKiBQQVNTV09SRCAqLzpcbiAgICAgICAgdGhpcy5pbnRlcm5hbFJlc3VsdC5wYXNzd29yZCA9IHRoaXMubWFrZUNvbXBvbmVudFN0cmluZygpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgNSAvKiBIT1NUTkFNRSAqLzpcbiAgICAgICAgdGhpcy5pbnRlcm5hbFJlc3VsdC5ob3N0bmFtZSA9IHRoaXMubWFrZUNvbXBvbmVudFN0cmluZygpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgNiAvKiBQT1JUICovOlxuICAgICAgICB0aGlzLmludGVybmFsUmVzdWx0LnBvcnQgPSB0aGlzLm1ha2VDb21wb25lbnRTdHJpbmcoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDcgLyogUEFUSE5BTUUgKi86XG4gICAgICAgIHRoaXMuaW50ZXJuYWxSZXN1bHQucGF0aG5hbWUgPSB0aGlzLm1ha2VDb21wb25lbnRTdHJpbmcoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDggLyogU0VBUkNIICovOlxuICAgICAgICB0aGlzLmludGVybmFsUmVzdWx0LnNlYXJjaCA9IHRoaXMubWFrZUNvbXBvbmVudFN0cmluZygpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgOSAvKiBIQVNIICovOlxuICAgICAgICB0aGlzLmludGVybmFsUmVzdWx0Lmhhc2ggPSB0aGlzLm1ha2VDb21wb25lbnRTdHJpbmcoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDEwIC8qIERPTkUgKi86XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB0aGlzLmNoYW5nZVN0YXRlV2l0aG91dFNldHRpbmdDb21wb25lbnQobmV3U3RhdGUsIHNraXApO1xuICB9XG4gIGNoYW5nZVN0YXRlV2l0aG91dFNldHRpbmdDb21wb25lbnQobmV3U3RhdGUsIHNraXApIHtcbiAgICB0aGlzLnN0YXRlID0gbmV3U3RhdGU7XG4gICAgdGhpcy5jb21wb25lbnRTdGFydCA9IHRoaXMudG9rZW5JbmRleCArIHNraXA7XG4gICAgdGhpcy50b2tlbkluZGV4ICs9IHNraXA7XG4gICAgdGhpcy50b2tlbkluY3JlbWVudCA9IDA7XG4gIH1cbiAgcmV3aW5kKCkge1xuICAgIHRoaXMudG9rZW5JbmRleCA9IHRoaXMuY29tcG9uZW50U3RhcnQ7XG4gICAgdGhpcy50b2tlbkluY3JlbWVudCA9IDA7XG4gIH1cbiAgcmV3aW5kQW5kU2V0U3RhdGUobmV3U3RhdGUpIHtcbiAgICB0aGlzLnJld2luZCgpO1xuICAgIHRoaXMuc3RhdGUgPSBuZXdTdGF0ZTtcbiAgfVxuICBzYWZlVG9rZW4oaW5kZXgpIHtcbiAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICBpbmRleCA9IHRoaXMudG9rZW5MaXN0Lmxlbmd0aCAtIGluZGV4O1xuICAgIH1cbiAgICBpZiAoaW5kZXggPCB0aGlzLnRva2VuTGlzdC5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLnRva2VuTGlzdFtpbmRleF07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnRva2VuTGlzdFt0aGlzLnRva2VuTGlzdC5sZW5ndGggLSAxXTtcbiAgfVxuICBpc05vblNwZWNpYWxQYXR0ZXJuQ2hhcihpbmRleCwgdmFsdWUpIHtcbiAgICBjb25zdCB0b2tlbiA9IHRoaXMuc2FmZVRva2VuKGluZGV4KTtcbiAgICByZXR1cm4gdG9rZW4udmFsdWUgPT09IHZhbHVlICYmICh0b2tlbi50eXBlID09PSBcIkNIQVJcIiB8fCB0b2tlbi50eXBlID09PSBcIkVTQ0FQRURfQ0hBUlwiIHx8IHRva2VuLnR5cGUgPT09IFwiSU5WQUxJRF9DSEFSXCIpO1xuICB9XG4gIGlzUHJvdG9jb2xTdWZmaXgoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNOb25TcGVjaWFsUGF0dGVybkNoYXIodGhpcy50b2tlbkluZGV4LCBcIjpcIik7XG4gIH1cbiAgbmV4dElzQXV0aG9yaXR5U2xhc2hlcygpIHtcbiAgICByZXR1cm4gdGhpcy5pc05vblNwZWNpYWxQYXR0ZXJuQ2hhcih0aGlzLnRva2VuSW5kZXggKyAxLCBcIi9cIikgJiYgdGhpcy5pc05vblNwZWNpYWxQYXR0ZXJuQ2hhcih0aGlzLnRva2VuSW5kZXggKyAyLCBcIi9cIik7XG4gIH1cbiAgaXNJZGVudGl0eVRlcm1pbmF0b3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNOb25TcGVjaWFsUGF0dGVybkNoYXIodGhpcy50b2tlbkluZGV4LCBcIkBcIik7XG4gIH1cbiAgaXNQYXNzd29yZFByZWZpeCgpIHtcbiAgICByZXR1cm4gdGhpcy5pc05vblNwZWNpYWxQYXR0ZXJuQ2hhcih0aGlzLnRva2VuSW5kZXgsIFwiOlwiKTtcbiAgfVxuICBpc1BvcnRQcmVmaXgoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNOb25TcGVjaWFsUGF0dGVybkNoYXIodGhpcy50b2tlbkluZGV4LCBcIjpcIik7XG4gIH1cbiAgaXNQYXRobmFtZVN0YXJ0KCkge1xuICAgIHJldHVybiB0aGlzLmlzTm9uU3BlY2lhbFBhdHRlcm5DaGFyKHRoaXMudG9rZW5JbmRleCwgXCIvXCIpO1xuICB9XG4gIGlzU2VhcmNoUHJlZml4KCkge1xuICAgIGlmICh0aGlzLmlzTm9uU3BlY2lhbFBhdHRlcm5DaGFyKHRoaXMudG9rZW5JbmRleCwgXCI/XCIpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHRoaXMudG9rZW5MaXN0W3RoaXMudG9rZW5JbmRleF0udmFsdWUgIT09IFwiP1wiKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHByZXZpb3VzVG9rZW4gPSB0aGlzLnNhZmVUb2tlbih0aGlzLnRva2VuSW5kZXggLSAxKTtcbiAgICByZXR1cm4gcHJldmlvdXNUb2tlbi50eXBlICE9PSBcIk5BTUVcIiAmJiBwcmV2aW91c1Rva2VuLnR5cGUgIT09IFwiUkVHRVhcIiAmJiBwcmV2aW91c1Rva2VuLnR5cGUgIT09IFwiQ0xPU0VcIiAmJiBwcmV2aW91c1Rva2VuLnR5cGUgIT09IFwiQVNURVJJU0tcIjtcbiAgfVxuICBpc0hhc2hQcmVmaXgoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNOb25TcGVjaWFsUGF0dGVybkNoYXIodGhpcy50b2tlbkluZGV4LCBcIiNcIik7XG4gIH1cbiAgaXNHcm91cE9wZW4oKSB7XG4gICAgcmV0dXJuIHRoaXMudG9rZW5MaXN0W3RoaXMudG9rZW5JbmRleF0udHlwZSA9PSBcIk9QRU5cIjtcbiAgfVxuICBpc0dyb3VwQ2xvc2UoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9rZW5MaXN0W3RoaXMudG9rZW5JbmRleF0udHlwZSA9PSBcIkNMT1NFXCI7XG4gIH1cbiAgaXNJUHY2T3BlbigpIHtcbiAgICByZXR1cm4gdGhpcy5pc05vblNwZWNpYWxQYXR0ZXJuQ2hhcih0aGlzLnRva2VuSW5kZXgsIFwiW1wiKTtcbiAgfVxuICBpc0lQdjZDbG9zZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pc05vblNwZWNpYWxQYXR0ZXJuQ2hhcih0aGlzLnRva2VuSW5kZXgsIFwiXVwiKTtcbiAgfVxuICBtYWtlQ29tcG9uZW50U3RyaW5nKCkge1xuICAgIGNvbnN0IHRva2VuID0gdGhpcy50b2tlbkxpc3RbdGhpcy50b2tlbkluZGV4XTtcbiAgICBjb25zdCBjb21wb25lbnRDaGFyU3RhcnQgPSB0aGlzLnNhZmVUb2tlbih0aGlzLmNvbXBvbmVudFN0YXJ0KS5pbmRleDtcbiAgICByZXR1cm4gdGhpcy5pbnB1dC5zdWJzdHJpbmcoY29tcG9uZW50Q2hhclN0YXJ0LCB0b2tlbi5pbmRleCk7XG4gIH1cbiAgY29tcHV0ZVNob3VsZFRyZWF0QXNTdGFuZGFyZFVSTCgpIHtcbiAgICBjb25zdCBvcHRpb25zID0ge307XG4gICAgT2JqZWN0LmFzc2lnbihvcHRpb25zLCBERUZBVUxUX09QVElPTlMpO1xuICAgIG9wdGlvbnMuZW5jb2RlUGFydCA9IHByb3RvY29sRW5jb2RlQ2FsbGJhY2s7XG4gICAgY29uc3QgcmVnZXhwID0gc3RyaW5nVG9SZWdleHAoXG4gICAgICB0aGlzLm1ha2VDb21wb25lbnRTdHJpbmcoKSxcbiAgICAgIC8qa2V5cz0qL1xuICAgICAgdm9pZCAwLFxuICAgICAgb3B0aW9uc1xuICAgICk7XG4gICAgdGhpcy5zaG91bGRUcmVhdEFzU3RhbmRhcmRVUkwgPSBpc1NwZWNpYWxTY2hlbWUocmVnZXhwKTtcbiAgfVxufTtcblxuLy8gc3JjL3VybC1wYXR0ZXJuLnRzXG52YXIgQ09NUE9ORU5UUyA9IFtcbiAgXCJwcm90b2NvbFwiLFxuICBcInVzZXJuYW1lXCIsXG4gIFwicGFzc3dvcmRcIixcbiAgXCJob3N0bmFtZVwiLFxuICBcInBvcnRcIixcbiAgXCJwYXRobmFtZVwiLFxuICBcInNlYXJjaFwiLFxuICBcImhhc2hcIlxuXTtcbnZhciBERUZBVUxUX1BBVFRFUk4gPSBcIipcIjtcbmZ1bmN0aW9uIGV4dHJhY3RWYWx1ZXModXJsLCBiYXNlVVJMKSB7XG4gIGlmICh0eXBlb2YgdXJsICE9PSBcInN0cmluZ1wiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgcGFyYW1ldGVyIDEgaXMgbm90IG9mIHR5cGUgJ3N0cmluZycuYCk7XG4gIH1cbiAgY29uc3QgbyA9IG5ldyBVUkwodXJsLCBiYXNlVVJMKTtcbiAgcmV0dXJuIHtcbiAgICBwcm90b2NvbDogby5wcm90b2NvbC5zdWJzdHJpbmcoMCwgby5wcm90b2NvbC5sZW5ndGggLSAxKSxcbiAgICB1c2VybmFtZTogby51c2VybmFtZSxcbiAgICBwYXNzd29yZDogby5wYXNzd29yZCxcbiAgICBob3N0bmFtZTogby5ob3N0bmFtZSxcbiAgICBwb3J0OiBvLnBvcnQsXG4gICAgcGF0aG5hbWU6IG8ucGF0aG5hbWUsXG4gICAgc2VhcmNoOiBvLnNlYXJjaCAhPT0gXCJcIiA/IG8uc2VhcmNoLnN1YnN0cmluZygxLCBvLnNlYXJjaC5sZW5ndGgpIDogdm9pZCAwLFxuICAgIGhhc2g6IG8uaGFzaCAhPT0gXCJcIiA/IG8uaGFzaC5zdWJzdHJpbmcoMSwgby5oYXNoLmxlbmd0aCkgOiB2b2lkIDBcbiAgfTtcbn1cbmZ1bmN0aW9uIHByb2Nlc3NCYXNlVVJMU3RyaW5nKGlucHV0LCBpc1BhdHRlcm4pIHtcbiAgaWYgKCFpc1BhdHRlcm4pIHtcbiAgICByZXR1cm4gaW5wdXQ7XG4gIH1cbiAgcmV0dXJuIGVzY2FwZVBhdHRlcm5TdHJpbmcoaW5wdXQpO1xufVxuZnVuY3Rpb24gYXBwbHlJbml0KG8sIGluaXQsIGlzUGF0dGVybikge1xuICBsZXQgYmFzZVVSTDtcbiAgaWYgKHR5cGVvZiBpbml0LmJhc2VVUkwgPT09IFwic3RyaW5nXCIpIHtcbiAgICB0cnkge1xuICAgICAgYmFzZVVSTCA9IG5ldyBVUkwoaW5pdC5iYXNlVVJMKTtcbiAgICAgIG8ucHJvdG9jb2wgPSBwcm9jZXNzQmFzZVVSTFN0cmluZyhiYXNlVVJMLnByb3RvY29sLnN1YnN0cmluZygwLCBiYXNlVVJMLnByb3RvY29sLmxlbmd0aCAtIDEpLCBpc1BhdHRlcm4pO1xuICAgICAgby51c2VybmFtZSA9IHByb2Nlc3NCYXNlVVJMU3RyaW5nKGJhc2VVUkwudXNlcm5hbWUsIGlzUGF0dGVybik7XG4gICAgICBvLnBhc3N3b3JkID0gcHJvY2Vzc0Jhc2VVUkxTdHJpbmcoYmFzZVVSTC5wYXNzd29yZCwgaXNQYXR0ZXJuKTtcbiAgICAgIG8uaG9zdG5hbWUgPSBwcm9jZXNzQmFzZVVSTFN0cmluZyhiYXNlVVJMLmhvc3RuYW1lLCBpc1BhdHRlcm4pO1xuICAgICAgby5wb3J0ID0gcHJvY2Vzc0Jhc2VVUkxTdHJpbmcoYmFzZVVSTC5wb3J0LCBpc1BhdHRlcm4pO1xuICAgICAgby5wYXRobmFtZSA9IHByb2Nlc3NCYXNlVVJMU3RyaW5nKGJhc2VVUkwucGF0aG5hbWUsIGlzUGF0dGVybik7XG4gICAgICBvLnNlYXJjaCA9IHByb2Nlc3NCYXNlVVJMU3RyaW5nKGJhc2VVUkwuc2VhcmNoLnN1YnN0cmluZygxLCBiYXNlVVJMLnNlYXJjaC5sZW5ndGgpLCBpc1BhdHRlcm4pO1xuICAgICAgby5oYXNoID0gcHJvY2Vzc0Jhc2VVUkxTdHJpbmcoYmFzZVVSTC5oYXNoLnN1YnN0cmluZygxLCBiYXNlVVJMLmhhc2gubGVuZ3RoKSwgaXNQYXR0ZXJuKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGludmFsaWQgYmFzZVVSTCAnJHtpbml0LmJhc2VVUkx9Jy5gKTtcbiAgICB9XG4gIH1cbiAgaWYgKHR5cGVvZiBpbml0LnByb3RvY29sID09PSBcInN0cmluZ1wiKSB7XG4gICAgby5wcm90b2NvbCA9IGNhbm9uaWNhbGl6ZVByb3RvY29sKGluaXQucHJvdG9jb2wsIGlzUGF0dGVybik7XG4gIH1cbiAgaWYgKHR5cGVvZiBpbml0LnVzZXJuYW1lID09PSBcInN0cmluZ1wiKSB7XG4gICAgby51c2VybmFtZSA9IGNhbm9uaWNhbGl6ZVVzZXJuYW1lKGluaXQudXNlcm5hbWUsIGlzUGF0dGVybik7XG4gIH1cbiAgaWYgKHR5cGVvZiBpbml0LnBhc3N3b3JkID09PSBcInN0cmluZ1wiKSB7XG4gICAgby5wYXNzd29yZCA9IGNhbm9uaWNhbGl6ZVBhc3N3b3JkKGluaXQucGFzc3dvcmQsIGlzUGF0dGVybik7XG4gIH1cbiAgaWYgKHR5cGVvZiBpbml0Lmhvc3RuYW1lID09PSBcInN0cmluZ1wiKSB7XG4gICAgby5ob3N0bmFtZSA9IGNhbm9uaWNhbGl6ZUhvc3RuYW1lKGluaXQuaG9zdG5hbWUsIGlzUGF0dGVybik7XG4gIH1cbiAgaWYgKHR5cGVvZiBpbml0LnBvcnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICBvLnBvcnQgPSBjYW5vbmljYWxpemVQb3J0KGluaXQucG9ydCwgby5wcm90b2NvbCwgaXNQYXR0ZXJuKTtcbiAgfVxuICBpZiAodHlwZW9mIGluaXQucGF0aG5hbWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICBvLnBhdGhuYW1lID0gaW5pdC5wYXRobmFtZTtcbiAgICBpZiAoYmFzZVVSTCAmJiAhaXNBYnNvbHV0ZVBhdGhuYW1lKG8ucGF0aG5hbWUsIGlzUGF0dGVybikpIHtcbiAgICAgIGNvbnN0IHNsYXNoSW5kZXggPSBiYXNlVVJMLnBhdGhuYW1lLmxhc3RJbmRleE9mKFwiL1wiKTtcbiAgICAgIGlmIChzbGFzaEluZGV4ID49IDApIHtcbiAgICAgICAgby5wYXRobmFtZSA9IHByb2Nlc3NCYXNlVVJMU3RyaW5nKGJhc2VVUkwucGF0aG5hbWUuc3Vic3RyaW5nKDAsIHNsYXNoSW5kZXggKyAxKSwgaXNQYXR0ZXJuKSArIG8ucGF0aG5hbWU7XG4gICAgICB9XG4gICAgfVxuICAgIG8ucGF0aG5hbWUgPSBjYW5vbmljYWxpemVQYXRobmFtZShvLnBhdGhuYW1lLCBvLnByb3RvY29sLCBpc1BhdHRlcm4pO1xuICB9XG4gIGlmICh0eXBlb2YgaW5pdC5zZWFyY2ggPT09IFwic3RyaW5nXCIpIHtcbiAgICBvLnNlYXJjaCA9IGNhbm9uaWNhbGl6ZVNlYXJjaChpbml0LnNlYXJjaCwgaXNQYXR0ZXJuKTtcbiAgfVxuICBpZiAodHlwZW9mIGluaXQuaGFzaCA9PT0gXCJzdHJpbmdcIikge1xuICAgIG8uaGFzaCA9IGNhbm9uaWNhbGl6ZUhhc2goaW5pdC5oYXNoLCBpc1BhdHRlcm4pO1xuICB9XG4gIHJldHVybiBvO1xufVxuZnVuY3Rpb24gZXNjYXBlUGF0dGVyblN0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUucmVwbGFjZSgvKFsrKj86e30oKVxcXFxdKS9nLCBcIlxcXFwkMVwiKTtcbn1cbmZ1bmN0aW9uIGVzY2FwZVJlZ2V4cFN0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUucmVwbGFjZSgvKFsuKyo/XiR7fSgpW1xcXXwvXFxcXF0pL2csIFwiXFxcXCQxXCIpO1xufVxuZnVuY3Rpb24gcGFydHNUb1BhdHRlcm4ocGFydHMsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucy5kZWxpbWl0ZXIgPz8gKG9wdGlvbnMuZGVsaW1pdGVyID0gXCIvIz9cIik7XG4gIG9wdGlvbnMucHJlZml4ZXMgPz8gKG9wdGlvbnMucHJlZml4ZXMgPSBcIi4vXCIpO1xuICBvcHRpb25zLnNlbnNpdGl2ZSA/PyAob3B0aW9ucy5zZW5zaXRpdmUgPSBmYWxzZSk7XG4gIG9wdGlvbnMuc3RyaWN0ID8/IChvcHRpb25zLnN0cmljdCA9IGZhbHNlKTtcbiAgb3B0aW9ucy5lbmQgPz8gKG9wdGlvbnMuZW5kID0gdHJ1ZSk7XG4gIG9wdGlvbnMuc3RhcnQgPz8gKG9wdGlvbnMuc3RhcnQgPSB0cnVlKTtcbiAgb3B0aW9ucy5lbmRzV2l0aCA9IFwiXCI7XG4gIGNvbnN0IGtGdWxsV2lsZGNhcmRSZWdleDIgPSBcIi4qXCI7XG4gIGNvbnN0IHNlZ21lbnRXaWxkY2FyZFJlZ2V4ID0gYFteJHtlc2NhcGVSZWdleHBTdHJpbmcob3B0aW9ucy5kZWxpbWl0ZXIpfV0rP2A7XG4gIGNvbnN0IHJlZ2V4SWRlbnRpZmllclBhcnQyID0gL1skX1xcdTIwMENcXHUyMDBEXFxwe0lEX0NvbnRpbnVlfV0vdTtcbiAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyArK2kpIHtcbiAgICBjb25zdCBwYXJ0ID0gcGFydHNbaV07XG4gICAgaWYgKHBhcnQudHlwZSA9PT0gMyAvKiBrRml4ZWQgKi8pIHtcbiAgICAgIGlmIChwYXJ0Lm1vZGlmaWVyID09PSAzIC8qIGtOb25lICovKSB7XG4gICAgICAgIHJlc3VsdCArPSBlc2NhcGVQYXR0ZXJuU3RyaW5nKHBhcnQudmFsdWUpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCArPSBgeyR7ZXNjYXBlUGF0dGVyblN0cmluZyhwYXJ0LnZhbHVlKX19JHttb2RpZmllclRvU3RyaW5nKHBhcnQubW9kaWZpZXIpfWA7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgY3VzdG9tTmFtZSA9IHBhcnQuaGFzQ3VzdG9tTmFtZSgpO1xuICAgIGxldCBuZWVkc0dyb3VwaW5nID0gISFwYXJ0LnN1ZmZpeC5sZW5ndGggfHwgISFwYXJ0LnByZWZpeC5sZW5ndGggJiYgKHBhcnQucHJlZml4Lmxlbmd0aCAhPT0gMSB8fCAhb3B0aW9ucy5wcmVmaXhlcy5pbmNsdWRlcyhwYXJ0LnByZWZpeCkpO1xuICAgIGNvbnN0IGxhc3RQYXJ0ID0gaSA+IDAgPyBwYXJ0c1tpIC0gMV0gOiBudWxsO1xuICAgIGNvbnN0IG5leHRQYXJ0ID0gaSA8IHBhcnRzLmxlbmd0aCAtIDEgPyBwYXJ0c1tpICsgMV0gOiBudWxsO1xuICAgIGlmICghbmVlZHNHcm91cGluZyAmJiBjdXN0b21OYW1lICYmIHBhcnQudHlwZSA9PT0gMSAvKiBrU2VnbWVudFdpbGRjYXJkICovICYmIHBhcnQubW9kaWZpZXIgPT09IDMgLyoga05vbmUgKi8gJiYgbmV4dFBhcnQgJiYgIW5leHRQYXJ0LnByZWZpeC5sZW5ndGggJiYgIW5leHRQYXJ0LnN1ZmZpeC5sZW5ndGgpIHtcbiAgICAgIGlmIChuZXh0UGFydC50eXBlID09PSAzIC8qIGtGaXhlZCAqLykge1xuICAgICAgICBjb25zdCBjb2RlID0gbmV4dFBhcnQudmFsdWUubGVuZ3RoID4gMCA/IG5leHRQYXJ0LnZhbHVlWzBdIDogXCJcIjtcbiAgICAgICAgbmVlZHNHcm91cGluZyA9IHJlZ2V4SWRlbnRpZmllclBhcnQyLnRlc3QoY29kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZWVkc0dyb3VwaW5nID0gIW5leHRQYXJ0Lmhhc0N1c3RvbU5hbWUoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFuZWVkc0dyb3VwaW5nICYmICFwYXJ0LnByZWZpeC5sZW5ndGggJiYgbGFzdFBhcnQgJiYgbGFzdFBhcnQudHlwZSA9PT0gMyAvKiBrRml4ZWQgKi8pIHtcbiAgICAgIGNvbnN0IGNvZGUgPSBsYXN0UGFydC52YWx1ZVtsYXN0UGFydC52YWx1ZS5sZW5ndGggLSAxXTtcbiAgICAgIG5lZWRzR3JvdXBpbmcgPSBvcHRpb25zLnByZWZpeGVzLmluY2x1ZGVzKGNvZGUpO1xuICAgIH1cbiAgICBpZiAobmVlZHNHcm91cGluZykge1xuICAgICAgcmVzdWx0ICs9IFwie1wiO1xuICAgIH1cbiAgICByZXN1bHQgKz0gZXNjYXBlUGF0dGVyblN0cmluZyhwYXJ0LnByZWZpeCk7XG4gICAgaWYgKGN1c3RvbU5hbWUpIHtcbiAgICAgIHJlc3VsdCArPSBgOiR7cGFydC5uYW1lfWA7XG4gICAgfVxuICAgIGlmIChwYXJ0LnR5cGUgPT09IDIgLyoga1JlZ2V4ICovKSB7XG4gICAgICByZXN1bHQgKz0gYCgke3BhcnQudmFsdWV9KWA7XG4gICAgfSBlbHNlIGlmIChwYXJ0LnR5cGUgPT09IDEgLyoga1NlZ21lbnRXaWxkY2FyZCAqLykge1xuICAgICAgaWYgKCFjdXN0b21OYW1lKSB7XG4gICAgICAgIHJlc3VsdCArPSBgKCR7c2VnbWVudFdpbGRjYXJkUmVnZXh9KWA7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwYXJ0LnR5cGUgPT09IDAgLyoga0Z1bGxXaWxkY2FyZCAqLykge1xuICAgICAgaWYgKCFjdXN0b21OYW1lICYmICghbGFzdFBhcnQgfHwgbGFzdFBhcnQudHlwZSA9PT0gMyAvKiBrRml4ZWQgKi8gfHwgbGFzdFBhcnQubW9kaWZpZXIgIT09IDMgLyoga05vbmUgKi8gfHwgbmVlZHNHcm91cGluZyB8fCBwYXJ0LnByZWZpeCAhPT0gXCJcIikpIHtcbiAgICAgICAgcmVzdWx0ICs9IFwiKlwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ICs9IGAoJHtrRnVsbFdpbGRjYXJkUmVnZXgyfSlgO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocGFydC50eXBlID09PSAxIC8qIGtTZWdtZW50V2lsZGNhcmQgKi8gJiYgY3VzdG9tTmFtZSAmJiAhIXBhcnQuc3VmZml4Lmxlbmd0aCkge1xuICAgICAgaWYgKHJlZ2V4SWRlbnRpZmllclBhcnQyLnRlc3QocGFydC5zdWZmaXhbMF0pKSB7XG4gICAgICAgIHJlc3VsdCArPSBcIlxcXFxcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0ICs9IGVzY2FwZVBhdHRlcm5TdHJpbmcocGFydC5zdWZmaXgpO1xuICAgIGlmIChuZWVkc0dyb3VwaW5nKSB7XG4gICAgICByZXN1bHQgKz0gXCJ9XCI7XG4gICAgfVxuICAgIGlmIChwYXJ0Lm1vZGlmaWVyICE9PSAzIC8qIGtOb25lICovKSB7XG4gICAgICByZXN1bHQgKz0gbW9kaWZpZXJUb1N0cmluZyhwYXJ0Lm1vZGlmaWVyKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbnZhciBVUkxQYXR0ZXJuID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihpbml0ID0ge30sIGJhc2VVUkxPck9wdGlvbnMsIG9wdGlvbnMpIHtcbiAgICB0aGlzLnJlZ2V4cCA9IHt9O1xuICAgIHRoaXMubmFtZXMgPSB7fTtcbiAgICB0aGlzLmNvbXBvbmVudF9wYXR0ZXJuID0ge307XG4gICAgdGhpcy5wYXJ0cyA9IHt9O1xuICAgIHRyeSB7XG4gICAgICBsZXQgYmFzZVVSTCA9IHZvaWQgMDtcbiAgICAgIGlmICh0eXBlb2YgYmFzZVVSTE9yT3B0aW9ucyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBiYXNlVVJMID0gYmFzZVVSTE9yT3B0aW9ucztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9wdGlvbnMgPSBiYXNlVVJMT3JPcHRpb25zO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBpbml0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGNvbnN0IHBhcnNlciA9IG5ldyBQYXJzZXIoaW5pdCk7XG4gICAgICAgIHBhcnNlci5wYXJzZSgpO1xuICAgICAgICBpbml0ID0gcGFyc2VyLnJlc3VsdDtcbiAgICAgICAgaWYgKGJhc2VVUkwgPT09IHZvaWQgMCAmJiB0eXBlb2YgaW5pdC5wcm90b2NvbCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEEgYmFzZSBVUkwgbXVzdCBiZSBwcm92aWRlZCBmb3IgYSByZWxhdGl2ZSBjb25zdHJ1Y3RvciBzdHJpbmcuYCk7XG4gICAgICAgIH1cbiAgICAgICAgaW5pdC5iYXNlVVJMID0gYmFzZVVSTDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghaW5pdCB8fCB0eXBlb2YgaW5pdCAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYHBhcmFtZXRlciAxIGlzIG5vdCBvZiB0eXBlICdzdHJpbmcnIGFuZCBjYW5ub3QgY29udmVydCB0byBkaWN0aW9uYXJ5LmApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiYXNlVVJMKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgcGFyYW1ldGVyIDEgaXMgbm90IG9mIHR5cGUgJ3N0cmluZycuYCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBvcHRpb25zID0geyBpZ25vcmVDYXNlOiBmYWxzZSB9O1xuICAgICAgfVxuICAgICAgY29uc3QgaWdub3JlQ2FzZU9wdGlvbnMgPSB7IGlnbm9yZUNhc2U6IG9wdGlvbnMuaWdub3JlQ2FzZSA9PT0gdHJ1ZSB9O1xuICAgICAgY29uc3QgZGVmYXVsdHMgPSB7XG4gICAgICAgIHBhdGhuYW1lOiBERUZBVUxUX1BBVFRFUk4sXG4gICAgICAgIHByb3RvY29sOiBERUZBVUxUX1BBVFRFUk4sXG4gICAgICAgIHVzZXJuYW1lOiBERUZBVUxUX1BBVFRFUk4sXG4gICAgICAgIHBhc3N3b3JkOiBERUZBVUxUX1BBVFRFUk4sXG4gICAgICAgIGhvc3RuYW1lOiBERUZBVUxUX1BBVFRFUk4sXG4gICAgICAgIHBvcnQ6IERFRkFVTFRfUEFUVEVSTixcbiAgICAgICAgc2VhcmNoOiBERUZBVUxUX1BBVFRFUk4sXG4gICAgICAgIGhhc2g6IERFRkFVTFRfUEFUVEVSTlxuICAgICAgfTtcbiAgICAgIHRoaXMucGF0dGVybiA9IGFwcGx5SW5pdChkZWZhdWx0cywgaW5pdCwgdHJ1ZSk7XG4gICAgICBpZiAoZGVmYXVsdFBvcnRGb3JQcm90b2NvbCh0aGlzLnBhdHRlcm4ucHJvdG9jb2wpID09PSB0aGlzLnBhdHRlcm4ucG9ydCkge1xuICAgICAgICB0aGlzLnBhdHRlcm4ucG9ydCA9IFwiXCI7XG4gICAgICB9XG4gICAgICBsZXQgY29tcG9uZW50O1xuICAgICAgZm9yIChjb21wb25lbnQgb2YgQ09NUE9ORU5UUykge1xuICAgICAgICBpZiAoIShjb21wb25lbnQgaW4gdGhpcy5wYXR0ZXJuKSlcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgY29uc3Qgb3B0aW9uczIgPSB7fTtcbiAgICAgICAgY29uc3QgcGF0dGVybiA9IHRoaXMucGF0dGVybltjb21wb25lbnRdO1xuICAgICAgICB0aGlzLm5hbWVzW2NvbXBvbmVudF0gPSBbXTtcbiAgICAgICAgc3dpdGNoIChjb21wb25lbnQpIHtcbiAgICAgICAgICBjYXNlIFwicHJvdG9jb2xcIjpcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ob3B0aW9uczIsIERFRkFVTFRfT1BUSU9OUyk7XG4gICAgICAgICAgICBvcHRpb25zMi5lbmNvZGVQYXJ0ID0gcHJvdG9jb2xFbmNvZGVDYWxsYmFjaztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJ1c2VybmFtZVwiOlxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihvcHRpb25zMiwgREVGQVVMVF9PUFRJT05TKTtcbiAgICAgICAgICAgIG9wdGlvbnMyLmVuY29kZVBhcnQgPSB1c2VybmFtZUVuY29kZUNhbGxiYWNrO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcInBhc3N3b3JkXCI6XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKG9wdGlvbnMyLCBERUZBVUxUX09QVElPTlMpO1xuICAgICAgICAgICAgb3B0aW9uczIuZW5jb2RlUGFydCA9IHBhc3N3b3JkRW5jb2RlQ2FsbGJhY2s7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiaG9zdG5hbWVcIjpcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ob3B0aW9uczIsIEhPU1ROQU1FX09QVElPTlMpO1xuICAgICAgICAgICAgaWYgKHRyZWF0QXNJUHY2SG9zdG5hbWUocGF0dGVybikpIHtcbiAgICAgICAgICAgICAgb3B0aW9uczIuZW5jb2RlUGFydCA9IGlwdjZIb3N0bmFtZUVuY29kZUNhbGxiYWNrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgb3B0aW9uczIuZW5jb2RlUGFydCA9IGhvc3RuYW1lRW5jb2RlQ2FsbGJhY2s7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwicG9ydFwiOlxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihvcHRpb25zMiwgREVGQVVMVF9PUFRJT05TKTtcbiAgICAgICAgICAgIG9wdGlvbnMyLmVuY29kZVBhcnQgPSBwb3J0RW5jb2RlQ2FsbGJhY2s7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwicGF0aG5hbWVcIjpcbiAgICAgICAgICAgIGlmIChpc1NwZWNpYWxTY2hlbWUodGhpcy5yZWdleHAucHJvdG9jb2wpKSB7XG4gICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ob3B0aW9uczIsIFBBVEhOQU1FX09QVElPTlMsIGlnbm9yZUNhc2VPcHRpb25zKTtcbiAgICAgICAgICAgICAgb3B0aW9uczIuZW5jb2RlUGFydCA9IHN0YW5kYXJkVVJMUGF0aG5hbWVFbmNvZGVDYWxsYmFjaztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ob3B0aW9uczIsIERFRkFVTFRfT1BUSU9OUywgaWdub3JlQ2FzZU9wdGlvbnMpO1xuICAgICAgICAgICAgICBvcHRpb25zMi5lbmNvZGVQYXJ0ID0gcGF0aFVSTFBhdGhuYW1lRW5jb2RlQ2FsbGJhY2s7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwic2VhcmNoXCI6XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKG9wdGlvbnMyLCBERUZBVUxUX09QVElPTlMsIGlnbm9yZUNhc2VPcHRpb25zKTtcbiAgICAgICAgICAgIG9wdGlvbnMyLmVuY29kZVBhcnQgPSBzZWFyY2hFbmNvZGVDYWxsYmFjaztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJoYXNoXCI6XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKG9wdGlvbnMyLCBERUZBVUxUX09QVElPTlMsIGlnbm9yZUNhc2VPcHRpb25zKTtcbiAgICAgICAgICAgIG9wdGlvbnMyLmVuY29kZVBhcnQgPSBoYXNoRW5jb2RlQ2FsbGJhY2s7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoaXMucGFydHNbY29tcG9uZW50XSA9IHBhcnNlKHBhdHRlcm4sIG9wdGlvbnMyKTtcbiAgICAgICAgICB0aGlzLnJlZ2V4cFtjb21wb25lbnRdID0gcGFydHNUb1JlZ2V4cChcbiAgICAgICAgICAgIHRoaXMucGFydHNbY29tcG9uZW50XSxcbiAgICAgICAgICAgIC8qIG91dCAqL1xuICAgICAgICAgICAgdGhpcy5uYW1lc1tjb21wb25lbnRdLFxuICAgICAgICAgICAgb3B0aW9uczJcbiAgICAgICAgICApO1xuICAgICAgICAgIHRoaXMuY29tcG9uZW50X3BhdHRlcm5bY29tcG9uZW50XSA9IHBhcnRzVG9QYXR0ZXJuKHRoaXMucGFydHNbY29tcG9uZW50XSwgb3B0aW9uczIpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBpbnZhbGlkICR7Y29tcG9uZW50fSBwYXR0ZXJuICcke3RoaXMucGF0dGVybltjb21wb25lbnRdfScuYCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEZhaWxlZCB0byBjb25zdHJ1Y3QgJ1VSTFBhdHRlcm4nOiAke2Vyci5tZXNzYWdlfWApO1xuICAgIH1cbiAgfVxuICB0ZXN0KGlucHV0ID0ge30sIGJhc2VVUkwpIHtcbiAgICBsZXQgdmFsdWVzID0ge1xuICAgICAgcGF0aG5hbWU6IFwiXCIsXG4gICAgICBwcm90b2NvbDogXCJcIixcbiAgICAgIHVzZXJuYW1lOiBcIlwiLFxuICAgICAgcGFzc3dvcmQ6IFwiXCIsXG4gICAgICBob3N0bmFtZTogXCJcIixcbiAgICAgIHBvcnQ6IFwiXCIsXG4gICAgICBzZWFyY2g6IFwiXCIsXG4gICAgICBoYXNoOiBcIlwiXG4gICAgfTtcbiAgICBpZiAodHlwZW9mIGlucHV0ICE9PSBcInN0cmluZ1wiICYmIGJhc2VVUkwpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYHBhcmFtZXRlciAxIGlzIG5vdCBvZiB0eXBlICdzdHJpbmcnLmApO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBpZiAodHlwZW9mIGlucHV0ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHZhbHVlcyA9IGFwcGx5SW5pdCh2YWx1ZXMsIGlucHV0LCBmYWxzZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZXMgPSBhcHBseUluaXQodmFsdWVzLCBleHRyYWN0VmFsdWVzKGlucHV0LCBiYXNlVVJMKSwgZmFsc2UpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBsZXQgY29tcG9uZW50O1xuICAgIGZvciAoY29tcG9uZW50IG9mIENPTVBPTkVOVFMpIHtcbiAgICAgIGlmICghdGhpcy5yZWdleHBbY29tcG9uZW50XS5leGVjKHZhbHVlc1tjb21wb25lbnRdKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGV4ZWMoaW5wdXQgPSB7fSwgYmFzZVVSTCkge1xuICAgIGxldCB2YWx1ZXMgPSB7XG4gICAgICBwYXRobmFtZTogXCJcIixcbiAgICAgIHByb3RvY29sOiBcIlwiLFxuICAgICAgdXNlcm5hbWU6IFwiXCIsXG4gICAgICBwYXNzd29yZDogXCJcIixcbiAgICAgIGhvc3RuYW1lOiBcIlwiLFxuICAgICAgcG9ydDogXCJcIixcbiAgICAgIHNlYXJjaDogXCJcIixcbiAgICAgIGhhc2g6IFwiXCJcbiAgICB9O1xuICAgIGlmICh0eXBlb2YgaW5wdXQgIT09IFwic3RyaW5nXCIgJiYgYmFzZVVSTCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgcGFyYW1ldGVyIDEgaXMgbm90IG9mIHR5cGUgJ3N0cmluZycuYCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgdmFsdWVzID0gYXBwbHlJbml0KHZhbHVlcywgaW5wdXQsIGZhbHNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlcyA9IGFwcGx5SW5pdCh2YWx1ZXMsIGV4dHJhY3RWYWx1ZXMoaW5wdXQsIGJhc2VVUkwpLCBmYWxzZSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgbGV0IHJlc3VsdCA9IHt9O1xuICAgIGlmIChiYXNlVVJMKSB7XG4gICAgICByZXN1bHQuaW5wdXRzID0gW2lucHV0LCBiYXNlVVJMXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LmlucHV0cyA9IFtpbnB1dF07XG4gICAgfVxuICAgIGxldCBjb21wb25lbnQ7XG4gICAgZm9yIChjb21wb25lbnQgb2YgQ09NUE9ORU5UUykge1xuICAgICAgbGV0IG1hdGNoID0gdGhpcy5yZWdleHBbY29tcG9uZW50XS5leGVjKHZhbHVlc1tjb21wb25lbnRdKTtcbiAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBsZXQgZ3JvdXBzID0ge307XG4gICAgICBmb3IgKGxldCBbaSwgbmFtZV0gb2YgdGhpcy5uYW1lc1tjb21wb25lbnRdLmVudHJpZXMoKSkge1xuICAgICAgICBpZiAodHlwZW9mIG5hbWUgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIG5hbWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICBsZXQgdmFsdWUgPSBtYXRjaFtpICsgMV07XG4gICAgICAgICAgZ3JvdXBzW25hbWVdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlc3VsdFtjb21wb25lbnRdID0ge1xuICAgICAgICBpbnB1dDogdmFsdWVzW2NvbXBvbmVudF0gPz8gXCJcIixcbiAgICAgICAgZ3JvdXBzXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHN0YXRpYyBjb21wYXJlQ29tcG9uZW50KGNvbXBvbmVudCwgbGVmdCwgcmlnaHQpIHtcbiAgICBjb25zdCBjb21wYXJlUGFydCA9IChsZWZ0MiwgcmlnaHQyKSA9PiB7XG4gICAgICBmb3IgKGxldCBhdHRyIG9mIFtcInR5cGVcIiwgXCJtb2RpZmllclwiLCBcInByZWZpeFwiLCBcInZhbHVlXCIsIFwic3VmZml4XCJdKSB7XG4gICAgICAgIGlmIChsZWZ0MlthdHRyXSA8IHJpZ2h0MlthdHRyXSlcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIGVsc2UgaWYgKGxlZnQyW2F0dHJdID09PSByaWdodDJbYXR0cl0pXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAwO1xuICAgIH07XG4gICAgY29uc3QgZW1wdHlGaXhlZFBhcnQgPSBuZXcgUGFydCgzIC8qIGtGaXhlZCAqLywgXCJcIiwgXCJcIiwgXCJcIiwgXCJcIiwgMyAvKiBrTm9uZSAqLyk7XG4gICAgY29uc3Qgd2lsZGNhcmRPbmx5UGFydCA9IG5ldyBQYXJ0KDAgLyoga0Z1bGxXaWxkY2FyZCAqLywgXCJcIiwgXCJcIiwgXCJcIiwgXCJcIiwgMyAvKiBrTm9uZSAqLyk7XG4gICAgY29uc3QgY29tcGFyZVBhcnRMaXN0ID0gKGxlZnQyLCByaWdodDIpID0+IHtcbiAgICAgIGxldCBpID0gMDtcbiAgICAgIGZvciAoOyBpIDwgTWF0aC5taW4obGVmdDIubGVuZ3RoLCByaWdodDIubGVuZ3RoKTsgKytpKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBjb21wYXJlUGFydChsZWZ0MltpXSwgcmlnaHQyW2ldKTtcbiAgICAgICAgaWYgKHJlc3VsdClcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgaWYgKGxlZnQyLmxlbmd0aCA9PT0gcmlnaHQyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb21wYXJlUGFydChsZWZ0MltpXSA/PyBlbXB0eUZpeGVkUGFydCwgcmlnaHQyW2ldID8/IGVtcHR5Rml4ZWRQYXJ0KTtcbiAgICB9O1xuICAgIGlmICghbGVmdC5jb21wb25lbnRfcGF0dGVybltjb21wb25lbnRdICYmICFyaWdodC5jb21wb25lbnRfcGF0dGVybltjb21wb25lbnRdKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgaWYgKGxlZnQuY29tcG9uZW50X3BhdHRlcm5bY29tcG9uZW50XSAmJiAhcmlnaHQuY29tcG9uZW50X3BhdHRlcm5bY29tcG9uZW50XSkge1xuICAgICAgcmV0dXJuIGNvbXBhcmVQYXJ0TGlzdChsZWZ0LnBhcnRzW2NvbXBvbmVudF0sIFt3aWxkY2FyZE9ubHlQYXJ0XSk7XG4gICAgfVxuICAgIGlmICghbGVmdC5jb21wb25lbnRfcGF0dGVybltjb21wb25lbnRdICYmIHJpZ2h0LmNvbXBvbmVudF9wYXR0ZXJuW2NvbXBvbmVudF0pIHtcbiAgICAgIHJldHVybiBjb21wYXJlUGFydExpc3QoW3dpbGRjYXJkT25seVBhcnRdLCByaWdodC5wYXJ0c1tjb21wb25lbnRdKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbXBhcmVQYXJ0TGlzdChsZWZ0LnBhcnRzW2NvbXBvbmVudF0sIHJpZ2h0LnBhcnRzW2NvbXBvbmVudF0pO1xuICB9XG4gIGdldCBwcm90b2NvbCgpIHtcbiAgICByZXR1cm4gdGhpcy5jb21wb25lbnRfcGF0dGVybi5wcm90b2NvbDtcbiAgfVxuICBnZXQgdXNlcm5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29tcG9uZW50X3BhdHRlcm4udXNlcm5hbWU7XG4gIH1cbiAgZ2V0IHBhc3N3b3JkKCkge1xuICAgIHJldHVybiB0aGlzLmNvbXBvbmVudF9wYXR0ZXJuLnBhc3N3b3JkO1xuICB9XG4gIGdldCBob3N0bmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jb21wb25lbnRfcGF0dGVybi5ob3N0bmFtZTtcbiAgfVxuICBnZXQgcG9ydCgpIHtcbiAgICByZXR1cm4gdGhpcy5jb21wb25lbnRfcGF0dGVybi5wb3J0O1xuICB9XG4gIGdldCBwYXRobmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jb21wb25lbnRfcGF0dGVybi5wYXRobmFtZTtcbiAgfVxuICBnZXQgc2VhcmNoKCkge1xuICAgIHJldHVybiB0aGlzLmNvbXBvbmVudF9wYXR0ZXJuLnNlYXJjaDtcbiAgfVxuICBnZXQgaGFzaCgpIHtcbiAgICByZXR1cm4gdGhpcy5jb21wb25lbnRfcGF0dGVybi5oYXNoO1xuICB9XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/urlpattern-polyfill/dist/urlpattern.cjs\n");

/***/ }),

/***/ "(ssr)/../node_modules/urlpattern-polyfill/index.cjs":
/*!*****************************************************!*\
  !*** ../node_modules/urlpattern-polyfill/index.cjs ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { URLPattern } = __webpack_require__(/*! ./dist/urlpattern.cjs */ \"(ssr)/../node_modules/urlpattern-polyfill/dist/urlpattern.cjs\");\n\nmodule.exports = { URLPattern };\n\nif (!globalThis.URLPattern) {\n  globalThis.URLPattern = URLPattern;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3VybHBhdHRlcm4tcG9seWZpbGwvaW5kZXguY2pzIiwibWFwcGluZ3MiOiJBQUFBLFFBQVEsYUFBYSxFQUFFLG1CQUFPLENBQUMsNEZBQXVCOztBQUV0RCxtQkFBbUI7O0FBRW5CO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xlZGdpdHkteWllbGQtZnJvbnRlbmQvLi4vbm9kZV9tb2R1bGVzL3VybHBhdHRlcm4tcG9seWZpbGwvaW5kZXguY2pzPzBkYTEiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgeyBVUkxQYXR0ZXJuIH0gPSByZXF1aXJlKFwiLi9kaXN0L3VybHBhdHRlcm4uY2pzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHsgVVJMUGF0dGVybiB9O1xuXG5pZiAoIWdsb2JhbFRoaXMuVVJMUGF0dGVybikge1xuICBnbG9iYWxUaGlzLlVSTFBhdHRlcm4gPSBVUkxQYXR0ZXJuO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/urlpattern-polyfill/index.cjs\n");

/***/ })

};
;