"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@repeaterjs";
exports.ids = ["vendor-chunks/@repeaterjs"];
exports.modules = {

/***/ "(ssr)/../node_modules/@repeaterjs/repeater/repeater.js":
/*!********************************************************!*\
  !*** ../node_modules/@repeaterjs/repeater/repeater.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DroppingBuffer: () => (/* binding */ DroppingBuffer),\n/* harmony export */   FixedBuffer: () => (/* binding */ FixedBuffer),\n/* harmony export */   MAX_QUEUE_LENGTH: () => (/* binding */ MAX_QUEUE_LENGTH),\n/* harmony export */   Repeater: () => (/* binding */ Repeater),\n/* harmony export */   RepeaterOverflowError: () => (/* binding */ RepeaterOverflowError),\n/* harmony export */   SlidingBuffer: () => (/* binding */ SlidingBuffer)\n/* harmony export */ });\n/// <reference types=\"./repeater.d.ts\" />\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nfunction __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nfunction __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nfunction __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nfunction __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\n\n/** An error subclass which is thrown when there are too many pending push or next operations on a single repeater. */\r\nvar RepeaterOverflowError = /** @class */ (function (_super) {\r\n    __extends(RepeaterOverflowError, _super);\r\n    function RepeaterOverflowError(message) {\r\n        var _this = _super.call(this, message) || this;\r\n        Object.defineProperty(_this, \"name\", {\r\n            value: \"RepeaterOverflowError\",\r\n            enumerable: false,\r\n        });\r\n        if (typeof Object.setPrototypeOf === \"function\") {\r\n            Object.setPrototypeOf(_this, _this.constructor.prototype);\r\n        }\r\n        else {\r\n            _this.__proto__ = _this.constructor.prototype;\r\n        }\r\n        if (typeof Error.captureStackTrace === \"function\") {\r\n            Error.captureStackTrace(_this, _this.constructor);\r\n        }\r\n        return _this;\r\n    }\r\n    return RepeaterOverflowError;\r\n}(Error));\r\n/** A buffer which allows you to push a set amount of values to the repeater without pushes waiting or throwing errors. */\r\nvar FixedBuffer = /** @class */ (function () {\r\n    function FixedBuffer(capacity) {\r\n        if (capacity < 0) {\r\n            throw new RangeError(\"Capacity may not be less than 0\");\r\n        }\r\n        this._c = capacity;\r\n        this._q = [];\r\n    }\r\n    Object.defineProperty(FixedBuffer.prototype, \"empty\", {\r\n        get: function () {\r\n            return this._q.length === 0;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(FixedBuffer.prototype, \"full\", {\r\n        get: function () {\r\n            return this._q.length >= this._c;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    FixedBuffer.prototype.add = function (value) {\r\n        if (this.full) {\r\n            throw new Error(\"Buffer full\");\r\n        }\r\n        else {\r\n            this._q.push(value);\r\n        }\r\n    };\r\n    FixedBuffer.prototype.remove = function () {\r\n        if (this.empty) {\r\n            throw new Error(\"Buffer empty\");\r\n        }\r\n        return this._q.shift();\r\n    };\r\n    return FixedBuffer;\r\n}());\r\n// TODO: Use a circular buffer here.\r\n/** Sliding buffers allow you to push a set amount of values to the repeater without pushes waiting or throwing errors. If the number of values exceeds the capacity set in the constructor, the buffer will discard the earliest values added. */\r\nvar SlidingBuffer = /** @class */ (function () {\r\n    function SlidingBuffer(capacity) {\r\n        if (capacity < 1) {\r\n            throw new RangeError(\"Capacity may not be less than 1\");\r\n        }\r\n        this._c = capacity;\r\n        this._q = [];\r\n    }\r\n    Object.defineProperty(SlidingBuffer.prototype, \"empty\", {\r\n        get: function () {\r\n            return this._q.length === 0;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(SlidingBuffer.prototype, \"full\", {\r\n        get: function () {\r\n            return false;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    SlidingBuffer.prototype.add = function (value) {\r\n        while (this._q.length >= this._c) {\r\n            this._q.shift();\r\n        }\r\n        this._q.push(value);\r\n    };\r\n    SlidingBuffer.prototype.remove = function () {\r\n        if (this.empty) {\r\n            throw new Error(\"Buffer empty\");\r\n        }\r\n        return this._q.shift();\r\n    };\r\n    return SlidingBuffer;\r\n}());\r\n/** Dropping buffers allow you to push a set amount of values to the repeater without the push function waiting or throwing errors. If the number of values exceeds the capacity set in the constructor, the buffer will discard the latest values added. */\r\nvar DroppingBuffer = /** @class */ (function () {\r\n    function DroppingBuffer(capacity) {\r\n        if (capacity < 1) {\r\n            throw new RangeError(\"Capacity may not be less than 1\");\r\n        }\r\n        this._c = capacity;\r\n        this._q = [];\r\n    }\r\n    Object.defineProperty(DroppingBuffer.prototype, \"empty\", {\r\n        get: function () {\r\n            return this._q.length === 0;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(DroppingBuffer.prototype, \"full\", {\r\n        get: function () {\r\n            return false;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    DroppingBuffer.prototype.add = function (value) {\r\n        if (this._q.length < this._c) {\r\n            this._q.push(value);\r\n        }\r\n    };\r\n    DroppingBuffer.prototype.remove = function () {\r\n        if (this.empty) {\r\n            throw new Error(\"Buffer empty\");\r\n        }\r\n        return this._q.shift();\r\n    };\r\n    return DroppingBuffer;\r\n}());\r\n/** Makes sure promise-likes don’t cause unhandled rejections. */\r\nfunction swallow(value) {\r\n    if (value != null && typeof value.then === \"function\") {\r\n        value.then(NOOP, NOOP);\r\n    }\r\n}\r\n/*** REPEATER STATES ***/\r\n/** The following is an enumeration of all possible repeater states. These states are ordered, and a repeater may only advance to higher states. */\r\n/** The initial state of the repeater. */\r\nvar Initial = 0;\r\n/** Repeaters advance to this state the first time the next method is called on the repeater. */\r\nvar Started = 1;\r\n/** Repeaters advance to this state when the stop function is called. */\r\nvar Stopped = 2;\r\n/** Repeaters advance to this state when there are no values left to be pulled from the repeater. */\r\nvar Done = 3;\r\n/** Repeaters advance to this state if an error is thrown into the repeater. */\r\nvar Rejected = 4;\r\n/** The maximum number of push or next operations which may exist on a single repeater. */\r\nvar MAX_QUEUE_LENGTH = 1024;\r\nvar NOOP = function () { };\r\n/** A helper function used to mimic the behavior of async generators where the final iteration is consumed. */\r\nfunction consumeExecution(r) {\r\n    var err = r.err;\r\n    var execution = Promise.resolve(r.execution).then(function (value) {\r\n        if (err != null) {\r\n            throw err;\r\n        }\r\n        return value;\r\n    });\r\n    r.err = undefined;\r\n    r.execution = execution.then(function () { return undefined; }, function () { return undefined; });\r\n    return r.pending === undefined ? execution : r.pending.then(function () { return execution; });\r\n}\r\n/** A helper function for building iterations from values. Promises are unwrapped, so that iterations never have their value property set to a promise. */\r\nfunction createIteration(r, value) {\r\n    var done = r.state >= Done;\r\n    return Promise.resolve(value).then(function (value) {\r\n        if (!done && r.state >= Rejected) {\r\n            return consumeExecution(r).then(function (value) { return ({\r\n                value: value,\r\n                done: true,\r\n            }); });\r\n        }\r\n        return { value: value, done: done };\r\n    });\r\n}\r\n/**\r\n * This function is bound and passed to the executor as the stop argument.\r\n *\r\n * Advances state to Stopped.\r\n */\r\nfunction stop(r, err) {\r\n    var e_1, _a;\r\n    if (r.state >= Stopped) {\r\n        return;\r\n    }\r\n    r.state = Stopped;\r\n    r.onnext();\r\n    r.onstop();\r\n    if (r.err == null) {\r\n        r.err = err;\r\n    }\r\n    if (r.pushes.length === 0 &&\r\n        (typeof r.buffer === \"undefined\" || r.buffer.empty)) {\r\n        finish(r);\r\n    }\r\n    else {\r\n        try {\r\n            for (var _b = __values(r.pushes), _d = _b.next(); !_d.done; _d = _b.next()) {\r\n                var push_1 = _d.value;\r\n                push_1.resolve();\r\n            }\r\n        }\r\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n        finally {\r\n            try {\r\n                if (_d && !_d.done && (_a = _b.return)) _a.call(_b);\r\n            }\r\n            finally { if (e_1) throw e_1.error; }\r\n        }\r\n    }\r\n}\r\n/**\r\n * The difference between stopping a repeater vs finishing a repeater is that stopping a repeater allows next to continue to drain values from the push queue and buffer, while finishing a repeater will clear all pending values and end iteration immediately. Once, a repeater is finished, all iterations will have the done property set to true.\r\n *\r\n * Advances state to Done.\r\n */\r\nfunction finish(r) {\r\n    var e_2, _a;\r\n    if (r.state >= Done) {\r\n        return;\r\n    }\r\n    if (r.state < Stopped) {\r\n        stop(r);\r\n    }\r\n    r.state = Done;\r\n    r.buffer = undefined;\r\n    try {\r\n        for (var _b = __values(r.nexts), _d = _b.next(); !_d.done; _d = _b.next()) {\r\n            var next = _d.value;\r\n            var execution = r.pending === undefined\r\n                ? consumeExecution(r)\r\n                : r.pending.then(function () { return consumeExecution(r); });\r\n            next.resolve(createIteration(r, execution));\r\n        }\r\n    }\r\n    catch (e_2_1) { e_2 = { error: e_2_1 }; }\r\n    finally {\r\n        try {\r\n            if (_d && !_d.done && (_a = _b.return)) _a.call(_b);\r\n        }\r\n        finally { if (e_2) throw e_2.error; }\r\n    }\r\n    r.pushes = [];\r\n    r.nexts = [];\r\n}\r\n/**\r\n * Called when a promise passed to push rejects, or when a push call is unhandled.\r\n *\r\n * Advances state to Rejected.\r\n */\r\nfunction reject(r) {\r\n    if (r.state >= Rejected) {\r\n        return;\r\n    }\r\n    if (r.state < Done) {\r\n        finish(r);\r\n    }\r\n    r.state = Rejected;\r\n}\r\n/** This function is bound and passed to the executor as the push argument. */\r\nfunction push(r, value) {\r\n    swallow(value);\r\n    if (r.pushes.length >= MAX_QUEUE_LENGTH) {\r\n        throw new RepeaterOverflowError(\"No more than \" + MAX_QUEUE_LENGTH + \" pending calls to push are allowed on a single repeater.\");\r\n    }\r\n    else if (r.state >= Stopped) {\r\n        return Promise.resolve(undefined);\r\n    }\r\n    var valueP = r.pending === undefined\r\n        ? Promise.resolve(value)\r\n        : r.pending.then(function () { return value; });\r\n    valueP = valueP.catch(function (err) {\r\n        if (r.state < Stopped) {\r\n            r.err = err;\r\n        }\r\n        reject(r);\r\n        return undefined; // void :(\r\n    });\r\n    var nextP;\r\n    if (r.nexts.length) {\r\n        var next_1 = r.nexts.shift();\r\n        next_1.resolve(createIteration(r, valueP));\r\n        if (r.nexts.length) {\r\n            nextP = Promise.resolve(r.nexts[0].value);\r\n        }\r\n        else if (typeof r.buffer !== \"undefined\" && !r.buffer.full) {\r\n            nextP = Promise.resolve(undefined);\r\n        }\r\n        else {\r\n            nextP = new Promise(function (resolve) { return (r.onnext = resolve); });\r\n        }\r\n    }\r\n    else if (typeof r.buffer !== \"undefined\" && !r.buffer.full) {\r\n        r.buffer.add(valueP);\r\n        nextP = Promise.resolve(undefined);\r\n    }\r\n    else {\r\n        nextP = new Promise(function (resolve) { return r.pushes.push({ resolve: resolve, value: valueP }); });\r\n    }\r\n    // If an error is thrown into the repeater via the next or throw methods, we give the repeater a chance to handle this by rejecting the promise returned from push. If the push call is not immediately handled we throw the next iteration of the repeater.\r\n    // To check that the promise returned from push is floating, we modify the then and catch methods of the returned promise so that they flip the floating flag. The push function actually does not return a promise, because modern engines do not call the then and catch methods on native promises. By making next a plain old javascript object, we ensure that the then and catch methods will be called.\r\n    var floating = true;\r\n    var next = {};\r\n    var unhandled = nextP.catch(function (err) {\r\n        if (floating) {\r\n            throw err;\r\n        }\r\n        return undefined; // void :(\r\n    });\r\n    next.then = function (onfulfilled, onrejected) {\r\n        floating = false;\r\n        return Promise.prototype.then.call(nextP, onfulfilled, onrejected);\r\n    };\r\n    next.catch = function (onrejected) {\r\n        floating = false;\r\n        return Promise.prototype.catch.call(nextP, onrejected);\r\n    };\r\n    next.finally = nextP.finally.bind(nextP);\r\n    r.pending = valueP\r\n        .then(function () { return unhandled; })\r\n        .catch(function (err) {\r\n        r.err = err;\r\n        reject(r);\r\n    });\r\n    return next;\r\n}\r\n/**\r\n * Creates the stop callable promise which is passed to the executor\r\n */\r\nfunction createStop(r) {\r\n    var stop1 = stop.bind(null, r);\r\n    var stopP = new Promise(function (resolve) { return (r.onstop = resolve); });\r\n    stop1.then = stopP.then.bind(stopP);\r\n    stop1.catch = stopP.catch.bind(stopP);\r\n    stop1.finally = stopP.finally.bind(stopP);\r\n    return stop1;\r\n}\r\n/**\r\n * Calls the executor passed into the constructor. This function is called the first time the next method is called on the repeater.\r\n *\r\n * Advances state to Started.\r\n */\r\nfunction execute(r) {\r\n    if (r.state >= Started) {\r\n        return;\r\n    }\r\n    r.state = Started;\r\n    var push1 = push.bind(null, r);\r\n    var stop1 = createStop(r);\r\n    r.execution = new Promise(function (resolve) { return resolve(r.executor(push1, stop1)); });\r\n    // TODO: We should consider stopping all repeaters when the executor settles.\r\n    r.execution.catch(function () { return stop(r); });\r\n}\r\nvar records = new WeakMap();\r\n// NOTE: While repeaters implement and are assignable to the AsyncGenerator interface, and you can use the types interchangeably, we don’t use typescript’s implements syntax here because this would make supporting earlier versions of typescript trickier. This is because TypeScript version 3.6 changed the iterator types by adding the TReturn and TNext type parameters.\r\nvar Repeater = /** @class */ (function () {\r\n    function Repeater(executor, buffer) {\r\n        records.set(this, {\r\n            executor: executor,\r\n            buffer: buffer,\r\n            err: undefined,\r\n            state: Initial,\r\n            pushes: [],\r\n            nexts: [],\r\n            pending: undefined,\r\n            execution: undefined,\r\n            onnext: NOOP,\r\n            onstop: NOOP,\r\n        });\r\n    }\r\n    Repeater.prototype.next = function (value) {\r\n        swallow(value);\r\n        var r = records.get(this);\r\n        if (r === undefined) {\r\n            throw new Error(\"WeakMap error\");\r\n        }\r\n        if (r.nexts.length >= MAX_QUEUE_LENGTH) {\r\n            throw new RepeaterOverflowError(\"No more than \" + MAX_QUEUE_LENGTH + \" pending calls to next are allowed on a single repeater.\");\r\n        }\r\n        if (r.state <= Initial) {\r\n            execute(r);\r\n        }\r\n        r.onnext(value);\r\n        if (typeof r.buffer !== \"undefined\" && !r.buffer.empty) {\r\n            var result = createIteration(r, r.buffer.remove());\r\n            if (r.pushes.length) {\r\n                var push_2 = r.pushes.shift();\r\n                r.buffer.add(push_2.value);\r\n                r.onnext = push_2.resolve;\r\n            }\r\n            return result;\r\n        }\r\n        else if (r.pushes.length) {\r\n            var push_3 = r.pushes.shift();\r\n            r.onnext = push_3.resolve;\r\n            return createIteration(r, push_3.value);\r\n        }\r\n        else if (r.state >= Stopped) {\r\n            finish(r);\r\n            return createIteration(r, consumeExecution(r));\r\n        }\r\n        return new Promise(function (resolve) { return r.nexts.push({ resolve: resolve, value: value }); });\r\n    };\r\n    Repeater.prototype.return = function (value) {\r\n        swallow(value);\r\n        var r = records.get(this);\r\n        if (r === undefined) {\r\n            throw new Error(\"WeakMap error\");\r\n        }\r\n        finish(r);\r\n        // We override the execution because return should always return the value passed in.\r\n        r.execution = Promise.resolve(r.execution).then(function () { return value; });\r\n        return createIteration(r, consumeExecution(r));\r\n    };\r\n    Repeater.prototype.throw = function (err) {\r\n        var r = records.get(this);\r\n        if (r === undefined) {\r\n            throw new Error(\"WeakMap error\");\r\n        }\r\n        if (r.state <= Initial ||\r\n            r.state >= Stopped ||\r\n            (typeof r.buffer !== \"undefined\" && !r.buffer.empty)) {\r\n            finish(r);\r\n            // If r.err is already set, that mean the repeater has already produced an error, so we throw that error rather than the error passed in, because doing so might be more informative for the caller.\r\n            if (r.err == null) {\r\n                r.err = err;\r\n            }\r\n            return createIteration(r, consumeExecution(r));\r\n        }\r\n        return this.next(Promise.reject(err));\r\n    };\r\n    Repeater.prototype[Symbol.asyncIterator] = function () {\r\n        return this;\r\n    };\r\n    // TODO: Remove these static methods from the class.\r\n    Repeater.race = race;\r\n    Repeater.merge = merge;\r\n    Repeater.zip = zip;\r\n    Repeater.latest = latest;\r\n    return Repeater;\r\n}());\r\n/*** COMBINATOR FUNCTIONS ***/\r\n// TODO: move these combinators to their own file.\r\nfunction getIterators(values, options) {\r\n    var e_3, _a;\r\n    var iters = [];\r\n    var _loop_1 = function (value) {\r\n        if (value != null && typeof value[Symbol.asyncIterator] === \"function\") {\r\n            iters.push(value[Symbol.asyncIterator]());\r\n        }\r\n        else if (value != null && typeof value[Symbol.iterator] === \"function\") {\r\n            iters.push(value[Symbol.iterator]());\r\n        }\r\n        else {\r\n            iters.push((function valueToAsyncIterator() {\r\n                return __asyncGenerator(this, arguments, function valueToAsyncIterator_1() {\r\n                    return __generator(this, function (_a) {\r\n                        switch (_a.label) {\r\n                            case 0:\r\n                                if (!options.yieldValues) return [3 /*break*/, 3];\r\n                                return [4 /*yield*/, __await(value)];\r\n                            case 1: return [4 /*yield*/, _a.sent()];\r\n                            case 2:\r\n                                _a.sent();\r\n                                _a.label = 3;\r\n                            case 3:\r\n                                if (!options.returnValues) return [3 /*break*/, 5];\r\n                                return [4 /*yield*/, __await(value)];\r\n                            case 4: return [2 /*return*/, _a.sent()];\r\n                            case 5: return [2 /*return*/];\r\n                        }\r\n                    });\r\n                });\r\n            })());\r\n        }\r\n    };\r\n    try {\r\n        for (var values_1 = __values(values), values_1_1 = values_1.next(); !values_1_1.done; values_1_1 = values_1.next()) {\r\n            var value = values_1_1.value;\r\n            _loop_1(value);\r\n        }\r\n    }\r\n    catch (e_3_1) { e_3 = { error: e_3_1 }; }\r\n    finally {\r\n        try {\r\n            if (values_1_1 && !values_1_1.done && (_a = values_1.return)) _a.call(values_1);\r\n        }\r\n        finally { if (e_3) throw e_3.error; }\r\n    }\r\n    return iters;\r\n}\r\n// NOTE: whenever you see any variables called `advance` or `advances`, know that it is a hack to get around the fact that `Promise.race` leaks memory. These variables are intended to be set to the resolve function of a promise which is constructed and awaited as an alternative to Promise.race. For more information, see this comment in the Node.js issue tracker: https://github.com/nodejs/node/issues/17469#issuecomment-685216777.\r\nfunction race(contenders) {\r\n    var _this = this;\r\n    var iters = getIterators(contenders, { returnValues: true });\r\n    return new Repeater(function (push, stop) { return __awaiter(_this, void 0, void 0, function () {\r\n        var advance, stopped, finalIteration, iteration, i_1, _loop_2;\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0:\r\n                    if (!iters.length) {\r\n                        stop();\r\n                        return [2 /*return*/];\r\n                    }\r\n                    stopped = false;\r\n                    stop.then(function () {\r\n                        advance();\r\n                        stopped = true;\r\n                    });\r\n                    _a.label = 1;\r\n                case 1:\r\n                    _a.trys.push([1, , 5, 7]);\r\n                    iteration = void 0;\r\n                    i_1 = 0;\r\n                    _loop_2 = function () {\r\n                        var j, iters_1, iters_1_1, iter;\r\n                        var e_4, _a;\r\n                        return __generator(this, function (_b) {\r\n                            switch (_b.label) {\r\n                                case 0:\r\n                                    j = i_1;\r\n                                    try {\r\n                                        for (iters_1 = (e_4 = void 0, __values(iters)), iters_1_1 = iters_1.next(); !iters_1_1.done; iters_1_1 = iters_1.next()) {\r\n                                            iter = iters_1_1.value;\r\n                                            Promise.resolve(iter.next()).then(function (iteration) {\r\n                                                if (iteration.done) {\r\n                                                    stop();\r\n                                                    if (finalIteration === undefined) {\r\n                                                        finalIteration = iteration;\r\n                                                    }\r\n                                                }\r\n                                                else if (i_1 === j) {\r\n                                                    // This iterator has won, advance i and resolve the promise.\r\n                                                    i_1++;\r\n                                                    advance(iteration);\r\n                                                }\r\n                                            }, function (err) { return stop(err); });\r\n                                        }\r\n                                    }\r\n                                    catch (e_4_1) { e_4 = { error: e_4_1 }; }\r\n                                    finally {\r\n                                        try {\r\n                                            if (iters_1_1 && !iters_1_1.done && (_a = iters_1.return)) _a.call(iters_1);\r\n                                        }\r\n                                        finally { if (e_4) throw e_4.error; }\r\n                                    }\r\n                                    return [4 /*yield*/, new Promise(function (resolve) { return (advance = resolve); })];\r\n                                case 1:\r\n                                    iteration = _b.sent();\r\n                                    if (!(iteration !== undefined)) return [3 /*break*/, 3];\r\n                                    return [4 /*yield*/, push(iteration.value)];\r\n                                case 2:\r\n                                    _b.sent();\r\n                                    _b.label = 3;\r\n                                case 3: return [2 /*return*/];\r\n                            }\r\n                        });\r\n                    };\r\n                    _a.label = 2;\r\n                case 2:\r\n                    if (!!stopped) return [3 /*break*/, 4];\r\n                    return [5 /*yield**/, _loop_2()];\r\n                case 3:\r\n                    _a.sent();\r\n                    return [3 /*break*/, 2];\r\n                case 4: return [2 /*return*/, finalIteration && finalIteration.value];\r\n                case 5:\r\n                    stop();\r\n                    return [4 /*yield*/, Promise.race(iters.map(function (iter) { return iter.return && iter.return(); }))];\r\n                case 6:\r\n                    _a.sent();\r\n                    return [7 /*endfinally*/];\r\n                case 7: return [2 /*return*/];\r\n            }\r\n        });\r\n    }); });\r\n}\r\nfunction merge(contenders) {\r\n    var _this = this;\r\n    var iters = getIterators(contenders, { yieldValues: true });\r\n    return new Repeater(function (push, stop) { return __awaiter(_this, void 0, void 0, function () {\r\n        var advances, stopped, finalIteration;\r\n        var _this = this;\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0:\r\n                    if (!iters.length) {\r\n                        stop();\r\n                        return [2 /*return*/];\r\n                    }\r\n                    advances = [];\r\n                    stopped = false;\r\n                    stop.then(function () {\r\n                        var e_5, _a;\r\n                        stopped = true;\r\n                        try {\r\n                            for (var advances_1 = __values(advances), advances_1_1 = advances_1.next(); !advances_1_1.done; advances_1_1 = advances_1.next()) {\r\n                                var advance = advances_1_1.value;\r\n                                advance();\r\n                            }\r\n                        }\r\n                        catch (e_5_1) { e_5 = { error: e_5_1 }; }\r\n                        finally {\r\n                            try {\r\n                                if (advances_1_1 && !advances_1_1.done && (_a = advances_1.return)) _a.call(advances_1);\r\n                            }\r\n                            finally { if (e_5) throw e_5.error; }\r\n                        }\r\n                    });\r\n                    _a.label = 1;\r\n                case 1:\r\n                    _a.trys.push([1, , 3, 4]);\r\n                    return [4 /*yield*/, Promise.all(iters.map(function (iter, i) { return __awaiter(_this, void 0, void 0, function () {\r\n                            var iteration, _a;\r\n                            return __generator(this, function (_b) {\r\n                                switch (_b.label) {\r\n                                    case 0:\r\n                                        _b.trys.push([0, , 6, 9]);\r\n                                        _b.label = 1;\r\n                                    case 1:\r\n                                        if (!!stopped) return [3 /*break*/, 5];\r\n                                        Promise.resolve(iter.next()).then(function (iteration) { return advances[i](iteration); }, function (err) { return stop(err); });\r\n                                        return [4 /*yield*/, new Promise(function (resolve) {\r\n                                                advances[i] = resolve;\r\n                                            })];\r\n                                    case 2:\r\n                                        iteration = _b.sent();\r\n                                        if (!(iteration !== undefined)) return [3 /*break*/, 4];\r\n                                        if (iteration.done) {\r\n                                            finalIteration = iteration;\r\n                                            return [2 /*return*/];\r\n                                        }\r\n                                        return [4 /*yield*/, push(iteration.value)];\r\n                                    case 3:\r\n                                        _b.sent();\r\n                                        _b.label = 4;\r\n                                    case 4: return [3 /*break*/, 1];\r\n                                    case 5: return [3 /*break*/, 9];\r\n                                    case 6:\r\n                                        _a = iter.return;\r\n                                        if (!_a) return [3 /*break*/, 8];\r\n                                        return [4 /*yield*/, iter.return()];\r\n                                    case 7:\r\n                                        _a = (_b.sent());\r\n                                        _b.label = 8;\r\n                                    case 8:\r\n                                        return [7 /*endfinally*/];\r\n                                    case 9: return [2 /*return*/];\r\n                                }\r\n                            });\r\n                        }); }))];\r\n                case 2:\r\n                    _a.sent();\r\n                    return [2 /*return*/, finalIteration && finalIteration.value];\r\n                case 3:\r\n                    stop();\r\n                    return [7 /*endfinally*/];\r\n                case 4: return [2 /*return*/];\r\n            }\r\n        });\r\n    }); });\r\n}\r\nfunction zip(contenders) {\r\n    var _this = this;\r\n    var iters = getIterators(contenders, { returnValues: true });\r\n    return new Repeater(function (push, stop) { return __awaiter(_this, void 0, void 0, function () {\r\n        var advance, stopped, iterations, values;\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0:\r\n                    if (!iters.length) {\r\n                        stop();\r\n                        return [2 /*return*/, []];\r\n                    }\r\n                    stopped = false;\r\n                    stop.then(function () {\r\n                        advance();\r\n                        stopped = true;\r\n                    });\r\n                    _a.label = 1;\r\n                case 1:\r\n                    _a.trys.push([1, , 6, 8]);\r\n                    _a.label = 2;\r\n                case 2:\r\n                    if (!!stopped) return [3 /*break*/, 5];\r\n                    Promise.all(iters.map(function (iter) { return iter.next(); })).then(function (iterations) { return advance(iterations); }, function (err) { return stop(err); });\r\n                    return [4 /*yield*/, new Promise(function (resolve) { return (advance = resolve); })];\r\n                case 3:\r\n                    iterations = _a.sent();\r\n                    if (iterations === undefined) {\r\n                        return [2 /*return*/];\r\n                    }\r\n                    values = iterations.map(function (iteration) { return iteration.value; });\r\n                    if (iterations.some(function (iteration) { return iteration.done; })) {\r\n                        return [2 /*return*/, values];\r\n                    }\r\n                    return [4 /*yield*/, push(values)];\r\n                case 4:\r\n                    _a.sent();\r\n                    return [3 /*break*/, 2];\r\n                case 5: return [3 /*break*/, 8];\r\n                case 6:\r\n                    stop();\r\n                    return [4 /*yield*/, Promise.all(iters.map(function (iter) { return iter.return && iter.return(); }))];\r\n                case 7:\r\n                    _a.sent();\r\n                    return [7 /*endfinally*/];\r\n                case 8: return [2 /*return*/];\r\n            }\r\n        });\r\n    }); });\r\n}\r\nfunction latest(contenders) {\r\n    var _this = this;\r\n    var iters = getIterators(contenders, {\r\n        yieldValues: true,\r\n        returnValues: true,\r\n    });\r\n    return new Repeater(function (push, stop) { return __awaiter(_this, void 0, void 0, function () {\r\n        var advance, advances, stopped, iterations_1, values_2;\r\n        var _this = this;\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0:\r\n                    if (!iters.length) {\r\n                        stop();\r\n                        return [2 /*return*/, []];\r\n                    }\r\n                    advances = [];\r\n                    stopped = false;\r\n                    stop.then(function () {\r\n                        var e_6, _a;\r\n                        advance();\r\n                        try {\r\n                            for (var advances_2 = __values(advances), advances_2_1 = advances_2.next(); !advances_2_1.done; advances_2_1 = advances_2.next()) {\r\n                                var advance1 = advances_2_1.value;\r\n                                advance1();\r\n                            }\r\n                        }\r\n                        catch (e_6_1) { e_6 = { error: e_6_1 }; }\r\n                        finally {\r\n                            try {\r\n                                if (advances_2_1 && !advances_2_1.done && (_a = advances_2.return)) _a.call(advances_2);\r\n                            }\r\n                            finally { if (e_6) throw e_6.error; }\r\n                        }\r\n                        stopped = true;\r\n                    });\r\n                    _a.label = 1;\r\n                case 1:\r\n                    _a.trys.push([1, , 5, 7]);\r\n                    Promise.all(iters.map(function (iter) { return iter.next(); })).then(function (iterations) { return advance(iterations); }, function (err) { return stop(err); });\r\n                    return [4 /*yield*/, new Promise(function (resolve) { return (advance = resolve); })];\r\n                case 2:\r\n                    iterations_1 = _a.sent();\r\n                    if (iterations_1 === undefined) {\r\n                        return [2 /*return*/];\r\n                    }\r\n                    values_2 = iterations_1.map(function (iteration) { return iteration.value; });\r\n                    if (iterations_1.every(function (iteration) { return iteration.done; })) {\r\n                        return [2 /*return*/, values_2];\r\n                    }\r\n                    // We continuously yield and mutate the same values array so we shallow copy it each time it is pushed.\r\n                    return [4 /*yield*/, push(values_2.slice())];\r\n                case 3:\r\n                    // We continuously yield and mutate the same values array so we shallow copy it each time it is pushed.\r\n                    _a.sent();\r\n                    return [4 /*yield*/, Promise.all(iters.map(function (iter, i) { return __awaiter(_this, void 0, void 0, function () {\r\n                            var iteration;\r\n                            return __generator(this, function (_a) {\r\n                                switch (_a.label) {\r\n                                    case 0:\r\n                                        if (iterations_1[i].done) {\r\n                                            return [2 /*return*/, iterations_1[i].value];\r\n                                        }\r\n                                        _a.label = 1;\r\n                                    case 1:\r\n                                        if (!!stopped) return [3 /*break*/, 4];\r\n                                        Promise.resolve(iter.next()).then(function (iteration) { return advances[i](iteration); }, function (err) { return stop(err); });\r\n                                        return [4 /*yield*/, new Promise(function (resolve) { return (advances[i] = resolve); })];\r\n                                    case 2:\r\n                                        iteration = _a.sent();\r\n                                        if (iteration === undefined) {\r\n                                            return [2 /*return*/, iterations_1[i].value];\r\n                                        }\r\n                                        else if (iteration.done) {\r\n                                            return [2 /*return*/, iteration.value];\r\n                                        }\r\n                                        values_2[i] = iteration.value;\r\n                                        return [4 /*yield*/, push(values_2.slice())];\r\n                                    case 3:\r\n                                        _a.sent();\r\n                                        return [3 /*break*/, 1];\r\n                                    case 4: return [2 /*return*/];\r\n                                }\r\n                            });\r\n                        }); }))];\r\n                case 4: return [2 /*return*/, _a.sent()];\r\n                case 5:\r\n                    stop();\r\n                    return [4 /*yield*/, Promise.all(iters.map(function (iter) { return iter.return && iter.return(); }))];\r\n                case 6:\r\n                    _a.sent();\r\n                    return [7 /*endfinally*/];\r\n                case 7: return [2 /*return*/];\r\n            }\r\n        });\r\n    }); });\r\n}\n\n\n//# sourceMappingURL=repeater.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0ByZXBlYXRlcmpzL3JlcGVhdGVyL3JlcGVhdGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0Isc0NBQXNDLGtCQUFrQjtBQUNuRiwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwrREFBK0QsaUJBQWlCO0FBQzVHO0FBQ0Esb0NBQW9DLE1BQU0sK0JBQStCLFlBQVk7QUFDckYsbUNBQW1DLE1BQU0sbUNBQW1DLFlBQVk7QUFDeEYsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGNBQWMsNkJBQTZCLDBCQUEwQixjQUFjLHFCQUFxQjtBQUN4RyxpQkFBaUIsb0RBQW9ELHFFQUFxRSxjQUFjO0FBQ3hKLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDLG1DQUFtQyxTQUFTO0FBQzVDLG1DQUFtQyxXQUFXLFVBQVU7QUFDeEQsMENBQTBDLGNBQWM7QUFDeEQ7QUFDQSw4R0FBOEcsT0FBTztBQUNySCxpRkFBaUYsaUJBQWlCO0FBQ2xHLHlEQUF5RCxnQkFBZ0IsUUFBUTtBQUNqRiwrQ0FBK0MsZ0JBQWdCLGdCQUFnQjtBQUMvRTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0EsVUFBVSxZQUFZLGFBQWEsU0FBUyxVQUFVO0FBQ3RELG9DQUFvQyxTQUFTO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0EsU0FBUztBQUNULEtBQUssSUFBSTtBQUNUOztBQUV5RztBQUN6RyIsInNvdXJjZXMiOlsid2VicGFjazovL2xlZGdpdHkteWllbGQtZnJvbnRlbmQvLi4vbm9kZV9tb2R1bGVzL0ByZXBlYXRlcmpzL3JlcGVhdGVyL3JlcGVhdGVyLmpzPzVmY2YiXSwic291cmNlc0NvbnRlbnQiOlsiLy8vIDxyZWZlcmVuY2UgdHlwZXM9XCIuL3JlcGVhdGVyLmQudHNcIiAvPlxuLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cclxuXHJcbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24oZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufVxyXG5cclxuZnVuY3Rpb24gX19hd2FpdGVyKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gX19nZW5lcmF0b3IodGhpc0FyZywgYm9keSkge1xyXG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcclxuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XHJcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xyXG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xyXG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XHJcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcclxuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XHJcbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fdmFsdWVzKG8pIHtcclxuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XHJcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcclxuICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcclxuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX2F3YWl0KHYpIHtcclxuICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgX19hd2FpdCA/ICh0aGlzLnYgPSB2LCB0aGlzKSA6IG5ldyBfX2F3YWl0KHYpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX2FzeW5jR2VuZXJhdG9yKHRoaXNBcmcsIF9hcmd1bWVudHMsIGdlbmVyYXRvcikge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBnID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pLCBpLCBxID0gW107XHJcbiAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaWYgKGdbbl0pIGlbbl0gPSBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGEsIGIpIHsgcS5wdXNoKFtuLCB2LCBhLCBiXSkgPiAxIHx8IHJlc3VtZShuLCB2KTsgfSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHJlc3VtZShuLCB2KSB7IHRyeSB7IHN0ZXAoZ1tuXSh2KSk7IH0gY2F0Y2ggKGUpIHsgc2V0dGxlKHFbMF1bM10sIGUpOyB9IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAocikgeyByLnZhbHVlIGluc3RhbmNlb2YgX19hd2FpdCA/IFByb21pc2UucmVzb2x2ZShyLnZhbHVlLnYpLnRoZW4oZnVsZmlsbCwgcmVqZWN0KSA6IHNldHRsZShxWzBdWzJdLCByKTsgfVxyXG4gICAgZnVuY3Rpb24gZnVsZmlsbCh2YWx1ZSkgeyByZXN1bWUoXCJuZXh0XCIsIHZhbHVlKTsgfVxyXG4gICAgZnVuY3Rpb24gcmVqZWN0KHZhbHVlKSB7IHJlc3VtZShcInRocm93XCIsIHZhbHVlKTsgfVxyXG4gICAgZnVuY3Rpb24gc2V0dGxlKGYsIHYpIHsgaWYgKGYodiksIHEuc2hpZnQoKSwgcS5sZW5ndGgpIHJlc3VtZShxWzBdWzBdLCBxWzBdWzFdKTsgfVxyXG59XG5cbi8qKiBBbiBlcnJvciBzdWJjbGFzcyB3aGljaCBpcyB0aHJvd24gd2hlbiB0aGVyZSBhcmUgdG9vIG1hbnkgcGVuZGluZyBwdXNoIG9yIG5leHQgb3BlcmF0aW9ucyBvbiBhIHNpbmdsZSByZXBlYXRlci4gKi9cclxudmFyIFJlcGVhdGVyT3ZlcmZsb3dFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhSZXBlYXRlck92ZXJmbG93RXJyb3IsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBSZXBlYXRlck92ZXJmbG93RXJyb3IobWVzc2FnZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG1lc3NhZ2UpIHx8IHRoaXM7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzLCBcIm5hbWVcIiwge1xyXG4gICAgICAgICAgICB2YWx1ZTogXCJSZXBlYXRlck92ZXJmbG93RXJyb3JcIixcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBPYmplY3Quc2V0UHJvdG90eXBlT2YgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoX3RoaXMsIF90aGlzLmNvbnN0cnVjdG9yLnByb3RvdHlwZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBfdGhpcy5fX3Byb3RvX18gPSBfdGhpcy5jb25zdHJ1Y3Rvci5wcm90b3R5cGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2YgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShfdGhpcywgX3RoaXMuY29uc3RydWN0b3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gUmVwZWF0ZXJPdmVyZmxvd0Vycm9yO1xyXG59KEVycm9yKSk7XHJcbi8qKiBBIGJ1ZmZlciB3aGljaCBhbGxvd3MgeW91IHRvIHB1c2ggYSBzZXQgYW1vdW50IG9mIHZhbHVlcyB0byB0aGUgcmVwZWF0ZXIgd2l0aG91dCBwdXNoZXMgd2FpdGluZyBvciB0aHJvd2luZyBlcnJvcnMuICovXHJcbnZhciBGaXhlZEJ1ZmZlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEZpeGVkQnVmZmVyKGNhcGFjaXR5KSB7XHJcbiAgICAgICAgaWYgKGNhcGFjaXR5IDwgMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkNhcGFjaXR5IG1heSBub3QgYmUgbGVzcyB0aGFuIDBcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2MgPSBjYXBhY2l0eTtcclxuICAgICAgICB0aGlzLl9xID0gW107XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRml4ZWRCdWZmZXIucHJvdG90eXBlLCBcImVtcHR5XCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3EubGVuZ3RoID09PSAwO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGaXhlZEJ1ZmZlci5wcm90b3R5cGUsIFwiZnVsbFwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9xLmxlbmd0aCA+PSB0aGlzLl9jO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIEZpeGVkQnVmZmVyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICBpZiAodGhpcy5mdWxsKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkJ1ZmZlciBmdWxsXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fcS5wdXNoKHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRml4ZWRCdWZmZXIucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5lbXB0eSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCdWZmZXIgZW1wdHlcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9xLnNoaWZ0KCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEZpeGVkQnVmZmVyO1xyXG59KCkpO1xyXG4vLyBUT0RPOiBVc2UgYSBjaXJjdWxhciBidWZmZXIgaGVyZS5cclxuLyoqIFNsaWRpbmcgYnVmZmVycyBhbGxvdyB5b3UgdG8gcHVzaCBhIHNldCBhbW91bnQgb2YgdmFsdWVzIHRvIHRoZSByZXBlYXRlciB3aXRob3V0IHB1c2hlcyB3YWl0aW5nIG9yIHRocm93aW5nIGVycm9ycy4gSWYgdGhlIG51bWJlciBvZiB2YWx1ZXMgZXhjZWVkcyB0aGUgY2FwYWNpdHkgc2V0IGluIHRoZSBjb25zdHJ1Y3RvciwgdGhlIGJ1ZmZlciB3aWxsIGRpc2NhcmQgdGhlIGVhcmxpZXN0IHZhbHVlcyBhZGRlZC4gKi9cclxudmFyIFNsaWRpbmdCdWZmZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBTbGlkaW5nQnVmZmVyKGNhcGFjaXR5KSB7XHJcbiAgICAgICAgaWYgKGNhcGFjaXR5IDwgMSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkNhcGFjaXR5IG1heSBub3QgYmUgbGVzcyB0aGFuIDFcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2MgPSBjYXBhY2l0eTtcclxuICAgICAgICB0aGlzLl9xID0gW107XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2xpZGluZ0J1ZmZlci5wcm90b3R5cGUsIFwiZW1wdHlcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcS5sZW5ndGggPT09IDA7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNsaWRpbmdCdWZmZXIucHJvdG90eXBlLCBcImZ1bGxcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgU2xpZGluZ0J1ZmZlci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgd2hpbGUgKHRoaXMuX3EubGVuZ3RoID49IHRoaXMuX2MpIHtcclxuICAgICAgICAgICAgdGhpcy5fcS5zaGlmdCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9xLnB1c2godmFsdWUpO1xyXG4gICAgfTtcclxuICAgIFNsaWRpbmdCdWZmZXIucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5lbXB0eSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCdWZmZXIgZW1wdHlcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9xLnNoaWZ0KCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFNsaWRpbmdCdWZmZXI7XHJcbn0oKSk7XHJcbi8qKiBEcm9wcGluZyBidWZmZXJzIGFsbG93IHlvdSB0byBwdXNoIGEgc2V0IGFtb3VudCBvZiB2YWx1ZXMgdG8gdGhlIHJlcGVhdGVyIHdpdGhvdXQgdGhlIHB1c2ggZnVuY3Rpb24gd2FpdGluZyBvciB0aHJvd2luZyBlcnJvcnMuIElmIHRoZSBudW1iZXIgb2YgdmFsdWVzIGV4Y2VlZHMgdGhlIGNhcGFjaXR5IHNldCBpbiB0aGUgY29uc3RydWN0b3IsIHRoZSBidWZmZXIgd2lsbCBkaXNjYXJkIHRoZSBsYXRlc3QgdmFsdWVzIGFkZGVkLiAqL1xyXG52YXIgRHJvcHBpbmdCdWZmZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBEcm9wcGluZ0J1ZmZlcihjYXBhY2l0eSkge1xyXG4gICAgICAgIGlmIChjYXBhY2l0eSA8IDEpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJDYXBhY2l0eSBtYXkgbm90IGJlIGxlc3MgdGhhbiAxXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9jID0gY2FwYWNpdHk7XHJcbiAgICAgICAgdGhpcy5fcSA9IFtdO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERyb3BwaW5nQnVmZmVyLnByb3RvdHlwZSwgXCJlbXB0eVwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9xLmxlbmd0aCA9PT0gMDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRHJvcHBpbmdCdWZmZXIucHJvdG90eXBlLCBcImZ1bGxcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgRHJvcHBpbmdCdWZmZXIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgIGlmICh0aGlzLl9xLmxlbmd0aCA8IHRoaXMuX2MpIHtcclxuICAgICAgICAgICAgdGhpcy5fcS5wdXNoKHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRHJvcHBpbmdCdWZmZXIucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5lbXB0eSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCdWZmZXIgZW1wdHlcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9xLnNoaWZ0KCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIERyb3BwaW5nQnVmZmVyO1xyXG59KCkpO1xyXG4vKiogTWFrZXMgc3VyZSBwcm9taXNlLWxpa2VzIGRvbuKAmXQgY2F1c2UgdW5oYW5kbGVkIHJlamVjdGlvbnMuICovXHJcbmZ1bmN0aW9uIHN3YWxsb3codmFsdWUpIHtcclxuICAgIGlmICh2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZS50aGVuID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICB2YWx1ZS50aGVuKE5PT1AsIE5PT1ApO1xyXG4gICAgfVxyXG59XHJcbi8qKiogUkVQRUFURVIgU1RBVEVTICoqKi9cclxuLyoqIFRoZSBmb2xsb3dpbmcgaXMgYW4gZW51bWVyYXRpb24gb2YgYWxsIHBvc3NpYmxlIHJlcGVhdGVyIHN0YXRlcy4gVGhlc2Ugc3RhdGVzIGFyZSBvcmRlcmVkLCBhbmQgYSByZXBlYXRlciBtYXkgb25seSBhZHZhbmNlIHRvIGhpZ2hlciBzdGF0ZXMuICovXHJcbi8qKiBUaGUgaW5pdGlhbCBzdGF0ZSBvZiB0aGUgcmVwZWF0ZXIuICovXHJcbnZhciBJbml0aWFsID0gMDtcclxuLyoqIFJlcGVhdGVycyBhZHZhbmNlIHRvIHRoaXMgc3RhdGUgdGhlIGZpcnN0IHRpbWUgdGhlIG5leHQgbWV0aG9kIGlzIGNhbGxlZCBvbiB0aGUgcmVwZWF0ZXIuICovXHJcbnZhciBTdGFydGVkID0gMTtcclxuLyoqIFJlcGVhdGVycyBhZHZhbmNlIHRvIHRoaXMgc3RhdGUgd2hlbiB0aGUgc3RvcCBmdW5jdGlvbiBpcyBjYWxsZWQuICovXHJcbnZhciBTdG9wcGVkID0gMjtcclxuLyoqIFJlcGVhdGVycyBhZHZhbmNlIHRvIHRoaXMgc3RhdGUgd2hlbiB0aGVyZSBhcmUgbm8gdmFsdWVzIGxlZnQgdG8gYmUgcHVsbGVkIGZyb20gdGhlIHJlcGVhdGVyLiAqL1xyXG52YXIgRG9uZSA9IDM7XHJcbi8qKiBSZXBlYXRlcnMgYWR2YW5jZSB0byB0aGlzIHN0YXRlIGlmIGFuIGVycm9yIGlzIHRocm93biBpbnRvIHRoZSByZXBlYXRlci4gKi9cclxudmFyIFJlamVjdGVkID0gNDtcclxuLyoqIFRoZSBtYXhpbXVtIG51bWJlciBvZiBwdXNoIG9yIG5leHQgb3BlcmF0aW9ucyB3aGljaCBtYXkgZXhpc3Qgb24gYSBzaW5nbGUgcmVwZWF0ZXIuICovXHJcbnZhciBNQVhfUVVFVUVfTEVOR1RIID0gMTAyNDtcclxudmFyIE5PT1AgPSBmdW5jdGlvbiAoKSB7IH07XHJcbi8qKiBBIGhlbHBlciBmdW5jdGlvbiB1c2VkIHRvIG1pbWljIHRoZSBiZWhhdmlvciBvZiBhc3luYyBnZW5lcmF0b3JzIHdoZXJlIHRoZSBmaW5hbCBpdGVyYXRpb24gaXMgY29uc3VtZWQuICovXHJcbmZ1bmN0aW9uIGNvbnN1bWVFeGVjdXRpb24ocikge1xyXG4gICAgdmFyIGVyciA9IHIuZXJyO1xyXG4gICAgdmFyIGV4ZWN1dGlvbiA9IFByb21pc2UucmVzb2x2ZShyLmV4ZWN1dGlvbikudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICBpZiAoZXJyICE9IG51bGwpIHtcclxuICAgICAgICAgICAgdGhyb3cgZXJyO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9KTtcclxuICAgIHIuZXJyID0gdW5kZWZpbmVkO1xyXG4gICAgci5leGVjdXRpb24gPSBleGVjdXRpb24udGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiB1bmRlZmluZWQ7IH0sIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSk7XHJcbiAgICByZXR1cm4gci5wZW5kaW5nID09PSB1bmRlZmluZWQgPyBleGVjdXRpb24gOiByLnBlbmRpbmcudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiBleGVjdXRpb247IH0pO1xyXG59XHJcbi8qKiBBIGhlbHBlciBmdW5jdGlvbiBmb3IgYnVpbGRpbmcgaXRlcmF0aW9ucyBmcm9tIHZhbHVlcy4gUHJvbWlzZXMgYXJlIHVud3JhcHBlZCwgc28gdGhhdCBpdGVyYXRpb25zIG5ldmVyIGhhdmUgdGhlaXIgdmFsdWUgcHJvcGVydHkgc2V0IHRvIGEgcHJvbWlzZS4gKi9cclxuZnVuY3Rpb24gY3JlYXRlSXRlcmF0aW9uKHIsIHZhbHVlKSB7XHJcbiAgICB2YXIgZG9uZSA9IHIuc3RhdGUgPj0gRG9uZTtcclxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKCFkb25lICYmIHIuc3RhdGUgPj0gUmVqZWN0ZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbnN1bWVFeGVjdXRpb24ocikudGhlbihmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuICh7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXHJcbiAgICAgICAgICAgICAgICBkb25lOiB0cnVlLFxyXG4gICAgICAgICAgICB9KTsgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7IHZhbHVlOiB2YWx1ZSwgZG9uZTogZG9uZSB9O1xyXG4gICAgfSk7XHJcbn1cclxuLyoqXHJcbiAqIFRoaXMgZnVuY3Rpb24gaXMgYm91bmQgYW5kIHBhc3NlZCB0byB0aGUgZXhlY3V0b3IgYXMgdGhlIHN0b3AgYXJndW1lbnQuXHJcbiAqXHJcbiAqIEFkdmFuY2VzIHN0YXRlIHRvIFN0b3BwZWQuXHJcbiAqL1xyXG5mdW5jdGlvbiBzdG9wKHIsIGVycikge1xyXG4gICAgdmFyIGVfMSwgX2E7XHJcbiAgICBpZiAoci5zdGF0ZSA+PSBTdG9wcGVkKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgci5zdGF0ZSA9IFN0b3BwZWQ7XHJcbiAgICByLm9ubmV4dCgpO1xyXG4gICAgci5vbnN0b3AoKTtcclxuICAgIGlmIChyLmVyciA9PSBudWxsKSB7XHJcbiAgICAgICAgci5lcnIgPSBlcnI7XHJcbiAgICB9XHJcbiAgICBpZiAoci5wdXNoZXMubGVuZ3RoID09PSAwICYmXHJcbiAgICAgICAgKHR5cGVvZiByLmJ1ZmZlciA9PT0gXCJ1bmRlZmluZWRcIiB8fCByLmJ1ZmZlci5lbXB0eSkpIHtcclxuICAgICAgICBmaW5pc2gocik7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfYiA9IF9fdmFsdWVzKHIucHVzaGVzKSwgX2QgPSBfYi5uZXh0KCk7ICFfZC5kb25lOyBfZCA9IF9iLm5leHQoKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHB1c2hfMSA9IF9kLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgcHVzaF8xLnJlc29sdmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxyXG4gICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgaWYgKF9kICYmICFfZC5kb25lICYmIChfYSA9IF9iLnJldHVybikpIF9hLmNhbGwoX2IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFRoZSBkaWZmZXJlbmNlIGJldHdlZW4gc3RvcHBpbmcgYSByZXBlYXRlciB2cyBmaW5pc2hpbmcgYSByZXBlYXRlciBpcyB0aGF0IHN0b3BwaW5nIGEgcmVwZWF0ZXIgYWxsb3dzIG5leHQgdG8gY29udGludWUgdG8gZHJhaW4gdmFsdWVzIGZyb20gdGhlIHB1c2ggcXVldWUgYW5kIGJ1ZmZlciwgd2hpbGUgZmluaXNoaW5nIGEgcmVwZWF0ZXIgd2lsbCBjbGVhciBhbGwgcGVuZGluZyB2YWx1ZXMgYW5kIGVuZCBpdGVyYXRpb24gaW1tZWRpYXRlbHkuIE9uY2UsIGEgcmVwZWF0ZXIgaXMgZmluaXNoZWQsIGFsbCBpdGVyYXRpb25zIHdpbGwgaGF2ZSB0aGUgZG9uZSBwcm9wZXJ0eSBzZXQgdG8gdHJ1ZS5cclxuICpcclxuICogQWR2YW5jZXMgc3RhdGUgdG8gRG9uZS5cclxuICovXHJcbmZ1bmN0aW9uIGZpbmlzaChyKSB7XHJcbiAgICB2YXIgZV8yLCBfYTtcclxuICAgIGlmIChyLnN0YXRlID49IERvbmUpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAoci5zdGF0ZSA8IFN0b3BwZWQpIHtcclxuICAgICAgICBzdG9wKHIpO1xyXG4gICAgfVxyXG4gICAgci5zdGF0ZSA9IERvbmU7XHJcbiAgICByLmJ1ZmZlciA9IHVuZGVmaW5lZDtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgZm9yICh2YXIgX2IgPSBfX3ZhbHVlcyhyLm5leHRzKSwgX2QgPSBfYi5uZXh0KCk7ICFfZC5kb25lOyBfZCA9IF9iLm5leHQoKSkge1xyXG4gICAgICAgICAgICB2YXIgbmV4dCA9IF9kLnZhbHVlO1xyXG4gICAgICAgICAgICB2YXIgZXhlY3V0aW9uID0gci5wZW5kaW5nID09PSB1bmRlZmluZWRcclxuICAgICAgICAgICAgICAgID8gY29uc3VtZUV4ZWN1dGlvbihyKVxyXG4gICAgICAgICAgICAgICAgOiByLnBlbmRpbmcudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiBjb25zdW1lRXhlY3V0aW9uKHIpOyB9KTtcclxuICAgICAgICAgICAgbmV4dC5yZXNvbHZlKGNyZWF0ZUl0ZXJhdGlvbihyLCBleGVjdXRpb24pKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZV8yXzEpIHsgZV8yID0geyBlcnJvcjogZV8yXzEgfTsgfVxyXG4gICAgZmluYWxseSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKF9kICYmICFfZC5kb25lICYmIChfYSA9IF9iLnJldHVybikpIF9hLmNhbGwoX2IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMikgdGhyb3cgZV8yLmVycm9yOyB9XHJcbiAgICB9XHJcbiAgICByLnB1c2hlcyA9IFtdO1xyXG4gICAgci5uZXh0cyA9IFtdO1xyXG59XHJcbi8qKlxyXG4gKiBDYWxsZWQgd2hlbiBhIHByb21pc2UgcGFzc2VkIHRvIHB1c2ggcmVqZWN0cywgb3Igd2hlbiBhIHB1c2ggY2FsbCBpcyB1bmhhbmRsZWQuXHJcbiAqXHJcbiAqIEFkdmFuY2VzIHN0YXRlIHRvIFJlamVjdGVkLlxyXG4gKi9cclxuZnVuY3Rpb24gcmVqZWN0KHIpIHtcclxuICAgIGlmIChyLnN0YXRlID49IFJlamVjdGVkKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKHIuc3RhdGUgPCBEb25lKSB7XHJcbiAgICAgICAgZmluaXNoKHIpO1xyXG4gICAgfVxyXG4gICAgci5zdGF0ZSA9IFJlamVjdGVkO1xyXG59XHJcbi8qKiBUaGlzIGZ1bmN0aW9uIGlzIGJvdW5kIGFuZCBwYXNzZWQgdG8gdGhlIGV4ZWN1dG9yIGFzIHRoZSBwdXNoIGFyZ3VtZW50LiAqL1xyXG5mdW5jdGlvbiBwdXNoKHIsIHZhbHVlKSB7XHJcbiAgICBzd2FsbG93KHZhbHVlKTtcclxuICAgIGlmIChyLnB1c2hlcy5sZW5ndGggPj0gTUFYX1FVRVVFX0xFTkdUSCkge1xyXG4gICAgICAgIHRocm93IG5ldyBSZXBlYXRlck92ZXJmbG93RXJyb3IoXCJObyBtb3JlIHRoYW4gXCIgKyBNQVhfUVVFVUVfTEVOR1RIICsgXCIgcGVuZGluZyBjYWxscyB0byBwdXNoIGFyZSBhbGxvd2VkIG9uIGEgc2luZ2xlIHJlcGVhdGVyLlwiKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHIuc3RhdGUgPj0gU3RvcHBlZCkge1xyXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodW5kZWZpbmVkKTtcclxuICAgIH1cclxuICAgIHZhciB2YWx1ZVAgPSByLnBlbmRpbmcgPT09IHVuZGVmaW5lZFxyXG4gICAgICAgID8gUHJvbWlzZS5yZXNvbHZlKHZhbHVlKVxyXG4gICAgICAgIDogci5wZW5kaW5nLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gdmFsdWU7IH0pO1xyXG4gICAgdmFsdWVQID0gdmFsdWVQLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICBpZiAoci5zdGF0ZSA8IFN0b3BwZWQpIHtcclxuICAgICAgICAgICAgci5lcnIgPSBlcnI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlamVjdChyKTtcclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkOyAvLyB2b2lkIDooXHJcbiAgICB9KTtcclxuICAgIHZhciBuZXh0UDtcclxuICAgIGlmIChyLm5leHRzLmxlbmd0aCkge1xyXG4gICAgICAgIHZhciBuZXh0XzEgPSByLm5leHRzLnNoaWZ0KCk7XHJcbiAgICAgICAgbmV4dF8xLnJlc29sdmUoY3JlYXRlSXRlcmF0aW9uKHIsIHZhbHVlUCkpO1xyXG4gICAgICAgIGlmIChyLm5leHRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBuZXh0UCA9IFByb21pc2UucmVzb2x2ZShyLm5leHRzWzBdLnZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHIuYnVmZmVyICE9PSBcInVuZGVmaW5lZFwiICYmICFyLmJ1ZmZlci5mdWxsKSB7XHJcbiAgICAgICAgICAgIG5leHRQID0gUHJvbWlzZS5yZXNvbHZlKHVuZGVmaW5lZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBuZXh0UCA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJldHVybiAoci5vbm5leHQgPSByZXNvbHZlKTsgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZW9mIHIuYnVmZmVyICE9PSBcInVuZGVmaW5lZFwiICYmICFyLmJ1ZmZlci5mdWxsKSB7XHJcbiAgICAgICAgci5idWZmZXIuYWRkKHZhbHVlUCk7XHJcbiAgICAgICAgbmV4dFAgPSBQcm9taXNlLnJlc29sdmUodW5kZWZpbmVkKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIG5leHRQID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmV0dXJuIHIucHVzaGVzLnB1c2goeyByZXNvbHZlOiByZXNvbHZlLCB2YWx1ZTogdmFsdWVQIH0pOyB9KTtcclxuICAgIH1cclxuICAgIC8vIElmIGFuIGVycm9yIGlzIHRocm93biBpbnRvIHRoZSByZXBlYXRlciB2aWEgdGhlIG5leHQgb3IgdGhyb3cgbWV0aG9kcywgd2UgZ2l2ZSB0aGUgcmVwZWF0ZXIgYSBjaGFuY2UgdG8gaGFuZGxlIHRoaXMgYnkgcmVqZWN0aW5nIHRoZSBwcm9taXNlIHJldHVybmVkIGZyb20gcHVzaC4gSWYgdGhlIHB1c2ggY2FsbCBpcyBub3QgaW1tZWRpYXRlbHkgaGFuZGxlZCB3ZSB0aHJvdyB0aGUgbmV4dCBpdGVyYXRpb24gb2YgdGhlIHJlcGVhdGVyLlxyXG4gICAgLy8gVG8gY2hlY2sgdGhhdCB0aGUgcHJvbWlzZSByZXR1cm5lZCBmcm9tIHB1c2ggaXMgZmxvYXRpbmcsIHdlIG1vZGlmeSB0aGUgdGhlbiBhbmQgY2F0Y2ggbWV0aG9kcyBvZiB0aGUgcmV0dXJuZWQgcHJvbWlzZSBzbyB0aGF0IHRoZXkgZmxpcCB0aGUgZmxvYXRpbmcgZmxhZy4gVGhlIHB1c2ggZnVuY3Rpb24gYWN0dWFsbHkgZG9lcyBub3QgcmV0dXJuIGEgcHJvbWlzZSwgYmVjYXVzZSBtb2Rlcm4gZW5naW5lcyBkbyBub3QgY2FsbCB0aGUgdGhlbiBhbmQgY2F0Y2ggbWV0aG9kcyBvbiBuYXRpdmUgcHJvbWlzZXMuIEJ5IG1ha2luZyBuZXh0IGEgcGxhaW4gb2xkIGphdmFzY3JpcHQgb2JqZWN0LCB3ZSBlbnN1cmUgdGhhdCB0aGUgdGhlbiBhbmQgY2F0Y2ggbWV0aG9kcyB3aWxsIGJlIGNhbGxlZC5cclxuICAgIHZhciBmbG9hdGluZyA9IHRydWU7XHJcbiAgICB2YXIgbmV4dCA9IHt9O1xyXG4gICAgdmFyIHVuaGFuZGxlZCA9IG5leHRQLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICBpZiAoZmxvYXRpbmcpIHtcclxuICAgICAgICAgICAgdGhyb3cgZXJyO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkOyAvLyB2b2lkIDooXHJcbiAgICB9KTtcclxuICAgIG5leHQudGhlbiA9IGZ1bmN0aW9uIChvbmZ1bGZpbGxlZCwgb25yZWplY3RlZCkge1xyXG4gICAgICAgIGZsb2F0aW5nID0gZmFsc2U7XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UucHJvdG90eXBlLnRoZW4uY2FsbChuZXh0UCwgb25mdWxmaWxsZWQsIG9ucmVqZWN0ZWQpO1xyXG4gICAgfTtcclxuICAgIG5leHQuY2F0Y2ggPSBmdW5jdGlvbiAob25yZWplY3RlZCkge1xyXG4gICAgICAgIGZsb2F0aW5nID0gZmFsc2U7XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UucHJvdG90eXBlLmNhdGNoLmNhbGwobmV4dFAsIG9ucmVqZWN0ZWQpO1xyXG4gICAgfTtcclxuICAgIG5leHQuZmluYWxseSA9IG5leHRQLmZpbmFsbHkuYmluZChuZXh0UCk7XHJcbiAgICByLnBlbmRpbmcgPSB2YWx1ZVBcclxuICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiB1bmhhbmRsZWQ7IH0pXHJcbiAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICByLmVyciA9IGVycjtcclxuICAgICAgICByZWplY3Qocik7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBuZXh0O1xyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGVzIHRoZSBzdG9wIGNhbGxhYmxlIHByb21pc2Ugd2hpY2ggaXMgcGFzc2VkIHRvIHRoZSBleGVjdXRvclxyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlU3RvcChyKSB7XHJcbiAgICB2YXIgc3RvcDEgPSBzdG9wLmJpbmQobnVsbCwgcik7XHJcbiAgICB2YXIgc3RvcFAgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXR1cm4gKHIub25zdG9wID0gcmVzb2x2ZSk7IH0pO1xyXG4gICAgc3RvcDEudGhlbiA9IHN0b3BQLnRoZW4uYmluZChzdG9wUCk7XHJcbiAgICBzdG9wMS5jYXRjaCA9IHN0b3BQLmNhdGNoLmJpbmQoc3RvcFApO1xyXG4gICAgc3RvcDEuZmluYWxseSA9IHN0b3BQLmZpbmFsbHkuYmluZChzdG9wUCk7XHJcbiAgICByZXR1cm4gc3RvcDE7XHJcbn1cclxuLyoqXHJcbiAqIENhbGxzIHRoZSBleGVjdXRvciBwYXNzZWQgaW50byB0aGUgY29uc3RydWN0b3IuIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHRoZSBmaXJzdCB0aW1lIHRoZSBuZXh0IG1ldGhvZCBpcyBjYWxsZWQgb24gdGhlIHJlcGVhdGVyLlxyXG4gKlxyXG4gKiBBZHZhbmNlcyBzdGF0ZSB0byBTdGFydGVkLlxyXG4gKi9cclxuZnVuY3Rpb24gZXhlY3V0ZShyKSB7XHJcbiAgICBpZiAoci5zdGF0ZSA+PSBTdGFydGVkKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgci5zdGF0ZSA9IFN0YXJ0ZWQ7XHJcbiAgICB2YXIgcHVzaDEgPSBwdXNoLmJpbmQobnVsbCwgcik7XHJcbiAgICB2YXIgc3RvcDEgPSBjcmVhdGVTdG9wKHIpO1xyXG4gICAgci5leGVjdXRpb24gPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXR1cm4gcmVzb2x2ZShyLmV4ZWN1dG9yKHB1c2gxLCBzdG9wMSkpOyB9KTtcclxuICAgIC8vIFRPRE86IFdlIHNob3VsZCBjb25zaWRlciBzdG9wcGluZyBhbGwgcmVwZWF0ZXJzIHdoZW4gdGhlIGV4ZWN1dG9yIHNldHRsZXMuXHJcbiAgICByLmV4ZWN1dGlvbi5jYXRjaChmdW5jdGlvbiAoKSB7IHJldHVybiBzdG9wKHIpOyB9KTtcclxufVxyXG52YXIgcmVjb3JkcyA9IG5ldyBXZWFrTWFwKCk7XHJcbi8vIE5PVEU6IFdoaWxlIHJlcGVhdGVycyBpbXBsZW1lbnQgYW5kIGFyZSBhc3NpZ25hYmxlIHRvIHRoZSBBc3luY0dlbmVyYXRvciBpbnRlcmZhY2UsIGFuZCB5b3UgY2FuIHVzZSB0aGUgdHlwZXMgaW50ZXJjaGFuZ2VhYmx5LCB3ZSBkb27igJl0IHVzZSB0eXBlc2NyaXB04oCZcyBpbXBsZW1lbnRzIHN5bnRheCBoZXJlIGJlY2F1c2UgdGhpcyB3b3VsZCBtYWtlIHN1cHBvcnRpbmcgZWFybGllciB2ZXJzaW9ucyBvZiB0eXBlc2NyaXB0IHRyaWNraWVyLiBUaGlzIGlzIGJlY2F1c2UgVHlwZVNjcmlwdCB2ZXJzaW9uIDMuNiBjaGFuZ2VkIHRoZSBpdGVyYXRvciB0eXBlcyBieSBhZGRpbmcgdGhlIFRSZXR1cm4gYW5kIFROZXh0IHR5cGUgcGFyYW1ldGVycy5cclxudmFyIFJlcGVhdGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gUmVwZWF0ZXIoZXhlY3V0b3IsIGJ1ZmZlcikge1xyXG4gICAgICAgIHJlY29yZHMuc2V0KHRoaXMsIHtcclxuICAgICAgICAgICAgZXhlY3V0b3I6IGV4ZWN1dG9yLFxyXG4gICAgICAgICAgICBidWZmZXI6IGJ1ZmZlcixcclxuICAgICAgICAgICAgZXJyOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIHN0YXRlOiBJbml0aWFsLFxyXG4gICAgICAgICAgICBwdXNoZXM6IFtdLFxyXG4gICAgICAgICAgICBuZXh0czogW10sXHJcbiAgICAgICAgICAgIHBlbmRpbmc6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgZXhlY3V0aW9uOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIG9ubmV4dDogTk9PUCxcclxuICAgICAgICAgICAgb25zdG9wOiBOT09QLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgUmVwZWF0ZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICBzd2FsbG93KHZhbHVlKTtcclxuICAgICAgICB2YXIgciA9IHJlY29yZHMuZ2V0KHRoaXMpO1xyXG4gICAgICAgIGlmIChyID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV2Vha01hcCBlcnJvclwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHIubmV4dHMubGVuZ3RoID49IE1BWF9RVUVVRV9MRU5HVEgpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFJlcGVhdGVyT3ZlcmZsb3dFcnJvcihcIk5vIG1vcmUgdGhhbiBcIiArIE1BWF9RVUVVRV9MRU5HVEggKyBcIiBwZW5kaW5nIGNhbGxzIHRvIG5leHQgYXJlIGFsbG93ZWQgb24gYSBzaW5nbGUgcmVwZWF0ZXIuXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoci5zdGF0ZSA8PSBJbml0aWFsKSB7XHJcbiAgICAgICAgICAgIGV4ZWN1dGUocik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHIub25uZXh0KHZhbHVlKTtcclxuICAgICAgICBpZiAodHlwZW9mIHIuYnVmZmVyICE9PSBcInVuZGVmaW5lZFwiICYmICFyLmJ1ZmZlci5lbXB0eSkge1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gY3JlYXRlSXRlcmF0aW9uKHIsIHIuYnVmZmVyLnJlbW92ZSgpKTtcclxuICAgICAgICAgICAgaWYgKHIucHVzaGVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHB1c2hfMiA9IHIucHVzaGVzLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICByLmJ1ZmZlci5hZGQocHVzaF8yLnZhbHVlKTtcclxuICAgICAgICAgICAgICAgIHIub25uZXh0ID0gcHVzaF8yLnJlc29sdmU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoci5wdXNoZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHZhciBwdXNoXzMgPSByLnB1c2hlcy5zaGlmdCgpO1xyXG4gICAgICAgICAgICByLm9ubmV4dCA9IHB1c2hfMy5yZXNvbHZlO1xyXG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlSXRlcmF0aW9uKHIsIHB1c2hfMy52YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHIuc3RhdGUgPj0gU3RvcHBlZCkge1xyXG4gICAgICAgICAgICBmaW5pc2gocik7XHJcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVJdGVyYXRpb24ociwgY29uc3VtZUV4ZWN1dGlvbihyKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXR1cm4gci5uZXh0cy5wdXNoKHsgcmVzb2x2ZTogcmVzb2x2ZSwgdmFsdWU6IHZhbHVlIH0pOyB9KTtcclxuICAgIH07XHJcbiAgICBSZXBlYXRlci5wcm90b3R5cGUucmV0dXJuID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgc3dhbGxvdyh2YWx1ZSk7XHJcbiAgICAgICAgdmFyIHIgPSByZWNvcmRzLmdldCh0aGlzKTtcclxuICAgICAgICBpZiAociA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIldlYWtNYXAgZXJyb3JcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpbmlzaChyKTtcclxuICAgICAgICAvLyBXZSBvdmVycmlkZSB0aGUgZXhlY3V0aW9uIGJlY2F1c2UgcmV0dXJuIHNob3VsZCBhbHdheXMgcmV0dXJuIHRoZSB2YWx1ZSBwYXNzZWQgaW4uXHJcbiAgICAgICAgci5leGVjdXRpb24gPSBQcm9taXNlLnJlc29sdmUoci5leGVjdXRpb24pLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gdmFsdWU7IH0pO1xyXG4gICAgICAgIHJldHVybiBjcmVhdGVJdGVyYXRpb24ociwgY29uc3VtZUV4ZWN1dGlvbihyKSk7XHJcbiAgICB9O1xyXG4gICAgUmVwZWF0ZXIucHJvdG90eXBlLnRocm93ID0gZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgIHZhciByID0gcmVjb3Jkcy5nZXQodGhpcyk7XHJcbiAgICAgICAgaWYgKHIgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXZWFrTWFwIGVycm9yXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoci5zdGF0ZSA8PSBJbml0aWFsIHx8XHJcbiAgICAgICAgICAgIHIuc3RhdGUgPj0gU3RvcHBlZCB8fFxyXG4gICAgICAgICAgICAodHlwZW9mIHIuYnVmZmVyICE9PSBcInVuZGVmaW5lZFwiICYmICFyLmJ1ZmZlci5lbXB0eSkpIHtcclxuICAgICAgICAgICAgZmluaXNoKHIpO1xyXG4gICAgICAgICAgICAvLyBJZiByLmVyciBpcyBhbHJlYWR5IHNldCwgdGhhdCBtZWFuIHRoZSByZXBlYXRlciBoYXMgYWxyZWFkeSBwcm9kdWNlZCBhbiBlcnJvciwgc28gd2UgdGhyb3cgdGhhdCBlcnJvciByYXRoZXIgdGhhbiB0aGUgZXJyb3IgcGFzc2VkIGluLCBiZWNhdXNlIGRvaW5nIHNvIG1pZ2h0IGJlIG1vcmUgaW5mb3JtYXRpdmUgZm9yIHRoZSBjYWxsZXIuXHJcbiAgICAgICAgICAgIGlmIChyLmVyciA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByLmVyciA9IGVycjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlSXRlcmF0aW9uKHIsIGNvbnN1bWVFeGVjdXRpb24ocikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5uZXh0KFByb21pc2UucmVqZWN0KGVycikpO1xyXG4gICAgfTtcclxuICAgIFJlcGVhdGVyLnByb3RvdHlwZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG4gICAgLy8gVE9ETzogUmVtb3ZlIHRoZXNlIHN0YXRpYyBtZXRob2RzIGZyb20gdGhlIGNsYXNzLlxyXG4gICAgUmVwZWF0ZXIucmFjZSA9IHJhY2U7XHJcbiAgICBSZXBlYXRlci5tZXJnZSA9IG1lcmdlO1xyXG4gICAgUmVwZWF0ZXIuemlwID0gemlwO1xyXG4gICAgUmVwZWF0ZXIubGF0ZXN0ID0gbGF0ZXN0O1xyXG4gICAgcmV0dXJuIFJlcGVhdGVyO1xyXG59KCkpO1xyXG4vKioqIENPTUJJTkFUT1IgRlVOQ1RJT05TICoqKi9cclxuLy8gVE9ETzogbW92ZSB0aGVzZSBjb21iaW5hdG9ycyB0byB0aGVpciBvd24gZmlsZS5cclxuZnVuY3Rpb24gZ2V0SXRlcmF0b3JzKHZhbHVlcywgb3B0aW9ucykge1xyXG4gICAgdmFyIGVfMywgX2E7XHJcbiAgICB2YXIgaXRlcnMgPSBbXTtcclxuICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgICAgIGl0ZXJzLnB1c2godmFsdWVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZVtTeW1ib2wuaXRlcmF0b3JdID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAgICAgaXRlcnMucHVzaCh2YWx1ZVtTeW1ib2wuaXRlcmF0b3JdKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaXRlcnMucHVzaCgoZnVuY3Rpb24gdmFsdWVUb0FzeW5jSXRlcmF0b3IoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX19hc3luY0dlbmVyYXRvcih0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uIHZhbHVlVG9Bc3luY0l0ZXJhdG9yXzEoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zLnlpZWxkVmFsdWVzKSByZXR1cm4gWzMgLypicmVhayovLCAzXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBfX2F3YWl0KHZhbHVlKV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbNCAvKnlpZWxkKi8sIF9hLnNlbnQoKV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbnMucmV0dXJuVmFsdWVzKSByZXR1cm4gWzMgLypicmVhayovLCA1XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBfX2F3YWl0KHZhbHVlKV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA1OiByZXR1cm4gWzIgLypyZXR1cm4qL107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KSgpKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBmb3IgKHZhciB2YWx1ZXNfMSA9IF9fdmFsdWVzKHZhbHVlcyksIHZhbHVlc18xXzEgPSB2YWx1ZXNfMS5uZXh0KCk7ICF2YWx1ZXNfMV8xLmRvbmU7IHZhbHVlc18xXzEgPSB2YWx1ZXNfMS5uZXh0KCkpIHtcclxuICAgICAgICAgICAgdmFyIHZhbHVlID0gdmFsdWVzXzFfMS52YWx1ZTtcclxuICAgICAgICAgICAgX2xvb3BfMSh2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVfM18xKSB7IGVfMyA9IHsgZXJyb3I6IGVfM18xIH07IH1cclxuICAgIGZpbmFsbHkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZXNfMV8xICYmICF2YWx1ZXNfMV8xLmRvbmUgJiYgKF9hID0gdmFsdWVzXzEucmV0dXJuKSkgX2EuY2FsbCh2YWx1ZXNfMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZV8zKSB0aHJvdyBlXzMuZXJyb3I7IH1cclxuICAgIH1cclxuICAgIHJldHVybiBpdGVycztcclxufVxyXG4vLyBOT1RFOiB3aGVuZXZlciB5b3Ugc2VlIGFueSB2YXJpYWJsZXMgY2FsbGVkIGBhZHZhbmNlYCBvciBgYWR2YW5jZXNgLCBrbm93IHRoYXQgaXQgaXMgYSBoYWNrIHRvIGdldCBhcm91bmQgdGhlIGZhY3QgdGhhdCBgUHJvbWlzZS5yYWNlYCBsZWFrcyBtZW1vcnkuIFRoZXNlIHZhcmlhYmxlcyBhcmUgaW50ZW5kZWQgdG8gYmUgc2V0IHRvIHRoZSByZXNvbHZlIGZ1bmN0aW9uIG9mIGEgcHJvbWlzZSB3aGljaCBpcyBjb25zdHJ1Y3RlZCBhbmQgYXdhaXRlZCBhcyBhbiBhbHRlcm5hdGl2ZSB0byBQcm9taXNlLnJhY2UuIEZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWUgdGhpcyBjb21tZW50IGluIHRoZSBOb2RlLmpzIGlzc3VlIHRyYWNrZXI6IGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9pc3N1ZXMvMTc0NjkjaXNzdWVjb21tZW50LTY4NTIxNjc3Ny5cclxuZnVuY3Rpb24gcmFjZShjb250ZW5kZXJzKSB7XHJcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgdmFyIGl0ZXJzID0gZ2V0SXRlcmF0b3JzKGNvbnRlbmRlcnMsIHsgcmV0dXJuVmFsdWVzOiB0cnVlIH0pO1xyXG4gICAgcmV0dXJuIG5ldyBSZXBlYXRlcihmdW5jdGlvbiAocHVzaCwgc3RvcCkgeyByZXR1cm4gX19hd2FpdGVyKF90aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBhZHZhbmNlLCBzdG9wcGVkLCBmaW5hbEl0ZXJhdGlvbiwgaXRlcmF0aW9uLCBpXzEsIF9sb29wXzI7XHJcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpdGVycy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHN0b3BwZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBzdG9wLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhZHZhbmNlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0b3BwZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMTtcclxuICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICBfYS50cnlzLnB1c2goWzEsICwgNSwgN10pO1xyXG4gICAgICAgICAgICAgICAgICAgIGl0ZXJhdGlvbiA9IHZvaWQgMDtcclxuICAgICAgICAgICAgICAgICAgICBpXzEgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIF9sb29wXzIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBqLCBpdGVyc18xLCBpdGVyc18xXzEsIGl0ZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlXzQsIF9hO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqID0gaV8xO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpdGVyc18xID0gKGVfNCA9IHZvaWQgMCwgX192YWx1ZXMoaXRlcnMpKSwgaXRlcnNfMV8xID0gaXRlcnNfMS5uZXh0KCk7ICFpdGVyc18xXzEuZG9uZTsgaXRlcnNfMV8xID0gaXRlcnNfMS5uZXh0KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVyID0gaXRlcnNfMV8xLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZShpdGVyLm5leHQoKSkudGhlbihmdW5jdGlvbiAoaXRlcmF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVyYXRpb24uZG9uZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbmFsSXRlcmF0aW9uID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbEl0ZXJhdGlvbiA9IGl0ZXJhdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpXzEgPT09IGopIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgaXRlcmF0b3IgaGFzIHdvbiwgYWR2YW5jZSBpIGFuZCByZXNvbHZlIHRoZSBwcm9taXNlLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaV8xKys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZHZhbmNlKGl0ZXJhdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7IHJldHVybiBzdG9wKGVycik7IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlXzRfMSkgeyBlXzQgPSB7IGVycm9yOiBlXzRfMSB9OyB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlcnNfMV8xICYmICFpdGVyc18xXzEuZG9uZSAmJiAoX2EgPSBpdGVyc18xLnJldHVybikpIF9hLmNhbGwoaXRlcnNfMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfNCkgdGhyb3cgZV80LmVycm9yOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmV0dXJuIChhZHZhbmNlID0gcmVzb2x2ZSk7IH0pXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZXJhdGlvbiA9IF9iLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoaXRlcmF0aW9uICE9PSB1bmRlZmluZWQpKSByZXR1cm4gWzMgLypicmVhayovLCAzXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgcHVzaChpdGVyYXRpb24udmFsdWUpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9iLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMjtcclxuICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISFzdG9wcGVkKSByZXR1cm4gWzMgLypicmVhayovLCA0XTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzUgLyp5aWVsZCoqLywgX2xvb3BfMigpXTtcclxuICAgICAgICAgICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMl07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IHJldHVybiBbMiAvKnJldHVybiovLCBmaW5hbEl0ZXJhdGlvbiAmJiBmaW5hbEl0ZXJhdGlvbi52YWx1ZV07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDU6XHJcbiAgICAgICAgICAgICAgICAgICAgc3RvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIFByb21pc2UucmFjZShpdGVycy5tYXAoZnVuY3Rpb24gKGl0ZXIpIHsgcmV0dXJuIGl0ZXIucmV0dXJuICYmIGl0ZXIucmV0dXJuKCk7IH0pKV07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDY6XHJcbiAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNyAvKmVuZGZpbmFsbHkqL107XHJcbiAgICAgICAgICAgICAgICBjYXNlIDc6IHJldHVybiBbMiAvKnJldHVybiovXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7IH0pO1xyXG59XHJcbmZ1bmN0aW9uIG1lcmdlKGNvbnRlbmRlcnMpIHtcclxuICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICB2YXIgaXRlcnMgPSBnZXRJdGVyYXRvcnMoY29udGVuZGVycywgeyB5aWVsZFZhbHVlczogdHJ1ZSB9KTtcclxuICAgIHJldHVybiBuZXcgUmVwZWF0ZXIoZnVuY3Rpb24gKHB1c2gsIHN0b3ApIHsgcmV0dXJuIF9fYXdhaXRlcihfdGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgYWR2YW5jZXMsIHN0b3BwZWQsIGZpbmFsSXRlcmF0aW9uO1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpdGVycy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGFkdmFuY2VzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgc3RvcHBlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0b3AudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlXzUsIF9hO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9wcGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGFkdmFuY2VzXzEgPSBfX3ZhbHVlcyhhZHZhbmNlcyksIGFkdmFuY2VzXzFfMSA9IGFkdmFuY2VzXzEubmV4dCgpOyAhYWR2YW5jZXNfMV8xLmRvbmU7IGFkdmFuY2VzXzFfMSA9IGFkdmFuY2VzXzEubmV4dCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFkdmFuY2UgPSBhZHZhbmNlc18xXzEudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWR2YW5jZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlXzVfMSkgeyBlXzUgPSB7IGVycm9yOiBlXzVfMSB9OyB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWR2YW5jZXNfMV8xICYmICFhZHZhbmNlc18xXzEuZG9uZSAmJiAoX2EgPSBhZHZhbmNlc18xLnJldHVybikpIF9hLmNhbGwoYWR2YW5jZXNfMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfNSkgdGhyb3cgZV81LmVycm9yOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDE7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgX2EudHJ5cy5wdXNoKFsxLCAsIDMsIDRdKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBQcm9taXNlLmFsbChpdGVycy5tYXAoZnVuY3Rpb24gKGl0ZXIsIGkpIHsgcmV0dXJuIF9fYXdhaXRlcihfdGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpdGVyYXRpb24sIF9hO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2IudHJ5cy5wdXNoKFswLCAsIDYsIDldKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEhc3RvcHBlZCkgcmV0dXJuIFszIC8qYnJlYWsqLywgNV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBQcm9taXNlLnJlc29sdmUoaXRlci5uZXh0KCkpLnRoZW4oZnVuY3Rpb24gKGl0ZXJhdGlvbikgeyByZXR1cm4gYWR2YW5jZXNbaV0oaXRlcmF0aW9uKTsgfSwgZnVuY3Rpb24gKGVycikgeyByZXR1cm4gc3RvcChlcnIpOyB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkdmFuY2VzW2ldID0gcmVzb2x2ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZXJhdGlvbiA9IF9iLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGl0ZXJhdGlvbiAhPT0gdW5kZWZpbmVkKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlcmF0aW9uLmRvbmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbEl0ZXJhdGlvbiA9IGl0ZXJhdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBwdXNoKGl0ZXJhdGlvbi52YWx1ZSldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYi5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNDogcmV0dXJuIFszIC8qYnJlYWsqLywgMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNTogcmV0dXJuIFszIC8qYnJlYWsqLywgOV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hID0gaXRlci5yZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV9hKSByZXR1cm4gWzMgLypicmVhayovLCA4XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGl0ZXIucmV0dXJuKCldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYSA9IChfYi5zZW50KCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSA4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDg6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzcgLyplbmRmaW5hbGx5Ki9dO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDk6IHJldHVybiBbMiAvKnJldHVybiovXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7IH0pKV07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBmaW5hbEl0ZXJhdGlvbiAmJiBmaW5hbEl0ZXJhdGlvbi52YWx1ZV07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICAgICAgc3RvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNyAvKmVuZGZpbmFsbHkqL107XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IHJldHVybiBbMiAvKnJldHVybiovXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7IH0pO1xyXG59XHJcbmZ1bmN0aW9uIHppcChjb250ZW5kZXJzKSB7XHJcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgdmFyIGl0ZXJzID0gZ2V0SXRlcmF0b3JzKGNvbnRlbmRlcnMsIHsgcmV0dXJuVmFsdWVzOiB0cnVlIH0pO1xyXG4gICAgcmV0dXJuIG5ldyBSZXBlYXRlcihmdW5jdGlvbiAocHVzaCwgc3RvcCkgeyByZXR1cm4gX19hd2FpdGVyKF90aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBhZHZhbmNlLCBzdG9wcGVkLCBpdGVyYXRpb25zLCB2YWx1ZXM7XHJcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpdGVycy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgW11dO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBzdG9wcGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RvcC50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWR2YW5jZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9wcGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDE7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgX2EudHJ5cy5wdXNoKFsxLCAsIDYsIDhdKTtcclxuICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDI7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEhc3RvcHBlZCkgcmV0dXJuIFszIC8qYnJlYWsqLywgNV07XHJcbiAgICAgICAgICAgICAgICAgICAgUHJvbWlzZS5hbGwoaXRlcnMubWFwKGZ1bmN0aW9uIChpdGVyKSB7IHJldHVybiBpdGVyLm5leHQoKTsgfSkpLnRoZW4oZnVuY3Rpb24gKGl0ZXJhdGlvbnMpIHsgcmV0dXJuIGFkdmFuY2UoaXRlcmF0aW9ucyk7IH0sIGZ1bmN0aW9uIChlcnIpIHsgcmV0dXJuIHN0b3AoZXJyKTsgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmV0dXJuIChhZHZhbmNlID0gcmVzb2x2ZSk7IH0pXTtcclxuICAgICAgICAgICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgICAgICAgICBpdGVyYXRpb25zID0gX2Euc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVyYXRpb25zID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZXMgPSBpdGVyYXRpb25zLm1hcChmdW5jdGlvbiAoaXRlcmF0aW9uKSB7IHJldHVybiBpdGVyYXRpb24udmFsdWU7IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVyYXRpb25zLnNvbWUoZnVuY3Rpb24gKGl0ZXJhdGlvbikgeyByZXR1cm4gaXRlcmF0aW9uLmRvbmU7IH0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB2YWx1ZXNdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBwdXNoKHZhbHVlcyldO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0OlxyXG4gICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAyXTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNTogcmV0dXJuIFszIC8qYnJlYWsqLywgOF07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDY6XHJcbiAgICAgICAgICAgICAgICAgICAgc3RvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIFByb21pc2UuYWxsKGl0ZXJzLm1hcChmdW5jdGlvbiAoaXRlcikgeyByZXR1cm4gaXRlci5yZXR1cm4gJiYgaXRlci5yZXR1cm4oKTsgfSkpXTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNzpcclxuICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs3IC8qZW5kZmluYWxseSovXTtcclxuICAgICAgICAgICAgICAgIGNhc2UgODogcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTsgfSk7XHJcbn1cclxuZnVuY3Rpb24gbGF0ZXN0KGNvbnRlbmRlcnMpIHtcclxuICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICB2YXIgaXRlcnMgPSBnZXRJdGVyYXRvcnMoY29udGVuZGVycywge1xyXG4gICAgICAgIHlpZWxkVmFsdWVzOiB0cnVlLFxyXG4gICAgICAgIHJldHVyblZhbHVlczogdHJ1ZSxcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIG5ldyBSZXBlYXRlcihmdW5jdGlvbiAocHVzaCwgc3RvcCkgeyByZXR1cm4gX19hd2FpdGVyKF90aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBhZHZhbmNlLCBhZHZhbmNlcywgc3RvcHBlZCwgaXRlcmF0aW9uc18xLCB2YWx1ZXNfMjtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXRlcnMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0b3AoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIFtdXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYWR2YW5jZXMgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICBzdG9wcGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RvcC50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVfNiwgX2E7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkdmFuY2UoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGFkdmFuY2VzXzIgPSBfX3ZhbHVlcyhhZHZhbmNlcyksIGFkdmFuY2VzXzJfMSA9IGFkdmFuY2VzXzIubmV4dCgpOyAhYWR2YW5jZXNfMl8xLmRvbmU7IGFkdmFuY2VzXzJfMSA9IGFkdmFuY2VzXzIubmV4dCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFkdmFuY2UxID0gYWR2YW5jZXNfMl8xLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkdmFuY2UxKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVfNl8xKSB7IGVfNiA9IHsgZXJyb3I6IGVfNl8xIH07IH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhZHZhbmNlc18yXzEgJiYgIWFkdmFuY2VzXzJfMS5kb25lICYmIChfYSA9IGFkdmFuY2VzXzIucmV0dXJuKSkgX2EuY2FsbChhZHZhbmNlc18yKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV82KSB0aHJvdyBlXzYuZXJyb3I7IH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9wcGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDE7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgX2EudHJ5cy5wdXNoKFsxLCAsIDUsIDddKTtcclxuICAgICAgICAgICAgICAgICAgICBQcm9taXNlLmFsbChpdGVycy5tYXAoZnVuY3Rpb24gKGl0ZXIpIHsgcmV0dXJuIGl0ZXIubmV4dCgpOyB9KSkudGhlbihmdW5jdGlvbiAoaXRlcmF0aW9ucykgeyByZXR1cm4gYWR2YW5jZShpdGVyYXRpb25zKTsgfSwgZnVuY3Rpb24gKGVycikgeyByZXR1cm4gc3RvcChlcnIpOyB9KTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXR1cm4gKGFkdmFuY2UgPSByZXNvbHZlKTsgfSldO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgIGl0ZXJhdGlvbnNfMSA9IF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlcmF0aW9uc18xID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZXNfMiA9IGl0ZXJhdGlvbnNfMS5tYXAoZnVuY3Rpb24gKGl0ZXJhdGlvbikgeyByZXR1cm4gaXRlcmF0aW9uLnZhbHVlOyB9KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlcmF0aW9uc18xLmV2ZXJ5KGZ1bmN0aW9uIChpdGVyYXRpb24pIHsgcmV0dXJuIGl0ZXJhdGlvbi5kb25lOyB9KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdmFsdWVzXzJdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBjb250aW51b3VzbHkgeWllbGQgYW5kIG11dGF0ZSB0aGUgc2FtZSB2YWx1ZXMgYXJyYXkgc28gd2Ugc2hhbGxvdyBjb3B5IGl0IGVhY2ggdGltZSBpdCBpcyBwdXNoZWQuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgcHVzaCh2YWx1ZXNfMi5zbGljZSgpKV07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgY29udGludW91c2x5IHlpZWxkIGFuZCBtdXRhdGUgdGhlIHNhbWUgdmFsdWVzIGFycmF5IHNvIHdlIHNoYWxsb3cgY29weSBpdCBlYWNoIHRpbWUgaXQgaXMgcHVzaGVkLlxyXG4gICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBQcm9taXNlLmFsbChpdGVycy5tYXAoZnVuY3Rpb24gKGl0ZXIsIGkpIHsgcmV0dXJuIF9fYXdhaXRlcihfdGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpdGVyYXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlcmF0aW9uc18xW2ldLmRvbmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgaXRlcmF0aW9uc18xW2ldLnZhbHVlXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEhc3RvcHBlZCkgcmV0dXJuIFszIC8qYnJlYWsqLywgNF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBQcm9taXNlLnJlc29sdmUoaXRlci5uZXh0KCkpLnRoZW4oZnVuY3Rpb24gKGl0ZXJhdGlvbikgeyByZXR1cm4gYWR2YW5jZXNbaV0oaXRlcmF0aW9uKTsgfSwgZnVuY3Rpb24gKGVycikgeyByZXR1cm4gc3RvcChlcnIpOyB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJldHVybiAoYWR2YW5jZXNbaV0gPSByZXNvbHZlKTsgfSldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVyYXRpb24gPSBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlcmF0aW9uID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgaXRlcmF0aW9uc18xW2ldLnZhbHVlXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGl0ZXJhdGlvbi5kb25lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGl0ZXJhdGlvbi52YWx1ZV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXNfMltpXSA9IGl0ZXJhdGlvbi52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHB1c2godmFsdWVzXzIuc2xpY2UoKSldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0OiByZXR1cm4gWzIgLypyZXR1cm4qL107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pOyB9KSldO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0OiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNTpcclxuICAgICAgICAgICAgICAgICAgICBzdG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgUHJvbWlzZS5hbGwoaXRlcnMubWFwKGZ1bmN0aW9uIChpdGVyKSB7IHJldHVybiBpdGVyLnJldHVybiAmJiBpdGVyLnJldHVybigpOyB9KSldO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA2OlxyXG4gICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzcgLyplbmRmaW5hbGx5Ki9dO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA3OiByZXR1cm4gWzIgLypyZXR1cm4qL107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH0pOyB9KTtcclxufVxuXG5leHBvcnQgeyBEcm9wcGluZ0J1ZmZlciwgRml4ZWRCdWZmZXIsIE1BWF9RVUVVRV9MRU5HVEgsIFJlcGVhdGVyLCBSZXBlYXRlck92ZXJmbG93RXJyb3IsIFNsaWRpbmdCdWZmZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlcGVhdGVyLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@repeaterjs/repeater/repeater.js\n");

/***/ })

};
;