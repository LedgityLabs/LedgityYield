"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/notistack";
exports.ids = ["vendor-chunks/notistack"];
exports.modules = {

/***/ "(ssr)/../node_modules/notistack/node_modules/clsx/dist/clsx.m.js":
/*!******************************************************************!*\
  !*** ../node_modules/notistack/node_modules/clsx/dist/clsx.m.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clsx: () => (/* binding */ clsx),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nfunction r(e){var t,f,n=\"\";if(\"string\"==typeof e||\"number\"==typeof e)n+=e;else if(\"object\"==typeof e)if(Array.isArray(e))for(t=0;t<e.length;t++)e[t]&&(f=r(e[t]))&&(n&&(n+=\" \"),n+=f);else for(t in e)e[t]&&(n&&(n+=\" \"),n+=t);return n}function clsx(){for(var e,t,f=0,n=\"\";f<arguments.length;)(e=arguments[f++])&&(t=r(e))&&(n&&(n+=\" \"),n+=t);return n}/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (clsx);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL25vdGlzdGFjay9ub2RlX21vZHVsZXMvY2xzeC9kaXN0L2Nsc3gubS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBLGNBQWMsYUFBYSwrQ0FBK0MsdURBQXVELFdBQVcsMENBQTBDLHlDQUF5QyxTQUFnQixnQkFBZ0IscUJBQXFCLG1CQUFtQixrREFBa0QsU0FBUyxpRUFBZSxJQUFJIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGVkZ2l0eS15aWVsZC1mcm9udGVuZC8uLi9ub2RlX21vZHVsZXMvbm90aXN0YWNrL25vZGVfbW9kdWxlcy9jbHN4L2Rpc3QvY2xzeC5tLmpzPzIwNWYiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gcihlKXt2YXIgdCxmLG49XCJcIjtpZihcInN0cmluZ1wiPT10eXBlb2YgZXx8XCJudW1iZXJcIj09dHlwZW9mIGUpbis9ZTtlbHNlIGlmKFwib2JqZWN0XCI9PXR5cGVvZiBlKWlmKEFycmF5LmlzQXJyYXkoZSkpZm9yKHQ9MDt0PGUubGVuZ3RoO3QrKyllW3RdJiYoZj1yKGVbdF0pKSYmKG4mJihuKz1cIiBcIiksbis9Zik7ZWxzZSBmb3IodCBpbiBlKWVbdF0mJihuJiYobis9XCIgXCIpLG4rPXQpO3JldHVybiBufWV4cG9ydCBmdW5jdGlvbiBjbHN4KCl7Zm9yKHZhciBlLHQsZj0wLG49XCJcIjtmPGFyZ3VtZW50cy5sZW5ndGg7KShlPWFyZ3VtZW50c1tmKytdKSYmKHQ9cihlKSkmJihuJiYobis9XCIgXCIpLG4rPXQpO3JldHVybiBufWV4cG9ydCBkZWZhdWx0IGNsc3g7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/notistack/node_modules/clsx/dist/clsx.m.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/notistack/notistack.esm.js":
/*!**************************************************!*\
  !*** ../node_modules/notistack/notistack.esm.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MaterialDesignContent: () => (/* binding */ MaterialDesignContent$1),\n/* harmony export */   SnackbarContent: () => (/* binding */ SnackbarContent),\n/* harmony export */   SnackbarProvider: () => (/* binding */ SnackbarProvider),\n/* harmony export */   Transition: () => (/* binding */ Transition),\n/* harmony export */   closeSnackbar: () => (/* binding */ closeSnackbar),\n/* harmony export */   enqueueSnackbar: () => (/* binding */ enqueueSnackbar),\n/* harmony export */   useSnackbar: () => (/* binding */ useSnackbar)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/../node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ \"(ssr)/../node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var clsx__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! clsx */ \"(ssr)/../node_modules/notistack/node_modules/clsx/dist/clsx.m.js\");\n/* harmony import */ var goober__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! goober */ \"(ssr)/../node_modules/goober/dist/goober.modern.js\");\n\n\n\n\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nvar noOp = function noOp() {\n  return '';\n};\n\nvar SnackbarContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createContext({\n  enqueueSnackbar: noOp,\n  closeSnackbar: noOp\n});\n\nvar breakpoints = {\n  downXs: '@media (max-width:599.95px)',\n  upSm: '@media (min-width:600px)'\n};\n\nvar capitalise = function capitalise(text) {\n  return text.charAt(0).toUpperCase() + text.slice(1);\n};\n\nvar originKeyExtractor = function originKeyExtractor(anchor) {\n  return \"\" + capitalise(anchor.vertical) + capitalise(anchor.horizontal);\n};\nvar isDefined = function isDefined(value) {\n  return !!value || value === 0;\n};\n\nvar UNMOUNTED = 'unmounted';\nvar EXITED = 'exited';\nvar ENTERING = 'entering';\nvar ENTERED = 'entered';\nvar EXITING = 'exiting';\n\nvar Transition = /*#__PURE__*/function (_React$Component) {\n  _inheritsLoose(Transition, _React$Component);\n\n  function Transition(props) {\n    var _this;\n\n    _this = _React$Component.call(this, props) || this;\n    var appear = props.appear;\n    var initialStatus;\n    _this.appearStatus = null;\n\n    if (props[\"in\"]) {\n      if (appear) {\n        initialStatus = EXITED;\n        _this.appearStatus = ENTERING;\n      } else {\n        initialStatus = ENTERED;\n      }\n    } else if (props.unmountOnExit || props.mountOnEnter) {\n      initialStatus = UNMOUNTED;\n    } else {\n      initialStatus = EXITED;\n    }\n\n    _this.state = {\n      status: initialStatus\n    };\n    _this.nextCallback = null;\n    return _this;\n  }\n\n  Transition.getDerivedStateFromProps = function getDerivedStateFromProps(_ref, prevState) {\n    var nextIn = _ref[\"in\"];\n\n    if (nextIn && prevState.status === UNMOUNTED) {\n      return {\n        status: EXITED\n      };\n    }\n\n    return null;\n  };\n\n  var _proto = Transition.prototype;\n\n  _proto.componentDidMount = function componentDidMount() {\n    this.updateStatus(true, this.appearStatus);\n  };\n\n  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {\n    var nextStatus = null;\n\n    if (prevProps !== this.props) {\n      var status = this.state.status;\n\n      if (this.props[\"in\"]) {\n        if (status !== ENTERING && status !== ENTERED) {\n          nextStatus = ENTERING;\n        }\n      } else if (status === ENTERING || status === ENTERED) {\n        nextStatus = EXITING;\n      }\n    }\n\n    this.updateStatus(false, nextStatus);\n  };\n\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    this.cancelNextCallback();\n  };\n\n  _proto.getTimeouts = function getTimeouts() {\n    var timeout = this.props.timeout;\n    var enter = timeout;\n    var exit = timeout;\n\n    if (timeout != null && typeof timeout !== 'number' && typeof timeout !== 'string') {\n      exit = timeout.exit;\n      enter = timeout.enter;\n    }\n\n    return {\n      exit: exit,\n      enter: enter\n    };\n  };\n\n  _proto.updateStatus = function updateStatus(mounting, nextStatus) {\n    if (mounting === void 0) {\n      mounting = false;\n    }\n\n    if (nextStatus !== null) {\n      this.cancelNextCallback();\n\n      if (nextStatus === ENTERING) {\n        this.performEnter(mounting);\n      } else {\n        this.performExit();\n      }\n    } else if (this.props.unmountOnExit && this.state.status === EXITED) {\n      this.setState({\n        status: UNMOUNTED\n      });\n    }\n  };\n\n  _proto.performEnter = function performEnter(mounting) {\n    var _this2 = this;\n\n    var enter = this.props.enter;\n    var isAppearing = mounting;\n    var timeouts = this.getTimeouts();\n\n    if (!mounting && !enter) {\n      this.safeSetState({\n        status: ENTERED\n      }, function () {\n        if (_this2.props.onEntered) {\n          _this2.props.onEntered(_this2.node, isAppearing);\n        }\n      });\n      return;\n    }\n\n    if (this.props.onEnter) {\n      this.props.onEnter(this.node, isAppearing);\n    }\n\n    this.safeSetState({\n      status: ENTERING\n    }, function () {\n      if (_this2.props.onEntering) {\n        _this2.props.onEntering(_this2.node, isAppearing);\n      }\n\n      _this2.onTransitionEnd(timeouts.enter, function () {\n        _this2.safeSetState({\n          status: ENTERED\n        }, function () {\n          if (_this2.props.onEntered) {\n            _this2.props.onEntered(_this2.node, isAppearing);\n          }\n        });\n      });\n    });\n  };\n\n  _proto.performExit = function performExit() {\n    var _this3 = this;\n\n    var exit = this.props.exit;\n    var timeouts = this.getTimeouts(); // no exit animation skip right to EXITED\n\n    if (!exit) {\n      this.safeSetState({\n        status: EXITED\n      }, function () {\n        if (_this3.props.onExited) {\n          _this3.props.onExited(_this3.node);\n        }\n      });\n      return;\n    }\n\n    if (this.props.onExit) {\n      this.props.onExit(this.node);\n    }\n\n    this.safeSetState({\n      status: EXITING\n    }, function () {\n      if (_this3.props.onExiting) {\n        _this3.props.onExiting(_this3.node);\n      }\n\n      _this3.onTransitionEnd(timeouts.exit, function () {\n        _this3.safeSetState({\n          status: EXITED\n        }, function () {\n          if (_this3.props.onExited) {\n            _this3.props.onExited(_this3.node);\n          }\n        });\n      });\n    });\n  };\n\n  _proto.cancelNextCallback = function cancelNextCallback() {\n    if (this.nextCallback !== null && this.nextCallback.cancel) {\n      this.nextCallback.cancel();\n      this.nextCallback = null;\n    }\n  };\n\n  _proto.safeSetState = function safeSetState(nextState, callback) {\n    callback = this.setNextCallback(callback);\n    this.setState(nextState, callback);\n  };\n\n  _proto.setNextCallback = function setNextCallback(callback) {\n    var _this4 = this;\n\n    var active = true;\n\n    this.nextCallback = function () {\n      if (active) {\n        active = false;\n        _this4.nextCallback = null;\n        callback();\n      }\n    };\n\n    this.nextCallback.cancel = function () {\n      active = false;\n    };\n\n    return this.nextCallback;\n  };\n\n  _proto.onTransitionEnd = function onTransitionEnd(timeout, handler) {\n    this.setNextCallback(handler);\n    var doesNotHaveTimeoutOrListener = timeout == null && !this.props.addEndListener;\n\n    if (!this.node || doesNotHaveTimeoutOrListener) {\n      setTimeout(this.nextCallback, 0);\n      return;\n    }\n\n    if (this.props.addEndListener) {\n      this.props.addEndListener(this.node, this.nextCallback);\n    }\n\n    if (timeout != null) {\n      setTimeout(this.nextCallback, timeout);\n    }\n  };\n\n  _proto.render = function render() {\n    var status = this.state.status;\n\n    if (status === UNMOUNTED) {\n      return null;\n    }\n\n    var _this$props = this.props,\n        children = _this$props.children,\n        childProps = _objectWithoutPropertiesLoose(_this$props, [\"children\", \"in\", \"mountOnEnter\", \"unmountOnExit\", \"appear\", \"enter\", \"exit\", \"timeout\", \"addEndListener\", \"onEnter\", \"onEntering\", \"onEntered\", \"onExit\", \"onExiting\", \"onExited\", \"nodeRef\"]);\n\n    return children(status, childProps);\n  };\n\n  _createClass(Transition, [{\n    key: \"node\",\n    get: function get() {\n      var _this$props$nodeRef;\n\n      var node = (_this$props$nodeRef = this.props.nodeRef) === null || _this$props$nodeRef === void 0 ? void 0 : _this$props$nodeRef.current;\n\n      if (!node) {\n        throw new Error('notistack - Custom snackbar is not refForwarding');\n      }\n\n      return node;\n    }\n  }]);\n\n  return Transition;\n}((react__WEBPACK_IMPORTED_MODULE_0___default().Component));\n\nfunction noop() {//\n}\n\nTransition.defaultProps = {\n  \"in\": false,\n  mountOnEnter: false,\n  unmountOnExit: false,\n  appear: false,\n  enter: true,\n  exit: true,\n  onEnter: noop,\n  onEntering: noop,\n  onEntered: noop,\n  onExit: noop,\n  onExiting: noop,\n  onExited: noop\n};\n\n/**\r\n * Credit to MUI team @ https://mui.com\r\n */\n/**\r\n * passes {value} to {ref}\r\n *\r\n * Useful if you want to expose the ref of an inner component to the public API\r\n * while still using it inside the component.\r\n * @param ref A ref callback or ref object. If anything falsy, this is a no-op.\r\n */\n\nfunction setRef(ref, value) {\n  if (typeof ref === 'function') {\n    ref(value);\n  } else if (ref) {\n    ref.current = value;\n  }\n}\n\nfunction useForkRef(refA, refB) {\n  /**\r\n   * This will create a new function if the ref props change and are defined.\r\n   * This means react will call the old forkRef with `null` and the new forkRef\r\n   * with the ref. Cleanup naturally emerges from this behavior.\r\n   */\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(function () {\n    if (refA == null && refB == null) {\n      return null;\n    }\n\n    return function (refValue) {\n      setRef(refA, refValue);\n      setRef(refB, refValue);\n    };\n  }, [refA, refB]);\n}\n\nfunction getTransitionProps(props) {\n  var timeout = props.timeout,\n      _props$style = props.style,\n      style = _props$style === void 0 ? {} : _props$style,\n      mode = props.mode;\n  return {\n    duration: typeof timeout === 'object' ? timeout[mode] || 0 : timeout,\n    easing: style.transitionTimingFunction,\n    delay: style.transitionDelay\n  };\n}\n\n/**\r\n * Credit to MUI team @ https://mui.com\r\n */\nvar defaultEasing = {\n  // This is the most common easing curve.\n  easeInOut: 'cubic-bezier(0.4, 0, 0.2, 1)',\n  // Objects enter the screen at full velocity from off-screen and\n  // slowly decelerate to a resting point.\n  easeOut: 'cubic-bezier(0.0, 0, 0.2, 1)',\n  // Objects leave the screen at full velocity. They do not decelerate when off-screen.\n  easeIn: 'cubic-bezier(0.4, 0, 1, 1)',\n  // The sharp curve is used by objects that may return to the screen at any time.\n  sharp: 'cubic-bezier(0.4, 0, 0.6, 1)'\n};\n/**\r\n * CSS hack to force a repaint\r\n */\n\nvar reflow = function reflow(node) {\n  // We have to do something with node.scrollTop.\n  // Otherwise it's removed from the compiled code by optimisers\n  // eslint-disable-next-line no-self-assign\n  node.scrollTop = node.scrollTop;\n};\n\nvar formatMs = function formatMs(milliseconds) {\n  return Math.round(milliseconds) + \"ms\";\n};\n\nfunction createTransition(props, options) {\n  if (props === void 0) {\n    props = ['all'];\n  }\n\n  var _ref = options || {},\n      _ref$duration = _ref.duration,\n      duration = _ref$duration === void 0 ? 300 : _ref$duration,\n      _ref$easing = _ref.easing,\n      easing = _ref$easing === void 0 ? defaultEasing.easeInOut : _ref$easing,\n      _ref$delay = _ref.delay,\n      delay = _ref$delay === void 0 ? 0 : _ref$delay;\n\n  var properties = Array.isArray(props) ? props : [props];\n  return properties.map(function (animatedProp) {\n    var formattedDuration = typeof duration === 'string' ? duration : formatMs(duration);\n    var formattedDelay = typeof delay === 'string' ? delay : formatMs(delay);\n    return animatedProp + \" \" + formattedDuration + \" \" + easing + \" \" + formattedDelay;\n  }).join(',');\n}\n\nfunction ownerDocument(node) {\n  return node && node.ownerDocument || document;\n}\n\nfunction ownerWindow(node) {\n  var doc = ownerDocument(node);\n  return doc.defaultView || window;\n}\n/**\r\n * Corresponds to 10 frames at 60 Hz.\r\n * A few bytes payload overhead when lodash/debounce is ~3 kB and debounce ~300 B.\r\n */\n\n\nfunction debounce(func, wait) {\n  if (wait === void 0) {\n    wait = 166;\n  }\n\n  var timeout;\n\n  function debounced() {\n    var _this = this;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    var later = function later() {\n      // @ts-ignore\n      func.apply(_this, args);\n    };\n\n    clearTimeout(timeout);\n    timeout = setTimeout(later, wait);\n  }\n\n  debounced.clear = function () {\n    clearTimeout(timeout);\n  };\n\n  return debounced;\n}\n/**\r\n * Translate the node so it can't be seen on the screen.\r\n * Later, we're going to translate the node back to its original location with `none`.\r\n */\n\n\nfunction getTranslateValue(direction, node) {\n  var rect = node.getBoundingClientRect();\n  var containerWindow = ownerWindow(node);\n  var transform;\n\n  if (node.fakeTransform) {\n    transform = node.fakeTransform;\n  } else {\n    var computedStyle = containerWindow.getComputedStyle(node);\n    transform = computedStyle.getPropertyValue('-webkit-transform') || computedStyle.getPropertyValue('transform');\n  }\n\n  var offsetX = 0;\n  var offsetY = 0;\n\n  if (transform && transform !== 'none' && typeof transform === 'string') {\n    var transformValues = transform.split('(')[1].split(')')[0].split(',');\n    offsetX = parseInt(transformValues[4], 10);\n    offsetY = parseInt(transformValues[5], 10);\n  }\n\n  switch (direction) {\n    case 'left':\n      return \"translateX(\" + (containerWindow.innerWidth + offsetX - rect.left) + \"px)\";\n\n    case 'right':\n      return \"translateX(-\" + (rect.left + rect.width - offsetX) + \"px)\";\n\n    case 'up':\n      return \"translateY(\" + (containerWindow.innerHeight + offsetY - rect.top) + \"px)\";\n\n    default:\n      // down\n      return \"translateY(-\" + (rect.top + rect.height - offsetY) + \"px)\";\n  }\n}\n\nfunction setTranslateValue(direction, node) {\n  if (!node) return;\n  var transform = getTranslateValue(direction, node);\n\n  if (transform) {\n    node.style.webkitTransform = transform;\n    node.style.transform = transform;\n  }\n}\n\nvar Slide = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(function (props, ref) {\n  var children = props.children,\n      _props$direction = props.direction,\n      direction = _props$direction === void 0 ? 'down' : _props$direction,\n      inProp = props[\"in\"],\n      style = props.style,\n      _props$timeout = props.timeout,\n      timeout = _props$timeout === void 0 ? 0 : _props$timeout,\n      onEnter = props.onEnter,\n      onEntered = props.onEntered,\n      onExit = props.onExit,\n      onExited = props.onExited,\n      other = _objectWithoutPropertiesLoose(props, [\"children\", \"direction\", \"in\", \"style\", \"timeout\", \"onEnter\", \"onEntered\", \"onExit\", \"onExited\"]);\n\n  var nodeRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  var handleRefIntermediary = useForkRef(children.ref, nodeRef);\n  var handleRef = useForkRef(handleRefIntermediary, ref);\n\n  var handleEnter = function handleEnter(node, isAppearing) {\n    setTranslateValue(direction, node);\n    reflow(node);\n\n    if (onEnter) {\n      onEnter(node, isAppearing);\n    }\n  };\n\n  var handleEntering = function handleEntering(node) {\n    var easing = (style === null || style === void 0 ? void 0 : style.transitionTimingFunction) || defaultEasing.easeOut;\n    var transitionProps = getTransitionProps({\n      timeout: timeout,\n      mode: 'enter',\n      style: _extends({}, style, {\n        transitionTimingFunction: easing\n      })\n    });\n    node.style.webkitTransition = createTransition('-webkit-transform', transitionProps);\n    node.style.transition = createTransition('transform', transitionProps);\n    node.style.webkitTransform = 'none';\n    node.style.transform = 'none';\n  };\n\n  var handleExit = function handleExit(node) {\n    var easing = (style === null || style === void 0 ? void 0 : style.transitionTimingFunction) || defaultEasing.sharp;\n    var transitionProps = getTransitionProps({\n      timeout: timeout,\n      mode: 'exit',\n      style: _extends({}, style, {\n        transitionTimingFunction: easing\n      })\n    });\n    node.style.webkitTransition = createTransition('-webkit-transform', transitionProps);\n    node.style.transition = createTransition('transform', transitionProps);\n    setTranslateValue(direction, node);\n\n    if (onExit) {\n      onExit(node);\n    }\n  };\n\n  var handleExited = function handleExited(node) {\n    // No need for transitions when the component is hidden\n    node.style.webkitTransition = '';\n    node.style.transition = '';\n\n    if (onExited) {\n      onExited(node);\n    }\n  };\n\n  var updatePosition = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function () {\n    if (nodeRef.current) {\n      setTranslateValue(direction, nodeRef.current);\n    }\n  }, [direction]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {\n    // Skip configuration where the position is screen size invariant.\n    if (inProp || direction === 'down' || direction === 'right') {\n      return undefined;\n    }\n\n    var handleResize = debounce(function () {\n      if (nodeRef.current) {\n        setTranslateValue(direction, nodeRef.current);\n      }\n    });\n    var containerWindow = ownerWindow(nodeRef.current);\n    containerWindow.addEventListener('resize', handleResize);\n    return function () {\n      handleResize.clear();\n      containerWindow.removeEventListener('resize', handleResize);\n    };\n  }, [direction, inProp]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {\n    if (!inProp) {\n      // We need to update the position of the drawer when the direction change and\n      // when it's hidden.\n      updatePosition();\n    }\n  }, [inProp, updatePosition]);\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(Transition, Object.assign({\n    appear: true,\n    nodeRef: nodeRef,\n    onEnter: handleEnter,\n    onEntered: onEntered,\n    onEntering: handleEntering,\n    onExit: handleExit,\n    onExited: handleExited,\n    \"in\": inProp,\n    timeout: timeout\n  }, other), function (state, childProps) {\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.cloneElement)(children, _extends({\n      ref: handleRef,\n      style: _extends({\n        visibility: state === 'exited' && !inProp ? 'hidden' : undefined\n      }, style, {}, children.props.style)\n    }, childProps));\n  });\n});\nSlide.displayName = 'Slide';\n\nvar SvgIcon = function SvgIcon(props) {\n  return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"svg\", Object.assign({\n    viewBox: \"0 0 24 24\",\n    focusable: \"false\",\n    style: {\n      fontSize: 20,\n      marginInlineEnd: 8,\n      userSelect: 'none',\n      width: '1em',\n      height: '1em',\n      display: 'inline-block',\n      fill: 'currentColor',\n      flexShrink: 0\n    }\n  }, props));\n};\n\nvar CheckIcon = function CheckIcon() {\n  return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(SvgIcon, null, react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"path\", {\n    d: \"M12 2C6.5 2 2 6.5 2 12S6.5 22 12 22 22 17.5 22 12 17.5 2 12 2M10 17L5 12L6.41\\n        10.59L10 14.17L17.59 6.58L19 8L10 17Z\"\n  }));\n};\n\nvar WarningIcon = function WarningIcon() {\n  return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(SvgIcon, null, react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"path\", {\n    d: \"M13,14H11V10H13M13,18H11V16H13M1,21H23L12,2L1,21Z\"\n  }));\n};\n\nvar ErrorIcon = function ErrorIcon() {\n  return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(SvgIcon, null, react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"path\", {\n    d: \"M12,2C17.53,2 22,6.47 22,12C22,17.53 17.53,22 12,22C6.47,22 2,17.53 2,12C2,\\n        6.47 6.47,2 12,2M15.59,7L12,10.59L8.41,7L7,8.41L10.59,12L7,15.59L8.41,17L12,\\n        13.41L15.59,17L17,15.59L13.41,12L17,8.41L15.59,7Z\"\n  }));\n};\n\nvar InfoIcon = function InfoIcon() {\n  return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(SvgIcon, null, react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"path\", {\n    d: \"M13,9H11V7H13M13,17H11V11H13M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,\\n        0 22,12A10,10 0 0,0 12,2Z\"\n  }));\n};\n\nvar defaultIconVariants = {\n  \"default\": undefined,\n  success: /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(CheckIcon, null),\n  warning: /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(WarningIcon, null),\n  error: /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(ErrorIcon, null),\n  info: /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(InfoIcon, null)\n};\n\nvar defaults = {\n  maxSnack: 3,\n  persist: false,\n  hideIconVariant: false,\n  disableWindowBlurListener: false,\n  variant: 'default',\n  autoHideDuration: 5000,\n  iconVariant: defaultIconVariants,\n  anchorOrigin: {\n    vertical: 'bottom',\n    horizontal: 'left'\n  },\n  TransitionComponent: Slide,\n  transitionDuration: {\n    enter: 225,\n    exit: 195\n  }\n};\n/**\r\n * Derives the right autoHideDuration taking into account the following\r\n * prority order: 1: Options, 2: Props, 3: default fallback\r\n */\n\nvar getAutoHideDuration = function getAutoHideDuration(optionsDuration, propsDuration) {\n  var isNumberOrNull = function isNumberOrNull(numberish) {\n    return typeof numberish === 'number' || numberish === null;\n  };\n\n  if (isNumberOrNull(optionsDuration)) return optionsDuration;\n  if (isNumberOrNull(propsDuration)) return propsDuration;\n  return defaults.autoHideDuration;\n};\n/**\r\n * Derives the right transitionDuration taking into account the following\r\n * prority order: 1: Options, 2: Props, 3: default fallback\r\n */\n\n\nvar getTransitionDuration = function getTransitionDuration(optionsDuration, propsDuration) {\n  var is = function is(item, types) {\n    return types.some(function (t) {\n      return typeof item === t;\n    });\n  };\n\n  if (is(optionsDuration, ['string', 'number'])) {\n    return optionsDuration;\n  }\n\n  if (is(optionsDuration, ['object'])) {\n    return _extends({}, defaults.transitionDuration, {}, is(propsDuration, ['object']) && propsDuration, {}, optionsDuration);\n  }\n\n  if (is(propsDuration, ['string', 'number'])) {\n    return propsDuration;\n  }\n\n  if (is(propsDuration, ['object'])) {\n    return _extends({}, defaults.transitionDuration, {}, propsDuration);\n  }\n\n  return defaults.transitionDuration;\n};\n\nvar merge = function merge(options, props) {\n  return function (name, shouldObjectMerge) {\n    if (shouldObjectMerge === void 0) {\n      shouldObjectMerge = false;\n    }\n\n    if (shouldObjectMerge) {\n      return _extends({}, defaults[name], {}, props[name], {}, options[name]);\n    }\n\n    if (name === 'autoHideDuration') {\n      return getAutoHideDuration(options.autoHideDuration, props.autoHideDuration);\n    }\n\n    if (name === 'transitionDuration') {\n      return getTransitionDuration(options.transitionDuration, props.transitionDuration);\n    }\n\n    return options[name] || props[name] || defaults[name];\n  };\n};\n\nfunction makeStyles(styles) {\n  return Object.entries(styles).reduce(function (acc, _ref) {\n    var _extends2;\n\n    var key = _ref[0],\n        value = _ref[1];\n    return _extends({}, acc, (_extends2 = {}, _extends2[key] = (0,goober__WEBPACK_IMPORTED_MODULE_3__.css)(value), _extends2));\n  }, {});\n}\nvar ComponentClasses = {\n  SnackbarContainer: 'notistack-SnackbarContainer',\n  Snackbar: 'notistack-Snackbar',\n  CollapseWrapper: 'notistack-CollapseWrapper',\n  MuiContent: 'notistack-MuiContent',\n  MuiContentVariant: function MuiContentVariant(variant) {\n    return \"notistack-MuiContent-\" + variant;\n  }\n};\n\nvar classes = /*#__PURE__*/makeStyles({\n  root: {\n    height: 0\n  },\n  entered: {\n    height: 'auto'\n  }\n});\nvar collapsedSize = '0px';\nvar timeout = 175;\nvar Collapse = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(function (props, ref) {\n  var children = props.children,\n      inProp = props[\"in\"],\n      onExited = props.onExited;\n  var wrapperRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  var nodeRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  var handleRef = useForkRef(ref, nodeRef);\n\n  var getWrapperSize = function getWrapperSize() {\n    return wrapperRef.current ? wrapperRef.current.clientHeight : 0;\n  };\n\n  var handleEnter = function handleEnter(node) {\n    node.style.height = collapsedSize;\n  };\n\n  var handleEntering = function handleEntering(node) {\n    var wrapperSize = getWrapperSize();\n\n    var _getTransitionProps = getTransitionProps({\n      timeout: timeout,\n      mode: 'enter'\n    }),\n        transitionDuration = _getTransitionProps.duration,\n        easing = _getTransitionProps.easing;\n\n    node.style.transitionDuration = typeof transitionDuration === 'string' ? transitionDuration : transitionDuration + \"ms\";\n    node.style.height = wrapperSize + \"px\";\n    node.style.transitionTimingFunction = easing || '';\n  };\n\n  var handleEntered = function handleEntered(node) {\n    node.style.height = 'auto';\n  };\n\n  var handleExit = function handleExit(node) {\n    node.style.height = getWrapperSize() + \"px\";\n  };\n\n  var handleExiting = function handleExiting(node) {\n    reflow(node);\n\n    var _getTransitionProps2 = getTransitionProps({\n      timeout: timeout,\n      mode: 'exit'\n    }),\n        transitionDuration = _getTransitionProps2.duration,\n        easing = _getTransitionProps2.easing;\n\n    node.style.transitionDuration = typeof transitionDuration === 'string' ? transitionDuration : transitionDuration + \"ms\";\n    node.style.height = collapsedSize;\n    node.style.transitionTimingFunction = easing || '';\n  };\n\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(Transition, {\n    \"in\": inProp,\n    unmountOnExit: true,\n    onEnter: handleEnter,\n    onEntered: handleEntered,\n    onEntering: handleEntering,\n    onExit: handleExit,\n    onExited: onExited,\n    onExiting: handleExiting,\n    nodeRef: nodeRef,\n    timeout: timeout\n  }, function (state, childProps) {\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", Object.assign({\n      ref: handleRef,\n      className: (0,clsx__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(classes.root, state === 'entered' && classes.entered),\n      style: _extends({\n        pointerEvents: 'all',\n        overflow: 'hidden',\n        minHeight: collapsedSize,\n        transition: createTransition('height')\n      }, state === 'entered' && {\n        overflow: 'visible'\n      }, {}, state === 'exited' && !inProp && {\n        visibility: 'hidden'\n      })\n    }, childProps), (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n      ref: wrapperRef,\n      className: ComponentClasses.CollapseWrapper,\n      // Hack to get children with a negative margin to not falsify the height computation.\n      style: {\n        display: 'flex',\n        width: '100%'\n      }\n    }, children));\n  });\n});\nCollapse.displayName = 'Collapse';\n\nvar direction = {\n  right: 'left',\n  left: 'right',\n  bottom: 'up',\n  top: 'down'\n};\nvar getSlideDirection = function getSlideDirection(anchorOrigin) {\n  if (anchorOrigin.horizontal !== 'center') {\n    return direction[anchorOrigin.horizontal];\n  }\n\n  return direction[anchorOrigin.vertical];\n};\n/** Tranforms classes name */\n\nvar toSnackbarAnchorOrigin = function toSnackbarAnchorOrigin(anchorOrigin) {\n  return \"anchorOrigin\" + originKeyExtractor(anchorOrigin);\n};\n/**\r\n * Omit SnackbarContainer class keys that are not needed for SnackbarItem\r\n */\n\nvar keepSnackbarClassKeys = function keepSnackbarClassKeys(classes) {\n  if (classes === void 0) {\n    classes = {};\n  }\n\n  var containerClasses = {\n    containerRoot: true,\n    containerAnchorOriginTopCenter: true,\n    containerAnchorOriginBottomCenter: true,\n    containerAnchorOriginTopRight: true,\n    containerAnchorOriginBottomRight: true,\n    containerAnchorOriginTopLeft: true,\n    containerAnchorOriginBottomLeft: true\n  };\n  return Object.keys(classes).filter(function (key) {\n    return !containerClasses[key];\n  }).reduce(function (obj, key) {\n    var _extends2;\n\n    return _extends({}, obj, (_extends2 = {}, _extends2[key] = classes[key], _extends2));\n  }, {});\n};\n\nvar noOp$1 = function noOp() {\n  /* */\n};\n/**\r\n * Credit to MUI team @ https://mui.com\r\n * Safe chained function.\r\n *\r\n * Will only create a new function if needed,\r\n * otherwise will pass back existing functions or null.\r\n */\n\n\nfunction createChainedFunction(funcs, snackbarId) {\n  // @ts-ignore\n  return funcs.reduce(function (acc, func) {\n    if (func === null || func === undefined) {\n      return acc;\n    }\n\n    return function chainedFunction() {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      var argums = [].concat(args);\n\n      if (snackbarId && argums.indexOf(snackbarId) === -1) {\n        argums.push(snackbarId);\n      } // @ts-ignore\n\n\n      acc.apply(this, argums);\n      func.apply(this, argums);\n    };\n  }, noOp$1);\n}\n\n/**\r\n * Credit to MUI team @ https://mui.com\r\n * https://github.com/facebook/react/issues/14099#issuecomment-440013892\r\n */\nvar useEnhancedEffect = typeof window !== 'undefined' ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\nfunction useEventCallback(fn) {\n  var ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(fn);\n  useEnhancedEffect(function () {\n    ref.current = fn;\n  });\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function () {\n    return (// @ts-expect-error hide `this`\n      (ref.current).apply(void 0, arguments)\n    );\n  }, []);\n}\n\n/**\r\n * Credit to MUI team @ https://mui.com\r\n */\nvar Snackbar = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(function (props, ref) {\n  var children = props.children,\n      className = props.className,\n      autoHideDuration = props.autoHideDuration,\n      _props$disableWindowB = props.disableWindowBlurListener,\n      disableWindowBlurListener = _props$disableWindowB === void 0 ? false : _props$disableWindowB,\n      onClose = props.onClose,\n      id = props.id,\n      open = props.open,\n      _props$SnackbarProps = props.SnackbarProps,\n      SnackbarProps = _props$SnackbarProps === void 0 ? {} : _props$SnackbarProps;\n  var timerAutoHide = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n  var handleClose = useEventCallback(function () {\n    if (onClose) {\n      onClose.apply(void 0, arguments);\n    }\n  });\n  var setAutoHideTimer = useEventCallback(function (autoHideDurationParam) {\n    if (!onClose || autoHideDurationParam == null) {\n      return;\n    }\n\n    if (timerAutoHide.current) {\n      clearTimeout(timerAutoHide.current);\n    }\n\n    timerAutoHide.current = setTimeout(function () {\n      handleClose(null, 'timeout', id);\n    }, autoHideDurationParam);\n  });\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {\n    if (open) {\n      setAutoHideTimer(autoHideDuration);\n    }\n\n    return function () {\n      if (timerAutoHide.current) {\n        clearTimeout(timerAutoHide.current);\n      }\n    };\n  }, [open, autoHideDuration, setAutoHideTimer]);\n  /**\r\n   * Pause the timer when the user is interacting with the Snackbar\r\n   * or when the user hide the window.\r\n   */\n\n  var handlePause = function handlePause() {\n    if (timerAutoHide.current) {\n      clearTimeout(timerAutoHide.current);\n    }\n  };\n  /**\r\n   * Restart the timer when the user is no longer interacting with the Snackbar\r\n   * or when the window is shown back.\r\n   */\n\n\n  var handleResume = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function () {\n    if (autoHideDuration != null) {\n      setAutoHideTimer(autoHideDuration * 0.5);\n    }\n  }, [autoHideDuration, setAutoHideTimer]);\n\n  var handleMouseEnter = function handleMouseEnter(event) {\n    if (SnackbarProps.onMouseEnter) {\n      SnackbarProps.onMouseEnter(event);\n    }\n\n    handlePause();\n  };\n\n  var handleMouseLeave = function handleMouseLeave(event) {\n    if (SnackbarProps.onMouseLeave) {\n      SnackbarProps.onMouseLeave(event);\n    }\n\n    handleResume();\n  };\n\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {\n    if (!disableWindowBlurListener && open) {\n      window.addEventListener('focus', handleResume);\n      window.addEventListener('blur', handlePause);\n      return function () {\n        window.removeEventListener('focus', handleResume);\n        window.removeEventListener('blur', handlePause);\n      };\n    }\n\n    return undefined;\n  }, [disableWindowBlurListener, handleResume, open]);\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", Object.assign({\n    ref: ref\n  }, SnackbarProps, {\n    className: (0,clsx__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(ComponentClasses.Snackbar, className),\n    onMouseEnter: handleMouseEnter,\n    onMouseLeave: handleMouseLeave\n  }), children);\n});\nSnackbar.displayName = 'Snackbar';\n\nvar _root;\nvar classes$1 = /*#__PURE__*/makeStyles({\n  root: (_root = {\n    display: 'flex',\n    flexWrap: 'wrap',\n    flexGrow: 1\n  }, _root[breakpoints.upSm] = {\n    flexGrow: 'initial',\n    minWidth: '288px'\n  }, _root)\n});\nvar SnackbarContent = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(function (_ref, ref) {\n  var className = _ref.className,\n      props = _objectWithoutPropertiesLoose(_ref, [\"className\"]);\n\n  return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", Object.assign({\n    ref: ref,\n    className: (0,clsx__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(classes$1.root, className)\n  }, props));\n});\nSnackbarContent.displayName = 'SnackbarContent';\n\nvar classes$2 = /*#__PURE__*/makeStyles({\n  root: {\n    backgroundColor: '#313131',\n    fontSize: '0.875rem',\n    lineHeight: 1.43,\n    letterSpacing: '0.01071em',\n    color: '#fff',\n    alignItems: 'center',\n    padding: '6px 16px',\n    borderRadius: '4px',\n    boxShadow: '0px 3px 5px -1px rgba(0,0,0,0.2),0px 6px 10px 0px rgba(0,0,0,0.14),0px 1px 18px 0px rgba(0,0,0,0.12)'\n  },\n  lessPadding: {\n    paddingLeft: 8 * 2.5 + \"px\"\n  },\n  \"default\": {\n    backgroundColor: '#313131'\n  },\n  success: {\n    backgroundColor: '#43a047'\n  },\n  error: {\n    backgroundColor: '#d32f2f'\n  },\n  warning: {\n    backgroundColor: '#ff9800'\n  },\n  info: {\n    backgroundColor: '#2196f3'\n  },\n  message: {\n    display: 'flex',\n    alignItems: 'center',\n    padding: '8px 0'\n  },\n  action: {\n    display: 'flex',\n    alignItems: 'center',\n    marginLeft: 'auto',\n    paddingLeft: '16px',\n    marginRight: '-8px'\n  }\n});\nvar ariaDescribedby = 'notistack-snackbar';\nvar MaterialDesignContent = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(function (props, forwardedRef) {\n  var id = props.id,\n      message = props.message,\n      componentOrFunctionAction = props.action,\n      iconVariant = props.iconVariant,\n      variant = props.variant,\n      hideIconVariant = props.hideIconVariant,\n      style = props.style,\n      className = props.className;\n  var icon = iconVariant[variant];\n  var action = componentOrFunctionAction;\n\n  if (typeof action === 'function') {\n    action = action(id);\n  }\n\n  return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(SnackbarContent, {\n    ref: forwardedRef,\n    role: \"alert\",\n    \"aria-describedby\": ariaDescribedby,\n    style: style,\n    className: (0,clsx__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(ComponentClasses.MuiContent, ComponentClasses.MuiContentVariant(variant), classes$2.root, classes$2[variant], className, !hideIconVariant && icon && classes$2.lessPadding)\n  }, react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    id: ariaDescribedby,\n    className: classes$2.message\n  }, !hideIconVariant ? icon : null, message), action && react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    className: classes$2.action\n  }, action));\n});\nMaterialDesignContent.displayName = 'MaterialDesignContent';\nvar MaterialDesignContent$1 = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(MaterialDesignContent);\n\nvar styles = /*#__PURE__*/makeStyles({\n  wrappedRoot: {\n    width: '100%',\n    position: 'relative',\n    transform: 'translateX(0)',\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    minWidth: '288px'\n  }\n});\n\nvar SnackbarItem = function SnackbarItem(props) {\n  var timeout = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n\n  var _useState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true),\n      collapsed = _useState[0],\n      setCollapsed = _useState[1];\n\n  var handleClose = createChainedFunction([props.snack.onClose, props.onClose]);\n\n  var handleEntered = function handleEntered() {\n    if (props.snack.requestClose) {\n      handleClose(null, 'instructed', props.snack.id);\n    }\n  };\n\n  var handleExitedScreen = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function () {\n    timeout.current = setTimeout(function () {\n      setCollapsed(function (col) {\n        return !col;\n      });\n    }, 125);\n  }, []);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {\n    return function () {\n      if (timeout.current) {\n        clearTimeout(timeout.current);\n      }\n    };\n  }, []);\n  var snack = props.snack,\n      allClasses = props.classes,\n      _props$Component = props.Component,\n      Component = _props$Component === void 0 ? MaterialDesignContent$1 : _props$Component;\n  var classes = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(function () {\n    return keepSnackbarClassKeys(allClasses);\n  }, [allClasses]);\n\n  var open = snack.open,\n      SnackbarProps = snack.SnackbarProps,\n      TransitionComponent = snack.TransitionComponent,\n      TransitionProps = snack.TransitionProps,\n      transitionDuration = snack.transitionDuration,\n      disableWindowBlurListener = snack.disableWindowBlurListener,\n      componentOrFunctionContent = snack.content,\n      otherSnack = _objectWithoutPropertiesLoose(snack, [\"open\", \"SnackbarProps\", \"TransitionComponent\", \"TransitionProps\", \"transitionDuration\", \"disableWindowBlurListener\", \"content\", \"entered\", \"requestClose\", \"onEnter\", \"onEntered\", \"onExit\", \"onExited\"]);\n\n  var transitionProps = _extends({\n    direction: getSlideDirection(otherSnack.anchorOrigin),\n    timeout: transitionDuration\n  }, TransitionProps);\n\n  var content = componentOrFunctionContent;\n\n  if (typeof content === 'function') {\n    content = content(otherSnack.id, otherSnack.message);\n  }\n\n  var callbacks = ['onEnter', 'onEntered', 'onExit', 'onExited'].reduce(function (acc, cbName) {\n    var _extends2;\n\n    return _extends({}, acc, (_extends2 = {}, _extends2[cbName] = createChainedFunction([props.snack[cbName], props[cbName]], otherSnack.id), _extends2));\n  }, {});\n  return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(Collapse, {\n    \"in\": collapsed,\n    onExited: callbacks.onExited\n  }, react__WEBPACK_IMPORTED_MODULE_0___default().createElement(Snackbar, {\n    open: open,\n    id: otherSnack.id,\n    disableWindowBlurListener: disableWindowBlurListener,\n    autoHideDuration: otherSnack.autoHideDuration,\n    className: (0,clsx__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(styles.wrappedRoot, classes.root, classes[toSnackbarAnchorOrigin(otherSnack.anchorOrigin)]),\n    SnackbarProps: SnackbarProps,\n    onClose: handleClose\n  }, react__WEBPACK_IMPORTED_MODULE_0___default().createElement(TransitionComponent, Object.assign({}, transitionProps, {\n    appear: true,\n    \"in\": open,\n    onExit: callbacks.onExit,\n    onExited: handleExitedScreen,\n    onEnter: callbacks.onEnter,\n    // order matters. first callbacks.onEntered to set entered: true,\n    // then handleEntered to check if there's a request for closing\n    onEntered: createChainedFunction([callbacks.onEntered, handleEntered], otherSnack.id)\n  }), content || react__WEBPACK_IMPORTED_MODULE_0___default().createElement(Component, Object.assign({}, otherSnack)))));\n};\n\nvar _root$1, _rootDense, _left, _right, _center;\nvar indents = {\n  view: {\n    \"default\": 20,\n    dense: 4\n  },\n  snackbar: {\n    \"default\": 6,\n    dense: 2\n  }\n};\nvar collapseWrapper = \".\" + ComponentClasses.CollapseWrapper;\nvar xsWidthMargin = 16;\nvar styles$1 = /*#__PURE__*/makeStyles({\n  root: (_root$1 = {\n    boxSizing: 'border-box',\n    display: 'flex',\n    maxHeight: '100%',\n    position: 'fixed',\n    zIndex: 1400,\n    height: 'auto',\n    width: 'auto',\n    transition: /*#__PURE__*/createTransition(['top', 'right', 'bottom', 'left', 'max-width'], {\n      duration: 300,\n      easing: 'ease'\n    }),\n    // container itself is invisible and should not block clicks, clicks should be passed to its children\n    // a pointerEvents: all is applied in the collapse component\n    pointerEvents: 'none'\n  }, _root$1[collapseWrapper] = {\n    padding: indents.snackbar[\"default\"] + \"px 0px\",\n    transition: 'padding 300ms ease 0ms'\n  }, _root$1.maxWidth = \"calc(100% - \" + indents.view[\"default\"] * 2 + \"px)\", _root$1[breakpoints.downXs] = {\n    width: '100%',\n    maxWidth: \"calc(100% - \" + xsWidthMargin * 2 + \"px)\"\n  }, _root$1),\n  rootDense: (_rootDense = {}, _rootDense[collapseWrapper] = {\n    padding: indents.snackbar.dense + \"px 0px\"\n  }, _rootDense),\n  top: {\n    top: indents.view[\"default\"] - indents.snackbar[\"default\"] + \"px\",\n    flexDirection: 'column'\n  },\n  bottom: {\n    bottom: indents.view[\"default\"] - indents.snackbar[\"default\"] + \"px\",\n    flexDirection: 'column-reverse'\n  },\n  left: (_left = {\n    left: indents.view[\"default\"] + \"px\"\n  }, _left[breakpoints.upSm] = {\n    alignItems: 'flex-start'\n  }, _left[breakpoints.downXs] = {\n    left: xsWidthMargin + \"px\"\n  }, _left),\n  right: (_right = {\n    right: indents.view[\"default\"] + \"px\"\n  }, _right[breakpoints.upSm] = {\n    alignItems: 'flex-end'\n  }, _right[breakpoints.downXs] = {\n    right: xsWidthMargin + \"px\"\n  }, _right),\n  center: (_center = {\n    left: '50%',\n    transform: 'translateX(-50%)'\n  }, _center[breakpoints.upSm] = {\n    alignItems: 'center'\n  }, _center)\n});\n\nvar SnackbarContainer = function SnackbarContainer(props) {\n  var _props$classes = props.classes,\n      classes = _props$classes === void 0 ? {} : _props$classes,\n      anchorOrigin = props.anchorOrigin,\n      dense = props.dense,\n      children = props.children;\n  var combinedClassname = (0,clsx__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(ComponentClasses.SnackbarContainer, styles$1[anchorOrigin.vertical], styles$1[anchorOrigin.horizontal], styles$1.root, // root should come after others to override maxWidth\n  classes.containerRoot, classes[\"containerAnchorOrigin\" + originKeyExtractor(anchorOrigin)], dense && styles$1.rootDense);\n  return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    className: combinedClassname\n  }, children);\n};\n\nvar SnackbarContainer$1 = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(SnackbarContainer);\n\n/* eslint-disable */\nvar __DEV__ = \"development\" !== 'production';\n\nvar messages = {\n  NO_PERSIST_ALL: \"Reached maxSnack while all enqueued snackbars have 'persist' flag. Notistack will dismiss the oldest snackbar anyway to allow other ones in the queue to be presented.\"\n};\nvar warning = (function (messageKey) {\n  if (!__DEV__) return;\n  var message = messages[messageKey];\n\n  if (typeof console !== 'undefined') {\n    console.error(\"WARNING - notistack: \" + message);\n  }\n\n  try {\n    throw new Error(message);\n  } catch (x) {}\n});\n\nvar isOptions = function isOptions(messageOrOptions) {\n  var isMessage = typeof messageOrOptions === 'string' || (0,react__WEBPACK_IMPORTED_MODULE_0__.isValidElement)(messageOrOptions);\n  return !isMessage;\n};\n\nvar enqueueSnackbar;\nvar closeSnackbar;\n\nvar SnackbarProvider = /*#__PURE__*/function (_Component) {\n  _inheritsLoose(SnackbarProvider, _Component);\n\n  function SnackbarProvider(props) {\n    var _this;\n\n    _this = _Component.call(this, props) || this;\n    /**\r\n     * Adds a new snackbar to the queue to be presented.\r\n     * Returns generated or user defined key referencing the new snackbar or null\r\n     */\n\n    _this.enqueueSnackbar = function (messageOrOptions, optsOrUndefined) {\n      if (optsOrUndefined === void 0) {\n        optsOrUndefined = {};\n      }\n\n      if (messageOrOptions === undefined || messageOrOptions === null) {\n        throw new Error('enqueueSnackbar called with invalid argument');\n      }\n\n      var opts = isOptions(messageOrOptions) ? messageOrOptions : optsOrUndefined;\n      var message = isOptions(messageOrOptions) ? messageOrOptions.message : messageOrOptions;\n\n      var key = opts.key,\n          preventDuplicate = opts.preventDuplicate,\n          options = _objectWithoutPropertiesLoose(opts, [\"key\", \"preventDuplicate\"]);\n\n      var hasSpecifiedKey = isDefined(key);\n      var id = hasSpecifiedKey ? key : new Date().getTime() + Math.random();\n      var merger = merge(options, _this.props);\n\n      var snack = _extends({\n        id: id\n      }, options, {\n        message: message,\n        open: true,\n        entered: false,\n        requestClose: false,\n        persist: merger('persist'),\n        action: merger('action'),\n        content: merger('content'),\n        variant: merger('variant'),\n        anchorOrigin: merger('anchorOrigin'),\n        disableWindowBlurListener: merger('disableWindowBlurListener'),\n        autoHideDuration: merger('autoHideDuration'),\n        hideIconVariant: merger('hideIconVariant'),\n        TransitionComponent: merger('TransitionComponent'),\n        transitionDuration: merger('transitionDuration'),\n        TransitionProps: merger('TransitionProps', true),\n        iconVariant: merger('iconVariant', true),\n        style: merger('style', true),\n        SnackbarProps: merger('SnackbarProps', true),\n        className: (0,clsx__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(_this.props.className, options.className)\n      });\n\n      if (snack.persist) {\n        snack.autoHideDuration = undefined;\n      }\n\n      _this.setState(function (state) {\n        if (preventDuplicate === undefined && _this.props.preventDuplicate || preventDuplicate) {\n          var compareFunction = function compareFunction(item) {\n            return hasSpecifiedKey ? item.id === id : item.message === message;\n          };\n\n          var inQueue = state.queue.findIndex(compareFunction) > -1;\n          var inView = state.snacks.findIndex(compareFunction) > -1;\n\n          if (inQueue || inView) {\n            return state;\n          }\n        }\n\n        return _this.handleDisplaySnack(_extends({}, state, {\n          queue: [].concat(state.queue, [snack])\n        }));\n      });\n\n      return id;\n    };\n    /**\r\n     * Reducer: Display snack if there's space for it. Otherwise, immediately\r\n     * begin dismissing the oldest message to start showing the new one.\r\n     */\n\n\n    _this.handleDisplaySnack = function (state) {\n      var snacks = state.snacks;\n\n      if (snacks.length >= _this.maxSnack) {\n        return _this.handleDismissOldest(state);\n      }\n\n      return _this.processQueue(state);\n    };\n    /**\r\n     * Reducer: Display items (notifications) in the queue if there's space for them.\r\n     */\n\n\n    _this.processQueue = function (state) {\n      var queue = state.queue,\n          snacks = state.snacks;\n\n      if (queue.length > 0) {\n        return _extends({}, state, {\n          snacks: [].concat(snacks, [queue[0]]),\n          queue: queue.slice(1, queue.length)\n        });\n      }\n\n      return state;\n    };\n    /**\r\n     * Reducer: Hide oldest snackbar on the screen because there exists a new one which we have to display.\r\n     * (ignoring the one with 'persist' flag. i.e. explicitly told by user not to get dismissed).\r\n     *\r\n     * Note 1: If there is already a message leaving the screen, no new messages are dismissed.\r\n     * Note 2: If the oldest message has not yet entered the screen, only a request to close the\r\n     *         snackbar is made. Once it entered the screen, it will be immediately dismissed.\r\n     */\n\n\n    _this.handleDismissOldest = function (state) {\n      if (state.snacks.some(function (item) {\n        return !item.open || item.requestClose;\n      })) {\n        return state;\n      }\n\n      var popped = false;\n      var ignore = false;\n      var persistentCount = state.snacks.reduce(function (acc, current) {\n        return acc + (current.open && current.persist ? 1 : 0);\n      }, 0);\n\n      if (persistentCount === _this.maxSnack) {\n         true ? warning('NO_PERSIST_ALL') : 0;\n        ignore = true;\n      }\n\n      var snacks = state.snacks.map(function (item) {\n        if (!popped && (!item.persist || ignore)) {\n          popped = true;\n\n          if (!item.entered) {\n            return _extends({}, item, {\n              requestClose: true\n            });\n          }\n\n          if (item.onClose) {\n            item.onClose(null, 'maxsnack', item.id);\n          }\n\n          if (_this.props.onClose) {\n            _this.props.onClose(null, 'maxsnack', item.id);\n          }\n\n          return _extends({}, item, {\n            open: false\n          });\n        }\n\n        return _extends({}, item);\n      });\n      return _extends({}, state, {\n        snacks: snacks\n      });\n    };\n    /**\r\n     * Set the entered state of the snackbar with the given key.\r\n     */\n\n\n    _this.handleEnteredSnack = function (node, isAppearing, key) {\n      if (!isDefined(key)) {\n        throw new Error('handleEnteredSnack Cannot be called with undefined key');\n      }\n\n      _this.setState(function (_ref) {\n        var snacks = _ref.snacks;\n        return {\n          snacks: snacks.map(function (item) {\n            return item.id === key ? _extends({}, item, {\n              entered: true\n            }) : _extends({}, item);\n          })\n        };\n      });\n    };\n    /**\r\n     * Hide a snackbar after its timeout.\r\n     */\n\n\n    _this.handleCloseSnack = function (event, reason, key) {\n      // should not use createChainedFunction for onClose.\n      // because this.closeSnackbar called this function\n      if (_this.props.onClose) {\n        _this.props.onClose(event, reason, key);\n      }\n\n      var shouldCloseAll = key === undefined;\n\n      _this.setState(function (_ref2) {\n        var snacks = _ref2.snacks,\n            queue = _ref2.queue;\n        return {\n          snacks: snacks.map(function (item) {\n            if (!shouldCloseAll && item.id !== key) {\n              return _extends({}, item);\n            }\n\n            return item.entered ? _extends({}, item, {\n              open: false\n            }) : _extends({}, item, {\n              requestClose: true\n            });\n          }),\n          queue: queue.filter(function (item) {\n            return item.id !== key;\n          })\n        };\n      });\n    };\n    /**\r\n     * Close snackbar with the given key\r\n     */\n\n\n    _this.closeSnackbar = function (key) {\n      // call individual snackbar onClose callback passed through options parameter\n      var toBeClosed = _this.state.snacks.find(function (item) {\n        return item.id === key;\n      });\n\n      if (isDefined(key) && toBeClosed && toBeClosed.onClose) {\n        toBeClosed.onClose(null, 'instructed', key);\n      }\n\n      _this.handleCloseSnack(null, 'instructed', key);\n    };\n    /**\r\n     * When we set open attribute of a snackbar to false (i.e. after we hide a snackbar),\r\n     * it leaves the screen and immediately after leaving animation is done, this method\r\n     * gets called. We remove the hidden snackbar from state and then display notifications\r\n     * waiting in the queue (if any). If after this process the queue is not empty, the\r\n     * oldest message is dismissed.\r\n     */\n\n\n    _this.handleExitedSnack = function (node, key) {\n      if (!isDefined(key)) {\n        throw new Error('handleExitedSnack Cannot be called with undefined key');\n      }\n\n      _this.setState(function (state) {\n        var newState = _this.processQueue(_extends({}, state, {\n          snacks: state.snacks.filter(function (item) {\n            return item.id !== key;\n          })\n        }));\n\n        if (newState.queue.length === 0) {\n          return newState;\n        }\n\n        return _this.handleDismissOldest(newState);\n      });\n    };\n\n    enqueueSnackbar = _this.enqueueSnackbar;\n    closeSnackbar = _this.closeSnackbar;\n    _this.state = {\n      snacks: [],\n      queue: [],\n      contextValue: {\n        enqueueSnackbar: _this.enqueueSnackbar.bind(_assertThisInitialized(_this)),\n        closeSnackbar: _this.closeSnackbar.bind(_assertThisInitialized(_this))\n      }\n    };\n    return _this;\n  }\n\n  var _proto = SnackbarProvider.prototype;\n\n  _proto.render = function render() {\n    var _this2 = this;\n\n    var contextValue = this.state.contextValue;\n    var _this$props = this.props,\n        domRoot = _this$props.domRoot,\n        children = _this$props.children,\n        _this$props$dense = _this$props.dense,\n        dense = _this$props$dense === void 0 ? false : _this$props$dense,\n        _this$props$Component = _this$props.Components,\n        Components = _this$props$Component === void 0 ? {} : _this$props$Component,\n        classes = _this$props.classes;\n    var categ = this.state.snacks.reduce(function (acc, current) {\n      var _extends2;\n\n      var category = originKeyExtractor(current.anchorOrigin);\n      var existingOfCategory = acc[category] || [];\n      return _extends({}, acc, (_extends2 = {}, _extends2[category] = [].concat(existingOfCategory, [current]), _extends2));\n    }, {});\n    var snackbars = Object.keys(categ).map(function (origin) {\n      var snacks = categ[origin];\n      var nomineeSnack = snacks[0];\n      return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(SnackbarContainer$1, {\n        key: origin,\n        dense: dense,\n        anchorOrigin: nomineeSnack.anchorOrigin,\n        classes: classes\n      }, snacks.map(function (snack) {\n        return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(SnackbarItem, {\n          key: snack.id,\n          snack: snack,\n          classes: classes,\n          Component: Components[snack.variant],\n          onClose: _this2.handleCloseSnack,\n          onEnter: _this2.props.onEnter,\n          onExit: _this2.props.onExit,\n          onExited: createChainedFunction([_this2.handleExitedSnack, _this2.props.onExited], snack.id),\n          onEntered: createChainedFunction([_this2.handleEnteredSnack, _this2.props.onEntered], snack.id)\n        });\n      }));\n    });\n    return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(SnackbarContext.Provider, {\n      value: contextValue\n    }, children, domRoot ? (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal)(snackbars, domRoot) : snackbars);\n  };\n\n  _createClass(SnackbarProvider, [{\n    key: \"maxSnack\",\n    get: function get() {\n      return this.props.maxSnack || defaults.maxSnack;\n    }\n  }]);\n\n  return SnackbarProvider;\n}(react__WEBPACK_IMPORTED_MODULE_0__.Component);\n\nvar useSnackbar = (function () {\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SnackbarContext);\n});\n\n\n//# sourceMappingURL=notistack.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL25vdGlzdGFjay9ub3Rpc3RhY2suZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBaU07QUFDeEo7QUFDakI7QUFDSzs7QUFFN0I7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyx1QkFBdUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBbUMsMERBQTRCO0FBQy9EO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsdUNBQXVDOztBQUV2QztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUMsQ0FBQyx3REFBd0I7O0FBRTFCLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPLElBQUk7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsOENBQU87QUFDaEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHdFQUF3RSxhQUFhO0FBQ3JGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7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QTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QixzQkFBc0I7QUFDOUMsS0FBSyxJQUFJO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYSwwREFBNEI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsZUFBZSwwREFBNEI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLO0FBQ0wsV0FBVywwREFBNEI7QUFDdkM7QUFDQSxLQUFLLHNCQUFzQix1REFBWTtBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUMsQ0FBQyw0Q0FBUzs7QUFFWDtBQUNBLFNBQVMsaURBQVU7QUFDbkIsQ0FBQzs7QUFFdUo7QUFDeEoiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sZWRnaXR5LXlpZWxkLWZyb250ZW5kLy4uL25vZGVfbW9kdWxlcy9ub3Rpc3RhY2svbm90aXN0YWNrLmVzbS5qcz82ZmY1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdF9fZGVmYXVsdCwgeyB1c2VNZW1vLCBmb3J3YXJkUmVmLCB1c2VSZWYsIHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QsIGNyZWF0ZUVsZW1lbnQsIGNsb25lRWxlbWVudCwgdXNlTGF5b3V0RWZmZWN0LCBtZW1vLCB1c2VTdGF0ZSwgQ29tcG9uZW50LCBpc1ZhbGlkRWxlbWVudCwgdXNlQ29udGV4dCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGNyZWF0ZVBvcnRhbCB9IGZyb20gJ3JlYWN0LWRvbSc7XG5pbXBvcnQgY2xzeCBmcm9tICdjbHN4JztcbmltcG9ydCB7IGNzcyB9IGZyb20gJ2dvb2Jlcic7XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cblxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfTtcblxuICByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7XG4gIHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzO1xuICBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzO1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuICB2YXIgdGFyZ2V0ID0ge307XG4gIHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgdmFyIGtleSwgaTtcblxuICBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGtleSA9IHNvdXJjZUtleXNbaV07XG4gICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cblxuICByZXR1cm4gc2VsZjtcbn1cblxudmFyIG5vT3AgPSBmdW5jdGlvbiBub09wKCkge1xuICByZXR1cm4gJyc7XG59O1xuXG52YXIgU25hY2tiYXJDb250ZXh0ID0gLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0LmNyZWF0ZUNvbnRleHQoe1xuICBlbnF1ZXVlU25hY2tiYXI6IG5vT3AsXG4gIGNsb3NlU25hY2tiYXI6IG5vT3Bcbn0pO1xuXG52YXIgYnJlYWtwb2ludHMgPSB7XG4gIGRvd25YczogJ0BtZWRpYSAobWF4LXdpZHRoOjU5OS45NXB4KScsXG4gIHVwU206ICdAbWVkaWEgKG1pbi13aWR0aDo2MDBweCknXG59O1xuXG52YXIgY2FwaXRhbGlzZSA9IGZ1bmN0aW9uIGNhcGl0YWxpc2UodGV4dCkge1xuICByZXR1cm4gdGV4dC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHRleHQuc2xpY2UoMSk7XG59O1xuXG52YXIgb3JpZ2luS2V5RXh0cmFjdG9yID0gZnVuY3Rpb24gb3JpZ2luS2V5RXh0cmFjdG9yKGFuY2hvcikge1xuICByZXR1cm4gXCJcIiArIGNhcGl0YWxpc2UoYW5jaG9yLnZlcnRpY2FsKSArIGNhcGl0YWxpc2UoYW5jaG9yLmhvcml6b250YWwpO1xufTtcbnZhciBpc0RlZmluZWQgPSBmdW5jdGlvbiBpc0RlZmluZWQodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWUgfHwgdmFsdWUgPT09IDA7XG59O1xuXG52YXIgVU5NT1VOVEVEID0gJ3VubW91bnRlZCc7XG52YXIgRVhJVEVEID0gJ2V4aXRlZCc7XG52YXIgRU5URVJJTkcgPSAnZW50ZXJpbmcnO1xudmFyIEVOVEVSRUQgPSAnZW50ZXJlZCc7XG52YXIgRVhJVElORyA9ICdleGl0aW5nJztcblxudmFyIFRyYW5zaXRpb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzTG9vc2UoVHJhbnNpdGlvbiwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gVHJhbnNpdGlvbihwcm9wcykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX1JlYWN0JENvbXBvbmVudC5jYWxsKHRoaXMsIHByb3BzKSB8fCB0aGlzO1xuICAgIHZhciBhcHBlYXIgPSBwcm9wcy5hcHBlYXI7XG4gICAgdmFyIGluaXRpYWxTdGF0dXM7XG4gICAgX3RoaXMuYXBwZWFyU3RhdHVzID0gbnVsbDtcblxuICAgIGlmIChwcm9wc1tcImluXCJdKSB7XG4gICAgICBpZiAoYXBwZWFyKSB7XG4gICAgICAgIGluaXRpYWxTdGF0dXMgPSBFWElURUQ7XG4gICAgICAgIF90aGlzLmFwcGVhclN0YXR1cyA9IEVOVEVSSU5HO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5pdGlhbFN0YXR1cyA9IEVOVEVSRUQ7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcm9wcy51bm1vdW50T25FeGl0IHx8IHByb3BzLm1vdW50T25FbnRlcikge1xuICAgICAgaW5pdGlhbFN0YXR1cyA9IFVOTU9VTlRFRDtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5pdGlhbFN0YXR1cyA9IEVYSVRFRDtcbiAgICB9XG5cbiAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgIHN0YXR1czogaW5pdGlhbFN0YXR1c1xuICAgIH07XG4gICAgX3RoaXMubmV4dENhbGxiYWNrID0gbnVsbDtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBUcmFuc2l0aW9uLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9IGZ1bmN0aW9uIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhfcmVmLCBwcmV2U3RhdGUpIHtcbiAgICB2YXIgbmV4dEluID0gX3JlZltcImluXCJdO1xuXG4gICAgaWYgKG5leHRJbiAmJiBwcmV2U3RhdGUuc3RhdHVzID09PSBVTk1PVU5URUQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0YXR1czogRVhJVEVEXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIHZhciBfcHJvdG8gPSBUcmFuc2l0aW9uLnByb3RvdHlwZTtcblxuICBfcHJvdG8uY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICB0aGlzLnVwZGF0ZVN0YXR1cyh0cnVlLCB0aGlzLmFwcGVhclN0YXR1cyk7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgICB2YXIgbmV4dFN0YXR1cyA9IG51bGw7XG5cbiAgICBpZiAocHJldlByb3BzICE9PSB0aGlzLnByb3BzKSB7XG4gICAgICB2YXIgc3RhdHVzID0gdGhpcy5zdGF0ZS5zdGF0dXM7XG5cbiAgICAgIGlmICh0aGlzLnByb3BzW1wiaW5cIl0pIHtcbiAgICAgICAgaWYgKHN0YXR1cyAhPT0gRU5URVJJTkcgJiYgc3RhdHVzICE9PSBFTlRFUkVEKSB7XG4gICAgICAgICAgbmV4dFN0YXR1cyA9IEVOVEVSSU5HO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHN0YXR1cyA9PT0gRU5URVJJTkcgfHwgc3RhdHVzID09PSBFTlRFUkVEKSB7XG4gICAgICAgIG5leHRTdGF0dXMgPSBFWElUSU5HO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMudXBkYXRlU3RhdHVzKGZhbHNlLCBuZXh0U3RhdHVzKTtcbiAgfTtcblxuICBfcHJvdG8uY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICB0aGlzLmNhbmNlbE5leHRDYWxsYmFjaygpO1xuICB9O1xuXG4gIF9wcm90by5nZXRUaW1lb3V0cyA9IGZ1bmN0aW9uIGdldFRpbWVvdXRzKCkge1xuICAgIHZhciB0aW1lb3V0ID0gdGhpcy5wcm9wcy50aW1lb3V0O1xuICAgIHZhciBlbnRlciA9IHRpbWVvdXQ7XG4gICAgdmFyIGV4aXQgPSB0aW1lb3V0O1xuXG4gICAgaWYgKHRpbWVvdXQgIT0gbnVsbCAmJiB0eXBlb2YgdGltZW91dCAhPT0gJ251bWJlcicgJiYgdHlwZW9mIHRpbWVvdXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICBleGl0ID0gdGltZW91dC5leGl0O1xuICAgICAgZW50ZXIgPSB0aW1lb3V0LmVudGVyO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBleGl0OiBleGl0LFxuICAgICAgZW50ZXI6IGVudGVyXG4gICAgfTtcbiAgfTtcblxuICBfcHJvdG8udXBkYXRlU3RhdHVzID0gZnVuY3Rpb24gdXBkYXRlU3RhdHVzKG1vdW50aW5nLCBuZXh0U3RhdHVzKSB7XG4gICAgaWYgKG1vdW50aW5nID09PSB2b2lkIDApIHtcbiAgICAgIG1vdW50aW5nID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKG5leHRTdGF0dXMgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuY2FuY2VsTmV4dENhbGxiYWNrKCk7XG5cbiAgICAgIGlmIChuZXh0U3RhdHVzID09PSBFTlRFUklORykge1xuICAgICAgICB0aGlzLnBlcmZvcm1FbnRlcihtb3VudGluZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnBlcmZvcm1FeGl0KCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLnByb3BzLnVubW91bnRPbkV4aXQgJiYgdGhpcy5zdGF0ZS5zdGF0dXMgPT09IEVYSVRFRCkge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIHN0YXR1czogVU5NT1VOVEVEXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnBlcmZvcm1FbnRlciA9IGZ1bmN0aW9uIHBlcmZvcm1FbnRlcihtb3VudGluZykge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgdmFyIGVudGVyID0gdGhpcy5wcm9wcy5lbnRlcjtcbiAgICB2YXIgaXNBcHBlYXJpbmcgPSBtb3VudGluZztcbiAgICB2YXIgdGltZW91dHMgPSB0aGlzLmdldFRpbWVvdXRzKCk7XG5cbiAgICBpZiAoIW1vdW50aW5nICYmICFlbnRlcikge1xuICAgICAgdGhpcy5zYWZlU2V0U3RhdGUoe1xuICAgICAgICBzdGF0dXM6IEVOVEVSRURcbiAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKF90aGlzMi5wcm9wcy5vbkVudGVyZWQpIHtcbiAgICAgICAgICBfdGhpczIucHJvcHMub25FbnRlcmVkKF90aGlzMi5ub2RlLCBpc0FwcGVhcmluZyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnByb3BzLm9uRW50ZXIpIHtcbiAgICAgIHRoaXMucHJvcHMub25FbnRlcih0aGlzLm5vZGUsIGlzQXBwZWFyaW5nKTtcbiAgICB9XG5cbiAgICB0aGlzLnNhZmVTZXRTdGF0ZSh7XG4gICAgICBzdGF0dXM6IEVOVEVSSU5HXG4gICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKF90aGlzMi5wcm9wcy5vbkVudGVyaW5nKSB7XG4gICAgICAgIF90aGlzMi5wcm9wcy5vbkVudGVyaW5nKF90aGlzMi5ub2RlLCBpc0FwcGVhcmluZyk7XG4gICAgICB9XG5cbiAgICAgIF90aGlzMi5vblRyYW5zaXRpb25FbmQodGltZW91dHMuZW50ZXIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMyLnNhZmVTZXRTdGF0ZSh7XG4gICAgICAgICAgc3RhdHVzOiBFTlRFUkVEXG4gICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoX3RoaXMyLnByb3BzLm9uRW50ZXJlZCkge1xuICAgICAgICAgICAgX3RoaXMyLnByb3BzLm9uRW50ZXJlZChfdGhpczIubm9kZSwgaXNBcHBlYXJpbmcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8ucGVyZm9ybUV4aXQgPSBmdW5jdGlvbiBwZXJmb3JtRXhpdCgpIHtcbiAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgIHZhciBleGl0ID0gdGhpcy5wcm9wcy5leGl0O1xuICAgIHZhciB0aW1lb3V0cyA9IHRoaXMuZ2V0VGltZW91dHMoKTsgLy8gbm8gZXhpdCBhbmltYXRpb24gc2tpcCByaWdodCB0byBFWElURURcblxuICAgIGlmICghZXhpdCkge1xuICAgICAgdGhpcy5zYWZlU2V0U3RhdGUoe1xuICAgICAgICBzdGF0dXM6IEVYSVRFRFxuICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoX3RoaXMzLnByb3BzLm9uRXhpdGVkKSB7XG4gICAgICAgICAgX3RoaXMzLnByb3BzLm9uRXhpdGVkKF90aGlzMy5ub2RlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucHJvcHMub25FeGl0KSB7XG4gICAgICB0aGlzLnByb3BzLm9uRXhpdCh0aGlzLm5vZGUpO1xuICAgIH1cblxuICAgIHRoaXMuc2FmZVNldFN0YXRlKHtcbiAgICAgIHN0YXR1czogRVhJVElOR1xuICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChfdGhpczMucHJvcHMub25FeGl0aW5nKSB7XG4gICAgICAgIF90aGlzMy5wcm9wcy5vbkV4aXRpbmcoX3RoaXMzLm5vZGUpO1xuICAgICAgfVxuXG4gICAgICBfdGhpczMub25UcmFuc2l0aW9uRW5kKHRpbWVvdXRzLmV4aXQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMzLnNhZmVTZXRTdGF0ZSh7XG4gICAgICAgICAgc3RhdHVzOiBFWElURURcbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChfdGhpczMucHJvcHMub25FeGl0ZWQpIHtcbiAgICAgICAgICAgIF90aGlzMy5wcm9wcy5vbkV4aXRlZChfdGhpczMubm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5jYW5jZWxOZXh0Q2FsbGJhY2sgPSBmdW5jdGlvbiBjYW5jZWxOZXh0Q2FsbGJhY2soKSB7XG4gICAgaWYgKHRoaXMubmV4dENhbGxiYWNrICE9PSBudWxsICYmIHRoaXMubmV4dENhbGxiYWNrLmNhbmNlbCkge1xuICAgICAgdGhpcy5uZXh0Q2FsbGJhY2suY2FuY2VsKCk7XG4gICAgICB0aGlzLm5leHRDYWxsYmFjayA9IG51bGw7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5zYWZlU2V0U3RhdGUgPSBmdW5jdGlvbiBzYWZlU2V0U3RhdGUobmV4dFN0YXRlLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gdGhpcy5zZXROZXh0Q2FsbGJhY2soY2FsbGJhY2spO1xuICAgIHRoaXMuc2V0U3RhdGUobmV4dFN0YXRlLCBjYWxsYmFjayk7XG4gIH07XG5cbiAgX3Byb3RvLnNldE5leHRDYWxsYmFjayA9IGZ1bmN0aW9uIHNldE5leHRDYWxsYmFjayhjYWxsYmFjaykge1xuICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgdmFyIGFjdGl2ZSA9IHRydWU7XG5cbiAgICB0aGlzLm5leHRDYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChhY3RpdmUpIHtcbiAgICAgICAgYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIF90aGlzNC5uZXh0Q2FsbGJhY2sgPSBudWxsO1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLm5leHRDYWxsYmFjay5jYW5jZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBhY3RpdmUgPSBmYWxzZTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHRoaXMubmV4dENhbGxiYWNrO1xuICB9O1xuXG4gIF9wcm90by5vblRyYW5zaXRpb25FbmQgPSBmdW5jdGlvbiBvblRyYW5zaXRpb25FbmQodGltZW91dCwgaGFuZGxlcikge1xuICAgIHRoaXMuc2V0TmV4dENhbGxiYWNrKGhhbmRsZXIpO1xuICAgIHZhciBkb2VzTm90SGF2ZVRpbWVvdXRPckxpc3RlbmVyID0gdGltZW91dCA9PSBudWxsICYmICF0aGlzLnByb3BzLmFkZEVuZExpc3RlbmVyO1xuXG4gICAgaWYgKCF0aGlzLm5vZGUgfHwgZG9lc05vdEhhdmVUaW1lb3V0T3JMaXN0ZW5lcikge1xuICAgICAgc2V0VGltZW91dCh0aGlzLm5leHRDYWxsYmFjaywgMCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucHJvcHMuYWRkRW5kTGlzdGVuZXIpIHtcbiAgICAgIHRoaXMucHJvcHMuYWRkRW5kTGlzdGVuZXIodGhpcy5ub2RlLCB0aGlzLm5leHRDYWxsYmFjayk7XG4gICAgfVxuXG4gICAgaWYgKHRpbWVvdXQgIT0gbnVsbCkge1xuICAgICAgc2V0VGltZW91dCh0aGlzLm5leHRDYWxsYmFjaywgdGltZW91dCk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIHN0YXR1cyA9IHRoaXMuc3RhdGUuc3RhdHVzO1xuXG4gICAgaWYgKHN0YXR1cyA9PT0gVU5NT1VOVEVEKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgX3RoaXMkcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgICAgICBjaGlsZHJlbiA9IF90aGlzJHByb3BzLmNoaWxkcmVuLFxuICAgICAgICBjaGlsZFByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoX3RoaXMkcHJvcHMsIFtcImNoaWxkcmVuXCIsIFwiaW5cIiwgXCJtb3VudE9uRW50ZXJcIiwgXCJ1bm1vdW50T25FeGl0XCIsIFwiYXBwZWFyXCIsIFwiZW50ZXJcIiwgXCJleGl0XCIsIFwidGltZW91dFwiLCBcImFkZEVuZExpc3RlbmVyXCIsIFwib25FbnRlclwiLCBcIm9uRW50ZXJpbmdcIiwgXCJvbkVudGVyZWRcIiwgXCJvbkV4aXRcIiwgXCJvbkV4aXRpbmdcIiwgXCJvbkV4aXRlZFwiLCBcIm5vZGVSZWZcIl0pO1xuXG4gICAgcmV0dXJuIGNoaWxkcmVuKHN0YXR1cywgY2hpbGRQcm9wcyk7XG4gIH07XG5cbiAgX2NyZWF0ZUNsYXNzKFRyYW5zaXRpb24sIFt7XG4gICAga2V5OiBcIm5vZGVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wcyRub2RlUmVmO1xuXG4gICAgICB2YXIgbm9kZSA9IChfdGhpcyRwcm9wcyRub2RlUmVmID0gdGhpcy5wcm9wcy5ub2RlUmVmKSA9PT0gbnVsbCB8fCBfdGhpcyRwcm9wcyRub2RlUmVmID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRwcm9wcyRub2RlUmVmLmN1cnJlbnQ7XG5cbiAgICAgIGlmICghbm9kZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdGlzdGFjayAtIEN1c3RvbSBzbmFja2JhciBpcyBub3QgcmVmRm9yd2FyZGluZycpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVHJhbnNpdGlvbjtcbn0oUmVhY3RfX2RlZmF1bHQuQ29tcG9uZW50KTtcblxuZnVuY3Rpb24gbm9vcCgpIHsvL1xufVxuXG5UcmFuc2l0aW9uLmRlZmF1bHRQcm9wcyA9IHtcbiAgXCJpblwiOiBmYWxzZSxcbiAgbW91bnRPbkVudGVyOiBmYWxzZSxcbiAgdW5tb3VudE9uRXhpdDogZmFsc2UsXG4gIGFwcGVhcjogZmFsc2UsXG4gIGVudGVyOiB0cnVlLFxuICBleGl0OiB0cnVlLFxuICBvbkVudGVyOiBub29wLFxuICBvbkVudGVyaW5nOiBub29wLFxuICBvbkVudGVyZWQ6IG5vb3AsXG4gIG9uRXhpdDogbm9vcCxcbiAgb25FeGl0aW5nOiBub29wLFxuICBvbkV4aXRlZDogbm9vcFxufTtcblxuLyoqXHJcbiAqIENyZWRpdCB0byBNVUkgdGVhbSBAIGh0dHBzOi8vbXVpLmNvbVxyXG4gKi9cbi8qKlxyXG4gKiBwYXNzZXMge3ZhbHVlfSB0byB7cmVmfVxyXG4gKlxyXG4gKiBVc2VmdWwgaWYgeW91IHdhbnQgdG8gZXhwb3NlIHRoZSByZWYgb2YgYW4gaW5uZXIgY29tcG9uZW50IHRvIHRoZSBwdWJsaWMgQVBJXHJcbiAqIHdoaWxlIHN0aWxsIHVzaW5nIGl0IGluc2lkZSB0aGUgY29tcG9uZW50LlxyXG4gKiBAcGFyYW0gcmVmIEEgcmVmIGNhbGxiYWNrIG9yIHJlZiBvYmplY3QuIElmIGFueXRoaW5nIGZhbHN5LCB0aGlzIGlzIGEgbm8tb3AuXHJcbiAqL1xuXG5mdW5jdGlvbiBzZXRSZWYocmVmLCB2YWx1ZSkge1xuICBpZiAodHlwZW9mIHJlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJlZih2YWx1ZSk7XG4gIH0gZWxzZSBpZiAocmVmKSB7XG4gICAgcmVmLmN1cnJlbnQgPSB2YWx1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1c2VGb3JrUmVmKHJlZkEsIHJlZkIpIHtcbiAgLyoqXHJcbiAgICogVGhpcyB3aWxsIGNyZWF0ZSBhIG5ldyBmdW5jdGlvbiBpZiB0aGUgcmVmIHByb3BzIGNoYW5nZSBhbmQgYXJlIGRlZmluZWQuXHJcbiAgICogVGhpcyBtZWFucyByZWFjdCB3aWxsIGNhbGwgdGhlIG9sZCBmb3JrUmVmIHdpdGggYG51bGxgIGFuZCB0aGUgbmV3IGZvcmtSZWZcclxuICAgKiB3aXRoIHRoZSByZWYuIENsZWFudXAgbmF0dXJhbGx5IGVtZXJnZXMgZnJvbSB0aGlzIGJlaGF2aW9yLlxyXG4gICAqL1xuICByZXR1cm4gdXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHJlZkEgPT0gbnVsbCAmJiByZWZCID09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAocmVmVmFsdWUpIHtcbiAgICAgIHNldFJlZihyZWZBLCByZWZWYWx1ZSk7XG4gICAgICBzZXRSZWYocmVmQiwgcmVmVmFsdWUpO1xuICAgIH07XG4gIH0sIFtyZWZBLCByZWZCXSk7XG59XG5cbmZ1bmN0aW9uIGdldFRyYW5zaXRpb25Qcm9wcyhwcm9wcykge1xuICB2YXIgdGltZW91dCA9IHByb3BzLnRpbWVvdXQsXG4gICAgICBfcHJvcHMkc3R5bGUgPSBwcm9wcy5zdHlsZSxcbiAgICAgIHN0eWxlID0gX3Byb3BzJHN0eWxlID09PSB2b2lkIDAgPyB7fSA6IF9wcm9wcyRzdHlsZSxcbiAgICAgIG1vZGUgPSBwcm9wcy5tb2RlO1xuICByZXR1cm4ge1xuICAgIGR1cmF0aW9uOiB0eXBlb2YgdGltZW91dCA9PT0gJ29iamVjdCcgPyB0aW1lb3V0W21vZGVdIHx8IDAgOiB0aW1lb3V0LFxuICAgIGVhc2luZzogc3R5bGUudHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uLFxuICAgIGRlbGF5OiBzdHlsZS50cmFuc2l0aW9uRGVsYXlcbiAgfTtcbn1cblxuLyoqXHJcbiAqIENyZWRpdCB0byBNVUkgdGVhbSBAIGh0dHBzOi8vbXVpLmNvbVxyXG4gKi9cbnZhciBkZWZhdWx0RWFzaW5nID0ge1xuICAvLyBUaGlzIGlzIHRoZSBtb3N0IGNvbW1vbiBlYXNpbmcgY3VydmUuXG4gIGVhc2VJbk91dDogJ2N1YmljLWJlemllcigwLjQsIDAsIDAuMiwgMSknLFxuICAvLyBPYmplY3RzIGVudGVyIHRoZSBzY3JlZW4gYXQgZnVsbCB2ZWxvY2l0eSBmcm9tIG9mZi1zY3JlZW4gYW5kXG4gIC8vIHNsb3dseSBkZWNlbGVyYXRlIHRvIGEgcmVzdGluZyBwb2ludC5cbiAgZWFzZU91dDogJ2N1YmljLWJlemllcigwLjAsIDAsIDAuMiwgMSknLFxuICAvLyBPYmplY3RzIGxlYXZlIHRoZSBzY3JlZW4gYXQgZnVsbCB2ZWxvY2l0eS4gVGhleSBkbyBub3QgZGVjZWxlcmF0ZSB3aGVuIG9mZi1zY3JlZW4uXG4gIGVhc2VJbjogJ2N1YmljLWJlemllcigwLjQsIDAsIDEsIDEpJyxcbiAgLy8gVGhlIHNoYXJwIGN1cnZlIGlzIHVzZWQgYnkgb2JqZWN0cyB0aGF0IG1heSByZXR1cm4gdG8gdGhlIHNjcmVlbiBhdCBhbnkgdGltZS5cbiAgc2hhcnA6ICdjdWJpYy1iZXppZXIoMC40LCAwLCAwLjYsIDEpJ1xufTtcbi8qKlxyXG4gKiBDU1MgaGFjayB0byBmb3JjZSBhIHJlcGFpbnRcclxuICovXG5cbnZhciByZWZsb3cgPSBmdW5jdGlvbiByZWZsb3cobm9kZSkge1xuICAvLyBXZSBoYXZlIHRvIGRvIHNvbWV0aGluZyB3aXRoIG5vZGUuc2Nyb2xsVG9wLlxuICAvLyBPdGhlcndpc2UgaXQncyByZW1vdmVkIGZyb20gdGhlIGNvbXBpbGVkIGNvZGUgYnkgb3B0aW1pc2Vyc1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1hc3NpZ25cbiAgbm9kZS5zY3JvbGxUb3AgPSBub2RlLnNjcm9sbFRvcDtcbn07XG5cbnZhciBmb3JtYXRNcyA9IGZ1bmN0aW9uIGZvcm1hdE1zKG1pbGxpc2Vjb25kcykge1xuICByZXR1cm4gTWF0aC5yb3VuZChtaWxsaXNlY29uZHMpICsgXCJtc1wiO1xufTtcblxuZnVuY3Rpb24gY3JlYXRlVHJhbnNpdGlvbihwcm9wcywgb3B0aW9ucykge1xuICBpZiAocHJvcHMgPT09IHZvaWQgMCkge1xuICAgIHByb3BzID0gWydhbGwnXTtcbiAgfVxuXG4gIHZhciBfcmVmID0gb3B0aW9ucyB8fCB7fSxcbiAgICAgIF9yZWYkZHVyYXRpb24gPSBfcmVmLmR1cmF0aW9uLFxuICAgICAgZHVyYXRpb24gPSBfcmVmJGR1cmF0aW9uID09PSB2b2lkIDAgPyAzMDAgOiBfcmVmJGR1cmF0aW9uLFxuICAgICAgX3JlZiRlYXNpbmcgPSBfcmVmLmVhc2luZyxcbiAgICAgIGVhc2luZyA9IF9yZWYkZWFzaW5nID09PSB2b2lkIDAgPyBkZWZhdWx0RWFzaW5nLmVhc2VJbk91dCA6IF9yZWYkZWFzaW5nLFxuICAgICAgX3JlZiRkZWxheSA9IF9yZWYuZGVsYXksXG4gICAgICBkZWxheSA9IF9yZWYkZGVsYXkgPT09IHZvaWQgMCA/IDAgOiBfcmVmJGRlbGF5O1xuXG4gIHZhciBwcm9wZXJ0aWVzID0gQXJyYXkuaXNBcnJheShwcm9wcykgPyBwcm9wcyA6IFtwcm9wc107XG4gIHJldHVybiBwcm9wZXJ0aWVzLm1hcChmdW5jdGlvbiAoYW5pbWF0ZWRQcm9wKSB7XG4gICAgdmFyIGZvcm1hdHRlZER1cmF0aW9uID0gdHlwZW9mIGR1cmF0aW9uID09PSAnc3RyaW5nJyA/IGR1cmF0aW9uIDogZm9ybWF0TXMoZHVyYXRpb24pO1xuICAgIHZhciBmb3JtYXR0ZWREZWxheSA9IHR5cGVvZiBkZWxheSA9PT0gJ3N0cmluZycgPyBkZWxheSA6IGZvcm1hdE1zKGRlbGF5KTtcbiAgICByZXR1cm4gYW5pbWF0ZWRQcm9wICsgXCIgXCIgKyBmb3JtYXR0ZWREdXJhdGlvbiArIFwiIFwiICsgZWFzaW5nICsgXCIgXCIgKyBmb3JtYXR0ZWREZWxheTtcbiAgfSkuam9pbignLCcpO1xufVxuXG5mdW5jdGlvbiBvd25lckRvY3VtZW50KG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUgJiYgbm9kZS5vd25lckRvY3VtZW50IHx8IGRvY3VtZW50O1xufVxuXG5mdW5jdGlvbiBvd25lcldpbmRvdyhub2RlKSB7XG4gIHZhciBkb2MgPSBvd25lckRvY3VtZW50KG5vZGUpO1xuICByZXR1cm4gZG9jLmRlZmF1bHRWaWV3IHx8IHdpbmRvdztcbn1cbi8qKlxyXG4gKiBDb3JyZXNwb25kcyB0byAxMCBmcmFtZXMgYXQgNjAgSHouXHJcbiAqIEEgZmV3IGJ5dGVzIHBheWxvYWQgb3ZlcmhlYWQgd2hlbiBsb2Rhc2gvZGVib3VuY2UgaXMgfjMga0IgYW5kIGRlYm91bmNlIH4zMDAgQi5cclxuICovXG5cblxuZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgd2FpdCkge1xuICBpZiAod2FpdCA9PT0gdm9pZCAwKSB7XG4gICAgd2FpdCA9IDE2NjtcbiAgfVxuXG4gIHZhciB0aW1lb3V0O1xuXG4gIGZ1bmN0aW9uIGRlYm91bmNlZCgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHZhciBsYXRlciA9IGZ1bmN0aW9uIGxhdGVyKCkge1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgZnVuYy5hcHBseShfdGhpcywgYXJncyk7XG4gICAgfTtcblxuICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCk7XG4gIH1cblxuICBkZWJvdW5jZWQuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICB9O1xuXG4gIHJldHVybiBkZWJvdW5jZWQ7XG59XG4vKipcclxuICogVHJhbnNsYXRlIHRoZSBub2RlIHNvIGl0IGNhbid0IGJlIHNlZW4gb24gdGhlIHNjcmVlbi5cclxuICogTGF0ZXIsIHdlJ3JlIGdvaW5nIHRvIHRyYW5zbGF0ZSB0aGUgbm9kZSBiYWNrIHRvIGl0cyBvcmlnaW5hbCBsb2NhdGlvbiB3aXRoIGBub25lYC5cclxuICovXG5cblxuZnVuY3Rpb24gZ2V0VHJhbnNsYXRlVmFsdWUoZGlyZWN0aW9uLCBub2RlKSB7XG4gIHZhciByZWN0ID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgdmFyIGNvbnRhaW5lcldpbmRvdyA9IG93bmVyV2luZG93KG5vZGUpO1xuICB2YXIgdHJhbnNmb3JtO1xuXG4gIGlmIChub2RlLmZha2VUcmFuc2Zvcm0pIHtcbiAgICB0cmFuc2Zvcm0gPSBub2RlLmZha2VUcmFuc2Zvcm07XG4gIH0gZWxzZSB7XG4gICAgdmFyIGNvbXB1dGVkU3R5bGUgPSBjb250YWluZXJXaW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcbiAgICB0cmFuc2Zvcm0gPSBjb21wdXRlZFN0eWxlLmdldFByb3BlcnR5VmFsdWUoJy13ZWJraXQtdHJhbnNmb3JtJykgfHwgY29tcHV0ZWRTdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCd0cmFuc2Zvcm0nKTtcbiAgfVxuXG4gIHZhciBvZmZzZXRYID0gMDtcbiAgdmFyIG9mZnNldFkgPSAwO1xuXG4gIGlmICh0cmFuc2Zvcm0gJiYgdHJhbnNmb3JtICE9PSAnbm9uZScgJiYgdHlwZW9mIHRyYW5zZm9ybSA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgdHJhbnNmb3JtVmFsdWVzID0gdHJhbnNmb3JtLnNwbGl0KCcoJylbMV0uc3BsaXQoJyknKVswXS5zcGxpdCgnLCcpO1xuICAgIG9mZnNldFggPSBwYXJzZUludCh0cmFuc2Zvcm1WYWx1ZXNbNF0sIDEwKTtcbiAgICBvZmZzZXRZID0gcGFyc2VJbnQodHJhbnNmb3JtVmFsdWVzWzVdLCAxMCk7XG4gIH1cblxuICBzd2l0Y2ggKGRpcmVjdGlvbikge1xuICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgcmV0dXJuIFwidHJhbnNsYXRlWChcIiArIChjb250YWluZXJXaW5kb3cuaW5uZXJXaWR0aCArIG9mZnNldFggLSByZWN0LmxlZnQpICsgXCJweClcIjtcblxuICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgIHJldHVybiBcInRyYW5zbGF0ZVgoLVwiICsgKHJlY3QubGVmdCArIHJlY3Qud2lkdGggLSBvZmZzZXRYKSArIFwicHgpXCI7XG5cbiAgICBjYXNlICd1cCc6XG4gICAgICByZXR1cm4gXCJ0cmFuc2xhdGVZKFwiICsgKGNvbnRhaW5lcldpbmRvdy5pbm5lckhlaWdodCArIG9mZnNldFkgLSByZWN0LnRvcCkgKyBcInB4KVwiO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIGRvd25cbiAgICAgIHJldHVybiBcInRyYW5zbGF0ZVkoLVwiICsgKHJlY3QudG9wICsgcmVjdC5oZWlnaHQgLSBvZmZzZXRZKSArIFwicHgpXCI7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0VHJhbnNsYXRlVmFsdWUoZGlyZWN0aW9uLCBub2RlKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuO1xuICB2YXIgdHJhbnNmb3JtID0gZ2V0VHJhbnNsYXRlVmFsdWUoZGlyZWN0aW9uLCBub2RlKTtcblxuICBpZiAodHJhbnNmb3JtKSB7XG4gICAgbm9kZS5zdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG4gICAgbm9kZS5zdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG4gIH1cbn1cblxudmFyIFNsaWRlID0gLyojX19QVVJFX18qL2ZvcndhcmRSZWYoZnVuY3Rpb24gKHByb3BzLCByZWYpIHtcbiAgdmFyIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW4sXG4gICAgICBfcHJvcHMkZGlyZWN0aW9uID0gcHJvcHMuZGlyZWN0aW9uLFxuICAgICAgZGlyZWN0aW9uID0gX3Byb3BzJGRpcmVjdGlvbiA9PT0gdm9pZCAwID8gJ2Rvd24nIDogX3Byb3BzJGRpcmVjdGlvbixcbiAgICAgIGluUHJvcCA9IHByb3BzW1wiaW5cIl0sXG4gICAgICBzdHlsZSA9IHByb3BzLnN0eWxlLFxuICAgICAgX3Byb3BzJHRpbWVvdXQgPSBwcm9wcy50aW1lb3V0LFxuICAgICAgdGltZW91dCA9IF9wcm9wcyR0aW1lb3V0ID09PSB2b2lkIDAgPyAwIDogX3Byb3BzJHRpbWVvdXQsXG4gICAgICBvbkVudGVyID0gcHJvcHMub25FbnRlcixcbiAgICAgIG9uRW50ZXJlZCA9IHByb3BzLm9uRW50ZXJlZCxcbiAgICAgIG9uRXhpdCA9IHByb3BzLm9uRXhpdCxcbiAgICAgIG9uRXhpdGVkID0gcHJvcHMub25FeGl0ZWQsXG4gICAgICBvdGhlciA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHByb3BzLCBbXCJjaGlsZHJlblwiLCBcImRpcmVjdGlvblwiLCBcImluXCIsIFwic3R5bGVcIiwgXCJ0aW1lb3V0XCIsIFwib25FbnRlclwiLCBcIm9uRW50ZXJlZFwiLCBcIm9uRXhpdFwiLCBcIm9uRXhpdGVkXCJdKTtcblxuICB2YXIgbm9kZVJlZiA9IHVzZVJlZihudWxsKTtcbiAgdmFyIGhhbmRsZVJlZkludGVybWVkaWFyeSA9IHVzZUZvcmtSZWYoY2hpbGRyZW4ucmVmLCBub2RlUmVmKTtcbiAgdmFyIGhhbmRsZVJlZiA9IHVzZUZvcmtSZWYoaGFuZGxlUmVmSW50ZXJtZWRpYXJ5LCByZWYpO1xuXG4gIHZhciBoYW5kbGVFbnRlciA9IGZ1bmN0aW9uIGhhbmRsZUVudGVyKG5vZGUsIGlzQXBwZWFyaW5nKSB7XG4gICAgc2V0VHJhbnNsYXRlVmFsdWUoZGlyZWN0aW9uLCBub2RlKTtcbiAgICByZWZsb3cobm9kZSk7XG5cbiAgICBpZiAob25FbnRlcikge1xuICAgICAgb25FbnRlcihub2RlLCBpc0FwcGVhcmluZyk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBoYW5kbGVFbnRlcmluZyA9IGZ1bmN0aW9uIGhhbmRsZUVudGVyaW5nKG5vZGUpIHtcbiAgICB2YXIgZWFzaW5nID0gKHN0eWxlID09PSBudWxsIHx8IHN0eWxlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzdHlsZS50cmFuc2l0aW9uVGltaW5nRnVuY3Rpb24pIHx8IGRlZmF1bHRFYXNpbmcuZWFzZU91dDtcbiAgICB2YXIgdHJhbnNpdGlvblByb3BzID0gZ2V0VHJhbnNpdGlvblByb3BzKHtcbiAgICAgIHRpbWVvdXQ6IHRpbWVvdXQsXG4gICAgICBtb2RlOiAnZW50ZXInLFxuICAgICAgc3R5bGU6IF9leHRlbmRzKHt9LCBzdHlsZSwge1xuICAgICAgICB0cmFuc2l0aW9uVGltaW5nRnVuY3Rpb246IGVhc2luZ1xuICAgICAgfSlcbiAgICB9KTtcbiAgICBub2RlLnN0eWxlLndlYmtpdFRyYW5zaXRpb24gPSBjcmVhdGVUcmFuc2l0aW9uKCctd2Via2l0LXRyYW5zZm9ybScsIHRyYW5zaXRpb25Qcm9wcyk7XG4gICAgbm9kZS5zdHlsZS50cmFuc2l0aW9uID0gY3JlYXRlVHJhbnNpdGlvbigndHJhbnNmb3JtJywgdHJhbnNpdGlvblByb3BzKTtcbiAgICBub2RlLnN0eWxlLndlYmtpdFRyYW5zZm9ybSA9ICdub25lJztcbiAgICBub2RlLnN0eWxlLnRyYW5zZm9ybSA9ICdub25lJztcbiAgfTtcblxuICB2YXIgaGFuZGxlRXhpdCA9IGZ1bmN0aW9uIGhhbmRsZUV4aXQobm9kZSkge1xuICAgIHZhciBlYXNpbmcgPSAoc3R5bGUgPT09IG51bGwgfHwgc3R5bGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN0eWxlLnRyYW5zaXRpb25UaW1pbmdGdW5jdGlvbikgfHwgZGVmYXVsdEVhc2luZy5zaGFycDtcbiAgICB2YXIgdHJhbnNpdGlvblByb3BzID0gZ2V0VHJhbnNpdGlvblByb3BzKHtcbiAgICAgIHRpbWVvdXQ6IHRpbWVvdXQsXG4gICAgICBtb2RlOiAnZXhpdCcsXG4gICAgICBzdHlsZTogX2V4dGVuZHMoe30sIHN0eWxlLCB7XG4gICAgICAgIHRyYW5zaXRpb25UaW1pbmdGdW5jdGlvbjogZWFzaW5nXG4gICAgICB9KVxuICAgIH0pO1xuICAgIG5vZGUuc3R5bGUud2Via2l0VHJhbnNpdGlvbiA9IGNyZWF0ZVRyYW5zaXRpb24oJy13ZWJraXQtdHJhbnNmb3JtJywgdHJhbnNpdGlvblByb3BzKTtcbiAgICBub2RlLnN0eWxlLnRyYW5zaXRpb24gPSBjcmVhdGVUcmFuc2l0aW9uKCd0cmFuc2Zvcm0nLCB0cmFuc2l0aW9uUHJvcHMpO1xuICAgIHNldFRyYW5zbGF0ZVZhbHVlKGRpcmVjdGlvbiwgbm9kZSk7XG5cbiAgICBpZiAob25FeGl0KSB7XG4gICAgICBvbkV4aXQobm9kZSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBoYW5kbGVFeGl0ZWQgPSBmdW5jdGlvbiBoYW5kbGVFeGl0ZWQobm9kZSkge1xuICAgIC8vIE5vIG5lZWQgZm9yIHRyYW5zaXRpb25zIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBoaWRkZW5cbiAgICBub2RlLnN0eWxlLndlYmtpdFRyYW5zaXRpb24gPSAnJztcbiAgICBub2RlLnN0eWxlLnRyYW5zaXRpb24gPSAnJztcblxuICAgIGlmIChvbkV4aXRlZCkge1xuICAgICAgb25FeGl0ZWQobm9kZSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciB1cGRhdGVQb3NpdGlvbiA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAobm9kZVJlZi5jdXJyZW50KSB7XG4gICAgICBzZXRUcmFuc2xhdGVWYWx1ZShkaXJlY3Rpb24sIG5vZGVSZWYuY3VycmVudCk7XG4gICAgfVxuICB9LCBbZGlyZWN0aW9uXSk7XG4gIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgLy8gU2tpcCBjb25maWd1cmF0aW9uIHdoZXJlIHRoZSBwb3NpdGlvbiBpcyBzY3JlZW4gc2l6ZSBpbnZhcmlhbnQuXG4gICAgaWYgKGluUHJvcCB8fCBkaXJlY3Rpb24gPT09ICdkb3duJyB8fCBkaXJlY3Rpb24gPT09ICdyaWdodCcpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgdmFyIGhhbmRsZVJlc2l6ZSA9IGRlYm91bmNlKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChub2RlUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgc2V0VHJhbnNsYXRlVmFsdWUoZGlyZWN0aW9uLCBub2RlUmVmLmN1cnJlbnQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHZhciBjb250YWluZXJXaW5kb3cgPSBvd25lcldpbmRvdyhub2RlUmVmLmN1cnJlbnQpO1xuICAgIGNvbnRhaW5lcldpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVSZXNpemUpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBoYW5kbGVSZXNpemUuY2xlYXIoKTtcbiAgICAgIGNvbnRhaW5lcldpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVSZXNpemUpO1xuICAgIH07XG4gIH0sIFtkaXJlY3Rpb24sIGluUHJvcF0pO1xuICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGlmICghaW5Qcm9wKSB7XG4gICAgICAvLyBXZSBuZWVkIHRvIHVwZGF0ZSB0aGUgcG9zaXRpb24gb2YgdGhlIGRyYXdlciB3aGVuIHRoZSBkaXJlY3Rpb24gY2hhbmdlIGFuZFxuICAgICAgLy8gd2hlbiBpdCdzIGhpZGRlbi5cbiAgICAgIHVwZGF0ZVBvc2l0aW9uKCk7XG4gICAgfVxuICB9LCBbaW5Qcm9wLCB1cGRhdGVQb3NpdGlvbl0pO1xuICByZXR1cm4gY3JlYXRlRWxlbWVudChUcmFuc2l0aW9uLCBPYmplY3QuYXNzaWduKHtcbiAgICBhcHBlYXI6IHRydWUsXG4gICAgbm9kZVJlZjogbm9kZVJlZixcbiAgICBvbkVudGVyOiBoYW5kbGVFbnRlcixcbiAgICBvbkVudGVyZWQ6IG9uRW50ZXJlZCxcbiAgICBvbkVudGVyaW5nOiBoYW5kbGVFbnRlcmluZyxcbiAgICBvbkV4aXQ6IGhhbmRsZUV4aXQsXG4gICAgb25FeGl0ZWQ6IGhhbmRsZUV4aXRlZCxcbiAgICBcImluXCI6IGluUHJvcCxcbiAgICB0aW1lb3V0OiB0aW1lb3V0XG4gIH0sIG90aGVyKSwgZnVuY3Rpb24gKHN0YXRlLCBjaGlsZFByb3BzKSB7XG4gICAgcmV0dXJuIGNsb25lRWxlbWVudChjaGlsZHJlbiwgX2V4dGVuZHMoe1xuICAgICAgcmVmOiBoYW5kbGVSZWYsXG4gICAgICBzdHlsZTogX2V4dGVuZHMoe1xuICAgICAgICB2aXNpYmlsaXR5OiBzdGF0ZSA9PT0gJ2V4aXRlZCcgJiYgIWluUHJvcCA/ICdoaWRkZW4nIDogdW5kZWZpbmVkXG4gICAgICB9LCBzdHlsZSwge30sIGNoaWxkcmVuLnByb3BzLnN0eWxlKVxuICAgIH0sIGNoaWxkUHJvcHMpKTtcbiAgfSk7XG59KTtcblNsaWRlLmRpc3BsYXlOYW1lID0gJ1NsaWRlJztcblxudmFyIFN2Z0ljb24gPSBmdW5jdGlvbiBTdmdJY29uKHByb3BzKSB7XG4gIHJldHVybiBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwic3ZnXCIsIE9iamVjdC5hc3NpZ24oe1xuICAgIHZpZXdCb3g6IFwiMCAwIDI0IDI0XCIsXG4gICAgZm9jdXNhYmxlOiBcImZhbHNlXCIsXG4gICAgc3R5bGU6IHtcbiAgICAgIGZvbnRTaXplOiAyMCxcbiAgICAgIG1hcmdpbklubGluZUVuZDogOCxcbiAgICAgIHVzZXJTZWxlY3Q6ICdub25lJyxcbiAgICAgIHdpZHRoOiAnMWVtJyxcbiAgICAgIGhlaWdodDogJzFlbScsXG4gICAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcbiAgICAgIGZpbGw6ICdjdXJyZW50Q29sb3InLFxuICAgICAgZmxleFNocmluazogMFxuICAgIH1cbiAgfSwgcHJvcHMpKTtcbn07XG5cbnZhciBDaGVja0ljb24gPSBmdW5jdGlvbiBDaGVja0ljb24oKSB7XG4gIHJldHVybiBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFN2Z0ljb24sIG51bGwsIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHtcbiAgICBkOiBcIk0xMiAyQzYuNSAyIDIgNi41IDIgMTJTNi41IDIyIDEyIDIyIDIyIDE3LjUgMjIgMTIgMTcuNSAyIDEyIDJNMTAgMTdMNSAxMkw2LjQxXFxuICAgICAgICAxMC41OUwxMCAxNC4xN0wxNy41OSA2LjU4TDE5IDhMMTAgMTdaXCJcbiAgfSkpO1xufTtcblxudmFyIFdhcm5pbmdJY29uID0gZnVuY3Rpb24gV2FybmluZ0ljb24oKSB7XG4gIHJldHVybiBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFN2Z0ljb24sIG51bGwsIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHtcbiAgICBkOiBcIk0xMywxNEgxMVYxMEgxM00xMywxOEgxMVYxNkgxM00xLDIxSDIzTDEyLDJMMSwyMVpcIlxuICB9KSk7XG59O1xuXG52YXIgRXJyb3JJY29uID0gZnVuY3Rpb24gRXJyb3JJY29uKCkge1xuICByZXR1cm4gUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChTdmdJY29uLCBudWxsLCBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7XG4gICAgZDogXCJNMTIsMkMxNy41MywyIDIyLDYuNDcgMjIsMTJDMjIsMTcuNTMgMTcuNTMsMjIgMTIsMjJDNi40NywyMiAyLDE3LjUzIDIsMTJDMixcXG4gICAgICAgIDYuNDcgNi40NywyIDEyLDJNMTUuNTksN0wxMiwxMC41OUw4LjQxLDdMNyw4LjQxTDEwLjU5LDEyTDcsMTUuNTlMOC40MSwxN0wxMixcXG4gICAgICAgIDEzLjQxTDE1LjU5LDE3TDE3LDE1LjU5TDEzLjQxLDEyTDE3LDguNDFMMTUuNTksN1pcIlxuICB9KSk7XG59O1xuXG52YXIgSW5mb0ljb24gPSBmdW5jdGlvbiBJbmZvSWNvbigpIHtcbiAgcmV0dXJuIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoU3ZnSWNvbiwgbnVsbCwgUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcInBhdGhcIiwge1xuICAgIGQ6IFwiTTEzLDlIMTFWN0gxM00xMywxN0gxMVYxMUgxM00xMiwyQTEwLDEwIDAgMCwwIDIsMTJBMTAsMTAgMCAwLDAgMTIsMjJBMTAsMTAgMCAwLFxcbiAgICAgICAgMCAyMiwxMkExMCwxMCAwIDAsMCAxMiwyWlwiXG4gIH0pKTtcbn07XG5cbnZhciBkZWZhdWx0SWNvblZhcmlhbnRzID0ge1xuICBcImRlZmF1bHRcIjogdW5kZWZpbmVkLFxuICBzdWNjZXNzOiAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChDaGVja0ljb24sIG51bGwpLFxuICB3YXJuaW5nOiAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChXYXJuaW5nSWNvbiwgbnVsbCksXG4gIGVycm9yOiAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChFcnJvckljb24sIG51bGwpLFxuICBpbmZvOiAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChJbmZvSWNvbiwgbnVsbClcbn07XG5cbnZhciBkZWZhdWx0cyA9IHtcbiAgbWF4U25hY2s6IDMsXG4gIHBlcnNpc3Q6IGZhbHNlLFxuICBoaWRlSWNvblZhcmlhbnQ6IGZhbHNlLFxuICBkaXNhYmxlV2luZG93Qmx1ckxpc3RlbmVyOiBmYWxzZSxcbiAgdmFyaWFudDogJ2RlZmF1bHQnLFxuICBhdXRvSGlkZUR1cmF0aW9uOiA1MDAwLFxuICBpY29uVmFyaWFudDogZGVmYXVsdEljb25WYXJpYW50cyxcbiAgYW5jaG9yT3JpZ2luOiB7XG4gICAgdmVydGljYWw6ICdib3R0b20nLFxuICAgIGhvcml6b250YWw6ICdsZWZ0J1xuICB9LFxuICBUcmFuc2l0aW9uQ29tcG9uZW50OiBTbGlkZSxcbiAgdHJhbnNpdGlvbkR1cmF0aW9uOiB7XG4gICAgZW50ZXI6IDIyNSxcbiAgICBleGl0OiAxOTVcbiAgfVxufTtcbi8qKlxyXG4gKiBEZXJpdmVzIHRoZSByaWdodCBhdXRvSGlkZUR1cmF0aW9uIHRha2luZyBpbnRvIGFjY291bnQgdGhlIGZvbGxvd2luZ1xyXG4gKiBwcm9yaXR5IG9yZGVyOiAxOiBPcHRpb25zLCAyOiBQcm9wcywgMzogZGVmYXVsdCBmYWxsYmFja1xyXG4gKi9cblxudmFyIGdldEF1dG9IaWRlRHVyYXRpb24gPSBmdW5jdGlvbiBnZXRBdXRvSGlkZUR1cmF0aW9uKG9wdGlvbnNEdXJhdGlvbiwgcHJvcHNEdXJhdGlvbikge1xuICB2YXIgaXNOdW1iZXJPck51bGwgPSBmdW5jdGlvbiBpc051bWJlck9yTnVsbChudW1iZXJpc2gpIHtcbiAgICByZXR1cm4gdHlwZW9mIG51bWJlcmlzaCA9PT0gJ251bWJlcicgfHwgbnVtYmVyaXNoID09PSBudWxsO1xuICB9O1xuXG4gIGlmIChpc051bWJlck9yTnVsbChvcHRpb25zRHVyYXRpb24pKSByZXR1cm4gb3B0aW9uc0R1cmF0aW9uO1xuICBpZiAoaXNOdW1iZXJPck51bGwocHJvcHNEdXJhdGlvbikpIHJldHVybiBwcm9wc0R1cmF0aW9uO1xuICByZXR1cm4gZGVmYXVsdHMuYXV0b0hpZGVEdXJhdGlvbjtcbn07XG4vKipcclxuICogRGVyaXZlcyB0aGUgcmlnaHQgdHJhbnNpdGlvbkR1cmF0aW9uIHRha2luZyBpbnRvIGFjY291bnQgdGhlIGZvbGxvd2luZ1xyXG4gKiBwcm9yaXR5IG9yZGVyOiAxOiBPcHRpb25zLCAyOiBQcm9wcywgMzogZGVmYXVsdCBmYWxsYmFja1xyXG4gKi9cblxuXG52YXIgZ2V0VHJhbnNpdGlvbkR1cmF0aW9uID0gZnVuY3Rpb24gZ2V0VHJhbnNpdGlvbkR1cmF0aW9uKG9wdGlvbnNEdXJhdGlvbiwgcHJvcHNEdXJhdGlvbikge1xuICB2YXIgaXMgPSBmdW5jdGlvbiBpcyhpdGVtLCB0eXBlcykge1xuICAgIHJldHVybiB0eXBlcy5zb21lKGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gdHlwZW9mIGl0ZW0gPT09IHQ7XG4gICAgfSk7XG4gIH07XG5cbiAgaWYgKGlzKG9wdGlvbnNEdXJhdGlvbiwgWydzdHJpbmcnLCAnbnVtYmVyJ10pKSB7XG4gICAgcmV0dXJuIG9wdGlvbnNEdXJhdGlvbjtcbiAgfVxuXG4gIGlmIChpcyhvcHRpb25zRHVyYXRpb24sIFsnb2JqZWN0J10pKSB7XG4gICAgcmV0dXJuIF9leHRlbmRzKHt9LCBkZWZhdWx0cy50cmFuc2l0aW9uRHVyYXRpb24sIHt9LCBpcyhwcm9wc0R1cmF0aW9uLCBbJ29iamVjdCddKSAmJiBwcm9wc0R1cmF0aW9uLCB7fSwgb3B0aW9uc0R1cmF0aW9uKTtcbiAgfVxuXG4gIGlmIChpcyhwcm9wc0R1cmF0aW9uLCBbJ3N0cmluZycsICdudW1iZXInXSkpIHtcbiAgICByZXR1cm4gcHJvcHNEdXJhdGlvbjtcbiAgfVxuXG4gIGlmIChpcyhwcm9wc0R1cmF0aW9uLCBbJ29iamVjdCddKSkge1xuICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgZGVmYXVsdHMudHJhbnNpdGlvbkR1cmF0aW9uLCB7fSwgcHJvcHNEdXJhdGlvbik7XG4gIH1cblxuICByZXR1cm4gZGVmYXVsdHMudHJhbnNpdGlvbkR1cmF0aW9uO1xufTtcblxudmFyIG1lcmdlID0gZnVuY3Rpb24gbWVyZ2Uob3B0aW9ucywgcHJvcHMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChuYW1lLCBzaG91bGRPYmplY3RNZXJnZSkge1xuICAgIGlmIChzaG91bGRPYmplY3RNZXJnZSA9PT0gdm9pZCAwKSB7XG4gICAgICBzaG91bGRPYmplY3RNZXJnZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChzaG91bGRPYmplY3RNZXJnZSkge1xuICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBkZWZhdWx0c1tuYW1lXSwge30sIHByb3BzW25hbWVdLCB7fSwgb3B0aW9uc1tuYW1lXSk7XG4gICAgfVxuXG4gICAgaWYgKG5hbWUgPT09ICdhdXRvSGlkZUR1cmF0aW9uJykge1xuICAgICAgcmV0dXJuIGdldEF1dG9IaWRlRHVyYXRpb24ob3B0aW9ucy5hdXRvSGlkZUR1cmF0aW9uLCBwcm9wcy5hdXRvSGlkZUR1cmF0aW9uKTtcbiAgICB9XG5cbiAgICBpZiAobmFtZSA9PT0gJ3RyYW5zaXRpb25EdXJhdGlvbicpIHtcbiAgICAgIHJldHVybiBnZXRUcmFuc2l0aW9uRHVyYXRpb24ob3B0aW9ucy50cmFuc2l0aW9uRHVyYXRpb24sIHByb3BzLnRyYW5zaXRpb25EdXJhdGlvbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9wdGlvbnNbbmFtZV0gfHwgcHJvcHNbbmFtZV0gfHwgZGVmYXVsdHNbbmFtZV07XG4gIH07XG59O1xuXG5mdW5jdGlvbiBtYWtlU3R5bGVzKHN0eWxlcykge1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMoc3R5bGVzKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgX3JlZikge1xuICAgIHZhciBfZXh0ZW5kczI7XG5cbiAgICB2YXIga2V5ID0gX3JlZlswXSxcbiAgICAgICAgdmFsdWUgPSBfcmVmWzFdO1xuICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgYWNjLCAoX2V4dGVuZHMyID0ge30sIF9leHRlbmRzMltrZXldID0gY3NzKHZhbHVlKSwgX2V4dGVuZHMyKSk7XG4gIH0sIHt9KTtcbn1cbnZhciBDb21wb25lbnRDbGFzc2VzID0ge1xuICBTbmFja2JhckNvbnRhaW5lcjogJ25vdGlzdGFjay1TbmFja2JhckNvbnRhaW5lcicsXG4gIFNuYWNrYmFyOiAnbm90aXN0YWNrLVNuYWNrYmFyJyxcbiAgQ29sbGFwc2VXcmFwcGVyOiAnbm90aXN0YWNrLUNvbGxhcHNlV3JhcHBlcicsXG4gIE11aUNvbnRlbnQ6ICdub3Rpc3RhY2stTXVpQ29udGVudCcsXG4gIE11aUNvbnRlbnRWYXJpYW50OiBmdW5jdGlvbiBNdWlDb250ZW50VmFyaWFudCh2YXJpYW50KSB7XG4gICAgcmV0dXJuIFwibm90aXN0YWNrLU11aUNvbnRlbnQtXCIgKyB2YXJpYW50O1xuICB9XG59O1xuXG52YXIgY2xhc3NlcyA9IC8qI19fUFVSRV9fKi9tYWtlU3R5bGVzKHtcbiAgcm9vdDoge1xuICAgIGhlaWdodDogMFxuICB9LFxuICBlbnRlcmVkOiB7XG4gICAgaGVpZ2h0OiAnYXV0bydcbiAgfVxufSk7XG52YXIgY29sbGFwc2VkU2l6ZSA9ICcwcHgnO1xudmFyIHRpbWVvdXQgPSAxNzU7XG52YXIgQ29sbGFwc2UgPSAvKiNfX1BVUkVfXyovZm9yd2FyZFJlZihmdW5jdGlvbiAocHJvcHMsIHJlZikge1xuICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbixcbiAgICAgIGluUHJvcCA9IHByb3BzW1wiaW5cIl0sXG4gICAgICBvbkV4aXRlZCA9IHByb3BzLm9uRXhpdGVkO1xuICB2YXIgd3JhcHBlclJlZiA9IHVzZVJlZihudWxsKTtcbiAgdmFyIG5vZGVSZWYgPSB1c2VSZWYobnVsbCk7XG4gIHZhciBoYW5kbGVSZWYgPSB1c2VGb3JrUmVmKHJlZiwgbm9kZVJlZik7XG5cbiAgdmFyIGdldFdyYXBwZXJTaXplID0gZnVuY3Rpb24gZ2V0V3JhcHBlclNpemUoKSB7XG4gICAgcmV0dXJuIHdyYXBwZXJSZWYuY3VycmVudCA/IHdyYXBwZXJSZWYuY3VycmVudC5jbGllbnRIZWlnaHQgOiAwO1xuICB9O1xuXG4gIHZhciBoYW5kbGVFbnRlciA9IGZ1bmN0aW9uIGhhbmRsZUVudGVyKG5vZGUpIHtcbiAgICBub2RlLnN0eWxlLmhlaWdodCA9IGNvbGxhcHNlZFNpemU7XG4gIH07XG5cbiAgdmFyIGhhbmRsZUVudGVyaW5nID0gZnVuY3Rpb24gaGFuZGxlRW50ZXJpbmcobm9kZSkge1xuICAgIHZhciB3cmFwcGVyU2l6ZSA9IGdldFdyYXBwZXJTaXplKCk7XG5cbiAgICB2YXIgX2dldFRyYW5zaXRpb25Qcm9wcyA9IGdldFRyYW5zaXRpb25Qcm9wcyh7XG4gICAgICB0aW1lb3V0OiB0aW1lb3V0LFxuICAgICAgbW9kZTogJ2VudGVyJ1xuICAgIH0pLFxuICAgICAgICB0cmFuc2l0aW9uRHVyYXRpb24gPSBfZ2V0VHJhbnNpdGlvblByb3BzLmR1cmF0aW9uLFxuICAgICAgICBlYXNpbmcgPSBfZ2V0VHJhbnNpdGlvblByb3BzLmVhc2luZztcblxuICAgIG5vZGUuc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gdHlwZW9mIHRyYW5zaXRpb25EdXJhdGlvbiA9PT0gJ3N0cmluZycgPyB0cmFuc2l0aW9uRHVyYXRpb24gOiB0cmFuc2l0aW9uRHVyYXRpb24gKyBcIm1zXCI7XG4gICAgbm9kZS5zdHlsZS5oZWlnaHQgPSB3cmFwcGVyU2l6ZSArIFwicHhcIjtcbiAgICBub2RlLnN0eWxlLnRyYW5zaXRpb25UaW1pbmdGdW5jdGlvbiA9IGVhc2luZyB8fCAnJztcbiAgfTtcblxuICB2YXIgaGFuZGxlRW50ZXJlZCA9IGZ1bmN0aW9uIGhhbmRsZUVudGVyZWQobm9kZSkge1xuICAgIG5vZGUuc3R5bGUuaGVpZ2h0ID0gJ2F1dG8nO1xuICB9O1xuXG4gIHZhciBoYW5kbGVFeGl0ID0gZnVuY3Rpb24gaGFuZGxlRXhpdChub2RlKSB7XG4gICAgbm9kZS5zdHlsZS5oZWlnaHQgPSBnZXRXcmFwcGVyU2l6ZSgpICsgXCJweFwiO1xuICB9O1xuXG4gIHZhciBoYW5kbGVFeGl0aW5nID0gZnVuY3Rpb24gaGFuZGxlRXhpdGluZyhub2RlKSB7XG4gICAgcmVmbG93KG5vZGUpO1xuXG4gICAgdmFyIF9nZXRUcmFuc2l0aW9uUHJvcHMyID0gZ2V0VHJhbnNpdGlvblByb3BzKHtcbiAgICAgIHRpbWVvdXQ6IHRpbWVvdXQsXG4gICAgICBtb2RlOiAnZXhpdCdcbiAgICB9KSxcbiAgICAgICAgdHJhbnNpdGlvbkR1cmF0aW9uID0gX2dldFRyYW5zaXRpb25Qcm9wczIuZHVyYXRpb24sXG4gICAgICAgIGVhc2luZyA9IF9nZXRUcmFuc2l0aW9uUHJvcHMyLmVhc2luZztcblxuICAgIG5vZGUuc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gdHlwZW9mIHRyYW5zaXRpb25EdXJhdGlvbiA9PT0gJ3N0cmluZycgPyB0cmFuc2l0aW9uRHVyYXRpb24gOiB0cmFuc2l0aW9uRHVyYXRpb24gKyBcIm1zXCI7XG4gICAgbm9kZS5zdHlsZS5oZWlnaHQgPSBjb2xsYXBzZWRTaXplO1xuICAgIG5vZGUuc3R5bGUudHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uID0gZWFzaW5nIHx8ICcnO1xuICB9O1xuXG4gIHJldHVybiBjcmVhdGVFbGVtZW50KFRyYW5zaXRpb24sIHtcbiAgICBcImluXCI6IGluUHJvcCxcbiAgICB1bm1vdW50T25FeGl0OiB0cnVlLFxuICAgIG9uRW50ZXI6IGhhbmRsZUVudGVyLFxuICAgIG9uRW50ZXJlZDogaGFuZGxlRW50ZXJlZCxcbiAgICBvbkVudGVyaW5nOiBoYW5kbGVFbnRlcmluZyxcbiAgICBvbkV4aXQ6IGhhbmRsZUV4aXQsXG4gICAgb25FeGl0ZWQ6IG9uRXhpdGVkLFxuICAgIG9uRXhpdGluZzogaGFuZGxlRXhpdGluZyxcbiAgICBub2RlUmVmOiBub2RlUmVmLFxuICAgIHRpbWVvdXQ6IHRpbWVvdXRcbiAgfSwgZnVuY3Rpb24gKHN0YXRlLCBjaGlsZFByb3BzKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICByZWY6IGhhbmRsZVJlZixcbiAgICAgIGNsYXNzTmFtZTogY2xzeChjbGFzc2VzLnJvb3QsIHN0YXRlID09PSAnZW50ZXJlZCcgJiYgY2xhc3Nlcy5lbnRlcmVkKSxcbiAgICAgIHN0eWxlOiBfZXh0ZW5kcyh7XG4gICAgICAgIHBvaW50ZXJFdmVudHM6ICdhbGwnLFxuICAgICAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgICAgIG1pbkhlaWdodDogY29sbGFwc2VkU2l6ZSxcbiAgICAgICAgdHJhbnNpdGlvbjogY3JlYXRlVHJhbnNpdGlvbignaGVpZ2h0JylcbiAgICAgIH0sIHN0YXRlID09PSAnZW50ZXJlZCcgJiYge1xuICAgICAgICBvdmVyZmxvdzogJ3Zpc2libGUnXG4gICAgICB9LCB7fSwgc3RhdGUgPT09ICdleGl0ZWQnICYmICFpblByb3AgJiYge1xuICAgICAgICB2aXNpYmlsaXR5OiAnaGlkZGVuJ1xuICAgICAgfSlcbiAgICB9LCBjaGlsZFByb3BzKSwgY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICByZWY6IHdyYXBwZXJSZWYsXG4gICAgICBjbGFzc05hbWU6IENvbXBvbmVudENsYXNzZXMuQ29sbGFwc2VXcmFwcGVyLFxuICAgICAgLy8gSGFjayB0byBnZXQgY2hpbGRyZW4gd2l0aCBhIG5lZ2F0aXZlIG1hcmdpbiB0byBub3QgZmFsc2lmeSB0aGUgaGVpZ2h0IGNvbXB1dGF0aW9uLlxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgICAgICB3aWR0aDogJzEwMCUnXG4gICAgICB9XG4gICAgfSwgY2hpbGRyZW4pKTtcbiAgfSk7XG59KTtcbkNvbGxhcHNlLmRpc3BsYXlOYW1lID0gJ0NvbGxhcHNlJztcblxudmFyIGRpcmVjdGlvbiA9IHtcbiAgcmlnaHQ6ICdsZWZ0JyxcbiAgbGVmdDogJ3JpZ2h0JyxcbiAgYm90dG9tOiAndXAnLFxuICB0b3A6ICdkb3duJ1xufTtcbnZhciBnZXRTbGlkZURpcmVjdGlvbiA9IGZ1bmN0aW9uIGdldFNsaWRlRGlyZWN0aW9uKGFuY2hvck9yaWdpbikge1xuICBpZiAoYW5jaG9yT3JpZ2luLmhvcml6b250YWwgIT09ICdjZW50ZXInKSB7XG4gICAgcmV0dXJuIGRpcmVjdGlvblthbmNob3JPcmlnaW4uaG9yaXpvbnRhbF07XG4gIH1cblxuICByZXR1cm4gZGlyZWN0aW9uW2FuY2hvck9yaWdpbi52ZXJ0aWNhbF07XG59O1xuLyoqIFRyYW5mb3JtcyBjbGFzc2VzIG5hbWUgKi9cblxudmFyIHRvU25hY2tiYXJBbmNob3JPcmlnaW4gPSBmdW5jdGlvbiB0b1NuYWNrYmFyQW5jaG9yT3JpZ2luKGFuY2hvck9yaWdpbikge1xuICByZXR1cm4gXCJhbmNob3JPcmlnaW5cIiArIG9yaWdpbktleUV4dHJhY3RvcihhbmNob3JPcmlnaW4pO1xufTtcbi8qKlxyXG4gKiBPbWl0IFNuYWNrYmFyQ29udGFpbmVyIGNsYXNzIGtleXMgdGhhdCBhcmUgbm90IG5lZWRlZCBmb3IgU25hY2tiYXJJdGVtXHJcbiAqL1xuXG52YXIga2VlcFNuYWNrYmFyQ2xhc3NLZXlzID0gZnVuY3Rpb24ga2VlcFNuYWNrYmFyQ2xhc3NLZXlzKGNsYXNzZXMpIHtcbiAgaWYgKGNsYXNzZXMgPT09IHZvaWQgMCkge1xuICAgIGNsYXNzZXMgPSB7fTtcbiAgfVxuXG4gIHZhciBjb250YWluZXJDbGFzc2VzID0ge1xuICAgIGNvbnRhaW5lclJvb3Q6IHRydWUsXG4gICAgY29udGFpbmVyQW5jaG9yT3JpZ2luVG9wQ2VudGVyOiB0cnVlLFxuICAgIGNvbnRhaW5lckFuY2hvck9yaWdpbkJvdHRvbUNlbnRlcjogdHJ1ZSxcbiAgICBjb250YWluZXJBbmNob3JPcmlnaW5Ub3BSaWdodDogdHJ1ZSxcbiAgICBjb250YWluZXJBbmNob3JPcmlnaW5Cb3R0b21SaWdodDogdHJ1ZSxcbiAgICBjb250YWluZXJBbmNob3JPcmlnaW5Ub3BMZWZ0OiB0cnVlLFxuICAgIGNvbnRhaW5lckFuY2hvck9yaWdpbkJvdHRvbUxlZnQ6IHRydWVcbiAgfTtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKGNsYXNzZXMpLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuICFjb250YWluZXJDbGFzc2VzW2tleV07XG4gIH0pLnJlZHVjZShmdW5jdGlvbiAob2JqLCBrZXkpIHtcbiAgICB2YXIgX2V4dGVuZHMyO1xuXG4gICAgcmV0dXJuIF9leHRlbmRzKHt9LCBvYmosIChfZXh0ZW5kczIgPSB7fSwgX2V4dGVuZHMyW2tleV0gPSBjbGFzc2VzW2tleV0sIF9leHRlbmRzMikpO1xuICB9LCB7fSk7XG59O1xuXG52YXIgbm9PcCQxID0gZnVuY3Rpb24gbm9PcCgpIHtcbiAgLyogKi9cbn07XG4vKipcclxuICogQ3JlZGl0IHRvIE1VSSB0ZWFtIEAgaHR0cHM6Ly9tdWkuY29tXHJcbiAqIFNhZmUgY2hhaW5lZCBmdW5jdGlvbi5cclxuICpcclxuICogV2lsbCBvbmx5IGNyZWF0ZSBhIG5ldyBmdW5jdGlvbiBpZiBuZWVkZWQsXHJcbiAqIG90aGVyd2lzZSB3aWxsIHBhc3MgYmFjayBleGlzdGluZyBmdW5jdGlvbnMgb3IgbnVsbC5cclxuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlQ2hhaW5lZEZ1bmN0aW9uKGZ1bmNzLCBzbmFja2JhcklkKSB7XG4gIC8vIEB0cy1pZ25vcmVcbiAgcmV0dXJuIGZ1bmNzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBmdW5jKSB7XG4gICAgaWYgKGZ1bmMgPT09IG51bGwgfHwgZnVuYyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiBjaGFpbmVkRnVuY3Rpb24oKSB7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgdmFyIGFyZ3VtcyA9IFtdLmNvbmNhdChhcmdzKTtcblxuICAgICAgaWYgKHNuYWNrYmFySWQgJiYgYXJndW1zLmluZGV4T2Yoc25hY2tiYXJJZCkgPT09IC0xKSB7XG4gICAgICAgIGFyZ3Vtcy5wdXNoKHNuYWNrYmFySWQpO1xuICAgICAgfSAvLyBAdHMtaWdub3JlXG5cblxuICAgICAgYWNjLmFwcGx5KHRoaXMsIGFyZ3Vtcyk7XG4gICAgICBmdW5jLmFwcGx5KHRoaXMsIGFyZ3Vtcyk7XG4gICAgfTtcbiAgfSwgbm9PcCQxKTtcbn1cblxuLyoqXHJcbiAqIENyZWRpdCB0byBNVUkgdGVhbSBAIGh0dHBzOi8vbXVpLmNvbVxyXG4gKiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzE0MDk5I2lzc3VlY29tbWVudC00NDAwMTM4OTJcclxuICovXG52YXIgdXNlRW5oYW5jZWRFZmZlY3QgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHVzZUxheW91dEVmZmVjdCA6IHVzZUVmZmVjdDtcbmZ1bmN0aW9uIHVzZUV2ZW50Q2FsbGJhY2soZm4pIHtcbiAgdmFyIHJlZiA9IHVzZVJlZihmbik7XG4gIHVzZUVuaGFuY2VkRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICByZWYuY3VycmVudCA9IGZuO1xuICB9KTtcbiAgcmV0dXJuIHVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKC8vIEB0cy1leHBlY3QtZXJyb3IgaGlkZSBgdGhpc2BcbiAgICAgIChyZWYuY3VycmVudCkuYXBwbHkodm9pZCAwLCBhcmd1bWVudHMpXG4gICAgKTtcbiAgfSwgW10pO1xufVxuXG4vKipcclxuICogQ3JlZGl0IHRvIE1VSSB0ZWFtIEAgaHR0cHM6Ly9tdWkuY29tXHJcbiAqL1xudmFyIFNuYWNrYmFyID0gLyojX19QVVJFX18qL2ZvcndhcmRSZWYoZnVuY3Rpb24gKHByb3BzLCByZWYpIHtcbiAgdmFyIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW4sXG4gICAgICBjbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWUsXG4gICAgICBhdXRvSGlkZUR1cmF0aW9uID0gcHJvcHMuYXV0b0hpZGVEdXJhdGlvbixcbiAgICAgIF9wcm9wcyRkaXNhYmxlV2luZG93QiA9IHByb3BzLmRpc2FibGVXaW5kb3dCbHVyTGlzdGVuZXIsXG4gICAgICBkaXNhYmxlV2luZG93Qmx1ckxpc3RlbmVyID0gX3Byb3BzJGRpc2FibGVXaW5kb3dCID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRkaXNhYmxlV2luZG93QixcbiAgICAgIG9uQ2xvc2UgPSBwcm9wcy5vbkNsb3NlLFxuICAgICAgaWQgPSBwcm9wcy5pZCxcbiAgICAgIG9wZW4gPSBwcm9wcy5vcGVuLFxuICAgICAgX3Byb3BzJFNuYWNrYmFyUHJvcHMgPSBwcm9wcy5TbmFja2JhclByb3BzLFxuICAgICAgU25hY2tiYXJQcm9wcyA9IF9wcm9wcyRTbmFja2JhclByb3BzID09PSB2b2lkIDAgPyB7fSA6IF9wcm9wcyRTbmFja2JhclByb3BzO1xuICB2YXIgdGltZXJBdXRvSGlkZSA9IHVzZVJlZigpO1xuICB2YXIgaGFuZGxlQ2xvc2UgPSB1c2VFdmVudENhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAob25DbG9zZSkge1xuICAgICAgb25DbG9zZS5hcHBseSh2b2lkIDAsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9KTtcbiAgdmFyIHNldEF1dG9IaWRlVGltZXIgPSB1c2VFdmVudENhbGxiYWNrKGZ1bmN0aW9uIChhdXRvSGlkZUR1cmF0aW9uUGFyYW0pIHtcbiAgICBpZiAoIW9uQ2xvc2UgfHwgYXV0b0hpZGVEdXJhdGlvblBhcmFtID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGltZXJBdXRvSGlkZS5jdXJyZW50KSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZXJBdXRvSGlkZS5jdXJyZW50KTtcbiAgICB9XG5cbiAgICB0aW1lckF1dG9IaWRlLmN1cnJlbnQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGhhbmRsZUNsb3NlKG51bGwsICd0aW1lb3V0JywgaWQpO1xuICAgIH0sIGF1dG9IaWRlRHVyYXRpb25QYXJhbSk7XG4gIH0pO1xuICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGlmIChvcGVuKSB7XG4gICAgICBzZXRBdXRvSGlkZVRpbWVyKGF1dG9IaWRlRHVyYXRpb24pO1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAodGltZXJBdXRvSGlkZS5jdXJyZW50KSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lckF1dG9IaWRlLmN1cnJlbnQpO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtvcGVuLCBhdXRvSGlkZUR1cmF0aW9uLCBzZXRBdXRvSGlkZVRpbWVyXSk7XG4gIC8qKlxyXG4gICAqIFBhdXNlIHRoZSB0aW1lciB3aGVuIHRoZSB1c2VyIGlzIGludGVyYWN0aW5nIHdpdGggdGhlIFNuYWNrYmFyXHJcbiAgICogb3Igd2hlbiB0aGUgdXNlciBoaWRlIHRoZSB3aW5kb3cuXHJcbiAgICovXG5cbiAgdmFyIGhhbmRsZVBhdXNlID0gZnVuY3Rpb24gaGFuZGxlUGF1c2UoKSB7XG4gICAgaWYgKHRpbWVyQXV0b0hpZGUuY3VycmVudCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyQXV0b0hpZGUuY3VycmVudCk7XG4gICAgfVxuICB9O1xuICAvKipcclxuICAgKiBSZXN0YXJ0IHRoZSB0aW1lciB3aGVuIHRoZSB1c2VyIGlzIG5vIGxvbmdlciBpbnRlcmFjdGluZyB3aXRoIHRoZSBTbmFja2JhclxyXG4gICAqIG9yIHdoZW4gdGhlIHdpbmRvdyBpcyBzaG93biBiYWNrLlxyXG4gICAqL1xuXG5cbiAgdmFyIGhhbmRsZVJlc3VtZSA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoYXV0b0hpZGVEdXJhdGlvbiAhPSBudWxsKSB7XG4gICAgICBzZXRBdXRvSGlkZVRpbWVyKGF1dG9IaWRlRHVyYXRpb24gKiAwLjUpO1xuICAgIH1cbiAgfSwgW2F1dG9IaWRlRHVyYXRpb24sIHNldEF1dG9IaWRlVGltZXJdKTtcblxuICB2YXIgaGFuZGxlTW91c2VFbnRlciA9IGZ1bmN0aW9uIGhhbmRsZU1vdXNlRW50ZXIoZXZlbnQpIHtcbiAgICBpZiAoU25hY2tiYXJQcm9wcy5vbk1vdXNlRW50ZXIpIHtcbiAgICAgIFNuYWNrYmFyUHJvcHMub25Nb3VzZUVudGVyKGV2ZW50KTtcbiAgICB9XG5cbiAgICBoYW5kbGVQYXVzZSgpO1xuICB9O1xuXG4gIHZhciBoYW5kbGVNb3VzZUxlYXZlID0gZnVuY3Rpb24gaGFuZGxlTW91c2VMZWF2ZShldmVudCkge1xuICAgIGlmIChTbmFja2JhclByb3BzLm9uTW91c2VMZWF2ZSkge1xuICAgICAgU25hY2tiYXJQcm9wcy5vbk1vdXNlTGVhdmUoZXZlbnQpO1xuICAgIH1cblxuICAgIGhhbmRsZVJlc3VtZSgpO1xuICB9O1xuXG4gIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFkaXNhYmxlV2luZG93Qmx1ckxpc3RlbmVyICYmIG9wZW4pIHtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdmb2N1cycsIGhhbmRsZVJlc3VtZSk7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIGhhbmRsZVBhdXNlKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1cycsIGhhbmRsZVJlc3VtZSk7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdibHVyJywgaGFuZGxlUGF1c2UpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9LCBbZGlzYWJsZVdpbmRvd0JsdXJMaXN0ZW5lciwgaGFuZGxlUmVzdW1lLCBvcGVuXSk7XG4gIHJldHVybiBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgIHJlZjogcmVmXG4gIH0sIFNuYWNrYmFyUHJvcHMsIHtcbiAgICBjbGFzc05hbWU6IGNsc3goQ29tcG9uZW50Q2xhc3Nlcy5TbmFja2JhciwgY2xhc3NOYW1lKSxcbiAgICBvbk1vdXNlRW50ZXI6IGhhbmRsZU1vdXNlRW50ZXIsXG4gICAgb25Nb3VzZUxlYXZlOiBoYW5kbGVNb3VzZUxlYXZlXG4gIH0pLCBjaGlsZHJlbik7XG59KTtcblNuYWNrYmFyLmRpc3BsYXlOYW1lID0gJ1NuYWNrYmFyJztcblxudmFyIF9yb290O1xudmFyIGNsYXNzZXMkMSA9IC8qI19fUFVSRV9fKi9tYWtlU3R5bGVzKHtcbiAgcm9vdDogKF9yb290ID0ge1xuICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICBmbGV4V3JhcDogJ3dyYXAnLFxuICAgIGZsZXhHcm93OiAxXG4gIH0sIF9yb290W2JyZWFrcG9pbnRzLnVwU21dID0ge1xuICAgIGZsZXhHcm93OiAnaW5pdGlhbCcsXG4gICAgbWluV2lkdGg6ICcyODhweCdcbiAgfSwgX3Jvb3QpXG59KTtcbnZhciBTbmFja2JhckNvbnRlbnQgPSAvKiNfX1BVUkVfXyovZm9yd2FyZFJlZihmdW5jdGlvbiAoX3JlZiwgcmVmKSB7XG4gIHZhciBjbGFzc05hbWUgPSBfcmVmLmNsYXNzTmFtZSxcbiAgICAgIHByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoX3JlZiwgW1wiY2xhc3NOYW1lXCJdKTtcblxuICByZXR1cm4gUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcImRpdlwiLCBPYmplY3QuYXNzaWduKHtcbiAgICByZWY6IHJlZixcbiAgICBjbGFzc05hbWU6IGNsc3goY2xhc3NlcyQxLnJvb3QsIGNsYXNzTmFtZSlcbiAgfSwgcHJvcHMpKTtcbn0pO1xuU25hY2tiYXJDb250ZW50LmRpc3BsYXlOYW1lID0gJ1NuYWNrYmFyQ29udGVudCc7XG5cbnZhciBjbGFzc2VzJDIgPSAvKiNfX1BVUkVfXyovbWFrZVN0eWxlcyh7XG4gIHJvb3Q6IHtcbiAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjMzEzMTMxJyxcbiAgICBmb250U2l6ZTogJzAuODc1cmVtJyxcbiAgICBsaW5lSGVpZ2h0OiAxLjQzLFxuICAgIGxldHRlclNwYWNpbmc6ICcwLjAxMDcxZW0nLFxuICAgIGNvbG9yOiAnI2ZmZicsXG4gICAgYWxpZ25JdGVtczogJ2NlbnRlcicsXG4gICAgcGFkZGluZzogJzZweCAxNnB4JyxcbiAgICBib3JkZXJSYWRpdXM6ICc0cHgnLFxuICAgIGJveFNoYWRvdzogJzBweCAzcHggNXB4IC0xcHggcmdiYSgwLDAsMCwwLjIpLDBweCA2cHggMTBweCAwcHggcmdiYSgwLDAsMCwwLjE0KSwwcHggMXB4IDE4cHggMHB4IHJnYmEoMCwwLDAsMC4xMiknXG4gIH0sXG4gIGxlc3NQYWRkaW5nOiB7XG4gICAgcGFkZGluZ0xlZnQ6IDggKiAyLjUgKyBcInB4XCJcbiAgfSxcbiAgXCJkZWZhdWx0XCI6IHtcbiAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjMzEzMTMxJ1xuICB9LFxuICBzdWNjZXNzOiB7XG4gICAgYmFja2dyb3VuZENvbG9yOiAnIzQzYTA0NydcbiAgfSxcbiAgZXJyb3I6IHtcbiAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjZDMyZjJmJ1xuICB9LFxuICB3YXJuaW5nOiB7XG4gICAgYmFja2dyb3VuZENvbG9yOiAnI2ZmOTgwMCdcbiAgfSxcbiAgaW5mbzoge1xuICAgIGJhY2tncm91bmRDb2xvcjogJyMyMTk2ZjMnXG4gIH0sXG4gIG1lc3NhZ2U6IHtcbiAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgYWxpZ25JdGVtczogJ2NlbnRlcicsXG4gICAgcGFkZGluZzogJzhweCAwJ1xuICB9LFxuICBhY3Rpb246IHtcbiAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgYWxpZ25JdGVtczogJ2NlbnRlcicsXG4gICAgbWFyZ2luTGVmdDogJ2F1dG8nLFxuICAgIHBhZGRpbmdMZWZ0OiAnMTZweCcsXG4gICAgbWFyZ2luUmlnaHQ6ICctOHB4J1xuICB9XG59KTtcbnZhciBhcmlhRGVzY3JpYmVkYnkgPSAnbm90aXN0YWNrLXNuYWNrYmFyJztcbnZhciBNYXRlcmlhbERlc2lnbkNvbnRlbnQgPSAvKiNfX1BVUkVfXyovZm9yd2FyZFJlZihmdW5jdGlvbiAocHJvcHMsIGZvcndhcmRlZFJlZikge1xuICB2YXIgaWQgPSBwcm9wcy5pZCxcbiAgICAgIG1lc3NhZ2UgPSBwcm9wcy5tZXNzYWdlLFxuICAgICAgY29tcG9uZW50T3JGdW5jdGlvbkFjdGlvbiA9IHByb3BzLmFjdGlvbixcbiAgICAgIGljb25WYXJpYW50ID0gcHJvcHMuaWNvblZhcmlhbnQsXG4gICAgICB2YXJpYW50ID0gcHJvcHMudmFyaWFudCxcbiAgICAgIGhpZGVJY29uVmFyaWFudCA9IHByb3BzLmhpZGVJY29uVmFyaWFudCxcbiAgICAgIHN0eWxlID0gcHJvcHMuc3R5bGUsXG4gICAgICBjbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWU7XG4gIHZhciBpY29uID0gaWNvblZhcmlhbnRbdmFyaWFudF07XG4gIHZhciBhY3Rpb24gPSBjb21wb25lbnRPckZ1bmN0aW9uQWN0aW9uO1xuXG4gIGlmICh0eXBlb2YgYWN0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgYWN0aW9uID0gYWN0aW9uKGlkKTtcbiAgfVxuXG4gIHJldHVybiBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFNuYWNrYmFyQ29udGVudCwge1xuICAgIHJlZjogZm9yd2FyZGVkUmVmLFxuICAgIHJvbGU6IFwiYWxlcnRcIixcbiAgICBcImFyaWEtZGVzY3JpYmVkYnlcIjogYXJpYURlc2NyaWJlZGJ5LFxuICAgIHN0eWxlOiBzdHlsZSxcbiAgICBjbGFzc05hbWU6IGNsc3goQ29tcG9uZW50Q2xhc3Nlcy5NdWlDb250ZW50LCBDb21wb25lbnRDbGFzc2VzLk11aUNvbnRlbnRWYXJpYW50KHZhcmlhbnQpLCBjbGFzc2VzJDIucm9vdCwgY2xhc3NlcyQyW3ZhcmlhbnRdLCBjbGFzc05hbWUsICFoaWRlSWNvblZhcmlhbnQgJiYgaWNvbiAmJiBjbGFzc2VzJDIubGVzc1BhZGRpbmcpXG4gIH0sIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIGlkOiBhcmlhRGVzY3JpYmVkYnksXG4gICAgY2xhc3NOYW1lOiBjbGFzc2VzJDIubWVzc2FnZVxuICB9LCAhaGlkZUljb25WYXJpYW50ID8gaWNvbiA6IG51bGwsIG1lc3NhZ2UpLCBhY3Rpb24gJiYgUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgY2xhc3NOYW1lOiBjbGFzc2VzJDIuYWN0aW9uXG4gIH0sIGFjdGlvbikpO1xufSk7XG5NYXRlcmlhbERlc2lnbkNvbnRlbnQuZGlzcGxheU5hbWUgPSAnTWF0ZXJpYWxEZXNpZ25Db250ZW50JztcbnZhciBNYXRlcmlhbERlc2lnbkNvbnRlbnQkMSA9IC8qI19fUFVSRV9fKi9tZW1vKE1hdGVyaWFsRGVzaWduQ29udGVudCk7XG5cbnZhciBzdHlsZXMgPSAvKiNfX1BVUkVfXyovbWFrZVN0eWxlcyh7XG4gIHdyYXBwZWRSb290OiB7XG4gICAgd2lkdGg6ICcxMDAlJyxcbiAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGVYKDApJyxcbiAgICB0b3A6IDAsXG4gICAgcmlnaHQ6IDAsXG4gICAgYm90dG9tOiAwLFxuICAgIGxlZnQ6IDAsXG4gICAgbWluV2lkdGg6ICcyODhweCdcbiAgfVxufSk7XG5cbnZhciBTbmFja2Jhckl0ZW0gPSBmdW5jdGlvbiBTbmFja2Jhckl0ZW0ocHJvcHMpIHtcbiAgdmFyIHRpbWVvdXQgPSB1c2VSZWYoKTtcblxuICB2YXIgX3VzZVN0YXRlID0gdXNlU3RhdGUodHJ1ZSksXG4gICAgICBjb2xsYXBzZWQgPSBfdXNlU3RhdGVbMF0sXG4gICAgICBzZXRDb2xsYXBzZWQgPSBfdXNlU3RhdGVbMV07XG5cbiAgdmFyIGhhbmRsZUNsb3NlID0gY3JlYXRlQ2hhaW5lZEZ1bmN0aW9uKFtwcm9wcy5zbmFjay5vbkNsb3NlLCBwcm9wcy5vbkNsb3NlXSk7XG5cbiAgdmFyIGhhbmRsZUVudGVyZWQgPSBmdW5jdGlvbiBoYW5kbGVFbnRlcmVkKCkge1xuICAgIGlmIChwcm9wcy5zbmFjay5yZXF1ZXN0Q2xvc2UpIHtcbiAgICAgIGhhbmRsZUNsb3NlKG51bGwsICdpbnN0cnVjdGVkJywgcHJvcHMuc25hY2suaWQpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgaGFuZGxlRXhpdGVkU2NyZWVuID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgIHRpbWVvdXQuY3VycmVudCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgc2V0Q29sbGFwc2VkKGZ1bmN0aW9uIChjb2wpIHtcbiAgICAgICAgcmV0dXJuICFjb2w7XG4gICAgICB9KTtcbiAgICB9LCAxMjUpO1xuICB9LCBbXSk7XG4gIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0aW1lb3V0LmN1cnJlbnQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQuY3VycmVudCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW10pO1xuICB2YXIgc25hY2sgPSBwcm9wcy5zbmFjayxcbiAgICAgIGFsbENsYXNzZXMgPSBwcm9wcy5jbGFzc2VzLFxuICAgICAgX3Byb3BzJENvbXBvbmVudCA9IHByb3BzLkNvbXBvbmVudCxcbiAgICAgIENvbXBvbmVudCA9IF9wcm9wcyRDb21wb25lbnQgPT09IHZvaWQgMCA/IE1hdGVyaWFsRGVzaWduQ29udGVudCQxIDogX3Byb3BzJENvbXBvbmVudDtcbiAgdmFyIGNsYXNzZXMgPSB1c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ga2VlcFNuYWNrYmFyQ2xhc3NLZXlzKGFsbENsYXNzZXMpO1xuICB9LCBbYWxsQ2xhc3Nlc10pO1xuXG4gIHZhciBvcGVuID0gc25hY2sub3BlbixcbiAgICAgIFNuYWNrYmFyUHJvcHMgPSBzbmFjay5TbmFja2JhclByb3BzLFxuICAgICAgVHJhbnNpdGlvbkNvbXBvbmVudCA9IHNuYWNrLlRyYW5zaXRpb25Db21wb25lbnQsXG4gICAgICBUcmFuc2l0aW9uUHJvcHMgPSBzbmFjay5UcmFuc2l0aW9uUHJvcHMsXG4gICAgICB0cmFuc2l0aW9uRHVyYXRpb24gPSBzbmFjay50cmFuc2l0aW9uRHVyYXRpb24sXG4gICAgICBkaXNhYmxlV2luZG93Qmx1ckxpc3RlbmVyID0gc25hY2suZGlzYWJsZVdpbmRvd0JsdXJMaXN0ZW5lcixcbiAgICAgIGNvbXBvbmVudE9yRnVuY3Rpb25Db250ZW50ID0gc25hY2suY29udGVudCxcbiAgICAgIG90aGVyU25hY2sgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzbmFjaywgW1wib3BlblwiLCBcIlNuYWNrYmFyUHJvcHNcIiwgXCJUcmFuc2l0aW9uQ29tcG9uZW50XCIsIFwiVHJhbnNpdGlvblByb3BzXCIsIFwidHJhbnNpdGlvbkR1cmF0aW9uXCIsIFwiZGlzYWJsZVdpbmRvd0JsdXJMaXN0ZW5lclwiLCBcImNvbnRlbnRcIiwgXCJlbnRlcmVkXCIsIFwicmVxdWVzdENsb3NlXCIsIFwib25FbnRlclwiLCBcIm9uRW50ZXJlZFwiLCBcIm9uRXhpdFwiLCBcIm9uRXhpdGVkXCJdKTtcblxuICB2YXIgdHJhbnNpdGlvblByb3BzID0gX2V4dGVuZHMoe1xuICAgIGRpcmVjdGlvbjogZ2V0U2xpZGVEaXJlY3Rpb24ob3RoZXJTbmFjay5hbmNob3JPcmlnaW4pLFxuICAgIHRpbWVvdXQ6IHRyYW5zaXRpb25EdXJhdGlvblxuICB9LCBUcmFuc2l0aW9uUHJvcHMpO1xuXG4gIHZhciBjb250ZW50ID0gY29tcG9uZW50T3JGdW5jdGlvbkNvbnRlbnQ7XG5cbiAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY29udGVudCA9IGNvbnRlbnQob3RoZXJTbmFjay5pZCwgb3RoZXJTbmFjay5tZXNzYWdlKTtcbiAgfVxuXG4gIHZhciBjYWxsYmFja3MgPSBbJ29uRW50ZXInLCAnb25FbnRlcmVkJywgJ29uRXhpdCcsICdvbkV4aXRlZCddLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBjYk5hbWUpIHtcbiAgICB2YXIgX2V4dGVuZHMyO1xuXG4gICAgcmV0dXJuIF9leHRlbmRzKHt9LCBhY2MsIChfZXh0ZW5kczIgPSB7fSwgX2V4dGVuZHMyW2NiTmFtZV0gPSBjcmVhdGVDaGFpbmVkRnVuY3Rpb24oW3Byb3BzLnNuYWNrW2NiTmFtZV0sIHByb3BzW2NiTmFtZV1dLCBvdGhlclNuYWNrLmlkKSwgX2V4dGVuZHMyKSk7XG4gIH0sIHt9KTtcbiAgcmV0dXJuIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoQ29sbGFwc2UsIHtcbiAgICBcImluXCI6IGNvbGxhcHNlZCxcbiAgICBvbkV4aXRlZDogY2FsbGJhY2tzLm9uRXhpdGVkXG4gIH0sIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoU25hY2tiYXIsIHtcbiAgICBvcGVuOiBvcGVuLFxuICAgIGlkOiBvdGhlclNuYWNrLmlkLFxuICAgIGRpc2FibGVXaW5kb3dCbHVyTGlzdGVuZXI6IGRpc2FibGVXaW5kb3dCbHVyTGlzdGVuZXIsXG4gICAgYXV0b0hpZGVEdXJhdGlvbjogb3RoZXJTbmFjay5hdXRvSGlkZUR1cmF0aW9uLFxuICAgIGNsYXNzTmFtZTogY2xzeChzdHlsZXMud3JhcHBlZFJvb3QsIGNsYXNzZXMucm9vdCwgY2xhc3Nlc1t0b1NuYWNrYmFyQW5jaG9yT3JpZ2luKG90aGVyU25hY2suYW5jaG9yT3JpZ2luKV0pLFxuICAgIFNuYWNrYmFyUHJvcHM6IFNuYWNrYmFyUHJvcHMsXG4gICAgb25DbG9zZTogaGFuZGxlQ2xvc2VcbiAgfSwgUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChUcmFuc2l0aW9uQ29tcG9uZW50LCBPYmplY3QuYXNzaWduKHt9LCB0cmFuc2l0aW9uUHJvcHMsIHtcbiAgICBhcHBlYXI6IHRydWUsXG4gICAgXCJpblwiOiBvcGVuLFxuICAgIG9uRXhpdDogY2FsbGJhY2tzLm9uRXhpdCxcbiAgICBvbkV4aXRlZDogaGFuZGxlRXhpdGVkU2NyZWVuLFxuICAgIG9uRW50ZXI6IGNhbGxiYWNrcy5vbkVudGVyLFxuICAgIC8vIG9yZGVyIG1hdHRlcnMuIGZpcnN0IGNhbGxiYWNrcy5vbkVudGVyZWQgdG8gc2V0IGVudGVyZWQ6IHRydWUsXG4gICAgLy8gdGhlbiBoYW5kbGVFbnRlcmVkIHRvIGNoZWNrIGlmIHRoZXJlJ3MgYSByZXF1ZXN0IGZvciBjbG9zaW5nXG4gICAgb25FbnRlcmVkOiBjcmVhdGVDaGFpbmVkRnVuY3Rpb24oW2NhbGxiYWNrcy5vbkVudGVyZWQsIGhhbmRsZUVudGVyZWRdLCBvdGhlclNuYWNrLmlkKVxuICB9KSwgY29udGVudCB8fCBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KENvbXBvbmVudCwgT2JqZWN0LmFzc2lnbih7fSwgb3RoZXJTbmFjaykpKSkpO1xufTtcblxudmFyIF9yb290JDEsIF9yb290RGVuc2UsIF9sZWZ0LCBfcmlnaHQsIF9jZW50ZXI7XG52YXIgaW5kZW50cyA9IHtcbiAgdmlldzoge1xuICAgIFwiZGVmYXVsdFwiOiAyMCxcbiAgICBkZW5zZTogNFxuICB9LFxuICBzbmFja2Jhcjoge1xuICAgIFwiZGVmYXVsdFwiOiA2LFxuICAgIGRlbnNlOiAyXG4gIH1cbn07XG52YXIgY29sbGFwc2VXcmFwcGVyID0gXCIuXCIgKyBDb21wb25lbnRDbGFzc2VzLkNvbGxhcHNlV3JhcHBlcjtcbnZhciB4c1dpZHRoTWFyZ2luID0gMTY7XG52YXIgc3R5bGVzJDEgPSAvKiNfX1BVUkVfXyovbWFrZVN0eWxlcyh7XG4gIHJvb3Q6IChfcm9vdCQxID0ge1xuICAgIGJveFNpemluZzogJ2JvcmRlci1ib3gnLFxuICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICBtYXhIZWlnaHQ6ICcxMDAlJyxcbiAgICBwb3NpdGlvbjogJ2ZpeGVkJyxcbiAgICB6SW5kZXg6IDE0MDAsXG4gICAgaGVpZ2h0OiAnYXV0bycsXG4gICAgd2lkdGg6ICdhdXRvJyxcbiAgICB0cmFuc2l0aW9uOiAvKiNfX1BVUkVfXyovY3JlYXRlVHJhbnNpdGlvbihbJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCAnbGVmdCcsICdtYXgtd2lkdGgnXSwge1xuICAgICAgZHVyYXRpb246IDMwMCxcbiAgICAgIGVhc2luZzogJ2Vhc2UnXG4gICAgfSksXG4gICAgLy8gY29udGFpbmVyIGl0c2VsZiBpcyBpbnZpc2libGUgYW5kIHNob3VsZCBub3QgYmxvY2sgY2xpY2tzLCBjbGlja3Mgc2hvdWxkIGJlIHBhc3NlZCB0byBpdHMgY2hpbGRyZW5cbiAgICAvLyBhIHBvaW50ZXJFdmVudHM6IGFsbCBpcyBhcHBsaWVkIGluIHRoZSBjb2xsYXBzZSBjb21wb25lbnRcbiAgICBwb2ludGVyRXZlbnRzOiAnbm9uZSdcbiAgfSwgX3Jvb3QkMVtjb2xsYXBzZVdyYXBwZXJdID0ge1xuICAgIHBhZGRpbmc6IGluZGVudHMuc25hY2tiYXJbXCJkZWZhdWx0XCJdICsgXCJweCAwcHhcIixcbiAgICB0cmFuc2l0aW9uOiAncGFkZGluZyAzMDBtcyBlYXNlIDBtcydcbiAgfSwgX3Jvb3QkMS5tYXhXaWR0aCA9IFwiY2FsYygxMDAlIC0gXCIgKyBpbmRlbnRzLnZpZXdbXCJkZWZhdWx0XCJdICogMiArIFwicHgpXCIsIF9yb290JDFbYnJlYWtwb2ludHMuZG93blhzXSA9IHtcbiAgICB3aWR0aDogJzEwMCUnLFxuICAgIG1heFdpZHRoOiBcImNhbGMoMTAwJSAtIFwiICsgeHNXaWR0aE1hcmdpbiAqIDIgKyBcInB4KVwiXG4gIH0sIF9yb290JDEpLFxuICByb290RGVuc2U6IChfcm9vdERlbnNlID0ge30sIF9yb290RGVuc2VbY29sbGFwc2VXcmFwcGVyXSA9IHtcbiAgICBwYWRkaW5nOiBpbmRlbnRzLnNuYWNrYmFyLmRlbnNlICsgXCJweCAwcHhcIlxuICB9LCBfcm9vdERlbnNlKSxcbiAgdG9wOiB7XG4gICAgdG9wOiBpbmRlbnRzLnZpZXdbXCJkZWZhdWx0XCJdIC0gaW5kZW50cy5zbmFja2JhcltcImRlZmF1bHRcIl0gKyBcInB4XCIsXG4gICAgZmxleERpcmVjdGlvbjogJ2NvbHVtbidcbiAgfSxcbiAgYm90dG9tOiB7XG4gICAgYm90dG9tOiBpbmRlbnRzLnZpZXdbXCJkZWZhdWx0XCJdIC0gaW5kZW50cy5zbmFja2JhcltcImRlZmF1bHRcIl0gKyBcInB4XCIsXG4gICAgZmxleERpcmVjdGlvbjogJ2NvbHVtbi1yZXZlcnNlJ1xuICB9LFxuICBsZWZ0OiAoX2xlZnQgPSB7XG4gICAgbGVmdDogaW5kZW50cy52aWV3W1wiZGVmYXVsdFwiXSArIFwicHhcIlxuICB9LCBfbGVmdFticmVha3BvaW50cy51cFNtXSA9IHtcbiAgICBhbGlnbkl0ZW1zOiAnZmxleC1zdGFydCdcbiAgfSwgX2xlZnRbYnJlYWtwb2ludHMuZG93blhzXSA9IHtcbiAgICBsZWZ0OiB4c1dpZHRoTWFyZ2luICsgXCJweFwiXG4gIH0sIF9sZWZ0KSxcbiAgcmlnaHQ6IChfcmlnaHQgPSB7XG4gICAgcmlnaHQ6IGluZGVudHMudmlld1tcImRlZmF1bHRcIl0gKyBcInB4XCJcbiAgfSwgX3JpZ2h0W2JyZWFrcG9pbnRzLnVwU21dID0ge1xuICAgIGFsaWduSXRlbXM6ICdmbGV4LWVuZCdcbiAgfSwgX3JpZ2h0W2JyZWFrcG9pbnRzLmRvd25Yc10gPSB7XG4gICAgcmlnaHQ6IHhzV2lkdGhNYXJnaW4gKyBcInB4XCJcbiAgfSwgX3JpZ2h0KSxcbiAgY2VudGVyOiAoX2NlbnRlciA9IHtcbiAgICBsZWZ0OiAnNTAlJyxcbiAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGVYKC01MCUpJ1xuICB9LCBfY2VudGVyW2JyZWFrcG9pbnRzLnVwU21dID0ge1xuICAgIGFsaWduSXRlbXM6ICdjZW50ZXInXG4gIH0sIF9jZW50ZXIpXG59KTtcblxudmFyIFNuYWNrYmFyQ29udGFpbmVyID0gZnVuY3Rpb24gU25hY2tiYXJDb250YWluZXIocHJvcHMpIHtcbiAgdmFyIF9wcm9wcyRjbGFzc2VzID0gcHJvcHMuY2xhc3NlcyxcbiAgICAgIGNsYXNzZXMgPSBfcHJvcHMkY2xhc3NlcyA9PT0gdm9pZCAwID8ge30gOiBfcHJvcHMkY2xhc3NlcyxcbiAgICAgIGFuY2hvck9yaWdpbiA9IHByb3BzLmFuY2hvck9yaWdpbixcbiAgICAgIGRlbnNlID0gcHJvcHMuZGVuc2UsXG4gICAgICBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuO1xuICB2YXIgY29tYmluZWRDbGFzc25hbWUgPSBjbHN4KENvbXBvbmVudENsYXNzZXMuU25hY2tiYXJDb250YWluZXIsIHN0eWxlcyQxW2FuY2hvck9yaWdpbi52ZXJ0aWNhbF0sIHN0eWxlcyQxW2FuY2hvck9yaWdpbi5ob3Jpem9udGFsXSwgc3R5bGVzJDEucm9vdCwgLy8gcm9vdCBzaG91bGQgY29tZSBhZnRlciBvdGhlcnMgdG8gb3ZlcnJpZGUgbWF4V2lkdGhcbiAgY2xhc3Nlcy5jb250YWluZXJSb290LCBjbGFzc2VzW1wiY29udGFpbmVyQW5jaG9yT3JpZ2luXCIgKyBvcmlnaW5LZXlFeHRyYWN0b3IoYW5jaG9yT3JpZ2luKV0sIGRlbnNlICYmIHN0eWxlcyQxLnJvb3REZW5zZSk7XG4gIHJldHVybiBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBjbGFzc05hbWU6IGNvbWJpbmVkQ2xhc3NuYW1lXG4gIH0sIGNoaWxkcmVuKTtcbn07XG5cbnZhciBTbmFja2JhckNvbnRhaW5lciQxID0gLyojX19QVVJFX18qL21lbW8oU25hY2tiYXJDb250YWluZXIpO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xudmFyIF9fREVWX18gPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nO1xuXG52YXIgbWVzc2FnZXMgPSB7XG4gIE5PX1BFUlNJU1RfQUxMOiBcIlJlYWNoZWQgbWF4U25hY2sgd2hpbGUgYWxsIGVucXVldWVkIHNuYWNrYmFycyBoYXZlICdwZXJzaXN0JyBmbGFnLiBOb3Rpc3RhY2sgd2lsbCBkaXNtaXNzIHRoZSBvbGRlc3Qgc25hY2tiYXIgYW55d2F5IHRvIGFsbG93IG90aGVyIG9uZXMgaW4gdGhlIHF1ZXVlIHRvIGJlIHByZXNlbnRlZC5cIlxufTtcbnZhciB3YXJuaW5nID0gKGZ1bmN0aW9uIChtZXNzYWdlS2V5KSB7XG4gIGlmICghX19ERVZfXykgcmV0dXJuO1xuICB2YXIgbWVzc2FnZSA9IG1lc3NhZ2VzW21lc3NhZ2VLZXldO1xuXG4gIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiV0FSTklORyAtIG5vdGlzdGFjazogXCIgKyBtZXNzYWdlKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICB9IGNhdGNoICh4KSB7fVxufSk7XG5cbnZhciBpc09wdGlvbnMgPSBmdW5jdGlvbiBpc09wdGlvbnMobWVzc2FnZU9yT3B0aW9ucykge1xuICB2YXIgaXNNZXNzYWdlID0gdHlwZW9mIG1lc3NhZ2VPck9wdGlvbnMgPT09ICdzdHJpbmcnIHx8IGlzVmFsaWRFbGVtZW50KG1lc3NhZ2VPck9wdGlvbnMpO1xuICByZXR1cm4gIWlzTWVzc2FnZTtcbn07XG5cbnZhciBlbnF1ZXVlU25hY2tiYXI7XG52YXIgY2xvc2VTbmFja2JhcjtcblxudmFyIFNuYWNrYmFyUHJvdmlkZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgX2luaGVyaXRzTG9vc2UoU25hY2tiYXJQcm92aWRlciwgX0NvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gU25hY2tiYXJQcm92aWRlcihwcm9wcykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX0NvbXBvbmVudC5jYWxsKHRoaXMsIHByb3BzKSB8fCB0aGlzO1xuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIG5ldyBzbmFja2JhciB0byB0aGUgcXVldWUgdG8gYmUgcHJlc2VudGVkLlxyXG4gICAgICogUmV0dXJucyBnZW5lcmF0ZWQgb3IgdXNlciBkZWZpbmVkIGtleSByZWZlcmVuY2luZyB0aGUgbmV3IHNuYWNrYmFyIG9yIG51bGxcclxuICAgICAqL1xuXG4gICAgX3RoaXMuZW5xdWV1ZVNuYWNrYmFyID0gZnVuY3Rpb24gKG1lc3NhZ2VPck9wdGlvbnMsIG9wdHNPclVuZGVmaW5lZCkge1xuICAgICAgaWYgKG9wdHNPclVuZGVmaW5lZCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIG9wdHNPclVuZGVmaW5lZCA9IHt9O1xuICAgICAgfVxuXG4gICAgICBpZiAobWVzc2FnZU9yT3B0aW9ucyA9PT0gdW5kZWZpbmVkIHx8IG1lc3NhZ2VPck9wdGlvbnMgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdlbnF1ZXVlU25hY2tiYXIgY2FsbGVkIHdpdGggaW52YWxpZCBhcmd1bWVudCcpO1xuICAgICAgfVxuXG4gICAgICB2YXIgb3B0cyA9IGlzT3B0aW9ucyhtZXNzYWdlT3JPcHRpb25zKSA/IG1lc3NhZ2VPck9wdGlvbnMgOiBvcHRzT3JVbmRlZmluZWQ7XG4gICAgICB2YXIgbWVzc2FnZSA9IGlzT3B0aW9ucyhtZXNzYWdlT3JPcHRpb25zKSA/IG1lc3NhZ2VPck9wdGlvbnMubWVzc2FnZSA6IG1lc3NhZ2VPck9wdGlvbnM7XG5cbiAgICAgIHZhciBrZXkgPSBvcHRzLmtleSxcbiAgICAgICAgICBwcmV2ZW50RHVwbGljYXRlID0gb3B0cy5wcmV2ZW50RHVwbGljYXRlLFxuICAgICAgICAgIG9wdGlvbnMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShvcHRzLCBbXCJrZXlcIiwgXCJwcmV2ZW50RHVwbGljYXRlXCJdKTtcblxuICAgICAgdmFyIGhhc1NwZWNpZmllZEtleSA9IGlzRGVmaW5lZChrZXkpO1xuICAgICAgdmFyIGlkID0gaGFzU3BlY2lmaWVkS2V5ID8ga2V5IDogbmV3IERhdGUoKS5nZXRUaW1lKCkgKyBNYXRoLnJhbmRvbSgpO1xuICAgICAgdmFyIG1lcmdlciA9IG1lcmdlKG9wdGlvbnMsIF90aGlzLnByb3BzKTtcblxuICAgICAgdmFyIHNuYWNrID0gX2V4dGVuZHMoe1xuICAgICAgICBpZDogaWRcbiAgICAgIH0sIG9wdGlvbnMsIHtcbiAgICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgICAgb3BlbjogdHJ1ZSxcbiAgICAgICAgZW50ZXJlZDogZmFsc2UsXG4gICAgICAgIHJlcXVlc3RDbG9zZTogZmFsc2UsXG4gICAgICAgIHBlcnNpc3Q6IG1lcmdlcigncGVyc2lzdCcpLFxuICAgICAgICBhY3Rpb246IG1lcmdlcignYWN0aW9uJyksXG4gICAgICAgIGNvbnRlbnQ6IG1lcmdlcignY29udGVudCcpLFxuICAgICAgICB2YXJpYW50OiBtZXJnZXIoJ3ZhcmlhbnQnKSxcbiAgICAgICAgYW5jaG9yT3JpZ2luOiBtZXJnZXIoJ2FuY2hvck9yaWdpbicpLFxuICAgICAgICBkaXNhYmxlV2luZG93Qmx1ckxpc3RlbmVyOiBtZXJnZXIoJ2Rpc2FibGVXaW5kb3dCbHVyTGlzdGVuZXInKSxcbiAgICAgICAgYXV0b0hpZGVEdXJhdGlvbjogbWVyZ2VyKCdhdXRvSGlkZUR1cmF0aW9uJyksXG4gICAgICAgIGhpZGVJY29uVmFyaWFudDogbWVyZ2VyKCdoaWRlSWNvblZhcmlhbnQnKSxcbiAgICAgICAgVHJhbnNpdGlvbkNvbXBvbmVudDogbWVyZ2VyKCdUcmFuc2l0aW9uQ29tcG9uZW50JyksXG4gICAgICAgIHRyYW5zaXRpb25EdXJhdGlvbjogbWVyZ2VyKCd0cmFuc2l0aW9uRHVyYXRpb24nKSxcbiAgICAgICAgVHJhbnNpdGlvblByb3BzOiBtZXJnZXIoJ1RyYW5zaXRpb25Qcm9wcycsIHRydWUpLFxuICAgICAgICBpY29uVmFyaWFudDogbWVyZ2VyKCdpY29uVmFyaWFudCcsIHRydWUpLFxuICAgICAgICBzdHlsZTogbWVyZ2VyKCdzdHlsZScsIHRydWUpLFxuICAgICAgICBTbmFja2JhclByb3BzOiBtZXJnZXIoJ1NuYWNrYmFyUHJvcHMnLCB0cnVlKSxcbiAgICAgICAgY2xhc3NOYW1lOiBjbHN4KF90aGlzLnByb3BzLmNsYXNzTmFtZSwgb3B0aW9ucy5jbGFzc05hbWUpXG4gICAgICB9KTtcblxuICAgICAgaWYgKHNuYWNrLnBlcnNpc3QpIHtcbiAgICAgICAgc25hY2suYXV0b0hpZGVEdXJhdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgX3RoaXMuc2V0U3RhdGUoZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgIGlmIChwcmV2ZW50RHVwbGljYXRlID09PSB1bmRlZmluZWQgJiYgX3RoaXMucHJvcHMucHJldmVudER1cGxpY2F0ZSB8fCBwcmV2ZW50RHVwbGljYXRlKSB7XG4gICAgICAgICAgdmFyIGNvbXBhcmVGdW5jdGlvbiA9IGZ1bmN0aW9uIGNvbXBhcmVGdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gaGFzU3BlY2lmaWVkS2V5ID8gaXRlbS5pZCA9PT0gaWQgOiBpdGVtLm1lc3NhZ2UgPT09IG1lc3NhZ2U7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHZhciBpblF1ZXVlID0gc3RhdGUucXVldWUuZmluZEluZGV4KGNvbXBhcmVGdW5jdGlvbikgPiAtMTtcbiAgICAgICAgICB2YXIgaW5WaWV3ID0gc3RhdGUuc25hY2tzLmZpbmRJbmRleChjb21wYXJlRnVuY3Rpb24pID4gLTE7XG5cbiAgICAgICAgICBpZiAoaW5RdWV1ZSB8fCBpblZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gX3RoaXMuaGFuZGxlRGlzcGxheVNuYWNrKF9leHRlbmRzKHt9LCBzdGF0ZSwge1xuICAgICAgICAgIHF1ZXVlOiBbXS5jb25jYXQoc3RhdGUucXVldWUsIFtzbmFja10pXG4gICAgICAgIH0pKTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gaWQ7XG4gICAgfTtcbiAgICAvKipcclxuICAgICAqIFJlZHVjZXI6IERpc3BsYXkgc25hY2sgaWYgdGhlcmUncyBzcGFjZSBmb3IgaXQuIE90aGVyd2lzZSwgaW1tZWRpYXRlbHlcclxuICAgICAqIGJlZ2luIGRpc21pc3NpbmcgdGhlIG9sZGVzdCBtZXNzYWdlIHRvIHN0YXJ0IHNob3dpbmcgdGhlIG5ldyBvbmUuXHJcbiAgICAgKi9cblxuXG4gICAgX3RoaXMuaGFuZGxlRGlzcGxheVNuYWNrID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICB2YXIgc25hY2tzID0gc3RhdGUuc25hY2tzO1xuXG4gICAgICBpZiAoc25hY2tzLmxlbmd0aCA+PSBfdGhpcy5tYXhTbmFjaykge1xuICAgICAgICByZXR1cm4gX3RoaXMuaGFuZGxlRGlzbWlzc09sZGVzdChzdGF0ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfdGhpcy5wcm9jZXNzUXVldWUoc3RhdGUpO1xuICAgIH07XG4gICAgLyoqXHJcbiAgICAgKiBSZWR1Y2VyOiBEaXNwbGF5IGl0ZW1zIChub3RpZmljYXRpb25zKSBpbiB0aGUgcXVldWUgaWYgdGhlcmUncyBzcGFjZSBmb3IgdGhlbS5cclxuICAgICAqL1xuXG5cbiAgICBfdGhpcy5wcm9jZXNzUXVldWUgPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgIHZhciBxdWV1ZSA9IHN0YXRlLnF1ZXVlLFxuICAgICAgICAgIHNuYWNrcyA9IHN0YXRlLnNuYWNrcztcblxuICAgICAgaWYgKHF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBzdGF0ZSwge1xuICAgICAgICAgIHNuYWNrczogW10uY29uY2F0KHNuYWNrcywgW3F1ZXVlWzBdXSksXG4gICAgICAgICAgcXVldWU6IHF1ZXVlLnNsaWNlKDEsIHF1ZXVlLmxlbmd0aClcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9O1xuICAgIC8qKlxyXG4gICAgICogUmVkdWNlcjogSGlkZSBvbGRlc3Qgc25hY2tiYXIgb24gdGhlIHNjcmVlbiBiZWNhdXNlIHRoZXJlIGV4aXN0cyBhIG5ldyBvbmUgd2hpY2ggd2UgaGF2ZSB0byBkaXNwbGF5LlxyXG4gICAgICogKGlnbm9yaW5nIHRoZSBvbmUgd2l0aCAncGVyc2lzdCcgZmxhZy4gaS5lLiBleHBsaWNpdGx5IHRvbGQgYnkgdXNlciBub3QgdG8gZ2V0IGRpc21pc3NlZCkuXHJcbiAgICAgKlxyXG4gICAgICogTm90ZSAxOiBJZiB0aGVyZSBpcyBhbHJlYWR5IGEgbWVzc2FnZSBsZWF2aW5nIHRoZSBzY3JlZW4sIG5vIG5ldyBtZXNzYWdlcyBhcmUgZGlzbWlzc2VkLlxyXG4gICAgICogTm90ZSAyOiBJZiB0aGUgb2xkZXN0IG1lc3NhZ2UgaGFzIG5vdCB5ZXQgZW50ZXJlZCB0aGUgc2NyZWVuLCBvbmx5IGEgcmVxdWVzdCB0byBjbG9zZSB0aGVcclxuICAgICAqICAgICAgICAgc25hY2tiYXIgaXMgbWFkZS4gT25jZSBpdCBlbnRlcmVkIHRoZSBzY3JlZW4sIGl0IHdpbGwgYmUgaW1tZWRpYXRlbHkgZGlzbWlzc2VkLlxyXG4gICAgICovXG5cblxuICAgIF90aGlzLmhhbmRsZURpc21pc3NPbGRlc3QgPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgIGlmIChzdGF0ZS5zbmFja3Muc29tZShmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICByZXR1cm4gIWl0ZW0ub3BlbiB8fCBpdGVtLnJlcXVlc3RDbG9zZTtcbiAgICAgIH0pKSB7XG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHBvcHBlZCA9IGZhbHNlO1xuICAgICAgdmFyIGlnbm9yZSA9IGZhbHNlO1xuICAgICAgdmFyIHBlcnNpc3RlbnRDb3VudCA9IHN0YXRlLnNuYWNrcy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgY3VycmVudCkge1xuICAgICAgICByZXR1cm4gYWNjICsgKGN1cnJlbnQub3BlbiAmJiBjdXJyZW50LnBlcnNpc3QgPyAxIDogMCk7XG4gICAgICB9LCAwKTtcblxuICAgICAgaWYgKHBlcnNpc3RlbnRDb3VudCA9PT0gX3RoaXMubWF4U25hY2spIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZygnTk9fUEVSU0lTVF9BTEwnKSA6IHZvaWQgMDtcbiAgICAgICAgaWdub3JlID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHNuYWNrcyA9IHN0YXRlLnNuYWNrcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgaWYgKCFwb3BwZWQgJiYgKCFpdGVtLnBlcnNpc3QgfHwgaWdub3JlKSkge1xuICAgICAgICAgIHBvcHBlZCA9IHRydWU7XG5cbiAgICAgICAgICBpZiAoIWl0ZW0uZW50ZXJlZCkge1xuICAgICAgICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBpdGVtLCB7XG4gICAgICAgICAgICAgIHJlcXVlc3RDbG9zZTogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGl0ZW0ub25DbG9zZSkge1xuICAgICAgICAgICAgaXRlbS5vbkNsb3NlKG51bGwsICdtYXhzbmFjaycsIGl0ZW0uaWQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChfdGhpcy5wcm9wcy5vbkNsb3NlKSB7XG4gICAgICAgICAgICBfdGhpcy5wcm9wcy5vbkNsb3NlKG51bGwsICdtYXhzbmFjaycsIGl0ZW0uaWQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgaXRlbSwge1xuICAgICAgICAgICAgb3BlbjogZmFsc2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgaXRlbSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgc3RhdGUsIHtcbiAgICAgICAgc25hY2tzOiBzbmFja3NcbiAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIGVudGVyZWQgc3RhdGUgb2YgdGhlIHNuYWNrYmFyIHdpdGggdGhlIGdpdmVuIGtleS5cclxuICAgICAqL1xuXG5cbiAgICBfdGhpcy5oYW5kbGVFbnRlcmVkU25hY2sgPSBmdW5jdGlvbiAobm9kZSwgaXNBcHBlYXJpbmcsIGtleSkge1xuICAgICAgaWYgKCFpc0RlZmluZWQoa2V5KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hhbmRsZUVudGVyZWRTbmFjayBDYW5ub3QgYmUgY2FsbGVkIHdpdGggdW5kZWZpbmVkIGtleScpO1xuICAgICAgfVxuXG4gICAgICBfdGhpcy5zZXRTdGF0ZShmdW5jdGlvbiAoX3JlZikge1xuICAgICAgICB2YXIgc25hY2tzID0gX3JlZi5zbmFja3M7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc25hY2tzOiBzbmFja3MubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbS5pZCA9PT0ga2V5ID8gX2V4dGVuZHMoe30sIGl0ZW0sIHtcbiAgICAgICAgICAgICAgZW50ZXJlZDogdHJ1ZVxuICAgICAgICAgICAgfSkgOiBfZXh0ZW5kcyh7fSwgaXRlbSk7XG4gICAgICAgICAgfSlcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXHJcbiAgICAgKiBIaWRlIGEgc25hY2tiYXIgYWZ0ZXIgaXRzIHRpbWVvdXQuXHJcbiAgICAgKi9cblxuXG4gICAgX3RoaXMuaGFuZGxlQ2xvc2VTbmFjayA9IGZ1bmN0aW9uIChldmVudCwgcmVhc29uLCBrZXkpIHtcbiAgICAgIC8vIHNob3VsZCBub3QgdXNlIGNyZWF0ZUNoYWluZWRGdW5jdGlvbiBmb3Igb25DbG9zZS5cbiAgICAgIC8vIGJlY2F1c2UgdGhpcy5jbG9zZVNuYWNrYmFyIGNhbGxlZCB0aGlzIGZ1bmN0aW9uXG4gICAgICBpZiAoX3RoaXMucHJvcHMub25DbG9zZSkge1xuICAgICAgICBfdGhpcy5wcm9wcy5vbkNsb3NlKGV2ZW50LCByZWFzb24sIGtleSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBzaG91bGRDbG9zZUFsbCA9IGtleSA9PT0gdW5kZWZpbmVkO1xuXG4gICAgICBfdGhpcy5zZXRTdGF0ZShmdW5jdGlvbiAoX3JlZjIpIHtcbiAgICAgICAgdmFyIHNuYWNrcyA9IF9yZWYyLnNuYWNrcyxcbiAgICAgICAgICAgIHF1ZXVlID0gX3JlZjIucXVldWU7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc25hY2tzOiBzbmFja3MubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICBpZiAoIXNob3VsZENsb3NlQWxsICYmIGl0ZW0uaWQgIT09IGtleSkge1xuICAgICAgICAgICAgICByZXR1cm4gX2V4dGVuZHMoe30sIGl0ZW0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gaXRlbS5lbnRlcmVkID8gX2V4dGVuZHMoe30sIGl0ZW0sIHtcbiAgICAgICAgICAgICAgb3BlbjogZmFsc2VcbiAgICAgICAgICAgIH0pIDogX2V4dGVuZHMoe30sIGl0ZW0sIHtcbiAgICAgICAgICAgICAgcmVxdWVzdENsb3NlOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBxdWV1ZTogcXVldWUuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbS5pZCAhPT0ga2V5O1xuICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxyXG4gICAgICogQ2xvc2Ugc25hY2tiYXIgd2l0aCB0aGUgZ2l2ZW4ga2V5XHJcbiAgICAgKi9cblxuXG4gICAgX3RoaXMuY2xvc2VTbmFja2JhciA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIC8vIGNhbGwgaW5kaXZpZHVhbCBzbmFja2JhciBvbkNsb3NlIGNhbGxiYWNrIHBhc3NlZCB0aHJvdWdoIG9wdGlvbnMgcGFyYW1ldGVyXG4gICAgICB2YXIgdG9CZUNsb3NlZCA9IF90aGlzLnN0YXRlLnNuYWNrcy5maW5kKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHJldHVybiBpdGVtLmlkID09PSBrZXk7XG4gICAgICB9KTtcblxuICAgICAgaWYgKGlzRGVmaW5lZChrZXkpICYmIHRvQmVDbG9zZWQgJiYgdG9CZUNsb3NlZC5vbkNsb3NlKSB7XG4gICAgICAgIHRvQmVDbG9zZWQub25DbG9zZShudWxsLCAnaW5zdHJ1Y3RlZCcsIGtleSk7XG4gICAgICB9XG5cbiAgICAgIF90aGlzLmhhbmRsZUNsb3NlU25hY2sobnVsbCwgJ2luc3RydWN0ZWQnLCBrZXkpO1xuICAgIH07XG4gICAgLyoqXHJcbiAgICAgKiBXaGVuIHdlIHNldCBvcGVuIGF0dHJpYnV0ZSBvZiBhIHNuYWNrYmFyIHRvIGZhbHNlIChpLmUuIGFmdGVyIHdlIGhpZGUgYSBzbmFja2JhciksXHJcbiAgICAgKiBpdCBsZWF2ZXMgdGhlIHNjcmVlbiBhbmQgaW1tZWRpYXRlbHkgYWZ0ZXIgbGVhdmluZyBhbmltYXRpb24gaXMgZG9uZSwgdGhpcyBtZXRob2RcclxuICAgICAqIGdldHMgY2FsbGVkLiBXZSByZW1vdmUgdGhlIGhpZGRlbiBzbmFja2JhciBmcm9tIHN0YXRlIGFuZCB0aGVuIGRpc3BsYXkgbm90aWZpY2F0aW9uc1xyXG4gICAgICogd2FpdGluZyBpbiB0aGUgcXVldWUgKGlmIGFueSkuIElmIGFmdGVyIHRoaXMgcHJvY2VzcyB0aGUgcXVldWUgaXMgbm90IGVtcHR5LCB0aGVcclxuICAgICAqIG9sZGVzdCBtZXNzYWdlIGlzIGRpc21pc3NlZC5cclxuICAgICAqL1xuXG5cbiAgICBfdGhpcy5oYW5kbGVFeGl0ZWRTbmFjayA9IGZ1bmN0aW9uIChub2RlLCBrZXkpIHtcbiAgICAgIGlmICghaXNEZWZpbmVkKGtleSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoYW5kbGVFeGl0ZWRTbmFjayBDYW5ub3QgYmUgY2FsbGVkIHdpdGggdW5kZWZpbmVkIGtleScpO1xuICAgICAgfVxuXG4gICAgICBfdGhpcy5zZXRTdGF0ZShmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgdmFyIG5ld1N0YXRlID0gX3RoaXMucHJvY2Vzc1F1ZXVlKF9leHRlbmRzKHt9LCBzdGF0ZSwge1xuICAgICAgICAgIHNuYWNrczogc3RhdGUuc25hY2tzLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW0uaWQgIT09IGtleTtcbiAgICAgICAgICB9KVxuICAgICAgICB9KSk7XG5cbiAgICAgICAgaWYgKG5ld1N0YXRlLnF1ZXVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBuZXdTdGF0ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBfdGhpcy5oYW5kbGVEaXNtaXNzT2xkZXN0KG5ld1N0YXRlKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBlbnF1ZXVlU25hY2tiYXIgPSBfdGhpcy5lbnF1ZXVlU25hY2tiYXI7XG4gICAgY2xvc2VTbmFja2JhciA9IF90aGlzLmNsb3NlU25hY2tiYXI7XG4gICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICBzbmFja3M6IFtdLFxuICAgICAgcXVldWU6IFtdLFxuICAgICAgY29udGV4dFZhbHVlOiB7XG4gICAgICAgIGVucXVldWVTbmFja2JhcjogX3RoaXMuZW5xdWV1ZVNuYWNrYmFyLmJpbmQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpLFxuICAgICAgICBjbG9zZVNuYWNrYmFyOiBfdGhpcy5jbG9zZVNuYWNrYmFyLmJpbmQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpXG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gU25hY2tiYXJQcm92aWRlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIHZhciBjb250ZXh0VmFsdWUgPSB0aGlzLnN0YXRlLmNvbnRleHRWYWx1ZTtcbiAgICB2YXIgX3RoaXMkcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgICAgICBkb21Sb290ID0gX3RoaXMkcHJvcHMuZG9tUm9vdCxcbiAgICAgICAgY2hpbGRyZW4gPSBfdGhpcyRwcm9wcy5jaGlsZHJlbixcbiAgICAgICAgX3RoaXMkcHJvcHMkZGVuc2UgPSBfdGhpcyRwcm9wcy5kZW5zZSxcbiAgICAgICAgZGVuc2UgPSBfdGhpcyRwcm9wcyRkZW5zZSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfdGhpcyRwcm9wcyRkZW5zZSxcbiAgICAgICAgX3RoaXMkcHJvcHMkQ29tcG9uZW50ID0gX3RoaXMkcHJvcHMuQ29tcG9uZW50cyxcbiAgICAgICAgQ29tcG9uZW50cyA9IF90aGlzJHByb3BzJENvbXBvbmVudCA9PT0gdm9pZCAwID8ge30gOiBfdGhpcyRwcm9wcyRDb21wb25lbnQsXG4gICAgICAgIGNsYXNzZXMgPSBfdGhpcyRwcm9wcy5jbGFzc2VzO1xuICAgIHZhciBjYXRlZyA9IHRoaXMuc3RhdGUuc25hY2tzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBjdXJyZW50KSB7XG4gICAgICB2YXIgX2V4dGVuZHMyO1xuXG4gICAgICB2YXIgY2F0ZWdvcnkgPSBvcmlnaW5LZXlFeHRyYWN0b3IoY3VycmVudC5hbmNob3JPcmlnaW4pO1xuICAgICAgdmFyIGV4aXN0aW5nT2ZDYXRlZ29yeSA9IGFjY1tjYXRlZ29yeV0gfHwgW107XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIGFjYywgKF9leHRlbmRzMiA9IHt9LCBfZXh0ZW5kczJbY2F0ZWdvcnldID0gW10uY29uY2F0KGV4aXN0aW5nT2ZDYXRlZ29yeSwgW2N1cnJlbnRdKSwgX2V4dGVuZHMyKSk7XG4gICAgfSwge30pO1xuICAgIHZhciBzbmFja2JhcnMgPSBPYmplY3Qua2V5cyhjYXRlZykubWFwKGZ1bmN0aW9uIChvcmlnaW4pIHtcbiAgICAgIHZhciBzbmFja3MgPSBjYXRlZ1tvcmlnaW5dO1xuICAgICAgdmFyIG5vbWluZWVTbmFjayA9IHNuYWNrc1swXTtcbiAgICAgIHJldHVybiBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFNuYWNrYmFyQ29udGFpbmVyJDEsIHtcbiAgICAgICAga2V5OiBvcmlnaW4sXG4gICAgICAgIGRlbnNlOiBkZW5zZSxcbiAgICAgICAgYW5jaG9yT3JpZ2luOiBub21pbmVlU25hY2suYW5jaG9yT3JpZ2luLFxuICAgICAgICBjbGFzc2VzOiBjbGFzc2VzXG4gICAgICB9LCBzbmFja3MubWFwKGZ1bmN0aW9uIChzbmFjaykge1xuICAgICAgICByZXR1cm4gUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChTbmFja2Jhckl0ZW0sIHtcbiAgICAgICAgICBrZXk6IHNuYWNrLmlkLFxuICAgICAgICAgIHNuYWNrOiBzbmFjayxcbiAgICAgICAgICBjbGFzc2VzOiBjbGFzc2VzLFxuICAgICAgICAgIENvbXBvbmVudDogQ29tcG9uZW50c1tzbmFjay52YXJpYW50XSxcbiAgICAgICAgICBvbkNsb3NlOiBfdGhpczIuaGFuZGxlQ2xvc2VTbmFjayxcbiAgICAgICAgICBvbkVudGVyOiBfdGhpczIucHJvcHMub25FbnRlcixcbiAgICAgICAgICBvbkV4aXQ6IF90aGlzMi5wcm9wcy5vbkV4aXQsXG4gICAgICAgICAgb25FeGl0ZWQ6IGNyZWF0ZUNoYWluZWRGdW5jdGlvbihbX3RoaXMyLmhhbmRsZUV4aXRlZFNuYWNrLCBfdGhpczIucHJvcHMub25FeGl0ZWRdLCBzbmFjay5pZCksXG4gICAgICAgICAgb25FbnRlcmVkOiBjcmVhdGVDaGFpbmVkRnVuY3Rpb24oW190aGlzMi5oYW5kbGVFbnRlcmVkU25hY2ssIF90aGlzMi5wcm9wcy5vbkVudGVyZWRdLCBzbmFjay5pZClcbiAgICAgICAgfSk7XG4gICAgICB9KSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoU25hY2tiYXJDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICB2YWx1ZTogY29udGV4dFZhbHVlXG4gICAgfSwgY2hpbGRyZW4sIGRvbVJvb3QgPyBjcmVhdGVQb3J0YWwoc25hY2tiYXJzLCBkb21Sb290KSA6IHNuYWNrYmFycyk7XG4gIH07XG5cbiAgX2NyZWF0ZUNsYXNzKFNuYWNrYmFyUHJvdmlkZXIsIFt7XG4gICAga2V5OiBcIm1heFNuYWNrXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcm9wcy5tYXhTbmFjayB8fCBkZWZhdWx0cy5tYXhTbmFjaztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU25hY2tiYXJQcm92aWRlcjtcbn0oQ29tcG9uZW50KTtcblxudmFyIHVzZVNuYWNrYmFyID0gKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHVzZUNvbnRleHQoU25hY2tiYXJDb250ZXh0KTtcbn0pO1xuXG5leHBvcnQgeyBNYXRlcmlhbERlc2lnbkNvbnRlbnQkMSBhcyBNYXRlcmlhbERlc2lnbkNvbnRlbnQsIFNuYWNrYmFyQ29udGVudCwgU25hY2tiYXJQcm92aWRlciwgVHJhbnNpdGlvbiwgY2xvc2VTbmFja2JhciwgZW5xdWV1ZVNuYWNrYmFyLCB1c2VTbmFja2JhciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bm90aXN0YWNrLmVzbS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/notistack/notistack.esm.js\n");

/***/ })

};
;