"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/graphql-jit";
exports.ids = ["vendor-chunks/graphql-jit"];
exports.modules = {

/***/ "(ssr)/../node_modules/graphql-jit/dist/esm/ast.js":
/*!***************************************************!*\
  !*** ../node_modules/graphql-jit/dist/esm/ast.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.joinSkipIncludePath = exports.serializeObjectPathForSkipInclude = exports.flattenPath = exports.addPath = exports.computeLocations = exports.valueFromAST = exports.getArgumentDefs = exports.collectSubfields = exports.resolveFieldDef = exports.collectFields = void 0;\nconst generate_function_1 = __importDefault(__webpack_require__(/*! generate-function */ \"(ssr)/../node_modules/generate-function/index.js\"));\nconst graphql_1 = __webpack_require__(/*! graphql */ \"(ssr)/../node_modules/graphql/index.mjs\");\nconst language_1 = __webpack_require__(/*! graphql/language */ \"(ssr)/../node_modules/graphql/language/index.js\");\nconst type_1 = __webpack_require__(/*! graphql/type */ \"(ssr)/../node_modules/graphql/type/index.js\");\nconst execution_1 = __webpack_require__(/*! ./execution */ \"(ssr)/../node_modules/graphql-jit/dist/esm/execution.js\");\nconst inspect_1 = __importDefault(__webpack_require__(/*! ./inspect */ \"(ssr)/../node_modules/graphql-jit/dist/esm/inspect.js\"));\nconst compat_1 = __webpack_require__(/*! ./compat */ \"(ssr)/../node_modules/graphql-jit/dist/esm/compat.js\");\nObject.defineProperty(exports, \"resolveFieldDef\", ({ enumerable: true, get: function () { return compat_1.resolveFieldDef; } }));\nconst inspect = (0, inspect_1.default)();\n/**\n * Given a selectionSet, adds all of the fields in that selection to\n * the passed in map of fields, and returns it at the end.\n *\n * CollectFields requires the \"runtime type\" of an object. For a field which\n * returns an Interface or Union type, the \"runtime type\" will be the actual\n * Object type returned by that field.\n */\nfunction collectFields(compilationContext, runtimeType, selectionSet, fields, visitedFragmentNames, parentResponsePath) {\n    return collectFieldsImpl(compilationContext, runtimeType, selectionSet, fields, visitedFragmentNames, undefined, serializeObjectPathForSkipInclude(parentResponsePath));\n}\nexports.collectFields = collectFields;\n/**\n * Implementation of collectFields defined above with extra parameters\n * used for recursion and need not be exposed publically\n */\nfunction collectFieldsImpl(compilationContext, runtimeType, selectionSet, fields, visitedFragmentNames, previousShouldInclude = \"\", parentResponsePath = \"\") {\n    for (const selection of selectionSet.selections) {\n        switch (selection.kind) {\n            case language_1.Kind.FIELD: {\n                const name = getFieldEntryKey(selection);\n                if (!fields[name]) {\n                    fields[name] = [];\n                }\n                const fieldNode = selection;\n                // the current path of the field\n                // This is used to generate per path skip/include code\n                // because the same field can be reached from different paths (e.g. fragment reuse)\n                const currentPath = joinSkipIncludePath(parentResponsePath, \n                // use alias(instead of selection.name.value) if available as the responsePath used for lookup uses alias\n                name);\n                // `should include`s generated for the current fieldNode\n                const compiledSkipInclude = compileSkipInclude(compilationContext, selection);\n                /**\n                 * Carry over fragment's skip and include code\n                 *\n                 * fieldNode.__internalShouldInclude\n                 * ---------------------------------\n                 * When the parent field has a skip or include, the current one\n                 * should be skipped if the parent is skipped in the path.\n                 *\n                 * previousShouldInclude\n                 * ---------------------\n                 * `should include`s from fragment spread and inline fragments\n                 *\n                 * compileSkipInclude(selection)\n                 * -----------------------------\n                 * `should include`s generated for the current fieldNode\n                 */\n                if (compilationContext.options.useExperimentalPathBasedSkipInclude) {\n                    if (!fieldNode.__internalShouldIncludePath)\n                        fieldNode.__internalShouldIncludePath = {};\n                    fieldNode.__internalShouldIncludePath[currentPath] =\n                        joinShouldIncludeCompilations(fieldNode.__internalShouldIncludePath?.[currentPath] ?? \"\", previousShouldInclude, compiledSkipInclude);\n                }\n                else {\n                    // @deprecated\n                    fieldNode.__internalShouldInclude = joinShouldIncludeCompilations(fieldNode.__internalShouldInclude ?? \"\", previousShouldInclude, compiledSkipInclude);\n                }\n                /**\n                 * We augment the entire subtree as the parent object's skip/include\n                 * directives influence the child even if the child doesn't have\n                 * skip/include on it's own.\n                 *\n                 * Refer the function definition for example.\n                 */\n                augmentFieldNodeTree(compilationContext, fieldNode, currentPath);\n                fields[name].push(fieldNode);\n                break;\n            }\n            case language_1.Kind.INLINE_FRAGMENT: {\n                if (!doesFragmentConditionMatch(compilationContext, selection, runtimeType)) {\n                    continue;\n                }\n                // current fragment's shouldInclude\n                const compiledSkipInclude = compileSkipInclude(compilationContext, selection);\n                // recurse\n                collectFieldsImpl(compilationContext, runtimeType, selection.selectionSet, fields, visitedFragmentNames, joinShouldIncludeCompilations(\n                // `should include`s from previous fragments\n                previousShouldInclude, \n                // current fragment's shouldInclude\n                compiledSkipInclude), parentResponsePath);\n                break;\n            }\n            case language_1.Kind.FRAGMENT_SPREAD: {\n                const fragName = selection.name.value;\n                if (visitedFragmentNames[fragName]) {\n                    continue;\n                }\n                visitedFragmentNames[fragName] = true;\n                const fragment = compilationContext.fragments[fragName];\n                if (!fragment ||\n                    !doesFragmentConditionMatch(compilationContext, fragment, runtimeType)) {\n                    continue;\n                }\n                // current fragment's shouldInclude\n                const compiledSkipInclude = compileSkipInclude(compilationContext, selection);\n                // recurse\n                collectFieldsImpl(compilationContext, runtimeType, fragment.selectionSet, fields, visitedFragmentNames, joinShouldIncludeCompilations(\n                // `should include`s from previous fragments\n                previousShouldInclude, \n                // current fragment's shouldInclude\n                compiledSkipInclude), parentResponsePath);\n                break;\n            }\n        }\n    }\n    return fields;\n}\n/**\n * Augment __internalShouldInclude code for all sub-fields in the\n * tree with @param rootfieldNode as the root.\n *\n * This is required to handle cases where there are multiple paths to\n * the same node. And each of those paths contain different skip/include\n * values.\n *\n * For example,\n *\n * ```\n * {\n *   foo @skip(if: $c1) {\n *     bar @skip(if: $c2)\n *   }\n *   ... {\n *     foo @skip(if: $c3) {\n *       bar\n *     }\n *   }\n * }\n * ```\n *\n * We decide shouldInclude at runtime per fieldNode. When we handle the\n * field `foo`, the logic is straight forward - it requires one of $c1 or $c3\n * to be false.\n *\n * But, when we handle the field `bar`, and we are in the context of the fieldNode,\n * not enough information is available. This is because, if we only included $c2\n * to decide if bar is included, consider the case -\n *\n * $c1: true, $c2: true, $c3: false\n *\n * If we considered only $c2, we would have skipped bar. But the correct implementation\n * is to include bar, because foo($c3) { bar } is not skipped. The entire sub-tree's\n * logic is required to handle bar.\n *\n * So, to handle this case, we augment the tree at each point to consider the\n * skip/include logic from the parent as well.\n *\n * @param compilationContext {CompilationContext} Required for getFragment by\n * name to handle fragment spread operation.\n *\n * @param rootFieldNode {JitFieldNode} The root field to traverse from for\n * adding __internalShouldInclude to all sub field nodes.\n *\n * @param parentResponsePath {string} The response path of the parent field.\n */\nfunction augmentFieldNodeTree(compilationContext, rootFieldNode, parentResponsePath) {\n    for (const selection of rootFieldNode.selectionSet?.selections ?? []) {\n        handle(rootFieldNode, selection, false, parentResponsePath);\n    }\n    /**\n     * Recursively traverse through sub-selection and combine `shouldInclude`s\n     * from parent and current ones.\n     */\n    function handle(parentFieldNode, selection, comesFromFragmentSpread = false, parentResponsePath) {\n        switch (selection.kind) {\n            case language_1.Kind.FIELD: {\n                const jitFieldNode = selection;\n                const currentPath = joinSkipIncludePath(parentResponsePath, \n                // use alias(instead of selection.name.value) if available as the responsePath used for lookup uses alias\n                getFieldEntryKey(jitFieldNode));\n                if (!comesFromFragmentSpread) {\n                    if (compilationContext.options.useExperimentalPathBasedSkipInclude) {\n                        if (!jitFieldNode.__internalShouldIncludePath)\n                            jitFieldNode.__internalShouldIncludePath = {};\n                        jitFieldNode.__internalShouldIncludePath[currentPath] =\n                            joinShouldIncludeCompilations(parentFieldNode.__internalShouldIncludePath?.[parentResponsePath] ?? \"\", jitFieldNode.__internalShouldIncludePath?.[currentPath] ?? \"\");\n                    }\n                    else {\n                        // @deprecated\n                        jitFieldNode.__internalShouldInclude =\n                            joinShouldIncludeCompilations(parentFieldNode.__internalShouldInclude ?? \"\", jitFieldNode.__internalShouldInclude ?? \"\");\n                    }\n                }\n                // go further down the query tree\n                for (const selection of jitFieldNode.selectionSet?.selections ?? []) {\n                    handle(jitFieldNode, selection, false, currentPath);\n                }\n                break;\n            }\n            case language_1.Kind.INLINE_FRAGMENT: {\n                for (const subSelection of selection.selectionSet.selections) {\n                    handle(parentFieldNode, subSelection, true, parentResponsePath);\n                }\n                break;\n            }\n            case language_1.Kind.FRAGMENT_SPREAD: {\n                const fragment = compilationContext.fragments[selection.name.value];\n                for (const subSelection of fragment.selectionSet.selections) {\n                    handle(parentFieldNode, subSelection, true, parentResponsePath);\n                }\n            }\n        }\n    }\n}\n/**\n * Joins a list of shouldInclude compiled code into a single logical\n * statement.\n *\n * The operation is `&&` because, it is used to join parent->child\n * relations in the query tree. Note: parent can be either parent field\n * or fragment.\n *\n * For example,\n * {\n *   foo @skip(if: $c1) {\n *     ... @skip(if: $c2) {\n *       bar @skip(if: $c3)\n *     }\n *   }\n * }\n *\n * Only when a parent is included, the child is included. So, we use `&&`.\n *\n * compilationFor($c1) && compilationFor($c2) && compilationFor($c3)\n *\n * @param compilations\n */\nfunction joinShouldIncludeCompilations(...compilations) {\n    // remove \"true\" since we are joining with '&&' as `true && X` = `X`\n    // This prevents an explosion of `&& true` which could break\n    // V8's internal size limit for string.\n    //\n    // Note: the `true` appears if a field does not have a skip/include directive\n    // So, the more nested the query is, the more of unnecessary `&& true`\n    // we get.\n    //\n    // Failing to do this results in [RangeError: invalid array length]\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Invalid_array_length\n    // remove empty strings\n    let filteredCompilations = compilations.filter((it) => it);\n    // Split conditions by && and flatten it\n    filteredCompilations = [].concat(...filteredCompilations.map((e) => e.split(\" && \").map((it) => it.trim())));\n    // Deduplicate items\n    filteredCompilations = Array.from(new Set(filteredCompilations));\n    return filteredCompilations.join(\" && \");\n}\n/**\n * Compiles directives `skip` and `include` and generates the compilation\n * code based on GraphQL specification.\n *\n * @param node {SelectionNode} The selection node (field/fragment/inline-fragment)\n * for which we generate the compiled skipInclude.\n */\nfunction compileSkipInclude(compilationContext, node) {\n    const gen = (0, generate_function_1.default)();\n    const { skipValue, includeValue } = compileSkipIncludeDirectiveValues(compilationContext, node);\n    /**\n     * Spec: https://spec.graphql.org/June2018/#sec--include\n     *\n     * Neither @skip nor @include has precedence over the other.\n     * In the case that both the @skip and @include directives\n     * are provided in on the same the field or fragment, it must\n     * be queried only if the @skip condition is false and the\n     * @include condition is true. Stated conversely, the field\n     * or fragment must not be queried if either the @skip\n     * condition is true or the @include condition is false.\n     */\n    if (skipValue != null && includeValue != null) {\n        gen(`${skipValue} === false && ${includeValue} === true`);\n    }\n    else if (skipValue != null) {\n        gen(`(${skipValue} === false)`);\n    }\n    else if (includeValue != null) {\n        gen(`(${includeValue} === true)`);\n    }\n    else {\n        gen(`true`);\n    }\n    return gen.toString();\n}\n/**\n * Compile skip or include directive values into JIT compatible\n * runtime code.\n *\n * @param node {SelectionNode}\n */\nfunction compileSkipIncludeDirectiveValues(compilationContext, node) {\n    const skipDirective = node.directives?.find((it) => it.name.value === graphql_1.GraphQLSkipDirective.name);\n    const includeDirective = node.directives?.find((it) => it.name.value === graphql_1.GraphQLIncludeDirective.name);\n    const skipValue = skipDirective\n        ? compileSkipIncludeDirective(compilationContext, skipDirective)\n        : // The null here indicates the absense of the directive\n            // which is later used to determine if both skip and include\n            // are present\n            null;\n    const includeValue = includeDirective\n        ? compileSkipIncludeDirective(compilationContext, includeDirective)\n        : // The null here indicates the absense of the directive\n            // which is later used to determine if both skip and include\n            // are present\n            null;\n    return { skipValue, includeValue };\n}\n/**\n * Compile the skip/include directive node. Resolve variables to it's\n * path from context, resolve scalars to their respective values.\n *\n * @param directive {DirectiveNode}\n */\nfunction compileSkipIncludeDirective(compilationContext, directive) {\n    const ifNode = directive.arguments?.find((it) => it.name.value === \"if\");\n    if (ifNode == null) {\n        throw new graphql_1.GraphQLError(`Directive '${directive.name.value}' is missing required arguments: 'if'`, (0, compat_1.getGraphQLErrorOptions)([directive]));\n    }\n    switch (ifNode.value.kind) {\n        case language_1.Kind.VARIABLE:\n            validateSkipIncludeVariableType(compilationContext, ifNode.value);\n            return `${execution_1.GLOBAL_VARIABLES_NAME}[\"${ifNode.value.name.value}\"]`;\n        case language_1.Kind.BOOLEAN:\n            return `${ifNode.value.value.toString()}`;\n        default:\n            throw new graphql_1.GraphQLError(`Argument 'if' on Directive '${directive.name.value}' has an invalid value (${(0, graphql_1.valueFromASTUntyped)(ifNode.value)}). Expected type 'Boolean!'`, (0, compat_1.getGraphQLErrorOptions)([ifNode]));\n    }\n}\n/**\n * Validate the skip and include directive's argument values at compile time.\n *\n * This validation step is required as these directives are part of an\n * implicit schema in GraphQL.\n *\n * @param compilationContext {CompilationContext}\n * @param variable {VariableNode} the variable used in 'if' argument of the skip/include directive\n */\nfunction validateSkipIncludeVariableType(compilationContext, variable) {\n    const variableDefinition = compilationContext.operation.variableDefinitions?.find((it) => it.variable.name.value === variable.name.value);\n    if (variableDefinition == null) {\n        throw new graphql_1.GraphQLError(`Variable '${variable.name.value}' is not defined`, (0, compat_1.getGraphQLErrorOptions)([variable]));\n    }\n    // Part of Spec text: https://spec.graphql.org/June2018/#sec-All-Variable-Usages-are-Allowed\n    if (!(\n    // The variable defintion is a Non-nullable Boolean type\n    ((variableDefinition.type.kind === language_1.Kind.NON_NULL_TYPE &&\n        variableDefinition.type.type.kind === language_1.Kind.NAMED_TYPE &&\n        variableDefinition.type.type.name.value === \"Boolean\") ||\n        // or the variable definition is a nullable Boolean type with a default value\n        (variableDefinition.type.kind === language_1.Kind.NAMED_TYPE &&\n            variableDefinition.type.name.value === \"Boolean\" &&\n            variableDefinition.defaultValue != null)))) {\n        throw new graphql_1.GraphQLError(`Variable '${variable.name.value}' of type '${typeNodeToString(variableDefinition.type)}' used in position expecting type 'Boolean!'`, (0, compat_1.getGraphQLErrorOptions)([variableDefinition]));\n    }\n}\n/**\n * Print the string representation of the TypeNode for error messages\n *\n * @param type {TypeNode} type node to be converted to string representation\n */\nfunction typeNodeToString(type) {\n    switch (type.kind) {\n        case language_1.Kind.NAMED_TYPE:\n            return type.name.value;\n        case language_1.Kind.NON_NULL_TYPE:\n            return `${typeNodeToString(type.type)}!`;\n        case language_1.Kind.LIST_TYPE:\n            return `[${typeNodeToString(type.type)}]`;\n    }\n}\n/**\n * Determines if a fragment is applicable to the given type.\n */\nfunction doesFragmentConditionMatch(compilationContext, fragment, type) {\n    const typeConditionNode = fragment.typeCondition;\n    if (!typeConditionNode) {\n        return true;\n    }\n    const conditionalType = (0, graphql_1.typeFromAST)(compilationContext.schema, typeConditionNode);\n    if (conditionalType === type) {\n        return true;\n    }\n    if (!conditionalType) {\n        return false;\n    }\n    if ((0, type_1.isAbstractType)(conditionalType)) {\n        return compilationContext.schema.isSubType(conditionalType, type);\n    }\n    return false;\n}\n/**\n * Implements the logic to compute the key of a given field's entry\n */\nfunction getFieldEntryKey(node) {\n    return node.alias ? node.alias.value : node.name.value;\n}\nfunction collectSubfields(compilationContext, returnType, fieldNodes, parentResponsePath) {\n    let subFieldNodes = Object.create(null);\n    const visitedFragmentNames = Object.create(null);\n    for (const fieldNode of fieldNodes) {\n        const selectionSet = fieldNode.selectionSet;\n        if (selectionSet) {\n            subFieldNodes = collectFields(compilationContext, returnType, selectionSet, subFieldNodes, visitedFragmentNames, parentResponsePath);\n        }\n    }\n    return subFieldNodes;\n}\nexports.collectSubfields = collectSubfields;\n/**\n * Prepares an object map of argument values given a list of argument\n * definitions and list of argument AST nodes.\n *\n * Note: The returned value is a plain Object with a prototype, since it is\n * exposed to user code. Care should be taken to not pull values from the\n * Object prototype.\n */\nfunction getArgumentDefs(def, node) {\n    const values = {};\n    const missing = [];\n    const argDefs = def.args;\n    const argNodes = node.arguments || [];\n    const argNodeMap = keyMap(argNodes, (arg) => arg.name.value);\n    for (const argDef of argDefs) {\n        const name = argDef.name;\n        if (argDef.defaultValue !== undefined) {\n            // Set the coerced value to the default\n            values[name] = argDef.defaultValue;\n        }\n        const argType = argDef.type;\n        const argumentNode = argNodeMap[name];\n        let hasVariables = false;\n        if (argumentNode && argumentNode.value.kind === language_1.Kind.VARIABLE) {\n            hasVariables = true;\n            missing.push({\n                valueNode: argumentNode.value,\n                path: addPath(undefined, name, \"literal\"),\n                argument: { definition: argDef, node: argumentNode }\n            });\n        }\n        else if (argumentNode) {\n            const coercedValue = valueFromAST(argumentNode.value, argType);\n            if (coercedValue === undefined) {\n                // Note: ValuesOfCorrectType validation should catch this before\n                // execution. This is a runtime check to ensure execution does not\n                // continue with an invalid argument value.\n                throw new graphql_1.GraphQLError(`Argument \"${name}\" of type \"${argType}\" has invalid value ${(0, graphql_1.print)(argumentNode.value)}.`, (0, compat_1.getGraphQLErrorOptions)(argumentNode.value));\n            }\n            if (isASTValueWithVariables(coercedValue)) {\n                missing.push(...coercedValue.variables.map(({ valueNode, path }) => ({\n                    valueNode,\n                    path: addPath(path, name, \"literal\")\n                })));\n            }\n            values[name] = coercedValue.value;\n        }\n        if ((0, graphql_1.isNonNullType)(argType) && values[name] === undefined && !hasVariables) {\n            // If no value or a nullish value was provided to a variable with a\n            // non-null type (required), produce an error.\n            throw new graphql_1.GraphQLError(argumentNode\n                ? `Argument \"${name}\" of non-null type ` +\n                    `\"${argType}\" must not be null.`\n                : `Argument \"${name}\" of required type ` +\n                    `\"${argType}\" was not provided.`, (0, compat_1.getGraphQLErrorOptions)(node));\n        }\n    }\n    return { values, missing };\n}\nexports.getArgumentDefs = getArgumentDefs;\nfunction isASTValueWithVariables(x) {\n    return !!x.variables;\n}\nfunction valueFromAST(valueNode, type) {\n    if ((0, graphql_1.isNonNullType)(type)) {\n        if (valueNode.kind === language_1.Kind.NULL) {\n            return; // Invalid: intentionally return no value.\n        }\n        return valueFromAST(valueNode, type.ofType);\n    }\n    if (valueNode.kind === language_1.Kind.NULL) {\n        // This is explicitly returning the value null.\n        return {\n            value: null\n        };\n    }\n    if (valueNode.kind === language_1.Kind.VARIABLE) {\n        return { value: null, variables: [{ valueNode, path: undefined }] };\n    }\n    if ((0, graphql_1.isListType)(type)) {\n        const itemType = type.ofType;\n        if (valueNode.kind === language_1.Kind.LIST) {\n            const coercedValues = [];\n            const variables = [];\n            const itemNodes = valueNode.values;\n            for (let i = 0; i < itemNodes.length; i++) {\n                const itemNode = itemNodes[i];\n                if (itemNode.kind === language_1.Kind.VARIABLE) {\n                    coercedValues.push(null);\n                    variables.push({\n                        valueNode: itemNode,\n                        path: addPath(undefined, i.toString(), \"literal\")\n                    });\n                }\n                else {\n                    const itemValue = valueFromAST(itemNode, itemType);\n                    if (!itemValue) {\n                        return; // Invalid: intentionally return no value.\n                    }\n                    coercedValues.push(itemValue.value);\n                    if (isASTValueWithVariables(itemValue)) {\n                        variables.push(...itemValue.variables.map(({ valueNode, path }) => ({\n                            valueNode,\n                            path: addPath(path, i.toString(), \"literal\")\n                        })));\n                    }\n                }\n            }\n            return { value: coercedValues, variables };\n        }\n        // Single item which will be coerced to a list\n        const coercedValue = valueFromAST(valueNode, itemType);\n        if (coercedValue === undefined) {\n            return; // Invalid: intentionally return no value.\n        }\n        if (isASTValueWithVariables(coercedValue)) {\n            return {\n                value: [coercedValue.value],\n                variables: coercedValue.variables.map(({ valueNode, path }) => ({\n                    valueNode,\n                    path: addPath(path, \"0\", \"literal\")\n                }))\n            };\n        }\n        return { value: [coercedValue.value] };\n    }\n    if ((0, graphql_1.isInputObjectType)(type)) {\n        if (valueNode.kind !== language_1.Kind.OBJECT) {\n            return; // Invalid: intentionally return no value.\n        }\n        const coercedObj = Object.create(null);\n        const variables = [];\n        const fieldNodes = keyMap(valueNode.fields, (field) => field.name.value);\n        const fields = Object.values(type.getFields());\n        for (const field of fields) {\n            if (field.defaultValue !== undefined) {\n                coercedObj[field.name] = field.defaultValue;\n            }\n            const fieldNode = fieldNodes[field.name];\n            if (!fieldNode) {\n                continue;\n            }\n            const fieldValue = valueFromAST(fieldNode.value, field.type);\n            if (!fieldValue) {\n                return; // Invalid: intentionally return no value.\n            }\n            if (isASTValueWithVariables(fieldValue)) {\n                variables.push(...fieldValue.variables.map(({ valueNode, path }) => ({\n                    valueNode,\n                    path: addPath(path, field.name, \"literal\")\n                })));\n            }\n            coercedObj[field.name] = fieldValue.value;\n        }\n        return { value: coercedObj, variables };\n    }\n    if ((0, graphql_1.isEnumType)(type)) {\n        if (valueNode.kind !== language_1.Kind.ENUM) {\n            return; // Invalid: intentionally return no value.\n        }\n        const enumValue = type.getValue(valueNode.value);\n        if (!enumValue) {\n            return; // Invalid: intentionally return no value.\n        }\n        return { value: enumValue.value };\n    }\n    if ((0, graphql_1.isScalarType)(type)) {\n        // Scalars fulfill parsing a literal value via parseLiteral().\n        // Invalid values represent a failure to parse correctly, in which case\n        // no value is returned.\n        let result;\n        try {\n            if (type.parseLiteral.length > 1) {\n                // eslint-disable-next-line\n                console.error(\"Scalar with variable inputs detected for parsing AST literals. This is not supported.\");\n            }\n            result = type.parseLiteral(valueNode, {});\n        }\n        catch (error) {\n            return; // Invalid: intentionally return no value.\n        }\n        if (isInvalid(result)) {\n            return; // Invalid: intentionally return no value.\n        }\n        return { value: result };\n    }\n    // Not reachable. All possible input types have been considered.\n    /* istanbul ignore next */\n    throw new Error(`Unexpected input type: \"${inspect(type)}\".`);\n}\nexports.valueFromAST = valueFromAST;\n/**\n * Creates a keyed JS object from an array, given a function to produce the keys\n * for each value in the array.\n *\n * This provides a convenient lookup for the array items if the key function\n * produces unique results.\n *\n *     const phoneBook = [\n *       { name: 'Jon', num: '555-1234' },\n *       { name: 'Jenny', num: '867-5309' }\n *     ]\n *\n *     // { Jon: { name: 'Jon', num: '555-1234' },\n *     //   Jenny: { name: 'Jenny', num: '867-5309' } }\n *     const entriesByName = keyMap(\n *       phoneBook,\n *       entry => entry.name\n *     )\n *\n *     // { name: 'Jenny', num: '857-6309' }\n *     const jennyEntry = entriesByName['Jenny']\n *\n */\nfunction keyMap(list, keyFn) {\n    return list.reduce(\n    // eslint-disable-next-line no-sequences\n    (map, item) => ((map[keyFn(item)] = item), map), Object.create(null));\n}\nfunction computeLocations(nodes) {\n    return nodes.reduce((list, node) => {\n        if (node.loc) {\n            list.push((0, graphql_1.getLocation)(node.loc.source, node.loc.start));\n        }\n        return list;\n    }, []);\n}\nexports.computeLocations = computeLocations;\nfunction addPath(responsePath, key, type = \"literal\") {\n    return { prev: responsePath, key, type };\n}\nexports.addPath = addPath;\nfunction flattenPath(path) {\n    const flattened = [];\n    let curr = path;\n    while (curr) {\n        flattened.push({ key: curr.key, type: curr.type });\n        curr = curr.prev;\n    }\n    return flattened;\n}\nexports.flattenPath = flattenPath;\n/**\n * Serialize a path for use in the skip/include directives.\n *\n * @param path The path to serialize\n * @returns The path serialized as a string, with the root path first.\n */\nfunction serializeObjectPathForSkipInclude(path) {\n    let serialized = \"\";\n    let curr = path;\n    while (curr) {\n        if (curr.type === \"literal\") {\n            serialized = joinSkipIncludePath(curr.key, serialized);\n        }\n        curr = curr.prev;\n    }\n    return serialized;\n}\nexports.serializeObjectPathForSkipInclude = serializeObjectPathForSkipInclude;\n/**\n * join two path segments to a dot notation, handling empty strings\n *\n * @param a path segment\n * @param b path segment\n * @returns combined path in dot notation\n */\nfunction joinSkipIncludePath(a, b) {\n    if (a) {\n        if (b) {\n            return `${a}.${b}`;\n        }\n        return a;\n    }\n    return b;\n}\nexports.joinSkipIncludePath = joinSkipIncludePath;\nfunction isInvalid(value) {\n    // eslint-disable-next-line no-self-compare\n    return value === undefined || value !== value;\n}\n//# sourceMappingURL=ast.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL2dyYXBocWwtaml0L2Rpc3QvZXNtL2FzdC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDJCQUEyQixHQUFHLHlDQUF5QyxHQUFHLG1CQUFtQixHQUFHLGVBQWUsR0FBRyx3QkFBd0IsR0FBRyxvQkFBb0IsR0FBRyx1QkFBdUIsR0FBRyx3QkFBd0IsR0FBRyx1QkFBdUIsR0FBRyxxQkFBcUI7QUFDeFEsNENBQTRDLG1CQUFPLENBQUMsMkVBQW1CO0FBQ3ZFLGtCQUFrQixtQkFBTyxDQUFDLHdEQUFTO0FBQ25DLG1CQUFtQixtQkFBTyxDQUFDLHlFQUFrQjtBQUM3QyxlQUFlLG1CQUFPLENBQUMsaUVBQWM7QUFDckMsb0JBQW9CLG1CQUFPLENBQUMsNEVBQWE7QUFDekMsa0NBQWtDLG1CQUFPLENBQUMsd0VBQVc7QUFDckQsaUJBQWlCLG1CQUFPLENBQUMsc0VBQVU7QUFDbkMsbURBQWtELEVBQUUscUNBQXFDLG9DQUFvQyxFQUFDO0FBQzlIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLE1BQU07QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixvQkFBb0I7QUFDbEQ7QUFDQTtBQUNBLHlCQUF5QixjQUFjO0FBQ3ZDO0FBQ0E7QUFDQSw4QkFBOEIsUUFBUTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QjtBQUNBLGFBQWE7QUFDYjtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixnQ0FBZ0M7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixFQUFFLEdBQUcsRUFBRTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sZWRnaXR5LXlpZWxkLWZyb250ZW5kLy4uL25vZGVfbW9kdWxlcy9ncmFwaHFsLWppdC9kaXN0L2VzbS9hc3QuanM/ZDM4OCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuam9pblNraXBJbmNsdWRlUGF0aCA9IGV4cG9ydHMuc2VyaWFsaXplT2JqZWN0UGF0aEZvclNraXBJbmNsdWRlID0gZXhwb3J0cy5mbGF0dGVuUGF0aCA9IGV4cG9ydHMuYWRkUGF0aCA9IGV4cG9ydHMuY29tcHV0ZUxvY2F0aW9ucyA9IGV4cG9ydHMudmFsdWVGcm9tQVNUID0gZXhwb3J0cy5nZXRBcmd1bWVudERlZnMgPSBleHBvcnRzLmNvbGxlY3RTdWJmaWVsZHMgPSBleHBvcnRzLnJlc29sdmVGaWVsZERlZiA9IGV4cG9ydHMuY29sbGVjdEZpZWxkcyA9IHZvaWQgMDtcbmNvbnN0IGdlbmVyYXRlX2Z1bmN0aW9uXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImdlbmVyYXRlLWZ1bmN0aW9uXCIpKTtcbmNvbnN0IGdyYXBocWxfMSA9IHJlcXVpcmUoXCJncmFwaHFsXCIpO1xuY29uc3QgbGFuZ3VhZ2VfMSA9IHJlcXVpcmUoXCJncmFwaHFsL2xhbmd1YWdlXCIpO1xuY29uc3QgdHlwZV8xID0gcmVxdWlyZShcImdyYXBocWwvdHlwZVwiKTtcbmNvbnN0IGV4ZWN1dGlvbl8xID0gcmVxdWlyZShcIi4vZXhlY3V0aW9uXCIpO1xuY29uc3QgaW5zcGVjdF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2luc3BlY3RcIikpO1xuY29uc3QgY29tcGF0XzEgPSByZXF1aXJlKFwiLi9jb21wYXRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJyZXNvbHZlRmllbGREZWZcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbXBhdF8xLnJlc29sdmVGaWVsZERlZjsgfSB9KTtcbmNvbnN0IGluc3BlY3QgPSAoMCwgaW5zcGVjdF8xLmRlZmF1bHQpKCk7XG4vKipcbiAqIEdpdmVuIGEgc2VsZWN0aW9uU2V0LCBhZGRzIGFsbCBvZiB0aGUgZmllbGRzIGluIHRoYXQgc2VsZWN0aW9uIHRvXG4gKiB0aGUgcGFzc2VkIGluIG1hcCBvZiBmaWVsZHMsIGFuZCByZXR1cm5zIGl0IGF0IHRoZSBlbmQuXG4gKlxuICogQ29sbGVjdEZpZWxkcyByZXF1aXJlcyB0aGUgXCJydW50aW1lIHR5cGVcIiBvZiBhbiBvYmplY3QuIEZvciBhIGZpZWxkIHdoaWNoXG4gKiByZXR1cm5zIGFuIEludGVyZmFjZSBvciBVbmlvbiB0eXBlLCB0aGUgXCJydW50aW1lIHR5cGVcIiB3aWxsIGJlIHRoZSBhY3R1YWxcbiAqIE9iamVjdCB0eXBlIHJldHVybmVkIGJ5IHRoYXQgZmllbGQuXG4gKi9cbmZ1bmN0aW9uIGNvbGxlY3RGaWVsZHMoY29tcGlsYXRpb25Db250ZXh0LCBydW50aW1lVHlwZSwgc2VsZWN0aW9uU2V0LCBmaWVsZHMsIHZpc2l0ZWRGcmFnbWVudE5hbWVzLCBwYXJlbnRSZXNwb25zZVBhdGgpIHtcbiAgICByZXR1cm4gY29sbGVjdEZpZWxkc0ltcGwoY29tcGlsYXRpb25Db250ZXh0LCBydW50aW1lVHlwZSwgc2VsZWN0aW9uU2V0LCBmaWVsZHMsIHZpc2l0ZWRGcmFnbWVudE5hbWVzLCB1bmRlZmluZWQsIHNlcmlhbGl6ZU9iamVjdFBhdGhGb3JTa2lwSW5jbHVkZShwYXJlbnRSZXNwb25zZVBhdGgpKTtcbn1cbmV4cG9ydHMuY29sbGVjdEZpZWxkcyA9IGNvbGxlY3RGaWVsZHM7XG4vKipcbiAqIEltcGxlbWVudGF0aW9uIG9mIGNvbGxlY3RGaWVsZHMgZGVmaW5lZCBhYm92ZSB3aXRoIGV4dHJhIHBhcmFtZXRlcnNcbiAqIHVzZWQgZm9yIHJlY3Vyc2lvbiBhbmQgbmVlZCBub3QgYmUgZXhwb3NlZCBwdWJsaWNhbGx5XG4gKi9cbmZ1bmN0aW9uIGNvbGxlY3RGaWVsZHNJbXBsKGNvbXBpbGF0aW9uQ29udGV4dCwgcnVudGltZVR5cGUsIHNlbGVjdGlvblNldCwgZmllbGRzLCB2aXNpdGVkRnJhZ21lbnROYW1lcywgcHJldmlvdXNTaG91bGRJbmNsdWRlID0gXCJcIiwgcGFyZW50UmVzcG9uc2VQYXRoID0gXCJcIikge1xuICAgIGZvciAoY29uc3Qgc2VsZWN0aW9uIG9mIHNlbGVjdGlvblNldC5zZWxlY3Rpb25zKSB7XG4gICAgICAgIHN3aXRjaCAoc2VsZWN0aW9uLmtpbmQpIHtcbiAgICAgICAgICAgIGNhc2UgbGFuZ3VhZ2VfMS5LaW5kLkZJRUxEOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmFtZSA9IGdldEZpZWxkRW50cnlLZXkoc2VsZWN0aW9uKTtcbiAgICAgICAgICAgICAgICBpZiAoIWZpZWxkc1tuYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICBmaWVsZHNbbmFtZV0gPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgZmllbGROb2RlID0gc2VsZWN0aW9uO1xuICAgICAgICAgICAgICAgIC8vIHRoZSBjdXJyZW50IHBhdGggb2YgdGhlIGZpZWxkXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyB1c2VkIHRvIGdlbmVyYXRlIHBlciBwYXRoIHNraXAvaW5jbHVkZSBjb2RlXG4gICAgICAgICAgICAgICAgLy8gYmVjYXVzZSB0aGUgc2FtZSBmaWVsZCBjYW4gYmUgcmVhY2hlZCBmcm9tIGRpZmZlcmVudCBwYXRocyAoZS5nLiBmcmFnbWVudCByZXVzZSlcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50UGF0aCA9IGpvaW5Ta2lwSW5jbHVkZVBhdGgocGFyZW50UmVzcG9uc2VQYXRoLCBcbiAgICAgICAgICAgICAgICAvLyB1c2UgYWxpYXMoaW5zdGVhZCBvZiBzZWxlY3Rpb24ubmFtZS52YWx1ZSkgaWYgYXZhaWxhYmxlIGFzIHRoZSByZXNwb25zZVBhdGggdXNlZCBmb3IgbG9va3VwIHVzZXMgYWxpYXNcbiAgICAgICAgICAgICAgICBuYW1lKTtcbiAgICAgICAgICAgICAgICAvLyBgc2hvdWxkIGluY2x1ZGVgcyBnZW5lcmF0ZWQgZm9yIHRoZSBjdXJyZW50IGZpZWxkTm9kZVxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbXBpbGVkU2tpcEluY2x1ZGUgPSBjb21waWxlU2tpcEluY2x1ZGUoY29tcGlsYXRpb25Db250ZXh0LCBzZWxlY3Rpb24pO1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIENhcnJ5IG92ZXIgZnJhZ21lbnQncyBza2lwIGFuZCBpbmNsdWRlIGNvZGVcbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIGZpZWxkTm9kZS5fX2ludGVybmFsU2hvdWxkSW5jbHVkZVxuICAgICAgICAgICAgICAgICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgICAgICAqIFdoZW4gdGhlIHBhcmVudCBmaWVsZCBoYXMgYSBza2lwIG9yIGluY2x1ZGUsIHRoZSBjdXJyZW50IG9uZVxuICAgICAgICAgICAgICAgICAqIHNob3VsZCBiZSBza2lwcGVkIGlmIHRoZSBwYXJlbnQgaXMgc2tpcHBlZCBpbiB0aGUgcGF0aC5cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIHByZXZpb3VzU2hvdWxkSW5jbHVkZVxuICAgICAgICAgICAgICAgICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgICAgICAqIGBzaG91bGQgaW5jbHVkZWBzIGZyb20gZnJhZ21lbnQgc3ByZWFkIGFuZCBpbmxpbmUgZnJhZ21lbnRzXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBjb21waWxlU2tpcEluY2x1ZGUoc2VsZWN0aW9uKVxuICAgICAgICAgICAgICAgICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgICAgICAgICogYHNob3VsZCBpbmNsdWRlYHMgZ2VuZXJhdGVkIGZvciB0aGUgY3VycmVudCBmaWVsZE5vZGVcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBpZiAoY29tcGlsYXRpb25Db250ZXh0Lm9wdGlvbnMudXNlRXhwZXJpbWVudGFsUGF0aEJhc2VkU2tpcEluY2x1ZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmaWVsZE5vZGUuX19pbnRlcm5hbFNob3VsZEluY2x1ZGVQYXRoKVxuICAgICAgICAgICAgICAgICAgICAgICAgZmllbGROb2RlLl9faW50ZXJuYWxTaG91bGRJbmNsdWRlUGF0aCA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBmaWVsZE5vZGUuX19pbnRlcm5hbFNob3VsZEluY2x1ZGVQYXRoW2N1cnJlbnRQYXRoXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICBqb2luU2hvdWxkSW5jbHVkZUNvbXBpbGF0aW9ucyhmaWVsZE5vZGUuX19pbnRlcm5hbFNob3VsZEluY2x1ZGVQYXRoPy5bY3VycmVudFBhdGhdID8/IFwiXCIsIHByZXZpb3VzU2hvdWxkSW5jbHVkZSwgY29tcGlsZWRTa2lwSW5jbHVkZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBAZGVwcmVjYXRlZFxuICAgICAgICAgICAgICAgICAgICBmaWVsZE5vZGUuX19pbnRlcm5hbFNob3VsZEluY2x1ZGUgPSBqb2luU2hvdWxkSW5jbHVkZUNvbXBpbGF0aW9ucyhmaWVsZE5vZGUuX19pbnRlcm5hbFNob3VsZEluY2x1ZGUgPz8gXCJcIiwgcHJldmlvdXNTaG91bGRJbmNsdWRlLCBjb21waWxlZFNraXBJbmNsdWRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogV2UgYXVnbWVudCB0aGUgZW50aXJlIHN1YnRyZWUgYXMgdGhlIHBhcmVudCBvYmplY3QncyBza2lwL2luY2x1ZGVcbiAgICAgICAgICAgICAgICAgKiBkaXJlY3RpdmVzIGluZmx1ZW5jZSB0aGUgY2hpbGQgZXZlbiBpZiB0aGUgY2hpbGQgZG9lc24ndCBoYXZlXG4gICAgICAgICAgICAgICAgICogc2tpcC9pbmNsdWRlIG9uIGl0J3Mgb3duLlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogUmVmZXIgdGhlIGZ1bmN0aW9uIGRlZmluaXRpb24gZm9yIGV4YW1wbGUuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgYXVnbWVudEZpZWxkTm9kZVRyZWUoY29tcGlsYXRpb25Db250ZXh0LCBmaWVsZE5vZGUsIGN1cnJlbnRQYXRoKTtcbiAgICAgICAgICAgICAgICBmaWVsZHNbbmFtZV0ucHVzaChmaWVsZE5vZGUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBsYW5ndWFnZV8xLktpbmQuSU5MSU5FX0ZSQUdNRU5UOiB7XG4gICAgICAgICAgICAgICAgaWYgKCFkb2VzRnJhZ21lbnRDb25kaXRpb25NYXRjaChjb21waWxhdGlvbkNvbnRleHQsIHNlbGVjdGlvbiwgcnVudGltZVR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBjdXJyZW50IGZyYWdtZW50J3Mgc2hvdWxkSW5jbHVkZVxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbXBpbGVkU2tpcEluY2x1ZGUgPSBjb21waWxlU2tpcEluY2x1ZGUoY29tcGlsYXRpb25Db250ZXh0LCBzZWxlY3Rpb24pO1xuICAgICAgICAgICAgICAgIC8vIHJlY3Vyc2VcbiAgICAgICAgICAgICAgICBjb2xsZWN0RmllbGRzSW1wbChjb21waWxhdGlvbkNvbnRleHQsIHJ1bnRpbWVUeXBlLCBzZWxlY3Rpb24uc2VsZWN0aW9uU2V0LCBmaWVsZHMsIHZpc2l0ZWRGcmFnbWVudE5hbWVzLCBqb2luU2hvdWxkSW5jbHVkZUNvbXBpbGF0aW9ucyhcbiAgICAgICAgICAgICAgICAvLyBgc2hvdWxkIGluY2x1ZGVgcyBmcm9tIHByZXZpb3VzIGZyYWdtZW50c1xuICAgICAgICAgICAgICAgIHByZXZpb3VzU2hvdWxkSW5jbHVkZSwgXG4gICAgICAgICAgICAgICAgLy8gY3VycmVudCBmcmFnbWVudCdzIHNob3VsZEluY2x1ZGVcbiAgICAgICAgICAgICAgICBjb21waWxlZFNraXBJbmNsdWRlKSwgcGFyZW50UmVzcG9uc2VQYXRoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgbGFuZ3VhZ2VfMS5LaW5kLkZSQUdNRU5UX1NQUkVBRDoge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZyYWdOYW1lID0gc2VsZWN0aW9uLm5hbWUudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKHZpc2l0ZWRGcmFnbWVudE5hbWVzW2ZyYWdOYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmlzaXRlZEZyYWdtZW50TmFtZXNbZnJhZ05hbWVdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25zdCBmcmFnbWVudCA9IGNvbXBpbGF0aW9uQ29udGV4dC5mcmFnbWVudHNbZnJhZ05hbWVdO1xuICAgICAgICAgICAgICAgIGlmICghZnJhZ21lbnQgfHxcbiAgICAgICAgICAgICAgICAgICAgIWRvZXNGcmFnbWVudENvbmRpdGlvbk1hdGNoKGNvbXBpbGF0aW9uQ29udGV4dCwgZnJhZ21lbnQsIHJ1bnRpbWVUeXBlKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gY3VycmVudCBmcmFnbWVudCdzIHNob3VsZEluY2x1ZGVcbiAgICAgICAgICAgICAgICBjb25zdCBjb21waWxlZFNraXBJbmNsdWRlID0gY29tcGlsZVNraXBJbmNsdWRlKGNvbXBpbGF0aW9uQ29udGV4dCwgc2VsZWN0aW9uKTtcbiAgICAgICAgICAgICAgICAvLyByZWN1cnNlXG4gICAgICAgICAgICAgICAgY29sbGVjdEZpZWxkc0ltcGwoY29tcGlsYXRpb25Db250ZXh0LCBydW50aW1lVHlwZSwgZnJhZ21lbnQuc2VsZWN0aW9uU2V0LCBmaWVsZHMsIHZpc2l0ZWRGcmFnbWVudE5hbWVzLCBqb2luU2hvdWxkSW5jbHVkZUNvbXBpbGF0aW9ucyhcbiAgICAgICAgICAgICAgICAvLyBgc2hvdWxkIGluY2x1ZGVgcyBmcm9tIHByZXZpb3VzIGZyYWdtZW50c1xuICAgICAgICAgICAgICAgIHByZXZpb3VzU2hvdWxkSW5jbHVkZSwgXG4gICAgICAgICAgICAgICAgLy8gY3VycmVudCBmcmFnbWVudCdzIHNob3VsZEluY2x1ZGVcbiAgICAgICAgICAgICAgICBjb21waWxlZFNraXBJbmNsdWRlKSwgcGFyZW50UmVzcG9uc2VQYXRoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmllbGRzO1xufVxuLyoqXG4gKiBBdWdtZW50IF9faW50ZXJuYWxTaG91bGRJbmNsdWRlIGNvZGUgZm9yIGFsbCBzdWItZmllbGRzIGluIHRoZVxuICogdHJlZSB3aXRoIEBwYXJhbSByb290ZmllbGROb2RlIGFzIHRoZSByb290LlxuICpcbiAqIFRoaXMgaXMgcmVxdWlyZWQgdG8gaGFuZGxlIGNhc2VzIHdoZXJlIHRoZXJlIGFyZSBtdWx0aXBsZSBwYXRocyB0b1xuICogdGhlIHNhbWUgbm9kZS4gQW5kIGVhY2ggb2YgdGhvc2UgcGF0aHMgY29udGFpbiBkaWZmZXJlbnQgc2tpcC9pbmNsdWRlXG4gKiB2YWx1ZXMuXG4gKlxuICogRm9yIGV4YW1wbGUsXG4gKlxuICogYGBgXG4gKiB7XG4gKiAgIGZvbyBAc2tpcChpZjogJGMxKSB7XG4gKiAgICAgYmFyIEBza2lwKGlmOiAkYzIpXG4gKiAgIH1cbiAqICAgLi4uIHtcbiAqICAgICBmb28gQHNraXAoaWY6ICRjMykge1xuICogICAgICAgYmFyXG4gKiAgICAgfVxuICogICB9XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBXZSBkZWNpZGUgc2hvdWxkSW5jbHVkZSBhdCBydW50aW1lIHBlciBmaWVsZE5vZGUuIFdoZW4gd2UgaGFuZGxlIHRoZVxuICogZmllbGQgYGZvb2AsIHRoZSBsb2dpYyBpcyBzdHJhaWdodCBmb3J3YXJkIC0gaXQgcmVxdWlyZXMgb25lIG9mICRjMSBvciAkYzNcbiAqIHRvIGJlIGZhbHNlLlxuICpcbiAqIEJ1dCwgd2hlbiB3ZSBoYW5kbGUgdGhlIGZpZWxkIGBiYXJgLCBhbmQgd2UgYXJlIGluIHRoZSBjb250ZXh0IG9mIHRoZSBmaWVsZE5vZGUsXG4gKiBub3QgZW5vdWdoIGluZm9ybWF0aW9uIGlzIGF2YWlsYWJsZS4gVGhpcyBpcyBiZWNhdXNlLCBpZiB3ZSBvbmx5IGluY2x1ZGVkICRjMlxuICogdG8gZGVjaWRlIGlmIGJhciBpcyBpbmNsdWRlZCwgY29uc2lkZXIgdGhlIGNhc2UgLVxuICpcbiAqICRjMTogdHJ1ZSwgJGMyOiB0cnVlLCAkYzM6IGZhbHNlXG4gKlxuICogSWYgd2UgY29uc2lkZXJlZCBvbmx5ICRjMiwgd2Ugd291bGQgaGF2ZSBza2lwcGVkIGJhci4gQnV0IHRoZSBjb3JyZWN0IGltcGxlbWVudGF0aW9uXG4gKiBpcyB0byBpbmNsdWRlIGJhciwgYmVjYXVzZSBmb28oJGMzKSB7IGJhciB9IGlzIG5vdCBza2lwcGVkLiBUaGUgZW50aXJlIHN1Yi10cmVlJ3NcbiAqIGxvZ2ljIGlzIHJlcXVpcmVkIHRvIGhhbmRsZSBiYXIuXG4gKlxuICogU28sIHRvIGhhbmRsZSB0aGlzIGNhc2UsIHdlIGF1Z21lbnQgdGhlIHRyZWUgYXQgZWFjaCBwb2ludCB0byBjb25zaWRlciB0aGVcbiAqIHNraXAvaW5jbHVkZSBsb2dpYyBmcm9tIHRoZSBwYXJlbnQgYXMgd2VsbC5cbiAqXG4gKiBAcGFyYW0gY29tcGlsYXRpb25Db250ZXh0IHtDb21waWxhdGlvbkNvbnRleHR9IFJlcXVpcmVkIGZvciBnZXRGcmFnbWVudCBieVxuICogbmFtZSB0byBoYW5kbGUgZnJhZ21lbnQgc3ByZWFkIG9wZXJhdGlvbi5cbiAqXG4gKiBAcGFyYW0gcm9vdEZpZWxkTm9kZSB7Sml0RmllbGROb2RlfSBUaGUgcm9vdCBmaWVsZCB0byB0cmF2ZXJzZSBmcm9tIGZvclxuICogYWRkaW5nIF9faW50ZXJuYWxTaG91bGRJbmNsdWRlIHRvIGFsbCBzdWIgZmllbGQgbm9kZXMuXG4gKlxuICogQHBhcmFtIHBhcmVudFJlc3BvbnNlUGF0aCB7c3RyaW5nfSBUaGUgcmVzcG9uc2UgcGF0aCBvZiB0aGUgcGFyZW50IGZpZWxkLlxuICovXG5mdW5jdGlvbiBhdWdtZW50RmllbGROb2RlVHJlZShjb21waWxhdGlvbkNvbnRleHQsIHJvb3RGaWVsZE5vZGUsIHBhcmVudFJlc3BvbnNlUGF0aCkge1xuICAgIGZvciAoY29uc3Qgc2VsZWN0aW9uIG9mIHJvb3RGaWVsZE5vZGUuc2VsZWN0aW9uU2V0Py5zZWxlY3Rpb25zID8/IFtdKSB7XG4gICAgICAgIGhhbmRsZShyb290RmllbGROb2RlLCBzZWxlY3Rpb24sIGZhbHNlLCBwYXJlbnRSZXNwb25zZVBhdGgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWN1cnNpdmVseSB0cmF2ZXJzZSB0aHJvdWdoIHN1Yi1zZWxlY3Rpb24gYW5kIGNvbWJpbmUgYHNob3VsZEluY2x1ZGVgc1xuICAgICAqIGZyb20gcGFyZW50IGFuZCBjdXJyZW50IG9uZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaGFuZGxlKHBhcmVudEZpZWxkTm9kZSwgc2VsZWN0aW9uLCBjb21lc0Zyb21GcmFnbWVudFNwcmVhZCA9IGZhbHNlLCBwYXJlbnRSZXNwb25zZVBhdGgpIHtcbiAgICAgICAgc3dpdGNoIChzZWxlY3Rpb24ua2luZCkge1xuICAgICAgICAgICAgY2FzZSBsYW5ndWFnZV8xLktpbmQuRklFTEQ6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBqaXRGaWVsZE5vZGUgPSBzZWxlY3Rpb247XG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVudFBhdGggPSBqb2luU2tpcEluY2x1ZGVQYXRoKHBhcmVudFJlc3BvbnNlUGF0aCwgXG4gICAgICAgICAgICAgICAgLy8gdXNlIGFsaWFzKGluc3RlYWQgb2Ygc2VsZWN0aW9uLm5hbWUudmFsdWUpIGlmIGF2YWlsYWJsZSBhcyB0aGUgcmVzcG9uc2VQYXRoIHVzZWQgZm9yIGxvb2t1cCB1c2VzIGFsaWFzXG4gICAgICAgICAgICAgICAgZ2V0RmllbGRFbnRyeUtleShqaXRGaWVsZE5vZGUpKTtcbiAgICAgICAgICAgICAgICBpZiAoIWNvbWVzRnJvbUZyYWdtZW50U3ByZWFkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21waWxhdGlvbkNvbnRleHQub3B0aW9ucy51c2VFeHBlcmltZW50YWxQYXRoQmFzZWRTa2lwSW5jbHVkZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFqaXRGaWVsZE5vZGUuX19pbnRlcm5hbFNob3VsZEluY2x1ZGVQYXRoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGppdEZpZWxkTm9kZS5fX2ludGVybmFsU2hvdWxkSW5jbHVkZVBhdGggPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGppdEZpZWxkTm9kZS5fX2ludGVybmFsU2hvdWxkSW5jbHVkZVBhdGhbY3VycmVudFBhdGhdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqb2luU2hvdWxkSW5jbHVkZUNvbXBpbGF0aW9ucyhwYXJlbnRGaWVsZE5vZGUuX19pbnRlcm5hbFNob3VsZEluY2x1ZGVQYXRoPy5bcGFyZW50UmVzcG9uc2VQYXRoXSA/PyBcIlwiLCBqaXRGaWVsZE5vZGUuX19pbnRlcm5hbFNob3VsZEluY2x1ZGVQYXRoPy5bY3VycmVudFBhdGhdID8/IFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQGRlcHJlY2F0ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIGppdEZpZWxkTm9kZS5fX2ludGVybmFsU2hvdWxkSW5jbHVkZSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgam9pblNob3VsZEluY2x1ZGVDb21waWxhdGlvbnMocGFyZW50RmllbGROb2RlLl9faW50ZXJuYWxTaG91bGRJbmNsdWRlID8/IFwiXCIsIGppdEZpZWxkTm9kZS5fX2ludGVybmFsU2hvdWxkSW5jbHVkZSA/PyBcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBnbyBmdXJ0aGVyIGRvd24gdGhlIHF1ZXJ5IHRyZWVcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHNlbGVjdGlvbiBvZiBqaXRGaWVsZE5vZGUuc2VsZWN0aW9uU2V0Py5zZWxlY3Rpb25zID8/IFtdKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZShqaXRGaWVsZE5vZGUsIHNlbGVjdGlvbiwgZmFsc2UsIGN1cnJlbnRQYXRoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIGxhbmd1YWdlXzEuS2luZC5JTkxJTkVfRlJBR01FTlQ6IHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHN1YlNlbGVjdGlvbiBvZiBzZWxlY3Rpb24uc2VsZWN0aW9uU2V0LnNlbGVjdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlKHBhcmVudEZpZWxkTm9kZSwgc3ViU2VsZWN0aW9uLCB0cnVlLCBwYXJlbnRSZXNwb25zZVBhdGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgbGFuZ3VhZ2VfMS5LaW5kLkZSQUdNRU5UX1NQUkVBRDoge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZyYWdtZW50ID0gY29tcGlsYXRpb25Db250ZXh0LmZyYWdtZW50c1tzZWxlY3Rpb24ubmFtZS52YWx1ZV07XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBzdWJTZWxlY3Rpb24gb2YgZnJhZ21lbnQuc2VsZWN0aW9uU2V0LnNlbGVjdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlKHBhcmVudEZpZWxkTm9kZSwgc3ViU2VsZWN0aW9uLCB0cnVlLCBwYXJlbnRSZXNwb25zZVBhdGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogSm9pbnMgYSBsaXN0IG9mIHNob3VsZEluY2x1ZGUgY29tcGlsZWQgY29kZSBpbnRvIGEgc2luZ2xlIGxvZ2ljYWxcbiAqIHN0YXRlbWVudC5cbiAqXG4gKiBUaGUgb3BlcmF0aW9uIGlzIGAmJmAgYmVjYXVzZSwgaXQgaXMgdXNlZCB0byBqb2luIHBhcmVudC0+Y2hpbGRcbiAqIHJlbGF0aW9ucyBpbiB0aGUgcXVlcnkgdHJlZS4gTm90ZTogcGFyZW50IGNhbiBiZSBlaXRoZXIgcGFyZW50IGZpZWxkXG4gKiBvciBmcmFnbWVudC5cbiAqXG4gKiBGb3IgZXhhbXBsZSxcbiAqIHtcbiAqICAgZm9vIEBza2lwKGlmOiAkYzEpIHtcbiAqICAgICAuLi4gQHNraXAoaWY6ICRjMikge1xuICogICAgICAgYmFyIEBza2lwKGlmOiAkYzMpXG4gKiAgICAgfVxuICogICB9XG4gKiB9XG4gKlxuICogT25seSB3aGVuIGEgcGFyZW50IGlzIGluY2x1ZGVkLCB0aGUgY2hpbGQgaXMgaW5jbHVkZWQuIFNvLCB3ZSB1c2UgYCYmYC5cbiAqXG4gKiBjb21waWxhdGlvbkZvcigkYzEpICYmIGNvbXBpbGF0aW9uRm9yKCRjMikgJiYgY29tcGlsYXRpb25Gb3IoJGMzKVxuICpcbiAqIEBwYXJhbSBjb21waWxhdGlvbnNcbiAqL1xuZnVuY3Rpb24gam9pblNob3VsZEluY2x1ZGVDb21waWxhdGlvbnMoLi4uY29tcGlsYXRpb25zKSB7XG4gICAgLy8gcmVtb3ZlIFwidHJ1ZVwiIHNpbmNlIHdlIGFyZSBqb2luaW5nIHdpdGggJyYmJyBhcyBgdHJ1ZSAmJiBYYCA9IGBYYFxuICAgIC8vIFRoaXMgcHJldmVudHMgYW4gZXhwbG9zaW9uIG9mIGAmJiB0cnVlYCB3aGljaCBjb3VsZCBicmVha1xuICAgIC8vIFY4J3MgaW50ZXJuYWwgc2l6ZSBsaW1pdCBmb3Igc3RyaW5nLlxuICAgIC8vXG4gICAgLy8gTm90ZTogdGhlIGB0cnVlYCBhcHBlYXJzIGlmIGEgZmllbGQgZG9lcyBub3QgaGF2ZSBhIHNraXAvaW5jbHVkZSBkaXJlY3RpdmVcbiAgICAvLyBTbywgdGhlIG1vcmUgbmVzdGVkIHRoZSBxdWVyeSBpcywgdGhlIG1vcmUgb2YgdW5uZWNlc3NhcnkgYCYmIHRydWVgXG4gICAgLy8gd2UgZ2V0LlxuICAgIC8vXG4gICAgLy8gRmFpbGluZyB0byBkbyB0aGlzIHJlc3VsdHMgaW4gW1JhbmdlRXJyb3I6IGludmFsaWQgYXJyYXkgbGVuZ3RoXVxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0Vycm9ycy9JbnZhbGlkX2FycmF5X2xlbmd0aFxuICAgIC8vIHJlbW92ZSBlbXB0eSBzdHJpbmdzXG4gICAgbGV0IGZpbHRlcmVkQ29tcGlsYXRpb25zID0gY29tcGlsYXRpb25zLmZpbHRlcigoaXQpID0+IGl0KTtcbiAgICAvLyBTcGxpdCBjb25kaXRpb25zIGJ5ICYmIGFuZCBmbGF0dGVuIGl0XG4gICAgZmlsdGVyZWRDb21waWxhdGlvbnMgPSBbXS5jb25jYXQoLi4uZmlsdGVyZWRDb21waWxhdGlvbnMubWFwKChlKSA9PiBlLnNwbGl0KFwiICYmIFwiKS5tYXAoKGl0KSA9PiBpdC50cmltKCkpKSk7XG4gICAgLy8gRGVkdXBsaWNhdGUgaXRlbXNcbiAgICBmaWx0ZXJlZENvbXBpbGF0aW9ucyA9IEFycmF5LmZyb20obmV3IFNldChmaWx0ZXJlZENvbXBpbGF0aW9ucykpO1xuICAgIHJldHVybiBmaWx0ZXJlZENvbXBpbGF0aW9ucy5qb2luKFwiICYmIFwiKTtcbn1cbi8qKlxuICogQ29tcGlsZXMgZGlyZWN0aXZlcyBgc2tpcGAgYW5kIGBpbmNsdWRlYCBhbmQgZ2VuZXJhdGVzIHRoZSBjb21waWxhdGlvblxuICogY29kZSBiYXNlZCBvbiBHcmFwaFFMIHNwZWNpZmljYXRpb24uXG4gKlxuICogQHBhcmFtIG5vZGUge1NlbGVjdGlvbk5vZGV9IFRoZSBzZWxlY3Rpb24gbm9kZSAoZmllbGQvZnJhZ21lbnQvaW5saW5lLWZyYWdtZW50KVxuICogZm9yIHdoaWNoIHdlIGdlbmVyYXRlIHRoZSBjb21waWxlZCBza2lwSW5jbHVkZS5cbiAqL1xuZnVuY3Rpb24gY29tcGlsZVNraXBJbmNsdWRlKGNvbXBpbGF0aW9uQ29udGV4dCwgbm9kZSkge1xuICAgIGNvbnN0IGdlbiA9ICgwLCBnZW5lcmF0ZV9mdW5jdGlvbl8xLmRlZmF1bHQpKCk7XG4gICAgY29uc3QgeyBza2lwVmFsdWUsIGluY2x1ZGVWYWx1ZSB9ID0gY29tcGlsZVNraXBJbmNsdWRlRGlyZWN0aXZlVmFsdWVzKGNvbXBpbGF0aW9uQ29udGV4dCwgbm9kZSk7XG4gICAgLyoqXG4gICAgICogU3BlYzogaHR0cHM6Ly9zcGVjLmdyYXBocWwub3JnL0p1bmUyMDE4LyNzZWMtLWluY2x1ZGVcbiAgICAgKlxuICAgICAqIE5laXRoZXIgQHNraXAgbm9yIEBpbmNsdWRlIGhhcyBwcmVjZWRlbmNlIG92ZXIgdGhlIG90aGVyLlxuICAgICAqIEluIHRoZSBjYXNlIHRoYXQgYm90aCB0aGUgQHNraXAgYW5kIEBpbmNsdWRlIGRpcmVjdGl2ZXNcbiAgICAgKiBhcmUgcHJvdmlkZWQgaW4gb24gdGhlIHNhbWUgdGhlIGZpZWxkIG9yIGZyYWdtZW50LCBpdCBtdXN0XG4gICAgICogYmUgcXVlcmllZCBvbmx5IGlmIHRoZSBAc2tpcCBjb25kaXRpb24gaXMgZmFsc2UgYW5kIHRoZVxuICAgICAqIEBpbmNsdWRlIGNvbmRpdGlvbiBpcyB0cnVlLiBTdGF0ZWQgY29udmVyc2VseSwgdGhlIGZpZWxkXG4gICAgICogb3IgZnJhZ21lbnQgbXVzdCBub3QgYmUgcXVlcmllZCBpZiBlaXRoZXIgdGhlIEBza2lwXG4gICAgICogY29uZGl0aW9uIGlzIHRydWUgb3IgdGhlIEBpbmNsdWRlIGNvbmRpdGlvbiBpcyBmYWxzZS5cbiAgICAgKi9cbiAgICBpZiAoc2tpcFZhbHVlICE9IG51bGwgJiYgaW5jbHVkZVZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgZ2VuKGAke3NraXBWYWx1ZX0gPT09IGZhbHNlICYmICR7aW5jbHVkZVZhbHVlfSA9PT0gdHJ1ZWApO1xuICAgIH1cbiAgICBlbHNlIGlmIChza2lwVmFsdWUgIT0gbnVsbCkge1xuICAgICAgICBnZW4oYCgke3NraXBWYWx1ZX0gPT09IGZhbHNlKWApO1xuICAgIH1cbiAgICBlbHNlIGlmIChpbmNsdWRlVmFsdWUgIT0gbnVsbCkge1xuICAgICAgICBnZW4oYCgke2luY2x1ZGVWYWx1ZX0gPT09IHRydWUpYCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBnZW4oYHRydWVgKTtcbiAgICB9XG4gICAgcmV0dXJuIGdlbi50b1N0cmluZygpO1xufVxuLyoqXG4gKiBDb21waWxlIHNraXAgb3IgaW5jbHVkZSBkaXJlY3RpdmUgdmFsdWVzIGludG8gSklUIGNvbXBhdGlibGVcbiAqIHJ1bnRpbWUgY29kZS5cbiAqXG4gKiBAcGFyYW0gbm9kZSB7U2VsZWN0aW9uTm9kZX1cbiAqL1xuZnVuY3Rpb24gY29tcGlsZVNraXBJbmNsdWRlRGlyZWN0aXZlVmFsdWVzKGNvbXBpbGF0aW9uQ29udGV4dCwgbm9kZSkge1xuICAgIGNvbnN0IHNraXBEaXJlY3RpdmUgPSBub2RlLmRpcmVjdGl2ZXM/LmZpbmQoKGl0KSA9PiBpdC5uYW1lLnZhbHVlID09PSBncmFwaHFsXzEuR3JhcGhRTFNraXBEaXJlY3RpdmUubmFtZSk7XG4gICAgY29uc3QgaW5jbHVkZURpcmVjdGl2ZSA9IG5vZGUuZGlyZWN0aXZlcz8uZmluZCgoaXQpID0+IGl0Lm5hbWUudmFsdWUgPT09IGdyYXBocWxfMS5HcmFwaFFMSW5jbHVkZURpcmVjdGl2ZS5uYW1lKTtcbiAgICBjb25zdCBza2lwVmFsdWUgPSBza2lwRGlyZWN0aXZlXG4gICAgICAgID8gY29tcGlsZVNraXBJbmNsdWRlRGlyZWN0aXZlKGNvbXBpbGF0aW9uQ29udGV4dCwgc2tpcERpcmVjdGl2ZSlcbiAgICAgICAgOiAvLyBUaGUgbnVsbCBoZXJlIGluZGljYXRlcyB0aGUgYWJzZW5zZSBvZiB0aGUgZGlyZWN0aXZlXG4gICAgICAgICAgICAvLyB3aGljaCBpcyBsYXRlciB1c2VkIHRvIGRldGVybWluZSBpZiBib3RoIHNraXAgYW5kIGluY2x1ZGVcbiAgICAgICAgICAgIC8vIGFyZSBwcmVzZW50XG4gICAgICAgICAgICBudWxsO1xuICAgIGNvbnN0IGluY2x1ZGVWYWx1ZSA9IGluY2x1ZGVEaXJlY3RpdmVcbiAgICAgICAgPyBjb21waWxlU2tpcEluY2x1ZGVEaXJlY3RpdmUoY29tcGlsYXRpb25Db250ZXh0LCBpbmNsdWRlRGlyZWN0aXZlKVxuICAgICAgICA6IC8vIFRoZSBudWxsIGhlcmUgaW5kaWNhdGVzIHRoZSBhYnNlbnNlIG9mIHRoZSBkaXJlY3RpdmVcbiAgICAgICAgICAgIC8vIHdoaWNoIGlzIGxhdGVyIHVzZWQgdG8gZGV0ZXJtaW5lIGlmIGJvdGggc2tpcCBhbmQgaW5jbHVkZVxuICAgICAgICAgICAgLy8gYXJlIHByZXNlbnRcbiAgICAgICAgICAgIG51bGw7XG4gICAgcmV0dXJuIHsgc2tpcFZhbHVlLCBpbmNsdWRlVmFsdWUgfTtcbn1cbi8qKlxuICogQ29tcGlsZSB0aGUgc2tpcC9pbmNsdWRlIGRpcmVjdGl2ZSBub2RlLiBSZXNvbHZlIHZhcmlhYmxlcyB0byBpdCdzXG4gKiBwYXRoIGZyb20gY29udGV4dCwgcmVzb2x2ZSBzY2FsYXJzIHRvIHRoZWlyIHJlc3BlY3RpdmUgdmFsdWVzLlxuICpcbiAqIEBwYXJhbSBkaXJlY3RpdmUge0RpcmVjdGl2ZU5vZGV9XG4gKi9cbmZ1bmN0aW9uIGNvbXBpbGVTa2lwSW5jbHVkZURpcmVjdGl2ZShjb21waWxhdGlvbkNvbnRleHQsIGRpcmVjdGl2ZSkge1xuICAgIGNvbnN0IGlmTm9kZSA9IGRpcmVjdGl2ZS5hcmd1bWVudHM/LmZpbmQoKGl0KSA9PiBpdC5uYW1lLnZhbHVlID09PSBcImlmXCIpO1xuICAgIGlmIChpZk5vZGUgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgZ3JhcGhxbF8xLkdyYXBoUUxFcnJvcihgRGlyZWN0aXZlICcke2RpcmVjdGl2ZS5uYW1lLnZhbHVlfScgaXMgbWlzc2luZyByZXF1aXJlZCBhcmd1bWVudHM6ICdpZidgLCAoMCwgY29tcGF0XzEuZ2V0R3JhcGhRTEVycm9yT3B0aW9ucykoW2RpcmVjdGl2ZV0pKTtcbiAgICB9XG4gICAgc3dpdGNoIChpZk5vZGUudmFsdWUua2luZCkge1xuICAgICAgICBjYXNlIGxhbmd1YWdlXzEuS2luZC5WQVJJQUJMRTpcbiAgICAgICAgICAgIHZhbGlkYXRlU2tpcEluY2x1ZGVWYXJpYWJsZVR5cGUoY29tcGlsYXRpb25Db250ZXh0LCBpZk5vZGUudmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIGAke2V4ZWN1dGlvbl8xLkdMT0JBTF9WQVJJQUJMRVNfTkFNRX1bXCIke2lmTm9kZS52YWx1ZS5uYW1lLnZhbHVlfVwiXWA7XG4gICAgICAgIGNhc2UgbGFuZ3VhZ2VfMS5LaW5kLkJPT0xFQU46XG4gICAgICAgICAgICByZXR1cm4gYCR7aWZOb2RlLnZhbHVlLnZhbHVlLnRvU3RyaW5nKCl9YDtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBncmFwaHFsXzEuR3JhcGhRTEVycm9yKGBBcmd1bWVudCAnaWYnIG9uIERpcmVjdGl2ZSAnJHtkaXJlY3RpdmUubmFtZS52YWx1ZX0nIGhhcyBhbiBpbnZhbGlkIHZhbHVlICgkeygwLCBncmFwaHFsXzEudmFsdWVGcm9tQVNUVW50eXBlZCkoaWZOb2RlLnZhbHVlKX0pLiBFeHBlY3RlZCB0eXBlICdCb29sZWFuISdgLCAoMCwgY29tcGF0XzEuZ2V0R3JhcGhRTEVycm9yT3B0aW9ucykoW2lmTm9kZV0pKTtcbiAgICB9XG59XG4vKipcbiAqIFZhbGlkYXRlIHRoZSBza2lwIGFuZCBpbmNsdWRlIGRpcmVjdGl2ZSdzIGFyZ3VtZW50IHZhbHVlcyBhdCBjb21waWxlIHRpbWUuXG4gKlxuICogVGhpcyB2YWxpZGF0aW9uIHN0ZXAgaXMgcmVxdWlyZWQgYXMgdGhlc2UgZGlyZWN0aXZlcyBhcmUgcGFydCBvZiBhblxuICogaW1wbGljaXQgc2NoZW1hIGluIEdyYXBoUUwuXG4gKlxuICogQHBhcmFtIGNvbXBpbGF0aW9uQ29udGV4dCB7Q29tcGlsYXRpb25Db250ZXh0fVxuICogQHBhcmFtIHZhcmlhYmxlIHtWYXJpYWJsZU5vZGV9IHRoZSB2YXJpYWJsZSB1c2VkIGluICdpZicgYXJndW1lbnQgb2YgdGhlIHNraXAvaW5jbHVkZSBkaXJlY3RpdmVcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVTa2lwSW5jbHVkZVZhcmlhYmxlVHlwZShjb21waWxhdGlvbkNvbnRleHQsIHZhcmlhYmxlKSB7XG4gICAgY29uc3QgdmFyaWFibGVEZWZpbml0aW9uID0gY29tcGlsYXRpb25Db250ZXh0Lm9wZXJhdGlvbi52YXJpYWJsZURlZmluaXRpb25zPy5maW5kKChpdCkgPT4gaXQudmFyaWFibGUubmFtZS52YWx1ZSA9PT0gdmFyaWFibGUubmFtZS52YWx1ZSk7XG4gICAgaWYgKHZhcmlhYmxlRGVmaW5pdGlvbiA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBncmFwaHFsXzEuR3JhcGhRTEVycm9yKGBWYXJpYWJsZSAnJHt2YXJpYWJsZS5uYW1lLnZhbHVlfScgaXMgbm90IGRlZmluZWRgLCAoMCwgY29tcGF0XzEuZ2V0R3JhcGhRTEVycm9yT3B0aW9ucykoW3ZhcmlhYmxlXSkpO1xuICAgIH1cbiAgICAvLyBQYXJ0IG9mIFNwZWMgdGV4dDogaHR0cHM6Ly9zcGVjLmdyYXBocWwub3JnL0p1bmUyMDE4LyNzZWMtQWxsLVZhcmlhYmxlLVVzYWdlcy1hcmUtQWxsb3dlZFxuICAgIGlmICghKFxuICAgIC8vIFRoZSB2YXJpYWJsZSBkZWZpbnRpb24gaXMgYSBOb24tbnVsbGFibGUgQm9vbGVhbiB0eXBlXG4gICAgKCh2YXJpYWJsZURlZmluaXRpb24udHlwZS5raW5kID09PSBsYW5ndWFnZV8xLktpbmQuTk9OX05VTExfVFlQRSAmJlxuICAgICAgICB2YXJpYWJsZURlZmluaXRpb24udHlwZS50eXBlLmtpbmQgPT09IGxhbmd1YWdlXzEuS2luZC5OQU1FRF9UWVBFICYmXG4gICAgICAgIHZhcmlhYmxlRGVmaW5pdGlvbi50eXBlLnR5cGUubmFtZS52YWx1ZSA9PT0gXCJCb29sZWFuXCIpIHx8XG4gICAgICAgIC8vIG9yIHRoZSB2YXJpYWJsZSBkZWZpbml0aW9uIGlzIGEgbnVsbGFibGUgQm9vbGVhbiB0eXBlIHdpdGggYSBkZWZhdWx0IHZhbHVlXG4gICAgICAgICh2YXJpYWJsZURlZmluaXRpb24udHlwZS5raW5kID09PSBsYW5ndWFnZV8xLktpbmQuTkFNRURfVFlQRSAmJlxuICAgICAgICAgICAgdmFyaWFibGVEZWZpbml0aW9uLnR5cGUubmFtZS52YWx1ZSA9PT0gXCJCb29sZWFuXCIgJiZcbiAgICAgICAgICAgIHZhcmlhYmxlRGVmaW5pdGlvbi5kZWZhdWx0VmFsdWUgIT0gbnVsbCkpKSkge1xuICAgICAgICB0aHJvdyBuZXcgZ3JhcGhxbF8xLkdyYXBoUUxFcnJvcihgVmFyaWFibGUgJyR7dmFyaWFibGUubmFtZS52YWx1ZX0nIG9mIHR5cGUgJyR7dHlwZU5vZGVUb1N0cmluZyh2YXJpYWJsZURlZmluaXRpb24udHlwZSl9JyB1c2VkIGluIHBvc2l0aW9uIGV4cGVjdGluZyB0eXBlICdCb29sZWFuISdgLCAoMCwgY29tcGF0XzEuZ2V0R3JhcGhRTEVycm9yT3B0aW9ucykoW3ZhcmlhYmxlRGVmaW5pdGlvbl0pKTtcbiAgICB9XG59XG4vKipcbiAqIFByaW50IHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIFR5cGVOb2RlIGZvciBlcnJvciBtZXNzYWdlc1xuICpcbiAqIEBwYXJhbSB0eXBlIHtUeXBlTm9kZX0gdHlwZSBub2RlIHRvIGJlIGNvbnZlcnRlZCB0byBzdHJpbmcgcmVwcmVzZW50YXRpb25cbiAqL1xuZnVuY3Rpb24gdHlwZU5vZGVUb1N0cmluZyh0eXBlKSB7XG4gICAgc3dpdGNoICh0eXBlLmtpbmQpIHtcbiAgICAgICAgY2FzZSBsYW5ndWFnZV8xLktpbmQuTkFNRURfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiB0eXBlLm5hbWUudmFsdWU7XG4gICAgICAgIGNhc2UgbGFuZ3VhZ2VfMS5LaW5kLk5PTl9OVUxMX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gYCR7dHlwZU5vZGVUb1N0cmluZyh0eXBlLnR5cGUpfSFgO1xuICAgICAgICBjYXNlIGxhbmd1YWdlXzEuS2luZC5MSVNUX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gYFske3R5cGVOb2RlVG9TdHJpbmcodHlwZS50eXBlKX1dYDtcbiAgICB9XG59XG4vKipcbiAqIERldGVybWluZXMgaWYgYSBmcmFnbWVudCBpcyBhcHBsaWNhYmxlIHRvIHRoZSBnaXZlbiB0eXBlLlxuICovXG5mdW5jdGlvbiBkb2VzRnJhZ21lbnRDb25kaXRpb25NYXRjaChjb21waWxhdGlvbkNvbnRleHQsIGZyYWdtZW50LCB0eXBlKSB7XG4gICAgY29uc3QgdHlwZUNvbmRpdGlvbk5vZGUgPSBmcmFnbWVudC50eXBlQ29uZGl0aW9uO1xuICAgIGlmICghdHlwZUNvbmRpdGlvbk5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNvbnN0IGNvbmRpdGlvbmFsVHlwZSA9ICgwLCBncmFwaHFsXzEudHlwZUZyb21BU1QpKGNvbXBpbGF0aW9uQ29udGV4dC5zY2hlbWEsIHR5cGVDb25kaXRpb25Ob2RlKTtcbiAgICBpZiAoY29uZGl0aW9uYWxUeXBlID09PSB0eXBlKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoIWNvbmRpdGlvbmFsVHlwZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICgoMCwgdHlwZV8xLmlzQWJzdHJhY3RUeXBlKShjb25kaXRpb25hbFR5cGUpKSB7XG4gICAgICAgIHJldHVybiBjb21waWxhdGlvbkNvbnRleHQuc2NoZW1hLmlzU3ViVHlwZShjb25kaXRpb25hbFR5cGUsIHR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG4vKipcbiAqIEltcGxlbWVudHMgdGhlIGxvZ2ljIHRvIGNvbXB1dGUgdGhlIGtleSBvZiBhIGdpdmVuIGZpZWxkJ3MgZW50cnlcbiAqL1xuZnVuY3Rpb24gZ2V0RmllbGRFbnRyeUtleShub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUuYWxpYXMgPyBub2RlLmFsaWFzLnZhbHVlIDogbm9kZS5uYW1lLnZhbHVlO1xufVxuZnVuY3Rpb24gY29sbGVjdFN1YmZpZWxkcyhjb21waWxhdGlvbkNvbnRleHQsIHJldHVyblR5cGUsIGZpZWxkTm9kZXMsIHBhcmVudFJlc3BvbnNlUGF0aCkge1xuICAgIGxldCBzdWJGaWVsZE5vZGVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBjb25zdCB2aXNpdGVkRnJhZ21lbnROYW1lcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgZm9yIChjb25zdCBmaWVsZE5vZGUgb2YgZmllbGROb2Rlcykge1xuICAgICAgICBjb25zdCBzZWxlY3Rpb25TZXQgPSBmaWVsZE5vZGUuc2VsZWN0aW9uU2V0O1xuICAgICAgICBpZiAoc2VsZWN0aW9uU2V0KSB7XG4gICAgICAgICAgICBzdWJGaWVsZE5vZGVzID0gY29sbGVjdEZpZWxkcyhjb21waWxhdGlvbkNvbnRleHQsIHJldHVyblR5cGUsIHNlbGVjdGlvblNldCwgc3ViRmllbGROb2RlcywgdmlzaXRlZEZyYWdtZW50TmFtZXMsIHBhcmVudFJlc3BvbnNlUGF0aCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN1YkZpZWxkTm9kZXM7XG59XG5leHBvcnRzLmNvbGxlY3RTdWJmaWVsZHMgPSBjb2xsZWN0U3ViZmllbGRzO1xuLyoqXG4gKiBQcmVwYXJlcyBhbiBvYmplY3QgbWFwIG9mIGFyZ3VtZW50IHZhbHVlcyBnaXZlbiBhIGxpc3Qgb2YgYXJndW1lbnRcbiAqIGRlZmluaXRpb25zIGFuZCBsaXN0IG9mIGFyZ3VtZW50IEFTVCBub2Rlcy5cbiAqXG4gKiBOb3RlOiBUaGUgcmV0dXJuZWQgdmFsdWUgaXMgYSBwbGFpbiBPYmplY3Qgd2l0aCBhIHByb3RvdHlwZSwgc2luY2UgaXQgaXNcbiAqIGV4cG9zZWQgdG8gdXNlciBjb2RlLiBDYXJlIHNob3VsZCBiZSB0YWtlbiB0byBub3QgcHVsbCB2YWx1ZXMgZnJvbSB0aGVcbiAqIE9iamVjdCBwcm90b3R5cGUuXG4gKi9cbmZ1bmN0aW9uIGdldEFyZ3VtZW50RGVmcyhkZWYsIG5vZGUpIHtcbiAgICBjb25zdCB2YWx1ZXMgPSB7fTtcbiAgICBjb25zdCBtaXNzaW5nID0gW107XG4gICAgY29uc3QgYXJnRGVmcyA9IGRlZi5hcmdzO1xuICAgIGNvbnN0IGFyZ05vZGVzID0gbm9kZS5hcmd1bWVudHMgfHwgW107XG4gICAgY29uc3QgYXJnTm9kZU1hcCA9IGtleU1hcChhcmdOb2RlcywgKGFyZykgPT4gYXJnLm5hbWUudmFsdWUpO1xuICAgIGZvciAoY29uc3QgYXJnRGVmIG9mIGFyZ0RlZnMpIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IGFyZ0RlZi5uYW1lO1xuICAgICAgICBpZiAoYXJnRGVmLmRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBTZXQgdGhlIGNvZXJjZWQgdmFsdWUgdG8gdGhlIGRlZmF1bHRcbiAgICAgICAgICAgIHZhbHVlc1tuYW1lXSA9IGFyZ0RlZi5kZWZhdWx0VmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXJnVHlwZSA9IGFyZ0RlZi50eXBlO1xuICAgICAgICBjb25zdCBhcmd1bWVudE5vZGUgPSBhcmdOb2RlTWFwW25hbWVdO1xuICAgICAgICBsZXQgaGFzVmFyaWFibGVzID0gZmFsc2U7XG4gICAgICAgIGlmIChhcmd1bWVudE5vZGUgJiYgYXJndW1lbnROb2RlLnZhbHVlLmtpbmQgPT09IGxhbmd1YWdlXzEuS2luZC5WQVJJQUJMRSkge1xuICAgICAgICAgICAgaGFzVmFyaWFibGVzID0gdHJ1ZTtcbiAgICAgICAgICAgIG1pc3NpbmcucHVzaCh7XG4gICAgICAgICAgICAgICAgdmFsdWVOb2RlOiBhcmd1bWVudE5vZGUudmFsdWUsXG4gICAgICAgICAgICAgICAgcGF0aDogYWRkUGF0aCh1bmRlZmluZWQsIG5hbWUsIFwibGl0ZXJhbFwiKSxcbiAgICAgICAgICAgICAgICBhcmd1bWVudDogeyBkZWZpbml0aW9uOiBhcmdEZWYsIG5vZGU6IGFyZ3VtZW50Tm9kZSB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhcmd1bWVudE5vZGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvZXJjZWRWYWx1ZSA9IHZhbHVlRnJvbUFTVChhcmd1bWVudE5vZGUudmFsdWUsIGFyZ1R5cGUpO1xuICAgICAgICAgICAgaWYgKGNvZXJjZWRWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgLy8gTm90ZTogVmFsdWVzT2ZDb3JyZWN0VHlwZSB2YWxpZGF0aW9uIHNob3VsZCBjYXRjaCB0aGlzIGJlZm9yZVxuICAgICAgICAgICAgICAgIC8vIGV4ZWN1dGlvbi4gVGhpcyBpcyBhIHJ1bnRpbWUgY2hlY2sgdG8gZW5zdXJlIGV4ZWN1dGlvbiBkb2VzIG5vdFxuICAgICAgICAgICAgICAgIC8vIGNvbnRpbnVlIHdpdGggYW4gaW52YWxpZCBhcmd1bWVudCB2YWx1ZS5cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ3JhcGhxbF8xLkdyYXBoUUxFcnJvcihgQXJndW1lbnQgXCIke25hbWV9XCIgb2YgdHlwZSBcIiR7YXJnVHlwZX1cIiBoYXMgaW52YWxpZCB2YWx1ZSAkeygwLCBncmFwaHFsXzEucHJpbnQpKGFyZ3VtZW50Tm9kZS52YWx1ZSl9LmAsICgwLCBjb21wYXRfMS5nZXRHcmFwaFFMRXJyb3JPcHRpb25zKShhcmd1bWVudE5vZGUudmFsdWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0FTVFZhbHVlV2l0aFZhcmlhYmxlcyhjb2VyY2VkVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgbWlzc2luZy5wdXNoKC4uLmNvZXJjZWRWYWx1ZS52YXJpYWJsZXMubWFwKCh7IHZhbHVlTm9kZSwgcGF0aCB9KSA9PiAoe1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZU5vZGUsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGFkZFBhdGgocGF0aCwgbmFtZSwgXCJsaXRlcmFsXCIpXG4gICAgICAgICAgICAgICAgfSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbHVlc1tuYW1lXSA9IGNvZXJjZWRWYWx1ZS52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKDAsIGdyYXBocWxfMS5pc05vbk51bGxUeXBlKShhcmdUeXBlKSAmJiB2YWx1ZXNbbmFtZV0gPT09IHVuZGVmaW5lZCAmJiAhaGFzVmFyaWFibGVzKSB7XG4gICAgICAgICAgICAvLyBJZiBubyB2YWx1ZSBvciBhIG51bGxpc2ggdmFsdWUgd2FzIHByb3ZpZGVkIHRvIGEgdmFyaWFibGUgd2l0aCBhXG4gICAgICAgICAgICAvLyBub24tbnVsbCB0eXBlIChyZXF1aXJlZCksIHByb2R1Y2UgYW4gZXJyb3IuXG4gICAgICAgICAgICB0aHJvdyBuZXcgZ3JhcGhxbF8xLkdyYXBoUUxFcnJvcihhcmd1bWVudE5vZGVcbiAgICAgICAgICAgICAgICA/IGBBcmd1bWVudCBcIiR7bmFtZX1cIiBvZiBub24tbnVsbCB0eXBlIGAgK1xuICAgICAgICAgICAgICAgICAgICBgXCIke2FyZ1R5cGV9XCIgbXVzdCBub3QgYmUgbnVsbC5gXG4gICAgICAgICAgICAgICAgOiBgQXJndW1lbnQgXCIke25hbWV9XCIgb2YgcmVxdWlyZWQgdHlwZSBgICtcbiAgICAgICAgICAgICAgICAgICAgYFwiJHthcmdUeXBlfVwiIHdhcyBub3QgcHJvdmlkZWQuYCwgKDAsIGNvbXBhdF8xLmdldEdyYXBoUUxFcnJvck9wdGlvbnMpKG5vZGUpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyB2YWx1ZXMsIG1pc3NpbmcgfTtcbn1cbmV4cG9ydHMuZ2V0QXJndW1lbnREZWZzID0gZ2V0QXJndW1lbnREZWZzO1xuZnVuY3Rpb24gaXNBU1RWYWx1ZVdpdGhWYXJpYWJsZXMoeCkge1xuICAgIHJldHVybiAhIXgudmFyaWFibGVzO1xufVxuZnVuY3Rpb24gdmFsdWVGcm9tQVNUKHZhbHVlTm9kZSwgdHlwZSkge1xuICAgIGlmICgoMCwgZ3JhcGhxbF8xLmlzTm9uTnVsbFR5cGUpKHR5cGUpKSB7XG4gICAgICAgIGlmICh2YWx1ZU5vZGUua2luZCA9PT0gbGFuZ3VhZ2VfMS5LaW5kLk5VTEwpIHtcbiAgICAgICAgICAgIHJldHVybjsgLy8gSW52YWxpZDogaW50ZW50aW9uYWxseSByZXR1cm4gbm8gdmFsdWUuXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlRnJvbUFTVCh2YWx1ZU5vZGUsIHR5cGUub2ZUeXBlKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlTm9kZS5raW5kID09PSBsYW5ndWFnZV8xLktpbmQuTlVMTCkge1xuICAgICAgICAvLyBUaGlzIGlzIGV4cGxpY2l0bHkgcmV0dXJuaW5nIHRoZSB2YWx1ZSBudWxsLlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IG51bGxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHZhbHVlTm9kZS5raW5kID09PSBsYW5ndWFnZV8xLktpbmQuVkFSSUFCTEUpIHtcbiAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG51bGwsIHZhcmlhYmxlczogW3sgdmFsdWVOb2RlLCBwYXRoOiB1bmRlZmluZWQgfV0gfTtcbiAgICB9XG4gICAgaWYgKCgwLCBncmFwaHFsXzEuaXNMaXN0VHlwZSkodHlwZSkpIHtcbiAgICAgICAgY29uc3QgaXRlbVR5cGUgPSB0eXBlLm9mVHlwZTtcbiAgICAgICAgaWYgKHZhbHVlTm9kZS5raW5kID09PSBsYW5ndWFnZV8xLktpbmQuTElTVCkge1xuICAgICAgICAgICAgY29uc3QgY29lcmNlZFZhbHVlcyA9IFtdO1xuICAgICAgICAgICAgY29uc3QgdmFyaWFibGVzID0gW107XG4gICAgICAgICAgICBjb25zdCBpdGVtTm9kZXMgPSB2YWx1ZU5vZGUudmFsdWVzO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVtTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtTm9kZSA9IGl0ZW1Ob2Rlc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbU5vZGUua2luZCA9PT0gbGFuZ3VhZ2VfMS5LaW5kLlZBUklBQkxFKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvZXJjZWRWYWx1ZXMucHVzaChudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyaWFibGVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVOb2RlOiBpdGVtTm9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IGFkZFBhdGgodW5kZWZpbmVkLCBpLnRvU3RyaW5nKCksIFwibGl0ZXJhbFwiKVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW1WYWx1ZSA9IHZhbHVlRnJvbUFTVChpdGVtTm9kZSwgaXRlbVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWl0ZW1WYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBJbnZhbGlkOiBpbnRlbnRpb25hbGx5IHJldHVybiBubyB2YWx1ZS5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb2VyY2VkVmFsdWVzLnB1c2goaXRlbVZhbHVlLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQVNUVmFsdWVXaXRoVmFyaWFibGVzKGl0ZW1WYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlcy5wdXNoKC4uLml0ZW1WYWx1ZS52YXJpYWJsZXMubWFwKCh7IHZhbHVlTm9kZSwgcGF0aCB9KSA9PiAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlTm9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiBhZGRQYXRoKHBhdGgsIGkudG9TdHJpbmcoKSwgXCJsaXRlcmFsXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IGNvZXJjZWRWYWx1ZXMsIHZhcmlhYmxlcyB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIFNpbmdsZSBpdGVtIHdoaWNoIHdpbGwgYmUgY29lcmNlZCB0byBhIGxpc3RcbiAgICAgICAgY29uc3QgY29lcmNlZFZhbHVlID0gdmFsdWVGcm9tQVNUKHZhbHVlTm9kZSwgaXRlbVR5cGUpO1xuICAgICAgICBpZiAoY29lcmNlZFZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjsgLy8gSW52YWxpZDogaW50ZW50aW9uYWxseSByZXR1cm4gbm8gdmFsdWUuXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQVNUVmFsdWVXaXRoVmFyaWFibGVzKGNvZXJjZWRWYWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IFtjb2VyY2VkVmFsdWUudmFsdWVdLFxuICAgICAgICAgICAgICAgIHZhcmlhYmxlczogY29lcmNlZFZhbHVlLnZhcmlhYmxlcy5tYXAoKHsgdmFsdWVOb2RlLCBwYXRoIH0pID0+ICh7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlTm9kZSxcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogYWRkUGF0aChwYXRoLCBcIjBcIiwgXCJsaXRlcmFsXCIpXG4gICAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHZhbHVlOiBbY29lcmNlZFZhbHVlLnZhbHVlXSB9O1xuICAgIH1cbiAgICBpZiAoKDAsIGdyYXBocWxfMS5pc0lucHV0T2JqZWN0VHlwZSkodHlwZSkpIHtcbiAgICAgICAgaWYgKHZhbHVlTm9kZS5raW5kICE9PSBsYW5ndWFnZV8xLktpbmQuT0JKRUNUKSB7XG4gICAgICAgICAgICByZXR1cm47IC8vIEludmFsaWQ6IGludGVudGlvbmFsbHkgcmV0dXJuIG5vIHZhbHVlLlxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvZXJjZWRPYmogPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBjb25zdCB2YXJpYWJsZXMgPSBbXTtcbiAgICAgICAgY29uc3QgZmllbGROb2RlcyA9IGtleU1hcCh2YWx1ZU5vZGUuZmllbGRzLCAoZmllbGQpID0+IGZpZWxkLm5hbWUudmFsdWUpO1xuICAgICAgICBjb25zdCBmaWVsZHMgPSBPYmplY3QudmFsdWVzKHR5cGUuZ2V0RmllbGRzKCkpO1xuICAgICAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIGZpZWxkcykge1xuICAgICAgICAgICAgaWYgKGZpZWxkLmRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29lcmNlZE9ialtmaWVsZC5uYW1lXSA9IGZpZWxkLmRlZmF1bHRWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGZpZWxkTm9kZSA9IGZpZWxkTm9kZXNbZmllbGQubmFtZV07XG4gICAgICAgICAgICBpZiAoIWZpZWxkTm9kZSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZmllbGRWYWx1ZSA9IHZhbHVlRnJvbUFTVChmaWVsZE5vZGUudmFsdWUsIGZpZWxkLnR5cGUpO1xuICAgICAgICAgICAgaWYgKCFmaWVsZFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBJbnZhbGlkOiBpbnRlbnRpb25hbGx5IHJldHVybiBubyB2YWx1ZS5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0FTVFZhbHVlV2l0aFZhcmlhYmxlcyhmaWVsZFZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHZhcmlhYmxlcy5wdXNoKC4uLmZpZWxkVmFsdWUudmFyaWFibGVzLm1hcCgoeyB2YWx1ZU5vZGUsIHBhdGggfSkgPT4gKHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVOb2RlLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBhZGRQYXRoKHBhdGgsIGZpZWxkLm5hbWUsIFwibGl0ZXJhbFwiKVxuICAgICAgICAgICAgICAgIH0pKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb2VyY2VkT2JqW2ZpZWxkLm5hbWVdID0gZmllbGRWYWx1ZS52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyB2YWx1ZTogY29lcmNlZE9iaiwgdmFyaWFibGVzIH07XG4gICAgfVxuICAgIGlmICgoMCwgZ3JhcGhxbF8xLmlzRW51bVR5cGUpKHR5cGUpKSB7XG4gICAgICAgIGlmICh2YWx1ZU5vZGUua2luZCAhPT0gbGFuZ3VhZ2VfMS5LaW5kLkVOVU0pIHtcbiAgICAgICAgICAgIHJldHVybjsgLy8gSW52YWxpZDogaW50ZW50aW9uYWxseSByZXR1cm4gbm8gdmFsdWUuXG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZW51bVZhbHVlID0gdHlwZS5nZXRWYWx1ZSh2YWx1ZU5vZGUudmFsdWUpO1xuICAgICAgICBpZiAoIWVudW1WYWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuOyAvLyBJbnZhbGlkOiBpbnRlbnRpb25hbGx5IHJldHVybiBubyB2YWx1ZS5cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyB2YWx1ZTogZW51bVZhbHVlLnZhbHVlIH07XG4gICAgfVxuICAgIGlmICgoMCwgZ3JhcGhxbF8xLmlzU2NhbGFyVHlwZSkodHlwZSkpIHtcbiAgICAgICAgLy8gU2NhbGFycyBmdWxmaWxsIHBhcnNpbmcgYSBsaXRlcmFsIHZhbHVlIHZpYSBwYXJzZUxpdGVyYWwoKS5cbiAgICAgICAgLy8gSW52YWxpZCB2YWx1ZXMgcmVwcmVzZW50IGEgZmFpbHVyZSB0byBwYXJzZSBjb3JyZWN0bHksIGluIHdoaWNoIGNhc2VcbiAgICAgICAgLy8gbm8gdmFsdWUgaXMgcmV0dXJuZWQuXG4gICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodHlwZS5wYXJzZUxpdGVyYWwubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJTY2FsYXIgd2l0aCB2YXJpYWJsZSBpbnB1dHMgZGV0ZWN0ZWQgZm9yIHBhcnNpbmcgQVNUIGxpdGVyYWxzLiBUaGlzIGlzIG5vdCBzdXBwb3J0ZWQuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0ID0gdHlwZS5wYXJzZUxpdGVyYWwodmFsdWVOb2RlLCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm47IC8vIEludmFsaWQ6IGludGVudGlvbmFsbHkgcmV0dXJuIG5vIHZhbHVlLlxuICAgICAgICB9XG4gICAgICAgIGlmIChpc0ludmFsaWQocmVzdWx0KSkge1xuICAgICAgICAgICAgcmV0dXJuOyAvLyBJbnZhbGlkOiBpbnRlbnRpb25hbGx5IHJldHVybiBubyB2YWx1ZS5cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyB2YWx1ZTogcmVzdWx0IH07XG4gICAgfVxuICAgIC8vIE5vdCByZWFjaGFibGUuIEFsbCBwb3NzaWJsZSBpbnB1dCB0eXBlcyBoYXZlIGJlZW4gY29uc2lkZXJlZC5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBpbnB1dCB0eXBlOiBcIiR7aW5zcGVjdCh0eXBlKX1cIi5gKTtcbn1cbmV4cG9ydHMudmFsdWVGcm9tQVNUID0gdmFsdWVGcm9tQVNUO1xuLyoqXG4gKiBDcmVhdGVzIGEga2V5ZWQgSlMgb2JqZWN0IGZyb20gYW4gYXJyYXksIGdpdmVuIGEgZnVuY3Rpb24gdG8gcHJvZHVjZSB0aGUga2V5c1xuICogZm9yIGVhY2ggdmFsdWUgaW4gdGhlIGFycmF5LlxuICpcbiAqIFRoaXMgcHJvdmlkZXMgYSBjb252ZW5pZW50IGxvb2t1cCBmb3IgdGhlIGFycmF5IGl0ZW1zIGlmIHRoZSBrZXkgZnVuY3Rpb25cbiAqIHByb2R1Y2VzIHVuaXF1ZSByZXN1bHRzLlxuICpcbiAqICAgICBjb25zdCBwaG9uZUJvb2sgPSBbXG4gKiAgICAgICB7IG5hbWU6ICdKb24nLCBudW06ICc1NTUtMTIzNCcgfSxcbiAqICAgICAgIHsgbmFtZTogJ0plbm55JywgbnVtOiAnODY3LTUzMDknIH1cbiAqICAgICBdXG4gKlxuICogICAgIC8vIHsgSm9uOiB7IG5hbWU6ICdKb24nLCBudW06ICc1NTUtMTIzNCcgfSxcbiAqICAgICAvLyAgIEplbm55OiB7IG5hbWU6ICdKZW5ueScsIG51bTogJzg2Ny01MzA5JyB9IH1cbiAqICAgICBjb25zdCBlbnRyaWVzQnlOYW1lID0ga2V5TWFwKFxuICogICAgICAgcGhvbmVCb29rLFxuICogICAgICAgZW50cnkgPT4gZW50cnkubmFtZVxuICogICAgIClcbiAqXG4gKiAgICAgLy8geyBuYW1lOiAnSmVubnknLCBudW06ICc4NTctNjMwOScgfVxuICogICAgIGNvbnN0IGplbm55RW50cnkgPSBlbnRyaWVzQnlOYW1lWydKZW5ueSddXG4gKlxuICovXG5mdW5jdGlvbiBrZXlNYXAobGlzdCwga2V5Rm4pIHtcbiAgICByZXR1cm4gbGlzdC5yZWR1Y2UoXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlcXVlbmNlc1xuICAgIChtYXAsIGl0ZW0pID0+ICgobWFwW2tleUZuKGl0ZW0pXSA9IGl0ZW0pLCBtYXApLCBPYmplY3QuY3JlYXRlKG51bGwpKTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVMb2NhdGlvbnMobm9kZXMpIHtcbiAgICByZXR1cm4gbm9kZXMucmVkdWNlKChsaXN0LCBub2RlKSA9PiB7XG4gICAgICAgIGlmIChub2RlLmxvYykge1xuICAgICAgICAgICAgbGlzdC5wdXNoKCgwLCBncmFwaHFsXzEuZ2V0TG9jYXRpb24pKG5vZGUubG9jLnNvdXJjZSwgbm9kZS5sb2Muc3RhcnQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGlzdDtcbiAgICB9LCBbXSk7XG59XG5leHBvcnRzLmNvbXB1dGVMb2NhdGlvbnMgPSBjb21wdXRlTG9jYXRpb25zO1xuZnVuY3Rpb24gYWRkUGF0aChyZXNwb25zZVBhdGgsIGtleSwgdHlwZSA9IFwibGl0ZXJhbFwiKSB7XG4gICAgcmV0dXJuIHsgcHJldjogcmVzcG9uc2VQYXRoLCBrZXksIHR5cGUgfTtcbn1cbmV4cG9ydHMuYWRkUGF0aCA9IGFkZFBhdGg7XG5mdW5jdGlvbiBmbGF0dGVuUGF0aChwYXRoKSB7XG4gICAgY29uc3QgZmxhdHRlbmVkID0gW107XG4gICAgbGV0IGN1cnIgPSBwYXRoO1xuICAgIHdoaWxlIChjdXJyKSB7XG4gICAgICAgIGZsYXR0ZW5lZC5wdXNoKHsga2V5OiBjdXJyLmtleSwgdHlwZTogY3Vyci50eXBlIH0pO1xuICAgICAgICBjdXJyID0gY3Vyci5wcmV2O1xuICAgIH1cbiAgICByZXR1cm4gZmxhdHRlbmVkO1xufVxuZXhwb3J0cy5mbGF0dGVuUGF0aCA9IGZsYXR0ZW5QYXRoO1xuLyoqXG4gKiBTZXJpYWxpemUgYSBwYXRoIGZvciB1c2UgaW4gdGhlIHNraXAvaW5jbHVkZSBkaXJlY3RpdmVzLlxuICpcbiAqIEBwYXJhbSBwYXRoIFRoZSBwYXRoIHRvIHNlcmlhbGl6ZVxuICogQHJldHVybnMgVGhlIHBhdGggc2VyaWFsaXplZCBhcyBhIHN0cmluZywgd2l0aCB0aGUgcm9vdCBwYXRoIGZpcnN0LlxuICovXG5mdW5jdGlvbiBzZXJpYWxpemVPYmplY3RQYXRoRm9yU2tpcEluY2x1ZGUocGF0aCkge1xuICAgIGxldCBzZXJpYWxpemVkID0gXCJcIjtcbiAgICBsZXQgY3VyciA9IHBhdGg7XG4gICAgd2hpbGUgKGN1cnIpIHtcbiAgICAgICAgaWYgKGN1cnIudHlwZSA9PT0gXCJsaXRlcmFsXCIpIHtcbiAgICAgICAgICAgIHNlcmlhbGl6ZWQgPSBqb2luU2tpcEluY2x1ZGVQYXRoKGN1cnIua2V5LCBzZXJpYWxpemVkKTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyID0gY3Vyci5wcmV2O1xuICAgIH1cbiAgICByZXR1cm4gc2VyaWFsaXplZDtcbn1cbmV4cG9ydHMuc2VyaWFsaXplT2JqZWN0UGF0aEZvclNraXBJbmNsdWRlID0gc2VyaWFsaXplT2JqZWN0UGF0aEZvclNraXBJbmNsdWRlO1xuLyoqXG4gKiBqb2luIHR3byBwYXRoIHNlZ21lbnRzIHRvIGEgZG90IG5vdGF0aW9uLCBoYW5kbGluZyBlbXB0eSBzdHJpbmdzXG4gKlxuICogQHBhcmFtIGEgcGF0aCBzZWdtZW50XG4gKiBAcGFyYW0gYiBwYXRoIHNlZ21lbnRcbiAqIEByZXR1cm5zIGNvbWJpbmVkIHBhdGggaW4gZG90IG5vdGF0aW9uXG4gKi9cbmZ1bmN0aW9uIGpvaW5Ta2lwSW5jbHVkZVBhdGgoYSwgYikge1xuICAgIGlmIChhKSB7XG4gICAgICAgIGlmIChiKSB7XG4gICAgICAgICAgICByZXR1cm4gYCR7YX0uJHtifWA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfVxuICAgIHJldHVybiBiO1xufVxuZXhwb3J0cy5qb2luU2tpcEluY2x1ZGVQYXRoID0gam9pblNraXBJbmNsdWRlUGF0aDtcbmZ1bmN0aW9uIGlzSW52YWxpZCh2YWx1ZSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSAhPT0gdmFsdWU7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hc3QuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/graphql-jit/dist/esm/ast.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/graphql-jit/dist/esm/compat.js":
/*!******************************************************!*\
  !*** ../node_modules/graphql-jit/dist/esm/compat.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.resolveFieldDef = exports.getGraphQLErrorOptions = exports.formatError = exports.getOperationRootType = void 0;\nconst graphql_1 = __webpack_require__(/*! graphql */ \"(ssr)/../node_modules/graphql/index.mjs\");\nconst errorUtilities = __importStar(__webpack_require__(/*! graphql/error */ \"(ssr)/../node_modules/graphql/error/index.js\"));\nconst utilities = __importStar(__webpack_require__(/*! graphql/utilities */ \"(ssr)/../node_modules/graphql/utilities/index.js\"));\nconst execute = __importStar(__webpack_require__(/*! graphql/execution/execute */ \"(ssr)/../node_modules/graphql/execution/execute.js\"));\n/**\n * A helper file to support backward compatibility for different versions of graphql-js.\n */\n/**\n * v15 does not have schema.getRootType\n * v16 has both\n * v17 will not have getOperationRootType\n *\n * To support all these 3 versions of graphql-js, at least for migration, this helper\n * would be useful.\n *\n * This can be removed once we drop support for v15.\n *\n * GraphQL v17 would remove getOperationRootType.\n */\nfunction getOperationRootType(schema, operation) {\n    if (graphql_1.versionInfo.major < 16) {\n        return utilities.getOperationRootType(schema, operation);\n    }\n    const type = schema.getRootType(operation.operation);\n    if (!type) {\n        throw new Error(`No root type for operation ${operation.operation}`);\n    }\n    return type;\n}\nexports.getOperationRootType = getOperationRootType;\n/**\n * v16 and lower versions don't have .toJSON method on GraphQLError\n * v17 does have .toJSON and doesn't have \"formatError\" export anymore\n */\nfunction formatError(error) {\n    if (graphql_1.versionInfo.major < 16) {\n        return errorUtilities.formatError(error);\n    }\n    return error.toJSON();\n}\nexports.formatError = formatError;\n/**\n * v17 dropped support for positional arguments in GraphQLError constructor\n * https://github.com/graphql/graphql-js/pull/3577\n */\nfunction getGraphQLErrorOptions(nodes) {\n    if (graphql_1.versionInfo.major < 16) {\n        return nodes;\n    }\n    return { nodes };\n}\nexports.getGraphQLErrorOptions = getGraphQLErrorOptions;\n/**\n * Resolves the field on the given source object. In particular, this\n * figures out the value that the field returns by calling its resolve function,\n * then calls completeValue to complete promises, serialize scalars, or execute\n * the sub-selection-set for objects.\n *\n * v15 has getFieldDef that accepts field name\n * v16 has getFieldDef that accepts field node\n * v17 drops getFieldDef support and adds getField method\n */\nfunction resolveFieldDef(compilationContext, parentType, fieldNodes) {\n    const fieldNode = fieldNodes[0];\n    if (graphql_1.versionInfo.major < 16) {\n        const fieldName = fieldNode.name.value;\n        return execute.getFieldDef(compilationContext.schema, parentType, fieldName);\n    }\n    if (graphql_1.versionInfo.major < 17) {\n        return execute.getFieldDef(compilationContext.schema, parentType, fieldNode);\n    }\n    return compilationContext.schema.getField(parentType, fieldNode.name.value);\n}\nexports.resolveFieldDef = resolveFieldDef;\n//# sourceMappingURL=compat.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL2dyYXBocWwtaml0L2Rpc3QvZXNtL2NvbXBhdC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsdUJBQXVCLEdBQUcsOEJBQThCLEdBQUcsbUJBQW1CLEdBQUcsNEJBQTRCO0FBQzdHLGtCQUFrQixtQkFBTyxDQUFDLHdEQUFTO0FBQ25DLG9DQUFvQyxtQkFBTyxDQUFDLG1FQUFlO0FBQzNELCtCQUErQixtQkFBTyxDQUFDLDJFQUFtQjtBQUMxRCw2QkFBNkIsbUJBQU8sQ0FBQyxxRkFBMkI7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELG9CQUFvQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sZWRnaXR5LXlpZWxkLWZyb250ZW5kLy4uL25vZGVfbW9kdWxlcy9ncmFwaHFsLWppdC9kaXN0L2VzbS9jb21wYXQuanM/MWY4MSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5yZXNvbHZlRmllbGREZWYgPSBleHBvcnRzLmdldEdyYXBoUUxFcnJvck9wdGlvbnMgPSBleHBvcnRzLmZvcm1hdEVycm9yID0gZXhwb3J0cy5nZXRPcGVyYXRpb25Sb290VHlwZSA9IHZvaWQgMDtcbmNvbnN0IGdyYXBocWxfMSA9IHJlcXVpcmUoXCJncmFwaHFsXCIpO1xuY29uc3QgZXJyb3JVdGlsaXRpZXMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcImdyYXBocWwvZXJyb3JcIikpO1xuY29uc3QgdXRpbGl0aWVzID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJncmFwaHFsL3V0aWxpdGllc1wiKSk7XG5jb25zdCBleGVjdXRlID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJncmFwaHFsL2V4ZWN1dGlvbi9leGVjdXRlXCIpKTtcbi8qKlxuICogQSBoZWxwZXIgZmlsZSB0byBzdXBwb3J0IGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgZm9yIGRpZmZlcmVudCB2ZXJzaW9ucyBvZiBncmFwaHFsLWpzLlxuICovXG4vKipcbiAqIHYxNSBkb2VzIG5vdCBoYXZlIHNjaGVtYS5nZXRSb290VHlwZVxuICogdjE2IGhhcyBib3RoXG4gKiB2MTcgd2lsbCBub3QgaGF2ZSBnZXRPcGVyYXRpb25Sb290VHlwZVxuICpcbiAqIFRvIHN1cHBvcnQgYWxsIHRoZXNlIDMgdmVyc2lvbnMgb2YgZ3JhcGhxbC1qcywgYXQgbGVhc3QgZm9yIG1pZ3JhdGlvbiwgdGhpcyBoZWxwZXJcbiAqIHdvdWxkIGJlIHVzZWZ1bC5cbiAqXG4gKiBUaGlzIGNhbiBiZSByZW1vdmVkIG9uY2Ugd2UgZHJvcCBzdXBwb3J0IGZvciB2MTUuXG4gKlxuICogR3JhcGhRTCB2MTcgd291bGQgcmVtb3ZlIGdldE9wZXJhdGlvblJvb3RUeXBlLlxuICovXG5mdW5jdGlvbiBnZXRPcGVyYXRpb25Sb290VHlwZShzY2hlbWEsIG9wZXJhdGlvbikge1xuICAgIGlmIChncmFwaHFsXzEudmVyc2lvbkluZm8ubWFqb3IgPCAxNikge1xuICAgICAgICByZXR1cm4gdXRpbGl0aWVzLmdldE9wZXJhdGlvblJvb3RUeXBlKHNjaGVtYSwgb3BlcmF0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgdHlwZSA9IHNjaGVtYS5nZXRSb290VHlwZShvcGVyYXRpb24ub3BlcmF0aW9uKTtcbiAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyByb290IHR5cGUgZm9yIG9wZXJhdGlvbiAke29wZXJhdGlvbi5vcGVyYXRpb259YCk7XG4gICAgfVxuICAgIHJldHVybiB0eXBlO1xufVxuZXhwb3J0cy5nZXRPcGVyYXRpb25Sb290VHlwZSA9IGdldE9wZXJhdGlvblJvb3RUeXBlO1xuLyoqXG4gKiB2MTYgYW5kIGxvd2VyIHZlcnNpb25zIGRvbid0IGhhdmUgLnRvSlNPTiBtZXRob2Qgb24gR3JhcGhRTEVycm9yXG4gKiB2MTcgZG9lcyBoYXZlIC50b0pTT04gYW5kIGRvZXNuJ3QgaGF2ZSBcImZvcm1hdEVycm9yXCIgZXhwb3J0IGFueW1vcmVcbiAqL1xuZnVuY3Rpb24gZm9ybWF0RXJyb3IoZXJyb3IpIHtcbiAgICBpZiAoZ3JhcGhxbF8xLnZlcnNpb25JbmZvLm1ham9yIDwgMTYpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yVXRpbGl0aWVzLmZvcm1hdEVycm9yKGVycm9yKTtcbiAgICB9XG4gICAgcmV0dXJuIGVycm9yLnRvSlNPTigpO1xufVxuZXhwb3J0cy5mb3JtYXRFcnJvciA9IGZvcm1hdEVycm9yO1xuLyoqXG4gKiB2MTcgZHJvcHBlZCBzdXBwb3J0IGZvciBwb3NpdGlvbmFsIGFyZ3VtZW50cyBpbiBHcmFwaFFMRXJyb3IgY29uc3RydWN0b3JcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9ncmFwaHFsL2dyYXBocWwtanMvcHVsbC8zNTc3XG4gKi9cbmZ1bmN0aW9uIGdldEdyYXBoUUxFcnJvck9wdGlvbnMobm9kZXMpIHtcbiAgICBpZiAoZ3JhcGhxbF8xLnZlcnNpb25JbmZvLm1ham9yIDwgMTYpIHtcbiAgICAgICAgcmV0dXJuIG5vZGVzO1xuICAgIH1cbiAgICByZXR1cm4geyBub2RlcyB9O1xufVxuZXhwb3J0cy5nZXRHcmFwaFFMRXJyb3JPcHRpb25zID0gZ2V0R3JhcGhRTEVycm9yT3B0aW9ucztcbi8qKlxuICogUmVzb2x2ZXMgdGhlIGZpZWxkIG9uIHRoZSBnaXZlbiBzb3VyY2Ugb2JqZWN0LiBJbiBwYXJ0aWN1bGFyLCB0aGlzXG4gKiBmaWd1cmVzIG91dCB0aGUgdmFsdWUgdGhhdCB0aGUgZmllbGQgcmV0dXJucyBieSBjYWxsaW5nIGl0cyByZXNvbHZlIGZ1bmN0aW9uLFxuICogdGhlbiBjYWxscyBjb21wbGV0ZVZhbHVlIHRvIGNvbXBsZXRlIHByb21pc2VzLCBzZXJpYWxpemUgc2NhbGFycywgb3IgZXhlY3V0ZVxuICogdGhlIHN1Yi1zZWxlY3Rpb24tc2V0IGZvciBvYmplY3RzLlxuICpcbiAqIHYxNSBoYXMgZ2V0RmllbGREZWYgdGhhdCBhY2NlcHRzIGZpZWxkIG5hbWVcbiAqIHYxNiBoYXMgZ2V0RmllbGREZWYgdGhhdCBhY2NlcHRzIGZpZWxkIG5vZGVcbiAqIHYxNyBkcm9wcyBnZXRGaWVsZERlZiBzdXBwb3J0IGFuZCBhZGRzIGdldEZpZWxkIG1ldGhvZFxuICovXG5mdW5jdGlvbiByZXNvbHZlRmllbGREZWYoY29tcGlsYXRpb25Db250ZXh0LCBwYXJlbnRUeXBlLCBmaWVsZE5vZGVzKSB7XG4gICAgY29uc3QgZmllbGROb2RlID0gZmllbGROb2Rlc1swXTtcbiAgICBpZiAoZ3JhcGhxbF8xLnZlcnNpb25JbmZvLm1ham9yIDwgMTYpIHtcbiAgICAgICAgY29uc3QgZmllbGROYW1lID0gZmllbGROb2RlLm5hbWUudmFsdWU7XG4gICAgICAgIHJldHVybiBleGVjdXRlLmdldEZpZWxkRGVmKGNvbXBpbGF0aW9uQ29udGV4dC5zY2hlbWEsIHBhcmVudFR5cGUsIGZpZWxkTmFtZSk7XG4gICAgfVxuICAgIGlmIChncmFwaHFsXzEudmVyc2lvbkluZm8ubWFqb3IgPCAxNykge1xuICAgICAgICByZXR1cm4gZXhlY3V0ZS5nZXRGaWVsZERlZihjb21waWxhdGlvbkNvbnRleHQuc2NoZW1hLCBwYXJlbnRUeXBlLCBmaWVsZE5vZGUpO1xuICAgIH1cbiAgICByZXR1cm4gY29tcGlsYXRpb25Db250ZXh0LnNjaGVtYS5nZXRGaWVsZChwYXJlbnRUeXBlLCBmaWVsZE5vZGUubmFtZS52YWx1ZSk7XG59XG5leHBvcnRzLnJlc29sdmVGaWVsZERlZiA9IHJlc29sdmVGaWVsZERlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbXBhdC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/graphql-jit/dist/esm/compat.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/graphql-jit/dist/esm/error.js":
/*!*****************************************************!*\
  !*** ../node_modules/graphql-jit/dist/esm/error.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Based on https://github.com/graphql/graphql-js/blob/master/src/error/GraphQLError.js\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.GraphQLError = void 0;\nconst graphql_1 = __webpack_require__(/*! graphql */ \"(ssr)/../node_modules/graphql/index.mjs\");\nfunction GraphQLError(message, locations, path, originalError, skipStackCapturing) {\n    const extensions = originalError && originalError.extensions;\n    Object.defineProperties(this, {\n        message: {\n            value: message,\n            enumerable: true\n        },\n        locations: {\n            value: locations || undefined,\n            enumerable: locations && locations.length > 0\n        },\n        path: {\n            value: path || undefined,\n            enumerable: Boolean(path)\n        },\n        originalError: {\n            value: originalError\n        },\n        extensions: {\n            // Coercing falsey values to undefined ensures they will not be included\n            // in JSON.stringify() when not provided.\n            value: extensions || undefined,\n            enumerable: Boolean(extensions)\n        }\n    });\n    // Include (non-enumerable) stack trace.\n    if (originalError && originalError.stack) {\n        Object.defineProperty(this, \"stack\", {\n            value: originalError.stack,\n            writable: true,\n            configurable: true\n        });\n    }\n    else if (!skipStackCapturing) {\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(this, GraphQLError);\n        }\n        else {\n            Object.defineProperty(this, \"stack\", {\n                value: Error().stack,\n                writable: true,\n                configurable: true\n            });\n        }\n    }\n}\nexports.GraphQLError = GraphQLError;\nGraphQLError.prototype = Object.create(graphql_1.GraphQLError.prototype, {\n    constructor: { value: GraphQLError },\n    name: { value: \"GraphQLError\" }\n});\n//# sourceMappingURL=error.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL2dyYXBocWwtaml0L2Rpc3QvZXNtL2Vycm9yLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG9CQUFvQjtBQUNwQixrQkFBa0IsbUJBQU8sQ0FBQyx3REFBUztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0EsbUJBQW1CLHFCQUFxQjtBQUN4QyxZQUFZO0FBQ1osQ0FBQztBQUNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGVkZ2l0eS15aWVsZC1mcm9udGVuZC8uLi9ub2RlX21vZHVsZXMvZ3JhcGhxbC1qaXQvZGlzdC9lc20vZXJyb3IuanM/Yjk3MSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL2dyYXBocWwvZ3JhcGhxbC1qcy9ibG9iL21hc3Rlci9zcmMvZXJyb3IvR3JhcGhRTEVycm9yLmpzXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuR3JhcGhRTEVycm9yID0gdm9pZCAwO1xuY29uc3QgZ3JhcGhxbF8xID0gcmVxdWlyZShcImdyYXBocWxcIik7XG5mdW5jdGlvbiBHcmFwaFFMRXJyb3IobWVzc2FnZSwgbG9jYXRpb25zLCBwYXRoLCBvcmlnaW5hbEVycm9yLCBza2lwU3RhY2tDYXB0dXJpbmcpIHtcbiAgICBjb25zdCBleHRlbnNpb25zID0gb3JpZ2luYWxFcnJvciAmJiBvcmlnaW5hbEVycm9yLmV4dGVuc2lvbnM7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgICBtZXNzYWdlOiB7XG4gICAgICAgICAgICB2YWx1ZTogbWVzc2FnZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgbG9jYXRpb25zOiB7XG4gICAgICAgICAgICB2YWx1ZTogbG9jYXRpb25zIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGxvY2F0aW9ucyAmJiBsb2NhdGlvbnMubGVuZ3RoID4gMFxuICAgICAgICB9LFxuICAgICAgICBwYXRoOiB7XG4gICAgICAgICAgICB2YWx1ZTogcGF0aCB8fCB1bmRlZmluZWQsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBCb29sZWFuKHBhdGgpXG4gICAgICAgIH0sXG4gICAgICAgIG9yaWdpbmFsRXJyb3I6IHtcbiAgICAgICAgICAgIHZhbHVlOiBvcmlnaW5hbEVycm9yXG4gICAgICAgIH0sXG4gICAgICAgIGV4dGVuc2lvbnM6IHtcbiAgICAgICAgICAgIC8vIENvZXJjaW5nIGZhbHNleSB2YWx1ZXMgdG8gdW5kZWZpbmVkIGVuc3VyZXMgdGhleSB3aWxsIG5vdCBiZSBpbmNsdWRlZFxuICAgICAgICAgICAgLy8gaW4gSlNPTi5zdHJpbmdpZnkoKSB3aGVuIG5vdCBwcm92aWRlZC5cbiAgICAgICAgICAgIHZhbHVlOiBleHRlbnNpb25zIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IEJvb2xlYW4oZXh0ZW5zaW9ucylcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIC8vIEluY2x1ZGUgKG5vbi1lbnVtZXJhYmxlKSBzdGFjayB0cmFjZS5cbiAgICBpZiAob3JpZ2luYWxFcnJvciAmJiBvcmlnaW5hbEVycm9yLnN0YWNrKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0YWNrXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiBvcmlnaW5hbEVycm9yLnN0YWNrLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFza2lwU3RhY2tDYXB0dXJpbmcpIHtcbiAgICAgICAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBHcmFwaFFMRXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic3RhY2tcIiwge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBFcnJvcigpLnN0YWNrLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkdyYXBoUUxFcnJvciA9IEdyYXBoUUxFcnJvcjtcbkdyYXBoUUxFcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGdyYXBocWxfMS5HcmFwaFFMRXJyb3IucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHsgdmFsdWU6IEdyYXBoUUxFcnJvciB9LFxuICAgIG5hbWU6IHsgdmFsdWU6IFwiR3JhcGhRTEVycm9yXCIgfVxufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lcnJvci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/graphql-jit/dist/esm/error.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/graphql-jit/dist/esm/execution.js":
/*!*********************************************************!*\
  !*** ../node_modules/graphql-jit/dist/esm/execution.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isAsyncIterable = exports.isPromiseInliner = exports.isPromise = exports.createBoundQuery = exports.isCompiledQuery = exports.compileQuery = exports.GLOBAL_VARIABLES_NAME = void 0;\nconst fast_json_stringify_1 = __importDefault(__webpack_require__(/*! fast-json-stringify */ \"(ssr)/../node_modules/fast-json-stringify/index.js\"));\nconst generate_function_1 = __importDefault(__webpack_require__(/*! generate-function */ \"(ssr)/../node_modules/generate-function/index.js\"));\nconst graphql_1 = __webpack_require__(/*! graphql */ \"(ssr)/../node_modules/graphql/index.mjs\");\nconst Path_1 = __webpack_require__(/*! graphql/jsutils/Path */ \"(ssr)/../node_modules/graphql/jsutils/Path.js\");\nconst ast_1 = __webpack_require__(/*! ./ast */ \"(ssr)/../node_modules/graphql-jit/dist/esm/ast.js\");\nconst error_1 = __webpack_require__(/*! ./error */ \"(ssr)/../node_modules/graphql-jit/dist/esm/error.js\");\nconst inspect_1 = __importDefault(__webpack_require__(/*! ./inspect */ \"(ssr)/../node_modules/graphql-jit/dist/esm/inspect.js\"));\nconst json_1 = __webpack_require__(/*! ./json */ \"(ssr)/../node_modules/graphql-jit/dist/esm/json.js\");\nconst non_null_1 = __webpack_require__(/*! ./non-null */ \"(ssr)/../node_modules/graphql-jit/dist/esm/non-null.js\");\nconst resolve_info_1 = __webpack_require__(/*! ./resolve-info */ \"(ssr)/../node_modules/graphql-jit/dist/esm/resolve-info.js\");\nconst variables_1 = __webpack_require__(/*! ./variables */ \"(ssr)/../node_modules/graphql-jit/dist/esm/variables.js\");\nconst compat_1 = __webpack_require__(/*! ./compat */ \"(ssr)/../node_modules/graphql-jit/dist/esm/compat.js\");\nconst inspect = (0, inspect_1.default)();\n// prefix for the variable used ot cache validation results\nconst SAFETY_CHECK_PREFIX = \"__validNode\";\nconst GLOBAL_DATA_NAME = \"__context.data\";\nconst GLOBAL_ERRORS_NAME = \"__context.errors\";\nconst GLOBAL_NULL_ERRORS_NAME = \"__context.nullErrors\";\nconst GLOBAL_ROOT_NAME = \"__context.rootValue\";\nexports.GLOBAL_VARIABLES_NAME = \"__context.variables\";\nconst GLOBAL_CONTEXT_NAME = \"__context.context\";\nconst GLOBAL_EXECUTION_CONTEXT = \"__context\";\nconst GLOBAL_PROMISE_COUNTER = \"__context.promiseCounter\";\nconst GLOBAL_INSPECT_NAME = \"__context.inspect\";\nconst GLOBAL_SAFE_MAP_NAME = \"__context.safeMap\";\nconst GRAPHQL_ERROR = \"__context.GraphQLError\";\nconst GLOBAL_RESOLVE = \"__context.resolve\";\nconst GLOBAL_PARENT_NAME = \"__parent\";\nconst LOCAL_JS_FIELD_NAME_PREFIX = \"__field\";\n/**\n * It compiles a GraphQL query to an executable function\n * @param {GraphQLSchema} schema GraphQL schema\n * @param {DocumentNode} document Query being submitted\n * @param {string} operationName name of the operation\n * @param partialOptions compilation options to tune the compiler features\n * @returns {CompiledQuery} the cacheable result\n */\nfunction compileQuery(schema, document, operationName, partialOptions) {\n    if (!schema) {\n        throw new Error(`Expected ${schema} to be a GraphQL schema.`);\n    }\n    if (!document) {\n        throw new Error(\"Must provide document.\");\n    }\n    if (partialOptions &&\n        partialOptions.resolverInfoEnricher &&\n        typeof partialOptions.resolverInfoEnricher !== \"function\") {\n        throw new Error(\"resolverInfoEnricher must be a function\");\n    }\n    try {\n        const options = {\n            disablingCapturingStackErrors: false,\n            customJSONSerializer: false,\n            disableLeafSerialization: false,\n            customSerializers: {},\n            useExperimentalPathBasedSkipInclude: false,\n            ...partialOptions\n        };\n        // If a valid context cannot be created due to incorrect arguments,\n        // a \"Response\" with only errors is returned.\n        const context = buildCompilationContext(schema, document, options, operationName);\n        let stringify;\n        if (options.customJSONSerializer) {\n            const jsonSchema = (0, json_1.queryToJSONSchema)(context);\n            stringify = (0, fast_json_stringify_1.default)(jsonSchema);\n        }\n        else {\n            stringify = JSON.stringify;\n        }\n        const getVariables = (0, variables_1.compileVariableParsing)(schema, context.operation.variableDefinitions || []);\n        const type = (0, compat_1.getOperationRootType)(context.schema, context.operation);\n        const fieldMap = (0, ast_1.collectFields)(context, type, context.operation.selectionSet, Object.create(null), Object.create(null));\n        const functionBody = compileOperation(context, type, fieldMap);\n        const compiledQuery = {\n            query: createBoundQuery(context, document, \n            // eslint-disable-next-line no-new-func\n            new Function(\"return \" + functionBody)(), getVariables, context.operation.name != null\n                ? context.operation.name.value\n                : undefined),\n            stringify\n        };\n        if (context.operation.operation === \"subscription\") {\n            compiledQuery.subscribe = createBoundSubscribe(context, document, compileSubscriptionOperation(context, type, fieldMap, compiledQuery.query), getVariables, context.operation.name != null\n                ? context.operation.name.value\n                : undefined);\n        }\n        if (options.debug) {\n            // result of the compilation useful for debugging issues\n            // and visualization tools like try-jit.\n            compiledQuery.__DO_NOT_USE_THIS_OR_YOU_WILL_BE_FIRED_compilation =\n                functionBody;\n        }\n        return compiledQuery;\n    }\n    catch (err) {\n        return {\n            errors: normalizeErrors(err)\n        };\n    }\n}\nexports.compileQuery = compileQuery;\nfunction isCompiledQuery(query) {\n    return \"query\" in query && typeof query.query === \"function\";\n}\nexports.isCompiledQuery = isCompiledQuery;\n// Exported only for an error test\nfunction createBoundQuery(compilationContext, document, func, getVariableValues, operationName) {\n    const { resolvers, typeResolvers, isTypeOfs, serializers, resolveInfos } = compilationContext;\n    const trimmer = (0, non_null_1.createNullTrimmer)(compilationContext);\n    const fnName = operationName || \"query\";\n    /* eslint-disable */\n    /**\n     * In-order to assign a debuggable name to the bound query function,\n     * we create an intermediate object with a method named as the\n     * intended function name. This is because Function.prototype.name\n     * is not writeable.\n     *\n     * http://www.ecma-international.org/ecma-262/6.0/#sec-method-definitions-runtime-semantics-propertydefinitionevaluation\n     *\n     * section: 14.3.9.3 - calls SetFunctionName\n     */\n    /* eslint-enable */\n    const ret = {\n        [fnName](rootValue, context, variables) {\n            // this can be shared across in a batch request\n            const parsedVariables = getVariableValues(variables || {});\n            // Return early errors if variable coercing failed.\n            if ((0, variables_1.failToParseVariables)(parsedVariables)) {\n                return { errors: parsedVariables.errors };\n            }\n            const executionContext = {\n                rootValue,\n                context,\n                variables: parsedVariables.coerced,\n                safeMap,\n                inspect,\n                GraphQLError: error_1.GraphQLError,\n                resolvers,\n                typeResolvers,\n                isTypeOfs,\n                serializers,\n                resolveInfos,\n                trimmer,\n                promiseCounter: 0,\n                data: {},\n                nullErrors: [],\n                errors: []\n            };\n            // eslint-disable-next-line no-useless-call\n            const result = func.call(null, executionContext);\n            if (isPromise(result)) {\n                return result.then(postProcessResult);\n            }\n            return postProcessResult(executionContext);\n        }\n    };\n    return ret[fnName];\n}\nexports.createBoundQuery = createBoundQuery;\nfunction postProcessResult({ data, nullErrors, errors, trimmer }) {\n    if (nullErrors.length > 0) {\n        const trimmed = trimmer(data, nullErrors);\n        return {\n            data: trimmed.data,\n            errors: errors.concat(trimmed.errors)\n        };\n    }\n    else if (errors.length > 0) {\n        return {\n            data,\n            errors\n        };\n    }\n    return { data };\n}\n/**\n * Create the main function body.\n *\n * Implements the \"Evaluating operations\" section of the spec.\n *\n * It defers all top level field for consistency and protection for null root values,\n * all the fields are deferred regardless of presence of resolver or not.\n *\n * @param {CompilationContext} context compilation context with the execution context\n * @returns {string} a function body to be instantiated together with the header, footer\n */\nfunction compileOperation(context, type, fieldMap) {\n    const serialExecution = context.operation.operation === \"mutation\";\n    const topLevel = compileObjectType(context, type, [], [GLOBAL_ROOT_NAME], [GLOBAL_DATA_NAME], undefined, GLOBAL_ERRORS_NAME, fieldMap, true);\n    let body = `function query (${GLOBAL_EXECUTION_CONTEXT}) {\n  \"use strict\";\n`;\n    if (serialExecution) {\n        body += `${GLOBAL_EXECUTION_CONTEXT}.queue = [];`;\n    }\n    body += generateUniqueDeclarations(context, true);\n    body += `${GLOBAL_DATA_NAME} = ${topLevel}\\n`;\n    if (serialExecution) {\n        body += compileDeferredFieldsSerially(context);\n        body += `\n    ${GLOBAL_EXECUTION_CONTEXT}.finalResolve = () => {};\n    ${GLOBAL_RESOLVE} = (context) => {\n      if (context.jobCounter >= context.queue.length) {\n        // All mutations have finished\n        context.finalResolve(context);\n        return;\n      }\n      context.queue[context.jobCounter++](context);\n    };\n    // There might not be a job to run due to invalid queries\n    if (${GLOBAL_EXECUTION_CONTEXT}.queue.length > 0) {\n      ${GLOBAL_EXECUTION_CONTEXT}.jobCounter = 1; // since the first one will be run manually\n      ${GLOBAL_EXECUTION_CONTEXT}.queue[0](${GLOBAL_EXECUTION_CONTEXT});\n    }\n    // Promises have been scheduled so a new promise is returned\n    // that will be resolved once every promise is done\n    if (${GLOBAL_PROMISE_COUNTER} > 0) {\n      return new Promise(resolve => ${GLOBAL_EXECUTION_CONTEXT}.finalResolve = resolve);\n    }\n  `;\n    }\n    else {\n        body += compileDeferredFields(context);\n        body += `\n    // Promises have been scheduled so a new promise is returned\n    // that will be resolved once every promise is done\n    if (${GLOBAL_PROMISE_COUNTER} > 0) {\n      return new Promise(resolve => ${GLOBAL_RESOLVE} = resolve);\n    }`;\n    }\n    body += `\n  // sync execution, the results are ready\n  return undefined;\n  }`;\n    body += context.hoistedFunctions.join(\"\\n\");\n    return body;\n}\n/**\n * Processes the deferred node list in the compilation context.\n *\n * Each deferred node get a copy of the compilation context with\n * a new empty list for deferred nodes to properly scope the nodes.\n * @param {CompilationContext} context compilation context\n * @returns {string} compiled transformations all of deferred nodes\n */\nfunction compileDeferredFields(context) {\n    let body = \"\";\n    context.deferred.forEach((deferredField, index) => {\n        body += `\n      if (${SAFETY_CHECK_PREFIX}${index}) {\n        ${compileDeferredField(context, deferredField)}\n      }`;\n    });\n    return body;\n}\nfunction compileDeferredField(context, deferredField, appendix) {\n    const { name, originPaths, destinationPaths, fieldNodes, fieldType, fieldName, jsFieldName, responsePath, parentType, args } = deferredField;\n    const subContext = createSubCompilationContext(context);\n    const nodeBody = compileType(subContext, parentType, fieldType, fieldNodes, [jsFieldName], [`${GLOBAL_PARENT_NAME}.${name}`], responsePath);\n    const parentIndexes = getParentArgIndexes(context);\n    const resolverName = getResolverName(parentType.name, fieldName);\n    const resolverHandler = getHoistedFunctionName(context, `${name}${resolverName}Handler`);\n    const topLevelArgs = getArgumentsName(resolverName);\n    const validArgs = getValidArgumentsVarName(resolverName);\n    const executionError = createErrorObject(context, fieldNodes, responsePath, \"err.message != null ? err.message : err\", \"err\");\n    const executionInfo = getExecutionInfo(subContext, parentType, fieldType, fieldName, fieldNodes, responsePath);\n    const emptyError = createErrorObject(context, fieldNodes, responsePath, '\"\"');\n    const resolverParentPath = originPaths.join(\".\");\n    const resolverCall = `${GLOBAL_EXECUTION_CONTEXT}.resolvers.${resolverName}(\n          ${resolverParentPath},${topLevelArgs},${GLOBAL_CONTEXT_NAME}, ${executionInfo})`;\n    const resultParentPath = destinationPaths.join(\".\");\n    const compiledArgs = compileArguments(subContext, args, topLevelArgs, validArgs, fieldType, responsePath);\n    const body = `\n    ${compiledArgs}\n    if (${validArgs} === true) {\n      var __value = null;\n      try {\n        __value = ${resolverCall};\n      } catch (err) {\n        ${getErrorDestination(fieldType)}.push(${executionError});\n      }\n      if (${isPromiseInliner(\"__value\")}) {\n      ${promiseStarted()}\n       __value.then(result => {\n        ${resolverHandler}(${GLOBAL_EXECUTION_CONTEXT}, ${resultParentPath}, result, ${parentIndexes});\n        ${promiseDone()}\n       }, err => {\n        if (err) {\n          ${getErrorDestination(fieldType)}.push(${executionError});\n        } else {\n          ${getErrorDestination(fieldType)}.push(${emptyError});\n        }\n        ${promiseDone()}\n       });\n      } else {\n        ${resolverHandler}(${GLOBAL_EXECUTION_CONTEXT}, ${resultParentPath}, __value, ${parentIndexes});\n      }\n    }`;\n    context.hoistedFunctions.push(`\n    function ${resolverHandler}(${GLOBAL_EXECUTION_CONTEXT}, ${GLOBAL_PARENT_NAME}, ${jsFieldName}, ${parentIndexes}) {\n      ${generateUniqueDeclarations(subContext)}\n      ${GLOBAL_PARENT_NAME}.${name} = ${nodeBody};\n      ${compileDeferredFields(subContext)}\n      ${appendix || \"\"}\n    }\n  `);\n    return body;\n}\nfunction compileDeferredFieldsSerially(context) {\n    let body = \"\";\n    context.deferred.forEach((deferredField, index) => {\n        const { name, fieldName, parentType } = deferredField;\n        const resolverName = getResolverName(parentType.name, fieldName);\n        const mutationHandler = getHoistedFunctionName(context, `${name}${resolverName}Mutation`);\n        body += `\n      if (${SAFETY_CHECK_PREFIX}${index}) {\n        ${GLOBAL_EXECUTION_CONTEXT}.queue.push(${mutationHandler});\n      }\n    `;\n        const appendix = `\n    if (${GLOBAL_PROMISE_COUNTER} === 0) {\n      ${GLOBAL_RESOLVE}(${GLOBAL_EXECUTION_CONTEXT});\n    }\n    `;\n        context.hoistedFunctions.push(`\n      function ${mutationHandler}(${GLOBAL_EXECUTION_CONTEXT}) {\n        ${compileDeferredField(context, deferredField, appendix)}\n      }\n      `);\n    });\n    return body;\n}\n/**\n * Processes a generic node.\n *\n * The type is analysed and later reprocessed in dedicated functions.\n * @param {CompilationContext} context compilation context to hold deferred nodes\n * @param parentType\n * @param {GraphQLType} type type of current parent node\n * @param {FieldNode[]} fieldNodes array of the field nodes\n * @param originPaths originPaths path in the parent object from where to fetch results\n * @param destinationPaths path in the where to write the result\n * @param previousPath response path until this node\n * @returns {string} body of the resolvable fieldNodes\n */\nfunction compileType(context, parentType, type, fieldNodes, originPaths, destinationPaths, previousPath) {\n    const sourcePath = originPaths.join(\".\");\n    let body = `${sourcePath} == null ? `;\n    let errorDestination;\n    if ((0, graphql_1.isNonNullType)(type)) {\n        type = type.ofType;\n        const nullErrorStr = `\"Cannot return null for non-nullable field ${parentType.name}.${getFieldNodesName(fieldNodes)}.\"`;\n        body += `(${GLOBAL_NULL_ERRORS_NAME}.push(${createErrorObject(context, fieldNodes, previousPath, nullErrorStr)}), null) :`;\n        errorDestination = GLOBAL_NULL_ERRORS_NAME;\n    }\n    else {\n        body += \"null : \";\n        errorDestination = GLOBAL_ERRORS_NAME;\n    }\n    body += \"(\";\n    // value can be an error obj\n    const errorPath = `${sourcePath}.message != null ? ${sourcePath}.message : ${sourcePath}`;\n    body += `${sourcePath} instanceof Error ? (${errorDestination}.push(${createErrorObject(context, fieldNodes, previousPath, errorPath, sourcePath)}), null) : `;\n    if ((0, graphql_1.isLeafType)(type)) {\n        body += compileLeafType(context, type, originPaths, fieldNodes, previousPath, errorDestination);\n    }\n    else if ((0, graphql_1.isObjectType)(type)) {\n        const fieldMap = (0, ast_1.collectSubfields)(context, type, fieldNodes, previousPath);\n        body += compileObjectType(context, type, fieldNodes, originPaths, destinationPaths, previousPath, errorDestination, fieldMap, false);\n    }\n    else if ((0, graphql_1.isAbstractType)(type)) {\n        body += compileAbstractType(context, parentType, type, fieldNodes, originPaths, previousPath, errorDestination);\n    }\n    else if ((0, graphql_1.isListType)(type)) {\n        body += compileListType(context, parentType, type, fieldNodes, originPaths, previousPath, errorDestination);\n    }\n    else {\n        /* istanbul ignore next */\n        throw new Error(`unsupported type: ${type.toString()}`);\n    }\n    body += \")\";\n    return body;\n}\nfunction compileLeafType(context, type, originPaths, fieldNodes, previousPath, errorDestination) {\n    let body = \"\";\n    if (context.options.disableLeafSerialization &&\n        (type instanceof graphql_1.GraphQLEnumType || (0, graphql_1.isSpecifiedScalarType)(type))) {\n        body += `${originPaths.join(\".\")}`;\n    }\n    else {\n        const serializerName = getSerializerName(type.name);\n        context.serializers[serializerName] = getSerializer(type, context.options.customSerializers[type.name]);\n        const parentIndexes = getParentArgIndexes(context);\n        const serializerErrorHandler = getHoistedFunctionName(context, `${type.name}${originPaths.join(\"\")}SerializerErrorHandler`);\n        context.hoistedFunctions.push(`\n    function ${serializerErrorHandler}(${GLOBAL_EXECUTION_CONTEXT}, message, ${parentIndexes}) {\n    ${errorDestination}.push(${createErrorObject(context, fieldNodes, previousPath, \"message\")});}\n    `);\n        body += `${GLOBAL_EXECUTION_CONTEXT}.serializers.${serializerName}(${GLOBAL_EXECUTION_CONTEXT}, ${originPaths.join(\".\")}, ${serializerErrorHandler}, ${parentIndexes})`;\n    }\n    return body;\n}\n/**\n * Compile a node of object type.\n * @param {CompilationContext} context\n * @param {GraphQLObjectType} type type of the node\n * @param fieldNodes fieldNodes array with the nodes references\n * @param originPaths originPaths path in the parent object from where to fetch results\n * @param destinationPaths path in the where to write the result\n * @param responsePath response path until this node\n * @param errorDestination Path for error array\n * @param fieldMap map of fields to fieldNodes array with the nodes references\n * @param alwaysDefer used to force the field to be resolved with a resolver ala graphql-js\n * @returns {string}\n */\nfunction compileObjectType(context, type, fieldNodes, originPaths, destinationPaths, responsePath, errorDestination, fieldMap, alwaysDefer) {\n    const body = (0, generate_function_1.default)();\n    // Begin object compilation paren\n    body(\"(\");\n    if (typeof type.isTypeOf === \"function\" && !alwaysDefer) {\n        context.isTypeOfs[type.name + \"IsTypeOf\"] = type.isTypeOf;\n        body(`!${GLOBAL_EXECUTION_CONTEXT}.isTypeOfs[\"${type.name}IsTypeOf\"](${originPaths.join(\".\")}) ? (${errorDestination}.push(${createErrorObject(context, fieldNodes, responsePath, `\\`Expected value of type \"${type.name}\" but got: $\\{${GLOBAL_INSPECT_NAME}(${originPaths.join(\".\")})}.\\``)}), null) :`);\n    }\n    // object start\n    body(\"{\");\n    for (const name of Object.keys(fieldMap)) {\n        const fieldNodes = fieldMap[name];\n        const field = (0, ast_1.resolveFieldDef)(context, type, fieldNodes);\n        if (!field) {\n            // Field is invalid, should have been caught in validation\n            // but the error is swallowed for compatibility reasons.\n            continue;\n        }\n        // Key of the object\n        // `name` is the field name or an alias supplied by the user\n        body(`\"${name}\": `);\n        /**\n         * Value of the object\n         *\n         * The combined condition for whether a field should be included\n         * in the object.\n         *\n         * Here, the logical operation is `||` because every fieldNode\n         * is at the same level in the tree, if at least \"one of\" the nodes\n         * is included, then the field is included.\n         *\n         * For example,\n         *\n         * ```graphql\n         * {\n         *   foo @skip(if: $c1)\n         *   ... { foo @skip(if: $c2) }\n         * }\n         * ```\n         *\n         * The logic for `foo` becomes -\n         *\n         * `compilationFor($c1) || compilationFor($c2)`\n         */\n        const serializedResponsePath = (0, ast_1.joinSkipIncludePath)((0, ast_1.serializeObjectPathForSkipInclude)(responsePath), name);\n        const fieldCondition = context.options.useExperimentalPathBasedSkipInclude\n            ? fieldNodes\n                .map((it) => it.__internalShouldIncludePath?.[serializedResponsePath])\n                .filter((it) => it)\n                .join(\" || \") || /* if(true) - default */ \"true\"\n            : fieldNodes\n                .map((it) => it.__internalShouldInclude)\n                .filter((it) => it)\n                .join(\" || \") || /* if(true) - default */ \"true\";\n        body(`\n      (\n        ${fieldCondition}\n      )\n    `);\n        // Inline __typename\n        // No need to call a resolver for typename\n        if (field === graphql_1.TypeNameMetaFieldDef) {\n            // type.name if field is included else undefined - to remove from object\n            // during serialization\n            body(`? \"${type.name}\" : undefined,`);\n            continue;\n        }\n        let resolver = field.resolve;\n        if (!resolver && alwaysDefer) {\n            const fieldName = field.name;\n            resolver = (parent) => parent && parent[fieldName];\n        }\n        if (resolver) {\n            context.deferred.push({\n                name,\n                responsePath: (0, ast_1.addPath)(responsePath, name),\n                originPaths,\n                destinationPaths,\n                parentType: type,\n                fieldName: field.name,\n                jsFieldName: getJsFieldName(field.name),\n                fieldType: field.type,\n                fieldNodes,\n                args: (0, ast_1.getArgumentDefs)(field, fieldNodes[0])\n            });\n            context.resolvers[getResolverName(type.name, field.name)] = resolver;\n            body(`\n          ? (\n              ${SAFETY_CHECK_PREFIX}${context.deferred.length - 1} = true,\n              null\n            )\n          : (\n              ${SAFETY_CHECK_PREFIX}${context.deferred.length - 1} = false,\n              undefined\n            )\n        `);\n        }\n        else {\n            // if included\n            body(\"?\");\n            body(compileType(context, type, field.type, fieldNodes, originPaths.concat(field.name), destinationPaths.concat(name), (0, ast_1.addPath)(responsePath, name)));\n            // if not included\n            body(\": undefined\");\n        }\n        // End object property\n        body(\",\");\n    }\n    // End object\n    body(\"}\");\n    // End object compilation paren\n    body(\")\");\n    return body.toString();\n}\nfunction compileAbstractType(context, parentType, type, fieldNodes, originPaths, previousPath, errorDestination) {\n    let resolveType;\n    if (type.resolveType) {\n        resolveType = type.resolveType;\n    }\n    else {\n        resolveType = (value, context, info) => defaultResolveTypeFn(value, context, info, type);\n    }\n    const typeResolverName = getTypeResolverName(type.name);\n    context.typeResolvers[typeResolverName] = resolveType;\n    const collectedTypes = context.schema\n        .getPossibleTypes(type)\n        .map((objectType) => {\n        const subContext = createSubCompilationContext(context);\n        const object = compileType(subContext, parentType, objectType, fieldNodes, originPaths, [\"__concrete\"], (0, ast_1.addPath)(previousPath, objectType.name, \"meta\"));\n        return `case \"${objectType.name}\": {\n                  ${generateUniqueDeclarations(subContext)}\n                  const __concrete = ${object};\n                  ${compileDeferredFields(subContext)}\n                  return __concrete;\n              }`;\n    })\n        .join(\"\\n\");\n    const finalTypeName = \"finalType\";\n    const nullTypeError = `\"Runtime Object type is not a possible type for \\\\\"${type.name}\\\\\".\"`;\n    /* eslint-disable max-len */\n    const notPossibleTypeError = \n    // eslint-disable-next-line no-template-curly-in-string\n    '`Runtime Object type \"${nodeType}\" is not a possible type for \"' +\n        type.name +\n        '\".`';\n    const noTypeError = `${finalTypeName} ? ${notPossibleTypeError} : \"Abstract type ${type.name} must resolve to an Object type at runtime for field ${parentType.name}.${getFieldNodesName(fieldNodes)}. Either the ${type.name} type should provide a \\\\\"resolveType\\\\\" function or each possible types should provide an \\\\\"isTypeOf\\\\\" function.\"`;\n    /* eslint-enable max-len */\n    return `((nodeType, err) =>\n  {\n    if (err != null) {\n      ${errorDestination}.push(${createErrorObject(context, fieldNodes, previousPath, \"err.message != null ? err.message : err\", \"err\")});\n      return null;\n    }\n    if (nodeType == null) {\n      ${errorDestination}.push(${createErrorObject(context, fieldNodes, previousPath, nullTypeError)})\n      return null;\n    }\n    const ${finalTypeName} = typeof nodeType === \"string\" ? nodeType : nodeType.name;\n    switch(${finalTypeName}) {\n      ${collectedTypes}\n      default:\n      ${errorDestination}.push(${createErrorObject(context, fieldNodes, previousPath, noTypeError)})\n      return null;\n    }\n  })(\n    ${GLOBAL_EXECUTION_CONTEXT}.typeResolvers.${typeResolverName}(${originPaths.join(\".\")},\n    ${GLOBAL_CONTEXT_NAME},\n    ${getExecutionInfo(context, parentType, type, type.name, fieldNodes, previousPath)}))`;\n}\n/**\n * Compile a list transformation.\n *\n * @param {CompilationContext} context\n * @param {GraphQLObjectType} parentType type of the parent of object which contained this type\n * @param {GraphQLList<GraphQLType>} type list type being compiled\n * @param {FieldNode[]} fieldNodes\n * @param originalObjectPaths\n * @param {ObjectPath} responsePath\n * @param errorDestination\n * @returns {string} compiled list transformation\n */\nfunction compileListType(context, parentType, type, fieldNodes, originalObjectPaths, responsePath, errorDestination) {\n    const name = originalObjectPaths.join(\".\");\n    const listContext = createSubCompilationContext(context);\n    // context depth will be mutated, so we cache the current value.\n    const newDepth = ++listContext.depth;\n    const fieldType = type.ofType;\n    const dataBody = compileType(listContext, parentType, fieldType, fieldNodes, [\"__currentItem\"], [`${GLOBAL_PARENT_NAME}[idx${newDepth}]`], (0, ast_1.addPath)(responsePath, \"idx\" + newDepth, \"variable\"));\n    const errorMessage = `\"Expected Iterable, but did not find one for field ${parentType.name}.${getFieldNodesName(fieldNodes)}.\"`;\n    const errorCase = `(${errorDestination}.push(${createErrorObject(context, fieldNodes, responsePath, errorMessage)}), null)`;\n    const executionError = createErrorObject(context, fieldNodes, (0, ast_1.addPath)(responsePath, \"idx\" + newDepth, \"variable\"), \"err.message != null ? err.message : err\", \"err\");\n    const emptyError = createErrorObject(context, fieldNodes, responsePath, '\"\"');\n    const uniqueDeclarations = generateUniqueDeclarations(listContext);\n    const deferredFields = compileDeferredFields(listContext);\n    const itemHandler = getHoistedFunctionName(context, `${parentType.name}${originalObjectPaths.join(\"\")}MapItemHandler`);\n    const childIndexes = getParentArgIndexes(listContext);\n    listContext.hoistedFunctions.push(`\n  function ${itemHandler}(${GLOBAL_EXECUTION_CONTEXT}, ${GLOBAL_PARENT_NAME}, __currentItem, ${childIndexes}) {\n    ${uniqueDeclarations}\n    ${GLOBAL_PARENT_NAME}[idx${newDepth}] = ${dataBody};\n    ${deferredFields}\n  }\n  `);\n    const safeMapHandler = getHoistedFunctionName(context, `${parentType.name}${originalObjectPaths.join(\"\")}MapHandler`);\n    const parentIndexes = getParentArgIndexes(context);\n    listContext.hoistedFunctions.push(`\n  function ${safeMapHandler}(${GLOBAL_EXECUTION_CONTEXT}, __currentItem, idx${newDepth}, resultArray, ${parentIndexes}) {\n    if (${isPromiseInliner(\"__currentItem\")}) {\n      ${promiseStarted()}\n      __currentItem.then(result => {\n        ${itemHandler}(${GLOBAL_EXECUTION_CONTEXT}, resultArray, result, ${childIndexes});\n        ${promiseDone()}\n      }, err => {\n        resultArray.push(null);\n        if (err) {\n          ${getErrorDestination(fieldType)}.push(${executionError});\n        } else {\n          ${getErrorDestination(fieldType)}.push(${emptyError});\n        }\n        ${promiseDone()}\n      });\n    } else {\n       ${itemHandler}(${GLOBAL_EXECUTION_CONTEXT}, resultArray, __currentItem, ${childIndexes});\n    }\n  }\n  `);\n    return `(typeof ${name} === \"string\" || typeof ${name}[Symbol.iterator] !== \"function\") ?  ${errorCase} :\n  ${GLOBAL_SAFE_MAP_NAME}(${GLOBAL_EXECUTION_CONTEXT}, ${name}, ${safeMapHandler}, ${parentIndexes})`;\n}\n/**\n * Implements a generic map operation for any iterable.\n *\n * If the iterable is not valid, null is returned.\n * @param context\n * @param {Iterable<any> | string} iterable possible iterable\n * @param {(a: any) => any} cb callback that receives the item being iterated\n * @param idx\n * @returns {any[]} a new array with the result of the callback\n */\nfunction safeMap(context, iterable, cb, ...idx) {\n    let index = 0;\n    const result = [];\n    for (const a of iterable) {\n        cb(context, a, index, result, ...idx);\n        ++index;\n    }\n    return result;\n}\nconst MAGIC_MINUS_INFINITY = \"__MAGIC_MINUS_INFINITY__71d4310a_d4a3_4a05_b1fe_e60779d24998\";\nconst MAGIC_PLUS_INFINITY = \"__MAGIC_PLUS_INFINITY__bb201c39_3333_4695_b4ad_7f1722e7aa7a\";\nconst MAGIC_NAN = \"__MAGIC_NAN__57f286b9_4c20_487f_b409_79804ddcb4f8\";\nconst MAGIC_DATE = \"__MAGIC_DATE__33a9e76d_02e0_4128_8e92_3530ad3da74d\";\nfunction specialValueReplacer(key, value) {\n    if (Number.isNaN(value)) {\n        return MAGIC_NAN;\n    }\n    if (value === Infinity) {\n        return MAGIC_PLUS_INFINITY;\n    }\n    if (value === -Infinity) {\n        return MAGIC_MINUS_INFINITY;\n    }\n    if (this[key] instanceof Date) {\n        return MAGIC_DATE + this[key].getTime();\n    }\n    return value;\n}\nfunction objectStringify(val) {\n    return JSON.stringify(val, specialValueReplacer)\n        .replace(new RegExp(`\"${MAGIC_NAN}\"`, \"g\"), \"NaN\")\n        .replace(new RegExp(`\"${MAGIC_PLUS_INFINITY}\"`, \"g\"), \"Infinity\")\n        .replace(new RegExp(`\"${MAGIC_MINUS_INFINITY}\"`, \"g\"), \"-Infinity\")\n        .replace(new RegExp(`\"${MAGIC_DATE}([^\"]+)\"`, \"g\"), \"new Date($1)\");\n}\n/**\n * Calculates a GraphQLResolveInfo object for the resolver calls.\n *\n * if the resolver does not use, it returns null.\n * @param {CompilationContext} context compilation context to submit the resolveInfoResolver\n * @param parentType\n * @param fieldType\n * @param fieldName\n * @param fieldNodes\n * @param responsePath\n * @returns {string} a call to the resolve info creator or \"{}\" if unused\n */\nfunction getExecutionInfo(context, parentType, fieldType, fieldName, fieldNodes, responsePath) {\n    const resolveInfoName = createResolveInfoName(responsePath);\n    const { schema, fragments, operation } = context;\n    context.resolveInfos[resolveInfoName] = (0, resolve_info_1.createResolveInfoThunk)({\n        schema,\n        fragments,\n        operation,\n        parentType,\n        fieldName,\n        fieldType,\n        fieldNodes\n    }, context.options.resolverInfoEnricher);\n    return `${GLOBAL_EXECUTION_CONTEXT}.resolveInfos.${resolveInfoName}(${GLOBAL_ROOT_NAME}, ${exports.GLOBAL_VARIABLES_NAME}, ${serializeResponsePath(responsePath)})`;\n}\nfunction getArgumentsName(prefixName) {\n    return `${prefixName}Args`;\n}\nfunction getValidArgumentsVarName(prefixName) {\n    return `${prefixName}ValidArgs`;\n}\nfunction objectPath(topLevel, path) {\n    if (!path) {\n        return topLevel;\n    }\n    let objectPath = topLevel;\n    const flattened = (0, ast_1.flattenPath)(path);\n    for (const section of flattened) {\n        if (section.type === \"literal\") {\n            objectPath += `[\"${section.key}\"]`;\n        }\n        else {\n            /* istanbul ignore next */\n            throw new Error(\"should only have received literal paths\");\n        }\n    }\n    return objectPath;\n}\n/**\n * Returns a static object with the all the arguments needed for the resolver\n * @param context\n * @param {Arguments} args\n * @param topLevelArg name of the toplevel\n * @param validArgs\n * @param returnType\n * @param path\n * @returns {string}\n */\nfunction compileArguments(context, args, topLevelArg, validArgs, returnType, path) {\n    // default to assuming arguments are valid\n    let body = `\n  let ${validArgs} = true;\n  const ${topLevelArg} = ${objectStringify(args.values)};\n  `;\n    const errorDestination = getErrorDestination(returnType);\n    for (const variable of args.missing) {\n        const varName = variable.valueNode.name.value;\n        body += `if (Object.prototype.hasOwnProperty.call(${exports.GLOBAL_VARIABLES_NAME}, \"${varName}\")) {`;\n        if (variable.argument && (0, graphql_1.isNonNullType)(variable.argument.definition.type)) {\n            const message = `'Argument \"${variable.argument.definition.name}\" of non-null type \"${variable.argument.definition.type.toString()}\" must not be null.'`;\n            body += `if (${exports.GLOBAL_VARIABLES_NAME}['${variable.valueNode.name.value}'] == null) {\n      ${errorDestination}.push(${createErrorObject(context, [variable.argument.node.value], path, message)});\n      ${validArgs} = false;\n      }`;\n        }\n        body += `\n    ${objectPath(topLevelArg, variable.path)} = ${exports.GLOBAL_VARIABLES_NAME}['${variable.valueNode.name.value}'];\n    }`;\n        // If there is no default value and no variable input\n        // throw a field error\n        if (variable.argument &&\n            (0, graphql_1.isNonNullType)(variable.argument.definition.type) &&\n            variable.argument.definition.defaultValue === undefined) {\n            const message = `'Argument \"${variable.argument.definition.name}\" of required type \"${variable.argument.definition.type.toString()}\" was provided the variable \"$${varName}\" which was not provided a runtime value.'`;\n            body += ` else {\n      ${errorDestination}.push(${createErrorObject(context, [variable.argument.node.value], path, message)});\n      ${validArgs} = false;\n        }`;\n        }\n    }\n    return body;\n}\n/**\n *  Safety checks for resolver execution is done via side effects every time a resolver function\n *  is encountered.\n *\n *  This function generates the declarations, so the side effect is valid code.\n *\n * @param {CompilationContext} context compilation context\n * @param {boolean} defaultValue usually false, meant to be true at the top level\n * @returns {string} a list of declarations eg: var __validNode0 = false;\\nvar __validNode1 = false;\n */\nfunction generateUniqueDeclarations(context, defaultValue = false) {\n    return context.deferred\n        .map((_, idx) => `\n        let ${SAFETY_CHECK_PREFIX}${idx} = ${defaultValue};\n      `)\n        .join(\"\\n\");\n}\nfunction createSubCompilationContext(context) {\n    return { ...context, deferred: [] };\n}\nfunction isPromise(value) {\n    return (value != null &&\n        typeof value === \"object\" &&\n        typeof value.then === \"function\");\n}\nexports.isPromise = isPromise;\nfunction isPromiseInliner(value) {\n    return `${value} != null && typeof ${value} === \"object\" && typeof ${value}.then === \"function\"`;\n}\nexports.isPromiseInliner = isPromiseInliner;\n/**\n * Serializes the response path for an error response.\n *\n * @param {ObjectPath | undefined} path response path of a field\n * @returns {string} filtered serialization of the response path\n */\nfunction serializeResponsePathAsArray(path) {\n    const flattened = (0, ast_1.flattenPath)(path);\n    let src = \"[\";\n    for (let i = flattened.length - 1; i >= 0; i--) {\n        // meta is only used for the function name\n        if (flattened[i].type === \"meta\") {\n            continue;\n        }\n        src +=\n            flattened[i].type === \"literal\"\n                ? `\"${flattened[i].key}\",`\n                : `${flattened[i].key},`;\n    }\n    return src + \"]\";\n}\nfunction getErrorDestination(type) {\n    return (0, graphql_1.isNonNullType)(type) ? GLOBAL_NULL_ERRORS_NAME : GLOBAL_ERRORS_NAME;\n}\nfunction createResolveInfoName(path) {\n    return ((0, ast_1.flattenPath)(path)\n        .map((p) => p.key)\n        .join(\"_\") + \"Info\");\n}\n/**\n * Serializes the response path for the resolve info function\n * @param {ObjectPath | undefined} path response path of a field\n * @returns {string} filtered serialization of the response path\n */\nfunction serializeResponsePath(path) {\n    if (!path) {\n        return \"undefined\";\n    }\n    if (path.type === \"meta\") {\n        // meta is ignored while serializing for the resolve info functions\n        return serializeResponsePath(path.prev);\n    }\n    const literalValue = `\"${path.key}\"`;\n    return `{\n    key:  ${path.type === \"literal\" ? literalValue : path.key},\n    prev: ${serializeResponsePath(path.prev)}\n  }`;\n}\n/**\n * Returned a bound serialization function of a scalar or enum\n * @param {GraphQLScalarType | GraphQLEnumType} scalar\n * @param customSerializer custom serializer\n * @returns {(v: any) => any} bound serializationFunction\n */\nfunction getSerializer(scalar, customSerializer) {\n    const { name } = scalar;\n    const serialize = customSerializer || ((val) => scalar.serialize(val));\n    return function leafSerializer(context, v, onError, ...idx) {\n        try {\n            const value = serialize(v);\n            if (isInvalid(value)) {\n                onError(context, `Expected a value of type \"${name}\" but received: ${v}`, ...idx);\n                return null;\n            }\n            return value;\n        }\n        catch (e) {\n            onError(context, (e && e.message) ||\n                `Expected a value of type \"${name}\" but received an Error`, ...idx);\n            return null;\n        }\n    };\n}\n/**\n * Default abstract type resolver.\n *\n * It only handle sync type resolving.\n * @param value\n * @param contextValue\n * @param {GraphQLResolveInfo} info\n * @param {GraphQLAbstractType} abstractType\n * @returns {string}\n */\nfunction defaultResolveTypeFn(value, contextValue, info, abstractType) {\n    // First, look for `__typename`.\n    if (value != null &&\n        typeof value === \"object\" &&\n        typeof value.__typename === \"string\") {\n        return value.__typename;\n    }\n    // Otherwise, test each possible type.\n    const possibleTypes = info.schema.getPossibleTypes(abstractType);\n    for (const type of possibleTypes) {\n        if (type.isTypeOf) {\n            const isTypeOfResult = type.isTypeOf(value, contextValue, info);\n            if (isPromise(isTypeOfResult)) {\n                throw new Error(`Promises are not supported for resolving type of ${value}`);\n            }\n            else if (isTypeOfResult) {\n                return type.name;\n            }\n        }\n    }\n    throw new Error(`Could not resolve the object type in possible types of ${abstractType.name} for the value: ` +\n        inspect(value));\n}\n/**\n * Constructs a ExecutionContext object from the arguments passed to\n * execute, which we will pass throughout the other execution methods.\n *\n * Throws a GraphQLError if a valid execution context cannot be created.\n */\nfunction buildCompilationContext(schema, document, options, operationName) {\n    const errors = [];\n    let operation = undefined;\n    let hasMultipleAssumedOperations = false;\n    const fragments = Object.create(null);\n    for (const definition of document.definitions) {\n        switch (definition.kind) {\n            case graphql_1.Kind.OPERATION_DEFINITION:\n                if (!operationName && operation) {\n                    hasMultipleAssumedOperations = true;\n                }\n                else if (!operationName ||\n                    (definition.name && definition.name.value === operationName)) {\n                    operation = definition;\n                }\n                break;\n            case graphql_1.Kind.FRAGMENT_DEFINITION:\n                fragments[definition.name.value] = definition;\n                break;\n        }\n    }\n    if (!operation) {\n        if (operationName) {\n            throw new graphql_1.GraphQLError(`Unknown operation named \"${operationName}\".`);\n        }\n        else {\n            throw new graphql_1.GraphQLError(\"Must provide an operation.\");\n        }\n    }\n    else if (hasMultipleAssumedOperations) {\n        throw new graphql_1.GraphQLError(\"Must provide operation name if query contains multiple operations.\");\n    }\n    return {\n        schema,\n        fragments,\n        rootValue: null,\n        contextValue: null,\n        operation,\n        options,\n        resolvers: {},\n        serializers: {},\n        typeResolvers: {},\n        isTypeOfs: {},\n        resolveInfos: {},\n        hoistedFunctions: [],\n        hoistedFunctionNames: new Map(),\n        deferred: [],\n        depth: -1,\n        variableValues: {},\n        errors\n    };\n}\nfunction getFieldNodesName(nodes) {\n    return nodes.length > 1\n        ? \"(\" + nodes.map(({ name }) => name.value).join(\",\") + \")\"\n        : nodes[0].name.value;\n}\nfunction getHoistedFunctionName(context, name) {\n    const count = context.hoistedFunctionNames.get(name);\n    if (count === undefined) {\n        context.hoistedFunctionNames.set(name, 0);\n        return name;\n    }\n    context.hoistedFunctionNames.set(name, count + 1);\n    return `${name}${count + 1}`;\n}\nfunction createErrorObject(context, nodes, path, message, originalError) {\n    return `new ${GRAPHQL_ERROR}(${message},\n    ${JSON.stringify((0, ast_1.computeLocations)(nodes))},\n      ${serializeResponsePathAsArray(path)},\n      ${originalError || \"undefined\"},\n      ${context.options.disablingCapturingStackErrors ? \"true\" : \"false\"})`;\n}\nfunction getResolverName(parentName, name) {\n    return parentName + name + \"Resolver\";\n}\nfunction getTypeResolverName(name) {\n    return name + \"TypeResolver\";\n}\nfunction getSerializerName(name) {\n    return name + \"Serializer\";\n}\nfunction promiseStarted() {\n    return `\n     // increase the promise counter\n     ++${GLOBAL_PROMISE_COUNTER};\n  `;\n}\nfunction promiseDone() {\n    return `\n    --${GLOBAL_PROMISE_COUNTER};\n    if (${GLOBAL_PROMISE_COUNTER} === 0) {\n      ${GLOBAL_RESOLVE}(${GLOBAL_EXECUTION_CONTEXT});\n    }\n  `;\n}\nfunction normalizeErrors(err) {\n    if (Array.isArray(err)) {\n        return err.map((e) => normalizeError(e));\n    }\n    return [normalizeError(err)];\n}\nfunction normalizeError(err) {\n    return err instanceof graphql_1.GraphQLError\n        ? err\n        : new error_1.GraphQLError(err.message, err.locations, err.path, err);\n}\n/**\n * Returns true if a value is undefined, or NaN.\n */\nfunction isInvalid(value) {\n    // eslint-disable-next-line no-self-compare\n    return value === undefined || value !== value;\n}\nfunction getParentArgIndexes(context) {\n    let args = \"\";\n    for (let i = 0; i <= context.depth; ++i) {\n        if (i > 0) {\n            args += \", \";\n        }\n        args += `idx${i}`;\n    }\n    return args;\n}\nfunction getJsFieldName(fieldName) {\n    return `${LOCAL_JS_FIELD_NAME_PREFIX}${fieldName}`;\n}\nfunction isAsyncIterable(val) {\n    return typeof Object(val)[Symbol.asyncIterator] === \"function\";\n}\nexports.isAsyncIterable = isAsyncIterable;\nfunction compileSubscriptionOperation(context, type, fieldMap, queryFn) {\n    const fieldNodes = Object.values(fieldMap)[0];\n    const fieldNode = fieldNodes[0];\n    const fieldName = fieldNode.name.value;\n    const field = (0, ast_1.resolveFieldDef)(context, type, fieldNodes);\n    if (!field) {\n        throw new graphql_1.GraphQLError(`The subscription field \"${fieldName}\" is not defined.`, (0, compat_1.getGraphQLErrorOptions)(fieldNodes));\n    }\n    const responsePath = (0, ast_1.addPath)(undefined, fieldName);\n    const resolveInfoName = createResolveInfoName(responsePath);\n    const subscriber = field.subscribe;\n    async function executeSubscription(executionContext) {\n        const resolveInfo = executionContext.resolveInfos[resolveInfoName](executionContext.rootValue, executionContext.variables, responsePath);\n        try {\n            const eventStream = await subscriber?.(executionContext.rootValue, executionContext.variables, executionContext.context, resolveInfo);\n            if (eventStream instanceof Error) {\n                throw eventStream;\n            }\n            return eventStream;\n        }\n        catch (error) {\n            throw (0, graphql_1.locatedError)(error, resolveInfo.fieldNodes, (0, Path_1.pathToArray)(resolveInfo.path));\n        }\n    }\n    async function createSourceEventStream(executionContext) {\n        try {\n            const eventStream = await executeSubscription(executionContext);\n            // Assert field returned an event stream, otherwise yield an error.\n            if (!isAsyncIterable(eventStream)) {\n                throw new Error(\"Subscription field must return Async Iterable. \" +\n                    `Received: ${inspect(eventStream)}.`);\n            }\n            return eventStream;\n        }\n        catch (error) {\n            // If it is a GraphQLError, report it as an ExecutionResult, containing only errors and no data.\n            // Otherwise treat the error as a system-class error and re-throw it.\n            if (error instanceof graphql_1.GraphQLError) {\n                return { errors: [error] };\n            }\n            throw error;\n        }\n    }\n    return async function subscribe(executionContext) {\n        const resultOrStream = await createSourceEventStream(executionContext);\n        if (!isAsyncIterable(resultOrStream)) {\n            return resultOrStream;\n        }\n        // For each payload yielded from a subscription, map it over the normal\n        // GraphQL `execute` function, with `payload` as the rootValue.\n        // This implements the \"MapSourceToResponseEvent\" algorithm described in\n        // the GraphQL specification. The `execute` function provides the\n        // \"ExecuteSubscriptionEvent\" algorithm, as it is nearly identical to the\n        // \"ExecuteQuery\" algorithm, for which `execute` is also used.\n        // We use our `query` function in place of `execute`\n        const mapSourceToResponse = (payload) => queryFn(payload, executionContext.context, executionContext.variables);\n        return mapAsyncIterator(resultOrStream, mapSourceToResponse);\n    };\n}\nfunction createBoundSubscribe(compilationContext, document, func, getVariableValues, operationName) {\n    const { resolvers, typeResolvers, isTypeOfs, serializers, resolveInfos } = compilationContext;\n    const trimmer = (0, non_null_1.createNullTrimmer)(compilationContext);\n    const fnName = operationName || \"subscribe\";\n    const ret = {\n        async [fnName](rootValue, context, variables) {\n            // this can be shared across in a batch request\n            const parsedVariables = getVariableValues(variables || {});\n            // Return early errors if variable coercing failed.\n            if ((0, variables_1.failToParseVariables)(parsedVariables)) {\n                return { errors: parsedVariables.errors };\n            }\n            const executionContext = {\n                rootValue,\n                context,\n                variables: parsedVariables.coerced,\n                safeMap,\n                inspect,\n                GraphQLError: error_1.GraphQLError,\n                resolvers,\n                typeResolvers,\n                isTypeOfs,\n                serializers,\n                resolveInfos,\n                trimmer,\n                promiseCounter: 0,\n                nullErrors: [],\n                errors: [],\n                data: {}\n            };\n            // eslint-disable-next-line no-useless-call\n            return func.call(null, executionContext);\n        }\n    };\n    return ret[fnName];\n}\n/**\n * Given an AsyncIterable and a callback function, return an AsyncIterator\n * which produces values mapped via calling the callback function.\n */\nfunction mapAsyncIterator(iterable, callback) {\n    const iterator = iterable[Symbol.asyncIterator]();\n    async function mapResult(result) {\n        if (result.done) {\n            return result;\n        }\n        try {\n            return { value: await callback(result.value), done: false };\n        }\n        catch (error) {\n            if (typeof iterator.return === \"function\") {\n                try {\n                    await iterator.return();\n                }\n                catch (e) {\n                    /* ignore error */\n                }\n            }\n            throw error;\n        }\n    }\n    return {\n        async next() {\n            return mapResult(await iterator.next());\n        },\n        async return() {\n            return typeof iterator.return === \"function\"\n                ? mapResult(await iterator.return())\n                : { value: undefined, done: true };\n        },\n        async throw(error) {\n            return typeof iterator.throw === \"function\"\n                ? mapResult(await iterator.throw(error))\n                : Promise.reject(error);\n        },\n        [Symbol.asyncIterator]() {\n            return this;\n        }\n    };\n}\n//# sourceMappingURL=execution.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL2dyYXBocWwtaml0L2Rpc3QvZXNtL2V4ZWN1dGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHVCQUF1QixHQUFHLHdCQUF3QixHQUFHLGlCQUFpQixHQUFHLHdCQUF3QixHQUFHLHVCQUF1QixHQUFHLG9CQUFvQixHQUFHLDZCQUE2QjtBQUNsTCw4Q0FBOEMsbUJBQU8sQ0FBQywrRUFBcUI7QUFDM0UsNENBQTRDLG1CQUFPLENBQUMsMkVBQW1CO0FBQ3ZFLGtCQUFrQixtQkFBTyxDQUFDLHdEQUFTO0FBQ25DLGVBQWUsbUJBQU8sQ0FBQywyRUFBc0I7QUFDN0MsY0FBYyxtQkFBTyxDQUFDLGdFQUFPO0FBQzdCLGdCQUFnQixtQkFBTyxDQUFDLG9FQUFTO0FBQ2pDLGtDQUFrQyxtQkFBTyxDQUFDLHdFQUFXO0FBQ3JELGVBQWUsbUJBQU8sQ0FBQyxrRUFBUTtBQUMvQixtQkFBbUIsbUJBQU8sQ0FBQywwRUFBWTtBQUN2Qyx1QkFBdUIsbUJBQU8sQ0FBQyxrRkFBZ0I7QUFDL0Msb0JBQW9CLG1CQUFPLENBQUMsNEVBQWE7QUFDekMsaUJBQWlCLG1CQUFPLENBQUMsc0VBQVU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixXQUFXLGNBQWM7QUFDekIsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYSxlQUFlO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxRQUFRO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGlFQUFpRTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFO0FBQ3JFO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGVkZ2l0eS15aWVsZC1mcm9udGVuZC8uLi9ub2RlX21vZHVsZXMvZ3JhcGhxbC1qaXQvZGlzdC9lc20vZXhlY3V0aW9uLmpzP2M0NTYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmlzQXN5bmNJdGVyYWJsZSA9IGV4cG9ydHMuaXNQcm9taXNlSW5saW5lciA9IGV4cG9ydHMuaXNQcm9taXNlID0gZXhwb3J0cy5jcmVhdGVCb3VuZFF1ZXJ5ID0gZXhwb3J0cy5pc0NvbXBpbGVkUXVlcnkgPSBleHBvcnRzLmNvbXBpbGVRdWVyeSA9IGV4cG9ydHMuR0xPQkFMX1ZBUklBQkxFU19OQU1FID0gdm9pZCAwO1xuY29uc3QgZmFzdF9qc29uX3N0cmluZ2lmeV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJmYXN0LWpzb24tc3RyaW5naWZ5XCIpKTtcbmNvbnN0IGdlbmVyYXRlX2Z1bmN0aW9uXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImdlbmVyYXRlLWZ1bmN0aW9uXCIpKTtcbmNvbnN0IGdyYXBocWxfMSA9IHJlcXVpcmUoXCJncmFwaHFsXCIpO1xuY29uc3QgUGF0aF8xID0gcmVxdWlyZShcImdyYXBocWwvanN1dGlscy9QYXRoXCIpO1xuY29uc3QgYXN0XzEgPSByZXF1aXJlKFwiLi9hc3RcIik7XG5jb25zdCBlcnJvcl8xID0gcmVxdWlyZShcIi4vZXJyb3JcIik7XG5jb25zdCBpbnNwZWN0XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vaW5zcGVjdFwiKSk7XG5jb25zdCBqc29uXzEgPSByZXF1aXJlKFwiLi9qc29uXCIpO1xuY29uc3Qgbm9uX251bGxfMSA9IHJlcXVpcmUoXCIuL25vbi1udWxsXCIpO1xuY29uc3QgcmVzb2x2ZV9pbmZvXzEgPSByZXF1aXJlKFwiLi9yZXNvbHZlLWluZm9cIik7XG5jb25zdCB2YXJpYWJsZXNfMSA9IHJlcXVpcmUoXCIuL3ZhcmlhYmxlc1wiKTtcbmNvbnN0IGNvbXBhdF8xID0gcmVxdWlyZShcIi4vY29tcGF0XCIpO1xuY29uc3QgaW5zcGVjdCA9ICgwLCBpbnNwZWN0XzEuZGVmYXVsdCkoKTtcbi8vIHByZWZpeCBmb3IgdGhlIHZhcmlhYmxlIHVzZWQgb3QgY2FjaGUgdmFsaWRhdGlvbiByZXN1bHRzXG5jb25zdCBTQUZFVFlfQ0hFQ0tfUFJFRklYID0gXCJfX3ZhbGlkTm9kZVwiO1xuY29uc3QgR0xPQkFMX0RBVEFfTkFNRSA9IFwiX19jb250ZXh0LmRhdGFcIjtcbmNvbnN0IEdMT0JBTF9FUlJPUlNfTkFNRSA9IFwiX19jb250ZXh0LmVycm9yc1wiO1xuY29uc3QgR0xPQkFMX05VTExfRVJST1JTX05BTUUgPSBcIl9fY29udGV4dC5udWxsRXJyb3JzXCI7XG5jb25zdCBHTE9CQUxfUk9PVF9OQU1FID0gXCJfX2NvbnRleHQucm9vdFZhbHVlXCI7XG5leHBvcnRzLkdMT0JBTF9WQVJJQUJMRVNfTkFNRSA9IFwiX19jb250ZXh0LnZhcmlhYmxlc1wiO1xuY29uc3QgR0xPQkFMX0NPTlRFWFRfTkFNRSA9IFwiX19jb250ZXh0LmNvbnRleHRcIjtcbmNvbnN0IEdMT0JBTF9FWEVDVVRJT05fQ09OVEVYVCA9IFwiX19jb250ZXh0XCI7XG5jb25zdCBHTE9CQUxfUFJPTUlTRV9DT1VOVEVSID0gXCJfX2NvbnRleHQucHJvbWlzZUNvdW50ZXJcIjtcbmNvbnN0IEdMT0JBTF9JTlNQRUNUX05BTUUgPSBcIl9fY29udGV4dC5pbnNwZWN0XCI7XG5jb25zdCBHTE9CQUxfU0FGRV9NQVBfTkFNRSA9IFwiX19jb250ZXh0LnNhZmVNYXBcIjtcbmNvbnN0IEdSQVBIUUxfRVJST1IgPSBcIl9fY29udGV4dC5HcmFwaFFMRXJyb3JcIjtcbmNvbnN0IEdMT0JBTF9SRVNPTFZFID0gXCJfX2NvbnRleHQucmVzb2x2ZVwiO1xuY29uc3QgR0xPQkFMX1BBUkVOVF9OQU1FID0gXCJfX3BhcmVudFwiO1xuY29uc3QgTE9DQUxfSlNfRklFTERfTkFNRV9QUkVGSVggPSBcIl9fZmllbGRcIjtcbi8qKlxuICogSXQgY29tcGlsZXMgYSBHcmFwaFFMIHF1ZXJ5IHRvIGFuIGV4ZWN1dGFibGUgZnVuY3Rpb25cbiAqIEBwYXJhbSB7R3JhcGhRTFNjaGVtYX0gc2NoZW1hIEdyYXBoUUwgc2NoZW1hXG4gKiBAcGFyYW0ge0RvY3VtZW50Tm9kZX0gZG9jdW1lbnQgUXVlcnkgYmVpbmcgc3VibWl0dGVkXG4gKiBAcGFyYW0ge3N0cmluZ30gb3BlcmF0aW9uTmFtZSBuYW1lIG9mIHRoZSBvcGVyYXRpb25cbiAqIEBwYXJhbSBwYXJ0aWFsT3B0aW9ucyBjb21waWxhdGlvbiBvcHRpb25zIHRvIHR1bmUgdGhlIGNvbXBpbGVyIGZlYXR1cmVzXG4gKiBAcmV0dXJucyB7Q29tcGlsZWRRdWVyeX0gdGhlIGNhY2hlYWJsZSByZXN1bHRcbiAqL1xuZnVuY3Rpb24gY29tcGlsZVF1ZXJ5KHNjaGVtYSwgZG9jdW1lbnQsIG9wZXJhdGlvbk5hbWUsIHBhcnRpYWxPcHRpb25zKSB7XG4gICAgaWYgKCFzY2hlbWEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCAke3NjaGVtYX0gdG8gYmUgYSBHcmFwaFFMIHNjaGVtYS5gKTtcbiAgICB9XG4gICAgaWYgKCFkb2N1bWVudCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZG9jdW1lbnQuXCIpO1xuICAgIH1cbiAgICBpZiAocGFydGlhbE9wdGlvbnMgJiZcbiAgICAgICAgcGFydGlhbE9wdGlvbnMucmVzb2x2ZXJJbmZvRW5yaWNoZXIgJiZcbiAgICAgICAgdHlwZW9mIHBhcnRpYWxPcHRpb25zLnJlc29sdmVySW5mb0VucmljaGVyICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicmVzb2x2ZXJJbmZvRW5yaWNoZXIgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICAgICAgZGlzYWJsaW5nQ2FwdHVyaW5nU3RhY2tFcnJvcnM6IGZhbHNlLFxuICAgICAgICAgICAgY3VzdG9tSlNPTlNlcmlhbGl6ZXI6IGZhbHNlLFxuICAgICAgICAgICAgZGlzYWJsZUxlYWZTZXJpYWxpemF0aW9uOiBmYWxzZSxcbiAgICAgICAgICAgIGN1c3RvbVNlcmlhbGl6ZXJzOiB7fSxcbiAgICAgICAgICAgIHVzZUV4cGVyaW1lbnRhbFBhdGhCYXNlZFNraXBJbmNsdWRlOiBmYWxzZSxcbiAgICAgICAgICAgIC4uLnBhcnRpYWxPcHRpb25zXG4gICAgICAgIH07XG4gICAgICAgIC8vIElmIGEgdmFsaWQgY29udGV4dCBjYW5ub3QgYmUgY3JlYXRlZCBkdWUgdG8gaW5jb3JyZWN0IGFyZ3VtZW50cyxcbiAgICAgICAgLy8gYSBcIlJlc3BvbnNlXCIgd2l0aCBvbmx5IGVycm9ycyBpcyByZXR1cm5lZC5cbiAgICAgICAgY29uc3QgY29udGV4dCA9IGJ1aWxkQ29tcGlsYXRpb25Db250ZXh0KHNjaGVtYSwgZG9jdW1lbnQsIG9wdGlvbnMsIG9wZXJhdGlvbk5hbWUpO1xuICAgICAgICBsZXQgc3RyaW5naWZ5O1xuICAgICAgICBpZiAob3B0aW9ucy5jdXN0b21KU09OU2VyaWFsaXplcikge1xuICAgICAgICAgICAgY29uc3QganNvblNjaGVtYSA9ICgwLCBqc29uXzEucXVlcnlUb0pTT05TY2hlbWEpKGNvbnRleHQpO1xuICAgICAgICAgICAgc3RyaW5naWZ5ID0gKDAsIGZhc3RfanNvbl9zdHJpbmdpZnlfMS5kZWZhdWx0KShqc29uU2NoZW1hKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0cmluZ2lmeSA9IEpTT04uc3RyaW5naWZ5O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGdldFZhcmlhYmxlcyA9ICgwLCB2YXJpYWJsZXNfMS5jb21waWxlVmFyaWFibGVQYXJzaW5nKShzY2hlbWEsIGNvbnRleHQub3BlcmF0aW9uLnZhcmlhYmxlRGVmaW5pdGlvbnMgfHwgW10pO1xuICAgICAgICBjb25zdCB0eXBlID0gKDAsIGNvbXBhdF8xLmdldE9wZXJhdGlvblJvb3RUeXBlKShjb250ZXh0LnNjaGVtYSwgY29udGV4dC5vcGVyYXRpb24pO1xuICAgICAgICBjb25zdCBmaWVsZE1hcCA9ICgwLCBhc3RfMS5jb2xsZWN0RmllbGRzKShjb250ZXh0LCB0eXBlLCBjb250ZXh0Lm9wZXJhdGlvbi5zZWxlY3Rpb25TZXQsIE9iamVjdC5jcmVhdGUobnVsbCksIE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICAgICAgICBjb25zdCBmdW5jdGlvbkJvZHkgPSBjb21waWxlT3BlcmF0aW9uKGNvbnRleHQsIHR5cGUsIGZpZWxkTWFwKTtcbiAgICAgICAgY29uc3QgY29tcGlsZWRRdWVyeSA9IHtcbiAgICAgICAgICAgIHF1ZXJ5OiBjcmVhdGVCb3VuZFF1ZXJ5KGNvbnRleHQsIGRvY3VtZW50LCBcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuY1xuICAgICAgICAgICAgbmV3IEZ1bmN0aW9uKFwicmV0dXJuIFwiICsgZnVuY3Rpb25Cb2R5KSgpLCBnZXRWYXJpYWJsZXMsIGNvbnRleHQub3BlcmF0aW9uLm5hbWUgIT0gbnVsbFxuICAgICAgICAgICAgICAgID8gY29udGV4dC5vcGVyYXRpb24ubmFtZS52YWx1ZVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKSxcbiAgICAgICAgICAgIHN0cmluZ2lmeVxuICAgICAgICB9O1xuICAgICAgICBpZiAoY29udGV4dC5vcGVyYXRpb24ub3BlcmF0aW9uID09PSBcInN1YnNjcmlwdGlvblwiKSB7XG4gICAgICAgICAgICBjb21waWxlZFF1ZXJ5LnN1YnNjcmliZSA9IGNyZWF0ZUJvdW5kU3Vic2NyaWJlKGNvbnRleHQsIGRvY3VtZW50LCBjb21waWxlU3Vic2NyaXB0aW9uT3BlcmF0aW9uKGNvbnRleHQsIHR5cGUsIGZpZWxkTWFwLCBjb21waWxlZFF1ZXJ5LnF1ZXJ5KSwgZ2V0VmFyaWFibGVzLCBjb250ZXh0Lm9wZXJhdGlvbi5uYW1lICE9IG51bGxcbiAgICAgICAgICAgICAgICA/IGNvbnRleHQub3BlcmF0aW9uLm5hbWUudmFsdWVcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuZGVidWcpIHtcbiAgICAgICAgICAgIC8vIHJlc3VsdCBvZiB0aGUgY29tcGlsYXRpb24gdXNlZnVsIGZvciBkZWJ1Z2dpbmcgaXNzdWVzXG4gICAgICAgICAgICAvLyBhbmQgdmlzdWFsaXphdGlvbiB0b29scyBsaWtlIHRyeS1qaXQuXG4gICAgICAgICAgICBjb21waWxlZFF1ZXJ5Ll9fRE9fTk9UX1VTRV9USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEX2NvbXBpbGF0aW9uID1cbiAgICAgICAgICAgICAgICBmdW5jdGlvbkJvZHk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbXBpbGVkUXVlcnk7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVycm9yczogbm9ybWFsaXplRXJyb3JzKGVycilcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLmNvbXBpbGVRdWVyeSA9IGNvbXBpbGVRdWVyeTtcbmZ1bmN0aW9uIGlzQ29tcGlsZWRRdWVyeShxdWVyeSkge1xuICAgIHJldHVybiBcInF1ZXJ5XCIgaW4gcXVlcnkgJiYgdHlwZW9mIHF1ZXJ5LnF1ZXJ5ID09PSBcImZ1bmN0aW9uXCI7XG59XG5leHBvcnRzLmlzQ29tcGlsZWRRdWVyeSA9IGlzQ29tcGlsZWRRdWVyeTtcbi8vIEV4cG9ydGVkIG9ubHkgZm9yIGFuIGVycm9yIHRlc3RcbmZ1bmN0aW9uIGNyZWF0ZUJvdW5kUXVlcnkoY29tcGlsYXRpb25Db250ZXh0LCBkb2N1bWVudCwgZnVuYywgZ2V0VmFyaWFibGVWYWx1ZXMsIG9wZXJhdGlvbk5hbWUpIHtcbiAgICBjb25zdCB7IHJlc29sdmVycywgdHlwZVJlc29sdmVycywgaXNUeXBlT2ZzLCBzZXJpYWxpemVycywgcmVzb2x2ZUluZm9zIH0gPSBjb21waWxhdGlvbkNvbnRleHQ7XG4gICAgY29uc3QgdHJpbW1lciA9ICgwLCBub25fbnVsbF8xLmNyZWF0ZU51bGxUcmltbWVyKShjb21waWxhdGlvbkNvbnRleHQpO1xuICAgIGNvbnN0IGZuTmFtZSA9IG9wZXJhdGlvbk5hbWUgfHwgXCJxdWVyeVwiO1xuICAgIC8qIGVzbGludC1kaXNhYmxlICovXG4gICAgLyoqXG4gICAgICogSW4tb3JkZXIgdG8gYXNzaWduIGEgZGVidWdnYWJsZSBuYW1lIHRvIHRoZSBib3VuZCBxdWVyeSBmdW5jdGlvbixcbiAgICAgKiB3ZSBjcmVhdGUgYW4gaW50ZXJtZWRpYXRlIG9iamVjdCB3aXRoIGEgbWV0aG9kIG5hbWVkIGFzIHRoZVxuICAgICAqIGludGVuZGVkIGZ1bmN0aW9uIG5hbWUuIFRoaXMgaXMgYmVjYXVzZSBGdW5jdGlvbi5wcm90b3R5cGUubmFtZVxuICAgICAqIGlzIG5vdCB3cml0ZWFibGUuXG4gICAgICpcbiAgICAgKiBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtbWV0aG9kLWRlZmluaXRpb25zLXJ1bnRpbWUtc2VtYW50aWNzLXByb3BlcnR5ZGVmaW5pdGlvbmV2YWx1YXRpb25cbiAgICAgKlxuICAgICAqIHNlY3Rpb246IDE0LjMuOS4zIC0gY2FsbHMgU2V0RnVuY3Rpb25OYW1lXG4gICAgICovXG4gICAgLyogZXNsaW50LWVuYWJsZSAqL1xuICAgIGNvbnN0IHJldCA9IHtcbiAgICAgICAgW2ZuTmFtZV0ocm9vdFZhbHVlLCBjb250ZXh0LCB2YXJpYWJsZXMpIHtcbiAgICAgICAgICAgIC8vIHRoaXMgY2FuIGJlIHNoYXJlZCBhY3Jvc3MgaW4gYSBiYXRjaCByZXF1ZXN0XG4gICAgICAgICAgICBjb25zdCBwYXJzZWRWYXJpYWJsZXMgPSBnZXRWYXJpYWJsZVZhbHVlcyh2YXJpYWJsZXMgfHwge30pO1xuICAgICAgICAgICAgLy8gUmV0dXJuIGVhcmx5IGVycm9ycyBpZiB2YXJpYWJsZSBjb2VyY2luZyBmYWlsZWQuXG4gICAgICAgICAgICBpZiAoKDAsIHZhcmlhYmxlc18xLmZhaWxUb1BhcnNlVmFyaWFibGVzKShwYXJzZWRWYXJpYWJsZXMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZXJyb3JzOiBwYXJzZWRWYXJpYWJsZXMuZXJyb3JzIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBleGVjdXRpb25Db250ZXh0ID0ge1xuICAgICAgICAgICAgICAgIHJvb3RWYWx1ZSxcbiAgICAgICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgICAgICAgIHZhcmlhYmxlczogcGFyc2VkVmFyaWFibGVzLmNvZXJjZWQsXG4gICAgICAgICAgICAgICAgc2FmZU1hcCxcbiAgICAgICAgICAgICAgICBpbnNwZWN0LFxuICAgICAgICAgICAgICAgIEdyYXBoUUxFcnJvcjogZXJyb3JfMS5HcmFwaFFMRXJyb3IsXG4gICAgICAgICAgICAgICAgcmVzb2x2ZXJzLFxuICAgICAgICAgICAgICAgIHR5cGVSZXNvbHZlcnMsXG4gICAgICAgICAgICAgICAgaXNUeXBlT2ZzLFxuICAgICAgICAgICAgICAgIHNlcmlhbGl6ZXJzLFxuICAgICAgICAgICAgICAgIHJlc29sdmVJbmZvcyxcbiAgICAgICAgICAgICAgICB0cmltbWVyLFxuICAgICAgICAgICAgICAgIHByb21pc2VDb3VudGVyOiAwLFxuICAgICAgICAgICAgICAgIGRhdGE6IHt9LFxuICAgICAgICAgICAgICAgIG51bGxFcnJvcnM6IFtdLFxuICAgICAgICAgICAgICAgIGVycm9yczogW11cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlbGVzcy1jYWxsXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBmdW5jLmNhbGwobnVsbCwgZXhlY3V0aW9uQ29udGV4dCk7XG4gICAgICAgICAgICBpZiAoaXNQcm9taXNlKHJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0LnRoZW4ocG9zdFByb2Nlc3NSZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBvc3RQcm9jZXNzUmVzdWx0KGV4ZWN1dGlvbkNvbnRleHQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gcmV0W2ZuTmFtZV07XG59XG5leHBvcnRzLmNyZWF0ZUJvdW5kUXVlcnkgPSBjcmVhdGVCb3VuZFF1ZXJ5O1xuZnVuY3Rpb24gcG9zdFByb2Nlc3NSZXN1bHQoeyBkYXRhLCBudWxsRXJyb3JzLCBlcnJvcnMsIHRyaW1tZXIgfSkge1xuICAgIGlmIChudWxsRXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgdHJpbW1lZCA9IHRyaW1tZXIoZGF0YSwgbnVsbEVycm9ycyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXRhOiB0cmltbWVkLmRhdGEsXG4gICAgICAgICAgICBlcnJvcnM6IGVycm9ycy5jb25jYXQodHJpbW1lZC5lcnJvcnMpXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgZXJyb3JzXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7IGRhdGEgfTtcbn1cbi8qKlxuICogQ3JlYXRlIHRoZSBtYWluIGZ1bmN0aW9uIGJvZHkuXG4gKlxuICogSW1wbGVtZW50cyB0aGUgXCJFdmFsdWF0aW5nIG9wZXJhdGlvbnNcIiBzZWN0aW9uIG9mIHRoZSBzcGVjLlxuICpcbiAqIEl0IGRlZmVycyBhbGwgdG9wIGxldmVsIGZpZWxkIGZvciBjb25zaXN0ZW5jeSBhbmQgcHJvdGVjdGlvbiBmb3IgbnVsbCByb290IHZhbHVlcyxcbiAqIGFsbCB0aGUgZmllbGRzIGFyZSBkZWZlcnJlZCByZWdhcmRsZXNzIG9mIHByZXNlbmNlIG9mIHJlc29sdmVyIG9yIG5vdC5cbiAqXG4gKiBAcGFyYW0ge0NvbXBpbGF0aW9uQ29udGV4dH0gY29udGV4dCBjb21waWxhdGlvbiBjb250ZXh0IHdpdGggdGhlIGV4ZWN1dGlvbiBjb250ZXh0XG4gKiBAcmV0dXJucyB7c3RyaW5nfSBhIGZ1bmN0aW9uIGJvZHkgdG8gYmUgaW5zdGFudGlhdGVkIHRvZ2V0aGVyIHdpdGggdGhlIGhlYWRlciwgZm9vdGVyXG4gKi9cbmZ1bmN0aW9uIGNvbXBpbGVPcGVyYXRpb24oY29udGV4dCwgdHlwZSwgZmllbGRNYXApIHtcbiAgICBjb25zdCBzZXJpYWxFeGVjdXRpb24gPSBjb250ZXh0Lm9wZXJhdGlvbi5vcGVyYXRpb24gPT09IFwibXV0YXRpb25cIjtcbiAgICBjb25zdCB0b3BMZXZlbCA9IGNvbXBpbGVPYmplY3RUeXBlKGNvbnRleHQsIHR5cGUsIFtdLCBbR0xPQkFMX1JPT1RfTkFNRV0sIFtHTE9CQUxfREFUQV9OQU1FXSwgdW5kZWZpbmVkLCBHTE9CQUxfRVJST1JTX05BTUUsIGZpZWxkTWFwLCB0cnVlKTtcbiAgICBsZXQgYm9keSA9IGBmdW5jdGlvbiBxdWVyeSAoJHtHTE9CQUxfRVhFQ1VUSU9OX0NPTlRFWFR9KSB7XG4gIFwidXNlIHN0cmljdFwiO1xuYDtcbiAgICBpZiAoc2VyaWFsRXhlY3V0aW9uKSB7XG4gICAgICAgIGJvZHkgKz0gYCR7R0xPQkFMX0VYRUNVVElPTl9DT05URVhUfS5xdWV1ZSA9IFtdO2A7XG4gICAgfVxuICAgIGJvZHkgKz0gZ2VuZXJhdGVVbmlxdWVEZWNsYXJhdGlvbnMoY29udGV4dCwgdHJ1ZSk7XG4gICAgYm9keSArPSBgJHtHTE9CQUxfREFUQV9OQU1FfSA9ICR7dG9wTGV2ZWx9XFxuYDtcbiAgICBpZiAoc2VyaWFsRXhlY3V0aW9uKSB7XG4gICAgICAgIGJvZHkgKz0gY29tcGlsZURlZmVycmVkRmllbGRzU2VyaWFsbHkoY29udGV4dCk7XG4gICAgICAgIGJvZHkgKz0gYFxuICAgICR7R0xPQkFMX0VYRUNVVElPTl9DT05URVhUfS5maW5hbFJlc29sdmUgPSAoKSA9PiB7fTtcbiAgICAke0dMT0JBTF9SRVNPTFZFfSA9IChjb250ZXh0KSA9PiB7XG4gICAgICBpZiAoY29udGV4dC5qb2JDb3VudGVyID49IGNvbnRleHQucXVldWUubGVuZ3RoKSB7XG4gICAgICAgIC8vIEFsbCBtdXRhdGlvbnMgaGF2ZSBmaW5pc2hlZFxuICAgICAgICBjb250ZXh0LmZpbmFsUmVzb2x2ZShjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29udGV4dC5xdWV1ZVtjb250ZXh0LmpvYkNvdW50ZXIrK10oY29udGV4dCk7XG4gICAgfTtcbiAgICAvLyBUaGVyZSBtaWdodCBub3QgYmUgYSBqb2IgdG8gcnVuIGR1ZSB0byBpbnZhbGlkIHF1ZXJpZXNcbiAgICBpZiAoJHtHTE9CQUxfRVhFQ1VUSU9OX0NPTlRFWFR9LnF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICR7R0xPQkFMX0VYRUNVVElPTl9DT05URVhUfS5qb2JDb3VudGVyID0gMTsgLy8gc2luY2UgdGhlIGZpcnN0IG9uZSB3aWxsIGJlIHJ1biBtYW51YWxseVxuICAgICAgJHtHTE9CQUxfRVhFQ1VUSU9OX0NPTlRFWFR9LnF1ZXVlWzBdKCR7R0xPQkFMX0VYRUNVVElPTl9DT05URVhUfSk7XG4gICAgfVxuICAgIC8vIFByb21pc2VzIGhhdmUgYmVlbiBzY2hlZHVsZWQgc28gYSBuZXcgcHJvbWlzZSBpcyByZXR1cm5lZFxuICAgIC8vIHRoYXQgd2lsbCBiZSByZXNvbHZlZCBvbmNlIGV2ZXJ5IHByb21pc2UgaXMgZG9uZVxuICAgIGlmICgke0dMT0JBTF9QUk9NSVNFX0NPVU5URVJ9ID4gMCkge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4gJHtHTE9CQUxfRVhFQ1VUSU9OX0NPTlRFWFR9LmZpbmFsUmVzb2x2ZSA9IHJlc29sdmUpO1xuICAgIH1cbiAgYDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGJvZHkgKz0gY29tcGlsZURlZmVycmVkRmllbGRzKGNvbnRleHQpO1xuICAgICAgICBib2R5ICs9IGBcbiAgICAvLyBQcm9taXNlcyBoYXZlIGJlZW4gc2NoZWR1bGVkIHNvIGEgbmV3IHByb21pc2UgaXMgcmV0dXJuZWRcbiAgICAvLyB0aGF0IHdpbGwgYmUgcmVzb2x2ZWQgb25jZSBldmVyeSBwcm9taXNlIGlzIGRvbmVcbiAgICBpZiAoJHtHTE9CQUxfUFJPTUlTRV9DT1VOVEVSfSA+IDApIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+ICR7R0xPQkFMX1JFU09MVkV9ID0gcmVzb2x2ZSk7XG4gICAgfWA7XG4gICAgfVxuICAgIGJvZHkgKz0gYFxuICAvLyBzeW5jIGV4ZWN1dGlvbiwgdGhlIHJlc3VsdHMgYXJlIHJlYWR5XG4gIHJldHVybiB1bmRlZmluZWQ7XG4gIH1gO1xuICAgIGJvZHkgKz0gY29udGV4dC5ob2lzdGVkRnVuY3Rpb25zLmpvaW4oXCJcXG5cIik7XG4gICAgcmV0dXJuIGJvZHk7XG59XG4vKipcbiAqIFByb2Nlc3NlcyB0aGUgZGVmZXJyZWQgbm9kZSBsaXN0IGluIHRoZSBjb21waWxhdGlvbiBjb250ZXh0LlxuICpcbiAqIEVhY2ggZGVmZXJyZWQgbm9kZSBnZXQgYSBjb3B5IG9mIHRoZSBjb21waWxhdGlvbiBjb250ZXh0IHdpdGhcbiAqIGEgbmV3IGVtcHR5IGxpc3QgZm9yIGRlZmVycmVkIG5vZGVzIHRvIHByb3Blcmx5IHNjb3BlIHRoZSBub2Rlcy5cbiAqIEBwYXJhbSB7Q29tcGlsYXRpb25Db250ZXh0fSBjb250ZXh0IGNvbXBpbGF0aW9uIGNvbnRleHRcbiAqIEByZXR1cm5zIHtzdHJpbmd9IGNvbXBpbGVkIHRyYW5zZm9ybWF0aW9ucyBhbGwgb2YgZGVmZXJyZWQgbm9kZXNcbiAqL1xuZnVuY3Rpb24gY29tcGlsZURlZmVycmVkRmllbGRzKGNvbnRleHQpIHtcbiAgICBsZXQgYm9keSA9IFwiXCI7XG4gICAgY29udGV4dC5kZWZlcnJlZC5mb3JFYWNoKChkZWZlcnJlZEZpZWxkLCBpbmRleCkgPT4ge1xuICAgICAgICBib2R5ICs9IGBcbiAgICAgIGlmICgke1NBRkVUWV9DSEVDS19QUkVGSVh9JHtpbmRleH0pIHtcbiAgICAgICAgJHtjb21waWxlRGVmZXJyZWRGaWVsZChjb250ZXh0LCBkZWZlcnJlZEZpZWxkKX1cbiAgICAgIH1gO1xuICAgIH0pO1xuICAgIHJldHVybiBib2R5O1xufVxuZnVuY3Rpb24gY29tcGlsZURlZmVycmVkRmllbGQoY29udGV4dCwgZGVmZXJyZWRGaWVsZCwgYXBwZW5kaXgpIHtcbiAgICBjb25zdCB7IG5hbWUsIG9yaWdpblBhdGhzLCBkZXN0aW5hdGlvblBhdGhzLCBmaWVsZE5vZGVzLCBmaWVsZFR5cGUsIGZpZWxkTmFtZSwganNGaWVsZE5hbWUsIHJlc3BvbnNlUGF0aCwgcGFyZW50VHlwZSwgYXJncyB9ID0gZGVmZXJyZWRGaWVsZDtcbiAgICBjb25zdCBzdWJDb250ZXh0ID0gY3JlYXRlU3ViQ29tcGlsYXRpb25Db250ZXh0KGNvbnRleHQpO1xuICAgIGNvbnN0IG5vZGVCb2R5ID0gY29tcGlsZVR5cGUoc3ViQ29udGV4dCwgcGFyZW50VHlwZSwgZmllbGRUeXBlLCBmaWVsZE5vZGVzLCBbanNGaWVsZE5hbWVdLCBbYCR7R0xPQkFMX1BBUkVOVF9OQU1FfS4ke25hbWV9YF0sIHJlc3BvbnNlUGF0aCk7XG4gICAgY29uc3QgcGFyZW50SW5kZXhlcyA9IGdldFBhcmVudEFyZ0luZGV4ZXMoY29udGV4dCk7XG4gICAgY29uc3QgcmVzb2x2ZXJOYW1lID0gZ2V0UmVzb2x2ZXJOYW1lKHBhcmVudFR5cGUubmFtZSwgZmllbGROYW1lKTtcbiAgICBjb25zdCByZXNvbHZlckhhbmRsZXIgPSBnZXRIb2lzdGVkRnVuY3Rpb25OYW1lKGNvbnRleHQsIGAke25hbWV9JHtyZXNvbHZlck5hbWV9SGFuZGxlcmApO1xuICAgIGNvbnN0IHRvcExldmVsQXJncyA9IGdldEFyZ3VtZW50c05hbWUocmVzb2x2ZXJOYW1lKTtcbiAgICBjb25zdCB2YWxpZEFyZ3MgPSBnZXRWYWxpZEFyZ3VtZW50c1Zhck5hbWUocmVzb2x2ZXJOYW1lKTtcbiAgICBjb25zdCBleGVjdXRpb25FcnJvciA9IGNyZWF0ZUVycm9yT2JqZWN0KGNvbnRleHQsIGZpZWxkTm9kZXMsIHJlc3BvbnNlUGF0aCwgXCJlcnIubWVzc2FnZSAhPSBudWxsID8gZXJyLm1lc3NhZ2UgOiBlcnJcIiwgXCJlcnJcIik7XG4gICAgY29uc3QgZXhlY3V0aW9uSW5mbyA9IGdldEV4ZWN1dGlvbkluZm8oc3ViQ29udGV4dCwgcGFyZW50VHlwZSwgZmllbGRUeXBlLCBmaWVsZE5hbWUsIGZpZWxkTm9kZXMsIHJlc3BvbnNlUGF0aCk7XG4gICAgY29uc3QgZW1wdHlFcnJvciA9IGNyZWF0ZUVycm9yT2JqZWN0KGNvbnRleHQsIGZpZWxkTm9kZXMsIHJlc3BvbnNlUGF0aCwgJ1wiXCInKTtcbiAgICBjb25zdCByZXNvbHZlclBhcmVudFBhdGggPSBvcmlnaW5QYXRocy5qb2luKFwiLlwiKTtcbiAgICBjb25zdCByZXNvbHZlckNhbGwgPSBgJHtHTE9CQUxfRVhFQ1VUSU9OX0NPTlRFWFR9LnJlc29sdmVycy4ke3Jlc29sdmVyTmFtZX0oXG4gICAgICAgICAgJHtyZXNvbHZlclBhcmVudFBhdGh9LCR7dG9wTGV2ZWxBcmdzfSwke0dMT0JBTF9DT05URVhUX05BTUV9LCAke2V4ZWN1dGlvbkluZm99KWA7XG4gICAgY29uc3QgcmVzdWx0UGFyZW50UGF0aCA9IGRlc3RpbmF0aW9uUGF0aHMuam9pbihcIi5cIik7XG4gICAgY29uc3QgY29tcGlsZWRBcmdzID0gY29tcGlsZUFyZ3VtZW50cyhzdWJDb250ZXh0LCBhcmdzLCB0b3BMZXZlbEFyZ3MsIHZhbGlkQXJncywgZmllbGRUeXBlLCByZXNwb25zZVBhdGgpO1xuICAgIGNvbnN0IGJvZHkgPSBgXG4gICAgJHtjb21waWxlZEFyZ3N9XG4gICAgaWYgKCR7dmFsaWRBcmdzfSA9PT0gdHJ1ZSkge1xuICAgICAgdmFyIF9fdmFsdWUgPSBudWxsO1xuICAgICAgdHJ5IHtcbiAgICAgICAgX192YWx1ZSA9ICR7cmVzb2x2ZXJDYWxsfTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAke2dldEVycm9yRGVzdGluYXRpb24oZmllbGRUeXBlKX0ucHVzaCgke2V4ZWN1dGlvbkVycm9yfSk7XG4gICAgICB9XG4gICAgICBpZiAoJHtpc1Byb21pc2VJbmxpbmVyKFwiX192YWx1ZVwiKX0pIHtcbiAgICAgICR7cHJvbWlzZVN0YXJ0ZWQoKX1cbiAgICAgICBfX3ZhbHVlLnRoZW4ocmVzdWx0ID0+IHtcbiAgICAgICAgJHtyZXNvbHZlckhhbmRsZXJ9KCR7R0xPQkFMX0VYRUNVVElPTl9DT05URVhUfSwgJHtyZXN1bHRQYXJlbnRQYXRofSwgcmVzdWx0LCAke3BhcmVudEluZGV4ZXN9KTtcbiAgICAgICAgJHtwcm9taXNlRG9uZSgpfVxuICAgICAgIH0sIGVyciA9PiB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAke2dldEVycm9yRGVzdGluYXRpb24oZmllbGRUeXBlKX0ucHVzaCgke2V4ZWN1dGlvbkVycm9yfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgJHtnZXRFcnJvckRlc3RpbmF0aW9uKGZpZWxkVHlwZSl9LnB1c2goJHtlbXB0eUVycm9yfSk7XG4gICAgICAgIH1cbiAgICAgICAgJHtwcm9taXNlRG9uZSgpfVxuICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJHtyZXNvbHZlckhhbmRsZXJ9KCR7R0xPQkFMX0VYRUNVVElPTl9DT05URVhUfSwgJHtyZXN1bHRQYXJlbnRQYXRofSwgX192YWx1ZSwgJHtwYXJlbnRJbmRleGVzfSk7XG4gICAgICB9XG4gICAgfWA7XG4gICAgY29udGV4dC5ob2lzdGVkRnVuY3Rpb25zLnB1c2goYFxuICAgIGZ1bmN0aW9uICR7cmVzb2x2ZXJIYW5kbGVyfSgke0dMT0JBTF9FWEVDVVRJT05fQ09OVEVYVH0sICR7R0xPQkFMX1BBUkVOVF9OQU1FfSwgJHtqc0ZpZWxkTmFtZX0sICR7cGFyZW50SW5kZXhlc30pIHtcbiAgICAgICR7Z2VuZXJhdGVVbmlxdWVEZWNsYXJhdGlvbnMoc3ViQ29udGV4dCl9XG4gICAgICAke0dMT0JBTF9QQVJFTlRfTkFNRX0uJHtuYW1lfSA9ICR7bm9kZUJvZHl9O1xuICAgICAgJHtjb21waWxlRGVmZXJyZWRGaWVsZHMoc3ViQ29udGV4dCl9XG4gICAgICAke2FwcGVuZGl4IHx8IFwiXCJ9XG4gICAgfVxuICBgKTtcbiAgICByZXR1cm4gYm9keTtcbn1cbmZ1bmN0aW9uIGNvbXBpbGVEZWZlcnJlZEZpZWxkc1NlcmlhbGx5KGNvbnRleHQpIHtcbiAgICBsZXQgYm9keSA9IFwiXCI7XG4gICAgY29udGV4dC5kZWZlcnJlZC5mb3JFYWNoKChkZWZlcnJlZEZpZWxkLCBpbmRleCkgPT4ge1xuICAgICAgICBjb25zdCB7IG5hbWUsIGZpZWxkTmFtZSwgcGFyZW50VHlwZSB9ID0gZGVmZXJyZWRGaWVsZDtcbiAgICAgICAgY29uc3QgcmVzb2x2ZXJOYW1lID0gZ2V0UmVzb2x2ZXJOYW1lKHBhcmVudFR5cGUubmFtZSwgZmllbGROYW1lKTtcbiAgICAgICAgY29uc3QgbXV0YXRpb25IYW5kbGVyID0gZ2V0SG9pc3RlZEZ1bmN0aW9uTmFtZShjb250ZXh0LCBgJHtuYW1lfSR7cmVzb2x2ZXJOYW1lfU11dGF0aW9uYCk7XG4gICAgICAgIGJvZHkgKz0gYFxuICAgICAgaWYgKCR7U0FGRVRZX0NIRUNLX1BSRUZJWH0ke2luZGV4fSkge1xuICAgICAgICAke0dMT0JBTF9FWEVDVVRJT05fQ09OVEVYVH0ucXVldWUucHVzaCgke211dGF0aW9uSGFuZGxlcn0pO1xuICAgICAgfVxuICAgIGA7XG4gICAgICAgIGNvbnN0IGFwcGVuZGl4ID0gYFxuICAgIGlmICgke0dMT0JBTF9QUk9NSVNFX0NPVU5URVJ9ID09PSAwKSB7XG4gICAgICAke0dMT0JBTF9SRVNPTFZFfSgke0dMT0JBTF9FWEVDVVRJT05fQ09OVEVYVH0pO1xuICAgIH1cbiAgICBgO1xuICAgICAgICBjb250ZXh0LmhvaXN0ZWRGdW5jdGlvbnMucHVzaChgXG4gICAgICBmdW5jdGlvbiAke211dGF0aW9uSGFuZGxlcn0oJHtHTE9CQUxfRVhFQ1VUSU9OX0NPTlRFWFR9KSB7XG4gICAgICAgICR7Y29tcGlsZURlZmVycmVkRmllbGQoY29udGV4dCwgZGVmZXJyZWRGaWVsZCwgYXBwZW5kaXgpfVxuICAgICAgfVxuICAgICAgYCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGJvZHk7XG59XG4vKipcbiAqIFByb2Nlc3NlcyBhIGdlbmVyaWMgbm9kZS5cbiAqXG4gKiBUaGUgdHlwZSBpcyBhbmFseXNlZCBhbmQgbGF0ZXIgcmVwcm9jZXNzZWQgaW4gZGVkaWNhdGVkIGZ1bmN0aW9ucy5cbiAqIEBwYXJhbSB7Q29tcGlsYXRpb25Db250ZXh0fSBjb250ZXh0IGNvbXBpbGF0aW9uIGNvbnRleHQgdG8gaG9sZCBkZWZlcnJlZCBub2Rlc1xuICogQHBhcmFtIHBhcmVudFR5cGVcbiAqIEBwYXJhbSB7R3JhcGhRTFR5cGV9IHR5cGUgdHlwZSBvZiBjdXJyZW50IHBhcmVudCBub2RlXG4gKiBAcGFyYW0ge0ZpZWxkTm9kZVtdfSBmaWVsZE5vZGVzIGFycmF5IG9mIHRoZSBmaWVsZCBub2Rlc1xuICogQHBhcmFtIG9yaWdpblBhdGhzIG9yaWdpblBhdGhzIHBhdGggaW4gdGhlIHBhcmVudCBvYmplY3QgZnJvbSB3aGVyZSB0byBmZXRjaCByZXN1bHRzXG4gKiBAcGFyYW0gZGVzdGluYXRpb25QYXRocyBwYXRoIGluIHRoZSB3aGVyZSB0byB3cml0ZSB0aGUgcmVzdWx0XG4gKiBAcGFyYW0gcHJldmlvdXNQYXRoIHJlc3BvbnNlIHBhdGggdW50aWwgdGhpcyBub2RlXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBib2R5IG9mIHRoZSByZXNvbHZhYmxlIGZpZWxkTm9kZXNcbiAqL1xuZnVuY3Rpb24gY29tcGlsZVR5cGUoY29udGV4dCwgcGFyZW50VHlwZSwgdHlwZSwgZmllbGROb2Rlcywgb3JpZ2luUGF0aHMsIGRlc3RpbmF0aW9uUGF0aHMsIHByZXZpb3VzUGF0aCkge1xuICAgIGNvbnN0IHNvdXJjZVBhdGggPSBvcmlnaW5QYXRocy5qb2luKFwiLlwiKTtcbiAgICBsZXQgYm9keSA9IGAke3NvdXJjZVBhdGh9ID09IG51bGwgPyBgO1xuICAgIGxldCBlcnJvckRlc3RpbmF0aW9uO1xuICAgIGlmICgoMCwgZ3JhcGhxbF8xLmlzTm9uTnVsbFR5cGUpKHR5cGUpKSB7XG4gICAgICAgIHR5cGUgPSB0eXBlLm9mVHlwZTtcbiAgICAgICAgY29uc3QgbnVsbEVycm9yU3RyID0gYFwiQ2Fubm90IHJldHVybiBudWxsIGZvciBub24tbnVsbGFibGUgZmllbGQgJHtwYXJlbnRUeXBlLm5hbWV9LiR7Z2V0RmllbGROb2Rlc05hbWUoZmllbGROb2Rlcyl9LlwiYDtcbiAgICAgICAgYm9keSArPSBgKCR7R0xPQkFMX05VTExfRVJST1JTX05BTUV9LnB1c2goJHtjcmVhdGVFcnJvck9iamVjdChjb250ZXh0LCBmaWVsZE5vZGVzLCBwcmV2aW91c1BhdGgsIG51bGxFcnJvclN0cil9KSwgbnVsbCkgOmA7XG4gICAgICAgIGVycm9yRGVzdGluYXRpb24gPSBHTE9CQUxfTlVMTF9FUlJPUlNfTkFNRTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGJvZHkgKz0gXCJudWxsIDogXCI7XG4gICAgICAgIGVycm9yRGVzdGluYXRpb24gPSBHTE9CQUxfRVJST1JTX05BTUU7XG4gICAgfVxuICAgIGJvZHkgKz0gXCIoXCI7XG4gICAgLy8gdmFsdWUgY2FuIGJlIGFuIGVycm9yIG9ialxuICAgIGNvbnN0IGVycm9yUGF0aCA9IGAke3NvdXJjZVBhdGh9Lm1lc3NhZ2UgIT0gbnVsbCA/ICR7c291cmNlUGF0aH0ubWVzc2FnZSA6ICR7c291cmNlUGF0aH1gO1xuICAgIGJvZHkgKz0gYCR7c291cmNlUGF0aH0gaW5zdGFuY2VvZiBFcnJvciA/ICgke2Vycm9yRGVzdGluYXRpb259LnB1c2goJHtjcmVhdGVFcnJvck9iamVjdChjb250ZXh0LCBmaWVsZE5vZGVzLCBwcmV2aW91c1BhdGgsIGVycm9yUGF0aCwgc291cmNlUGF0aCl9KSwgbnVsbCkgOiBgO1xuICAgIGlmICgoMCwgZ3JhcGhxbF8xLmlzTGVhZlR5cGUpKHR5cGUpKSB7XG4gICAgICAgIGJvZHkgKz0gY29tcGlsZUxlYWZUeXBlKGNvbnRleHQsIHR5cGUsIG9yaWdpblBhdGhzLCBmaWVsZE5vZGVzLCBwcmV2aW91c1BhdGgsIGVycm9yRGVzdGluYXRpb24pO1xuICAgIH1cbiAgICBlbHNlIGlmICgoMCwgZ3JhcGhxbF8xLmlzT2JqZWN0VHlwZSkodHlwZSkpIHtcbiAgICAgICAgY29uc3QgZmllbGRNYXAgPSAoMCwgYXN0XzEuY29sbGVjdFN1YmZpZWxkcykoY29udGV4dCwgdHlwZSwgZmllbGROb2RlcywgcHJldmlvdXNQYXRoKTtcbiAgICAgICAgYm9keSArPSBjb21waWxlT2JqZWN0VHlwZShjb250ZXh0LCB0eXBlLCBmaWVsZE5vZGVzLCBvcmlnaW5QYXRocywgZGVzdGluYXRpb25QYXRocywgcHJldmlvdXNQYXRoLCBlcnJvckRlc3RpbmF0aW9uLCBmaWVsZE1hcCwgZmFsc2UpO1xuICAgIH1cbiAgICBlbHNlIGlmICgoMCwgZ3JhcGhxbF8xLmlzQWJzdHJhY3RUeXBlKSh0eXBlKSkge1xuICAgICAgICBib2R5ICs9IGNvbXBpbGVBYnN0cmFjdFR5cGUoY29udGV4dCwgcGFyZW50VHlwZSwgdHlwZSwgZmllbGROb2Rlcywgb3JpZ2luUGF0aHMsIHByZXZpb3VzUGF0aCwgZXJyb3JEZXN0aW5hdGlvbik7XG4gICAgfVxuICAgIGVsc2UgaWYgKCgwLCBncmFwaHFsXzEuaXNMaXN0VHlwZSkodHlwZSkpIHtcbiAgICAgICAgYm9keSArPSBjb21waWxlTGlzdFR5cGUoY29udGV4dCwgcGFyZW50VHlwZSwgdHlwZSwgZmllbGROb2Rlcywgb3JpZ2luUGF0aHMsIHByZXZpb3VzUGF0aCwgZXJyb3JEZXN0aW5hdGlvbik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIHR5cGU6ICR7dHlwZS50b1N0cmluZygpfWApO1xuICAgIH1cbiAgICBib2R5ICs9IFwiKVwiO1xuICAgIHJldHVybiBib2R5O1xufVxuZnVuY3Rpb24gY29tcGlsZUxlYWZUeXBlKGNvbnRleHQsIHR5cGUsIG9yaWdpblBhdGhzLCBmaWVsZE5vZGVzLCBwcmV2aW91c1BhdGgsIGVycm9yRGVzdGluYXRpb24pIHtcbiAgICBsZXQgYm9keSA9IFwiXCI7XG4gICAgaWYgKGNvbnRleHQub3B0aW9ucy5kaXNhYmxlTGVhZlNlcmlhbGl6YXRpb24gJiZcbiAgICAgICAgKHR5cGUgaW5zdGFuY2VvZiBncmFwaHFsXzEuR3JhcGhRTEVudW1UeXBlIHx8ICgwLCBncmFwaHFsXzEuaXNTcGVjaWZpZWRTY2FsYXJUeXBlKSh0eXBlKSkpIHtcbiAgICAgICAgYm9keSArPSBgJHtvcmlnaW5QYXRocy5qb2luKFwiLlwiKX1gO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3Qgc2VyaWFsaXplck5hbWUgPSBnZXRTZXJpYWxpemVyTmFtZSh0eXBlLm5hbWUpO1xuICAgICAgICBjb250ZXh0LnNlcmlhbGl6ZXJzW3NlcmlhbGl6ZXJOYW1lXSA9IGdldFNlcmlhbGl6ZXIodHlwZSwgY29udGV4dC5vcHRpb25zLmN1c3RvbVNlcmlhbGl6ZXJzW3R5cGUubmFtZV0pO1xuICAgICAgICBjb25zdCBwYXJlbnRJbmRleGVzID0gZ2V0UGFyZW50QXJnSW5kZXhlcyhjb250ZXh0KTtcbiAgICAgICAgY29uc3Qgc2VyaWFsaXplckVycm9ySGFuZGxlciA9IGdldEhvaXN0ZWRGdW5jdGlvbk5hbWUoY29udGV4dCwgYCR7dHlwZS5uYW1lfSR7b3JpZ2luUGF0aHMuam9pbihcIlwiKX1TZXJpYWxpemVyRXJyb3JIYW5kbGVyYCk7XG4gICAgICAgIGNvbnRleHQuaG9pc3RlZEZ1bmN0aW9ucy5wdXNoKGBcbiAgICBmdW5jdGlvbiAke3NlcmlhbGl6ZXJFcnJvckhhbmRsZXJ9KCR7R0xPQkFMX0VYRUNVVElPTl9DT05URVhUfSwgbWVzc2FnZSwgJHtwYXJlbnRJbmRleGVzfSkge1xuICAgICR7ZXJyb3JEZXN0aW5hdGlvbn0ucHVzaCgke2NyZWF0ZUVycm9yT2JqZWN0KGNvbnRleHQsIGZpZWxkTm9kZXMsIHByZXZpb3VzUGF0aCwgXCJtZXNzYWdlXCIpfSk7fVxuICAgIGApO1xuICAgICAgICBib2R5ICs9IGAke0dMT0JBTF9FWEVDVVRJT05fQ09OVEVYVH0uc2VyaWFsaXplcnMuJHtzZXJpYWxpemVyTmFtZX0oJHtHTE9CQUxfRVhFQ1VUSU9OX0NPTlRFWFR9LCAke29yaWdpblBhdGhzLmpvaW4oXCIuXCIpfSwgJHtzZXJpYWxpemVyRXJyb3JIYW5kbGVyfSwgJHtwYXJlbnRJbmRleGVzfSlgO1xuICAgIH1cbiAgICByZXR1cm4gYm9keTtcbn1cbi8qKlxuICogQ29tcGlsZSBhIG5vZGUgb2Ygb2JqZWN0IHR5cGUuXG4gKiBAcGFyYW0ge0NvbXBpbGF0aW9uQ29udGV4dH0gY29udGV4dFxuICogQHBhcmFtIHtHcmFwaFFMT2JqZWN0VHlwZX0gdHlwZSB0eXBlIG9mIHRoZSBub2RlXG4gKiBAcGFyYW0gZmllbGROb2RlcyBmaWVsZE5vZGVzIGFycmF5IHdpdGggdGhlIG5vZGVzIHJlZmVyZW5jZXNcbiAqIEBwYXJhbSBvcmlnaW5QYXRocyBvcmlnaW5QYXRocyBwYXRoIGluIHRoZSBwYXJlbnQgb2JqZWN0IGZyb20gd2hlcmUgdG8gZmV0Y2ggcmVzdWx0c1xuICogQHBhcmFtIGRlc3RpbmF0aW9uUGF0aHMgcGF0aCBpbiB0aGUgd2hlcmUgdG8gd3JpdGUgdGhlIHJlc3VsdFxuICogQHBhcmFtIHJlc3BvbnNlUGF0aCByZXNwb25zZSBwYXRoIHVudGlsIHRoaXMgbm9kZVxuICogQHBhcmFtIGVycm9yRGVzdGluYXRpb24gUGF0aCBmb3IgZXJyb3IgYXJyYXlcbiAqIEBwYXJhbSBmaWVsZE1hcCBtYXAgb2YgZmllbGRzIHRvIGZpZWxkTm9kZXMgYXJyYXkgd2l0aCB0aGUgbm9kZXMgcmVmZXJlbmNlc1xuICogQHBhcmFtIGFsd2F5c0RlZmVyIHVzZWQgdG8gZm9yY2UgdGhlIGZpZWxkIHRvIGJlIHJlc29sdmVkIHdpdGggYSByZXNvbHZlciBhbGEgZ3JhcGhxbC1qc1xuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gY29tcGlsZU9iamVjdFR5cGUoY29udGV4dCwgdHlwZSwgZmllbGROb2Rlcywgb3JpZ2luUGF0aHMsIGRlc3RpbmF0aW9uUGF0aHMsIHJlc3BvbnNlUGF0aCwgZXJyb3JEZXN0aW5hdGlvbiwgZmllbGRNYXAsIGFsd2F5c0RlZmVyKSB7XG4gICAgY29uc3QgYm9keSA9ICgwLCBnZW5lcmF0ZV9mdW5jdGlvbl8xLmRlZmF1bHQpKCk7XG4gICAgLy8gQmVnaW4gb2JqZWN0IGNvbXBpbGF0aW9uIHBhcmVuXG4gICAgYm9keShcIihcIik7XG4gICAgaWYgKHR5cGVvZiB0eXBlLmlzVHlwZU9mID09PSBcImZ1bmN0aW9uXCIgJiYgIWFsd2F5c0RlZmVyKSB7XG4gICAgICAgIGNvbnRleHQuaXNUeXBlT2ZzW3R5cGUubmFtZSArIFwiSXNUeXBlT2ZcIl0gPSB0eXBlLmlzVHlwZU9mO1xuICAgICAgICBib2R5KGAhJHtHTE9CQUxfRVhFQ1VUSU9OX0NPTlRFWFR9LmlzVHlwZU9mc1tcIiR7dHlwZS5uYW1lfUlzVHlwZU9mXCJdKCR7b3JpZ2luUGF0aHMuam9pbihcIi5cIil9KSA/ICgke2Vycm9yRGVzdGluYXRpb259LnB1c2goJHtjcmVhdGVFcnJvck9iamVjdChjb250ZXh0LCBmaWVsZE5vZGVzLCByZXNwb25zZVBhdGgsIGBcXGBFeHBlY3RlZCB2YWx1ZSBvZiB0eXBlIFwiJHt0eXBlLm5hbWV9XCIgYnV0IGdvdDogJFxceyR7R0xPQkFMX0lOU1BFQ1RfTkFNRX0oJHtvcmlnaW5QYXRocy5qb2luKFwiLlwiKX0pfS5cXGBgKX0pLCBudWxsKSA6YCk7XG4gICAgfVxuICAgIC8vIG9iamVjdCBzdGFydFxuICAgIGJvZHkoXCJ7XCIpO1xuICAgIGZvciAoY29uc3QgbmFtZSBvZiBPYmplY3Qua2V5cyhmaWVsZE1hcCkpIHtcbiAgICAgICAgY29uc3QgZmllbGROb2RlcyA9IGZpZWxkTWFwW25hbWVdO1xuICAgICAgICBjb25zdCBmaWVsZCA9ICgwLCBhc3RfMS5yZXNvbHZlRmllbGREZWYpKGNvbnRleHQsIHR5cGUsIGZpZWxkTm9kZXMpO1xuICAgICAgICBpZiAoIWZpZWxkKSB7XG4gICAgICAgICAgICAvLyBGaWVsZCBpcyBpbnZhbGlkLCBzaG91bGQgaGF2ZSBiZWVuIGNhdWdodCBpbiB2YWxpZGF0aW9uXG4gICAgICAgICAgICAvLyBidXQgdGhlIGVycm9yIGlzIHN3YWxsb3dlZCBmb3IgY29tcGF0aWJpbGl0eSByZWFzb25zLlxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gS2V5IG9mIHRoZSBvYmplY3RcbiAgICAgICAgLy8gYG5hbWVgIGlzIHRoZSBmaWVsZCBuYW1lIG9yIGFuIGFsaWFzIHN1cHBsaWVkIGJ5IHRoZSB1c2VyXG4gICAgICAgIGJvZHkoYFwiJHtuYW1lfVwiOiBgKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFZhbHVlIG9mIHRoZSBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIGNvbWJpbmVkIGNvbmRpdGlvbiBmb3Igd2hldGhlciBhIGZpZWxkIHNob3VsZCBiZSBpbmNsdWRlZFxuICAgICAgICAgKiBpbiB0aGUgb2JqZWN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBIZXJlLCB0aGUgbG9naWNhbCBvcGVyYXRpb24gaXMgYHx8YCBiZWNhdXNlIGV2ZXJ5IGZpZWxkTm9kZVxuICAgICAgICAgKiBpcyBhdCB0aGUgc2FtZSBsZXZlbCBpbiB0aGUgdHJlZSwgaWYgYXQgbGVhc3QgXCJvbmUgb2ZcIiB0aGUgbm9kZXNcbiAgICAgICAgICogaXMgaW5jbHVkZWQsIHRoZW4gdGhlIGZpZWxkIGlzIGluY2x1ZGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgZXhhbXBsZSxcbiAgICAgICAgICpcbiAgICAgICAgICogYGBgZ3JhcGhxbFxuICAgICAgICAgKiB7XG4gICAgICAgICAqICAgZm9vIEBza2lwKGlmOiAkYzEpXG4gICAgICAgICAqICAgLi4uIHsgZm9vIEBza2lwKGlmOiAkYzIpIH1cbiAgICAgICAgICogfVxuICAgICAgICAgKiBgYGBcbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIGxvZ2ljIGZvciBgZm9vYCBiZWNvbWVzIC1cbiAgICAgICAgICpcbiAgICAgICAgICogYGNvbXBpbGF0aW9uRm9yKCRjMSkgfHwgY29tcGlsYXRpb25Gb3IoJGMyKWBcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IHNlcmlhbGl6ZWRSZXNwb25zZVBhdGggPSAoMCwgYXN0XzEuam9pblNraXBJbmNsdWRlUGF0aCkoKDAsIGFzdF8xLnNlcmlhbGl6ZU9iamVjdFBhdGhGb3JTa2lwSW5jbHVkZSkocmVzcG9uc2VQYXRoKSwgbmFtZSk7XG4gICAgICAgIGNvbnN0IGZpZWxkQ29uZGl0aW9uID0gY29udGV4dC5vcHRpb25zLnVzZUV4cGVyaW1lbnRhbFBhdGhCYXNlZFNraXBJbmNsdWRlXG4gICAgICAgICAgICA/IGZpZWxkTm9kZXNcbiAgICAgICAgICAgICAgICAubWFwKChpdCkgPT4gaXQuX19pbnRlcm5hbFNob3VsZEluY2x1ZGVQYXRoPy5bc2VyaWFsaXplZFJlc3BvbnNlUGF0aF0pXG4gICAgICAgICAgICAgICAgLmZpbHRlcigoaXQpID0+IGl0KVxuICAgICAgICAgICAgICAgIC5qb2luKFwiIHx8IFwiKSB8fCAvKiBpZih0cnVlKSAtIGRlZmF1bHQgKi8gXCJ0cnVlXCJcbiAgICAgICAgICAgIDogZmllbGROb2Rlc1xuICAgICAgICAgICAgICAgIC5tYXAoKGl0KSA9PiBpdC5fX2ludGVybmFsU2hvdWxkSW5jbHVkZSlcbiAgICAgICAgICAgICAgICAuZmlsdGVyKChpdCkgPT4gaXQpXG4gICAgICAgICAgICAgICAgLmpvaW4oXCIgfHwgXCIpIHx8IC8qIGlmKHRydWUpIC0gZGVmYXVsdCAqLyBcInRydWVcIjtcbiAgICAgICAgYm9keShgXG4gICAgICAoXG4gICAgICAgICR7ZmllbGRDb25kaXRpb259XG4gICAgICApXG4gICAgYCk7XG4gICAgICAgIC8vIElubGluZSBfX3R5cGVuYW1lXG4gICAgICAgIC8vIE5vIG5lZWQgdG8gY2FsbCBhIHJlc29sdmVyIGZvciB0eXBlbmFtZVxuICAgICAgICBpZiAoZmllbGQgPT09IGdyYXBocWxfMS5UeXBlTmFtZU1ldGFGaWVsZERlZikge1xuICAgICAgICAgICAgLy8gdHlwZS5uYW1lIGlmIGZpZWxkIGlzIGluY2x1ZGVkIGVsc2UgdW5kZWZpbmVkIC0gdG8gcmVtb3ZlIGZyb20gb2JqZWN0XG4gICAgICAgICAgICAvLyBkdXJpbmcgc2VyaWFsaXphdGlvblxuICAgICAgICAgICAgYm9keShgPyBcIiR7dHlwZS5uYW1lfVwiIDogdW5kZWZpbmVkLGApO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc29sdmVyID0gZmllbGQucmVzb2x2ZTtcbiAgICAgICAgaWYgKCFyZXNvbHZlciAmJiBhbHdheXNEZWZlcikge1xuICAgICAgICAgICAgY29uc3QgZmllbGROYW1lID0gZmllbGQubmFtZTtcbiAgICAgICAgICAgIHJlc29sdmVyID0gKHBhcmVudCkgPT4gcGFyZW50ICYmIHBhcmVudFtmaWVsZE5hbWVdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXNvbHZlcikge1xuICAgICAgICAgICAgY29udGV4dC5kZWZlcnJlZC5wdXNoKHtcbiAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlUGF0aDogKDAsIGFzdF8xLmFkZFBhdGgpKHJlc3BvbnNlUGF0aCwgbmFtZSksXG4gICAgICAgICAgICAgICAgb3JpZ2luUGF0aHMsXG4gICAgICAgICAgICAgICAgZGVzdGluYXRpb25QYXRocyxcbiAgICAgICAgICAgICAgICBwYXJlbnRUeXBlOiB0eXBlLFxuICAgICAgICAgICAgICAgIGZpZWxkTmFtZTogZmllbGQubmFtZSxcbiAgICAgICAgICAgICAgICBqc0ZpZWxkTmFtZTogZ2V0SnNGaWVsZE5hbWUoZmllbGQubmFtZSksXG4gICAgICAgICAgICAgICAgZmllbGRUeXBlOiBmaWVsZC50eXBlLFxuICAgICAgICAgICAgICAgIGZpZWxkTm9kZXMsXG4gICAgICAgICAgICAgICAgYXJnczogKDAsIGFzdF8xLmdldEFyZ3VtZW50RGVmcykoZmllbGQsIGZpZWxkTm9kZXNbMF0pXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnRleHQucmVzb2x2ZXJzW2dldFJlc29sdmVyTmFtZSh0eXBlLm5hbWUsIGZpZWxkLm5hbWUpXSA9IHJlc29sdmVyO1xuICAgICAgICAgICAgYm9keShgXG4gICAgICAgICAgPyAoXG4gICAgICAgICAgICAgICR7U0FGRVRZX0NIRUNLX1BSRUZJWH0ke2NvbnRleHQuZGVmZXJyZWQubGVuZ3RoIC0gMX0gPSB0cnVlLFxuICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICApXG4gICAgICAgICAgOiAoXG4gICAgICAgICAgICAgICR7U0FGRVRZX0NIRUNLX1BSRUZJWH0ke2NvbnRleHQuZGVmZXJyZWQubGVuZ3RoIC0gMX0gPSBmYWxzZSxcbiAgICAgICAgICAgICAgdW5kZWZpbmVkXG4gICAgICAgICAgICApXG4gICAgICAgIGApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gaWYgaW5jbHVkZWRcbiAgICAgICAgICAgIGJvZHkoXCI/XCIpO1xuICAgICAgICAgICAgYm9keShjb21waWxlVHlwZShjb250ZXh0LCB0eXBlLCBmaWVsZC50eXBlLCBmaWVsZE5vZGVzLCBvcmlnaW5QYXRocy5jb25jYXQoZmllbGQubmFtZSksIGRlc3RpbmF0aW9uUGF0aHMuY29uY2F0KG5hbWUpLCAoMCwgYXN0XzEuYWRkUGF0aCkocmVzcG9uc2VQYXRoLCBuYW1lKSkpO1xuICAgICAgICAgICAgLy8gaWYgbm90IGluY2x1ZGVkXG4gICAgICAgICAgICBib2R5KFwiOiB1bmRlZmluZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRW5kIG9iamVjdCBwcm9wZXJ0eVxuICAgICAgICBib2R5KFwiLFwiKTtcbiAgICB9XG4gICAgLy8gRW5kIG9iamVjdFxuICAgIGJvZHkoXCJ9XCIpO1xuICAgIC8vIEVuZCBvYmplY3QgY29tcGlsYXRpb24gcGFyZW5cbiAgICBib2R5KFwiKVwiKTtcbiAgICByZXR1cm4gYm9keS50b1N0cmluZygpO1xufVxuZnVuY3Rpb24gY29tcGlsZUFic3RyYWN0VHlwZShjb250ZXh0LCBwYXJlbnRUeXBlLCB0eXBlLCBmaWVsZE5vZGVzLCBvcmlnaW5QYXRocywgcHJldmlvdXNQYXRoLCBlcnJvckRlc3RpbmF0aW9uKSB7XG4gICAgbGV0IHJlc29sdmVUeXBlO1xuICAgIGlmICh0eXBlLnJlc29sdmVUeXBlKSB7XG4gICAgICAgIHJlc29sdmVUeXBlID0gdHlwZS5yZXNvbHZlVHlwZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJlc29sdmVUeXBlID0gKHZhbHVlLCBjb250ZXh0LCBpbmZvKSA9PiBkZWZhdWx0UmVzb2x2ZVR5cGVGbih2YWx1ZSwgY29udGV4dCwgaW5mbywgdHlwZSk7XG4gICAgfVxuICAgIGNvbnN0IHR5cGVSZXNvbHZlck5hbWUgPSBnZXRUeXBlUmVzb2x2ZXJOYW1lKHR5cGUubmFtZSk7XG4gICAgY29udGV4dC50eXBlUmVzb2x2ZXJzW3R5cGVSZXNvbHZlck5hbWVdID0gcmVzb2x2ZVR5cGU7XG4gICAgY29uc3QgY29sbGVjdGVkVHlwZXMgPSBjb250ZXh0LnNjaGVtYVxuICAgICAgICAuZ2V0UG9zc2libGVUeXBlcyh0eXBlKVxuICAgICAgICAubWFwKChvYmplY3RUeXBlKSA9PiB7XG4gICAgICAgIGNvbnN0IHN1YkNvbnRleHQgPSBjcmVhdGVTdWJDb21waWxhdGlvbkNvbnRleHQoY29udGV4dCk7XG4gICAgICAgIGNvbnN0IG9iamVjdCA9IGNvbXBpbGVUeXBlKHN1YkNvbnRleHQsIHBhcmVudFR5cGUsIG9iamVjdFR5cGUsIGZpZWxkTm9kZXMsIG9yaWdpblBhdGhzLCBbXCJfX2NvbmNyZXRlXCJdLCAoMCwgYXN0XzEuYWRkUGF0aCkocHJldmlvdXNQYXRoLCBvYmplY3RUeXBlLm5hbWUsIFwibWV0YVwiKSk7XG4gICAgICAgIHJldHVybiBgY2FzZSBcIiR7b2JqZWN0VHlwZS5uYW1lfVwiOiB7XG4gICAgICAgICAgICAgICAgICAke2dlbmVyYXRlVW5pcXVlRGVjbGFyYXRpb25zKHN1YkNvbnRleHQpfVxuICAgICAgICAgICAgICAgICAgY29uc3QgX19jb25jcmV0ZSA9ICR7b2JqZWN0fTtcbiAgICAgICAgICAgICAgICAgICR7Y29tcGlsZURlZmVycmVkRmllbGRzKHN1YkNvbnRleHQpfVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fY29uY3JldGU7XG4gICAgICAgICAgICAgIH1gO1xuICAgIH0pXG4gICAgICAgIC5qb2luKFwiXFxuXCIpO1xuICAgIGNvbnN0IGZpbmFsVHlwZU5hbWUgPSBcImZpbmFsVHlwZVwiO1xuICAgIGNvbnN0IG51bGxUeXBlRXJyb3IgPSBgXCJSdW50aW1lIE9iamVjdCB0eXBlIGlzIG5vdCBhIHBvc3NpYmxlIHR5cGUgZm9yIFxcXFxcIiR7dHlwZS5uYW1lfVxcXFxcIi5cImA7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuICAgIGNvbnN0IG5vdFBvc3NpYmxlVHlwZUVycm9yID0gXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXRlbXBsYXRlLWN1cmx5LWluLXN0cmluZ1xuICAgICdgUnVudGltZSBPYmplY3QgdHlwZSBcIiR7bm9kZVR5cGV9XCIgaXMgbm90IGEgcG9zc2libGUgdHlwZSBmb3IgXCInICtcbiAgICAgICAgdHlwZS5uYW1lICtcbiAgICAgICAgJ1wiLmAnO1xuICAgIGNvbnN0IG5vVHlwZUVycm9yID0gYCR7ZmluYWxUeXBlTmFtZX0gPyAke25vdFBvc3NpYmxlVHlwZUVycm9yfSA6IFwiQWJzdHJhY3QgdHlwZSAke3R5cGUubmFtZX0gbXVzdCByZXNvbHZlIHRvIGFuIE9iamVjdCB0eXBlIGF0IHJ1bnRpbWUgZm9yIGZpZWxkICR7cGFyZW50VHlwZS5uYW1lfS4ke2dldEZpZWxkTm9kZXNOYW1lKGZpZWxkTm9kZXMpfS4gRWl0aGVyIHRoZSAke3R5cGUubmFtZX0gdHlwZSBzaG91bGQgcHJvdmlkZSBhIFxcXFxcInJlc29sdmVUeXBlXFxcXFwiIGZ1bmN0aW9uIG9yIGVhY2ggcG9zc2libGUgdHlwZXMgc2hvdWxkIHByb3ZpZGUgYW4gXFxcXFwiaXNUeXBlT2ZcXFxcXCIgZnVuY3Rpb24uXCJgO1xuICAgIC8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL1xuICAgIHJldHVybiBgKChub2RlVHlwZSwgZXJyKSA9PlxuICB7XG4gICAgaWYgKGVyciAhPSBudWxsKSB7XG4gICAgICAke2Vycm9yRGVzdGluYXRpb259LnB1c2goJHtjcmVhdGVFcnJvck9iamVjdChjb250ZXh0LCBmaWVsZE5vZGVzLCBwcmV2aW91c1BhdGgsIFwiZXJyLm1lc3NhZ2UgIT0gbnVsbCA/IGVyci5tZXNzYWdlIDogZXJyXCIsIFwiZXJyXCIpfSk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKG5vZGVUeXBlID09IG51bGwpIHtcbiAgICAgICR7ZXJyb3JEZXN0aW5hdGlvbn0ucHVzaCgke2NyZWF0ZUVycm9yT2JqZWN0KGNvbnRleHQsIGZpZWxkTm9kZXMsIHByZXZpb3VzUGF0aCwgbnVsbFR5cGVFcnJvcil9KVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0ICR7ZmluYWxUeXBlTmFtZX0gPSB0eXBlb2Ygbm9kZVR5cGUgPT09IFwic3RyaW5nXCIgPyBub2RlVHlwZSA6IG5vZGVUeXBlLm5hbWU7XG4gICAgc3dpdGNoKCR7ZmluYWxUeXBlTmFtZX0pIHtcbiAgICAgICR7Y29sbGVjdGVkVHlwZXN9XG4gICAgICBkZWZhdWx0OlxuICAgICAgJHtlcnJvckRlc3RpbmF0aW9ufS5wdXNoKCR7Y3JlYXRlRXJyb3JPYmplY3QoY29udGV4dCwgZmllbGROb2RlcywgcHJldmlvdXNQYXRoLCBub1R5cGVFcnJvcil9KVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9KShcbiAgICAke0dMT0JBTF9FWEVDVVRJT05fQ09OVEVYVH0udHlwZVJlc29sdmVycy4ke3R5cGVSZXNvbHZlck5hbWV9KCR7b3JpZ2luUGF0aHMuam9pbihcIi5cIil9LFxuICAgICR7R0xPQkFMX0NPTlRFWFRfTkFNRX0sXG4gICAgJHtnZXRFeGVjdXRpb25JbmZvKGNvbnRleHQsIHBhcmVudFR5cGUsIHR5cGUsIHR5cGUubmFtZSwgZmllbGROb2RlcywgcHJldmlvdXNQYXRoKX0pKWA7XG59XG4vKipcbiAqIENvbXBpbGUgYSBsaXN0IHRyYW5zZm9ybWF0aW9uLlxuICpcbiAqIEBwYXJhbSB7Q29tcGlsYXRpb25Db250ZXh0fSBjb250ZXh0XG4gKiBAcGFyYW0ge0dyYXBoUUxPYmplY3RUeXBlfSBwYXJlbnRUeXBlIHR5cGUgb2YgdGhlIHBhcmVudCBvZiBvYmplY3Qgd2hpY2ggY29udGFpbmVkIHRoaXMgdHlwZVxuICogQHBhcmFtIHtHcmFwaFFMTGlzdDxHcmFwaFFMVHlwZT59IHR5cGUgbGlzdCB0eXBlIGJlaW5nIGNvbXBpbGVkXG4gKiBAcGFyYW0ge0ZpZWxkTm9kZVtdfSBmaWVsZE5vZGVzXG4gKiBAcGFyYW0gb3JpZ2luYWxPYmplY3RQYXRoc1xuICogQHBhcmFtIHtPYmplY3RQYXRofSByZXNwb25zZVBhdGhcbiAqIEBwYXJhbSBlcnJvckRlc3RpbmF0aW9uXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBjb21waWxlZCBsaXN0IHRyYW5zZm9ybWF0aW9uXG4gKi9cbmZ1bmN0aW9uIGNvbXBpbGVMaXN0VHlwZShjb250ZXh0LCBwYXJlbnRUeXBlLCB0eXBlLCBmaWVsZE5vZGVzLCBvcmlnaW5hbE9iamVjdFBhdGhzLCByZXNwb25zZVBhdGgsIGVycm9yRGVzdGluYXRpb24pIHtcbiAgICBjb25zdCBuYW1lID0gb3JpZ2luYWxPYmplY3RQYXRocy5qb2luKFwiLlwiKTtcbiAgICBjb25zdCBsaXN0Q29udGV4dCA9IGNyZWF0ZVN1YkNvbXBpbGF0aW9uQ29udGV4dChjb250ZXh0KTtcbiAgICAvLyBjb250ZXh0IGRlcHRoIHdpbGwgYmUgbXV0YXRlZCwgc28gd2UgY2FjaGUgdGhlIGN1cnJlbnQgdmFsdWUuXG4gICAgY29uc3QgbmV3RGVwdGggPSArK2xpc3RDb250ZXh0LmRlcHRoO1xuICAgIGNvbnN0IGZpZWxkVHlwZSA9IHR5cGUub2ZUeXBlO1xuICAgIGNvbnN0IGRhdGFCb2R5ID0gY29tcGlsZVR5cGUobGlzdENvbnRleHQsIHBhcmVudFR5cGUsIGZpZWxkVHlwZSwgZmllbGROb2RlcywgW1wiX19jdXJyZW50SXRlbVwiXSwgW2Ake0dMT0JBTF9QQVJFTlRfTkFNRX1baWR4JHtuZXdEZXB0aH1dYF0sICgwLCBhc3RfMS5hZGRQYXRoKShyZXNwb25zZVBhdGgsIFwiaWR4XCIgKyBuZXdEZXB0aCwgXCJ2YXJpYWJsZVwiKSk7XG4gICAgY29uc3QgZXJyb3JNZXNzYWdlID0gYFwiRXhwZWN0ZWQgSXRlcmFibGUsIGJ1dCBkaWQgbm90IGZpbmQgb25lIGZvciBmaWVsZCAke3BhcmVudFR5cGUubmFtZX0uJHtnZXRGaWVsZE5vZGVzTmFtZShmaWVsZE5vZGVzKX0uXCJgO1xuICAgIGNvbnN0IGVycm9yQ2FzZSA9IGAoJHtlcnJvckRlc3RpbmF0aW9ufS5wdXNoKCR7Y3JlYXRlRXJyb3JPYmplY3QoY29udGV4dCwgZmllbGROb2RlcywgcmVzcG9uc2VQYXRoLCBlcnJvck1lc3NhZ2UpfSksIG51bGwpYDtcbiAgICBjb25zdCBleGVjdXRpb25FcnJvciA9IGNyZWF0ZUVycm9yT2JqZWN0KGNvbnRleHQsIGZpZWxkTm9kZXMsICgwLCBhc3RfMS5hZGRQYXRoKShyZXNwb25zZVBhdGgsIFwiaWR4XCIgKyBuZXdEZXB0aCwgXCJ2YXJpYWJsZVwiKSwgXCJlcnIubWVzc2FnZSAhPSBudWxsID8gZXJyLm1lc3NhZ2UgOiBlcnJcIiwgXCJlcnJcIik7XG4gICAgY29uc3QgZW1wdHlFcnJvciA9IGNyZWF0ZUVycm9yT2JqZWN0KGNvbnRleHQsIGZpZWxkTm9kZXMsIHJlc3BvbnNlUGF0aCwgJ1wiXCInKTtcbiAgICBjb25zdCB1bmlxdWVEZWNsYXJhdGlvbnMgPSBnZW5lcmF0ZVVuaXF1ZURlY2xhcmF0aW9ucyhsaXN0Q29udGV4dCk7XG4gICAgY29uc3QgZGVmZXJyZWRGaWVsZHMgPSBjb21waWxlRGVmZXJyZWRGaWVsZHMobGlzdENvbnRleHQpO1xuICAgIGNvbnN0IGl0ZW1IYW5kbGVyID0gZ2V0SG9pc3RlZEZ1bmN0aW9uTmFtZShjb250ZXh0LCBgJHtwYXJlbnRUeXBlLm5hbWV9JHtvcmlnaW5hbE9iamVjdFBhdGhzLmpvaW4oXCJcIil9TWFwSXRlbUhhbmRsZXJgKTtcbiAgICBjb25zdCBjaGlsZEluZGV4ZXMgPSBnZXRQYXJlbnRBcmdJbmRleGVzKGxpc3RDb250ZXh0KTtcbiAgICBsaXN0Q29udGV4dC5ob2lzdGVkRnVuY3Rpb25zLnB1c2goYFxuICBmdW5jdGlvbiAke2l0ZW1IYW5kbGVyfSgke0dMT0JBTF9FWEVDVVRJT05fQ09OVEVYVH0sICR7R0xPQkFMX1BBUkVOVF9OQU1FfSwgX19jdXJyZW50SXRlbSwgJHtjaGlsZEluZGV4ZXN9KSB7XG4gICAgJHt1bmlxdWVEZWNsYXJhdGlvbnN9XG4gICAgJHtHTE9CQUxfUEFSRU5UX05BTUV9W2lkeCR7bmV3RGVwdGh9XSA9ICR7ZGF0YUJvZHl9O1xuICAgICR7ZGVmZXJyZWRGaWVsZHN9XG4gIH1cbiAgYCk7XG4gICAgY29uc3Qgc2FmZU1hcEhhbmRsZXIgPSBnZXRIb2lzdGVkRnVuY3Rpb25OYW1lKGNvbnRleHQsIGAke3BhcmVudFR5cGUubmFtZX0ke29yaWdpbmFsT2JqZWN0UGF0aHMuam9pbihcIlwiKX1NYXBIYW5kbGVyYCk7XG4gICAgY29uc3QgcGFyZW50SW5kZXhlcyA9IGdldFBhcmVudEFyZ0luZGV4ZXMoY29udGV4dCk7XG4gICAgbGlzdENvbnRleHQuaG9pc3RlZEZ1bmN0aW9ucy5wdXNoKGBcbiAgZnVuY3Rpb24gJHtzYWZlTWFwSGFuZGxlcn0oJHtHTE9CQUxfRVhFQ1VUSU9OX0NPTlRFWFR9LCBfX2N1cnJlbnRJdGVtLCBpZHgke25ld0RlcHRofSwgcmVzdWx0QXJyYXksICR7cGFyZW50SW5kZXhlc30pIHtcbiAgICBpZiAoJHtpc1Byb21pc2VJbmxpbmVyKFwiX19jdXJyZW50SXRlbVwiKX0pIHtcbiAgICAgICR7cHJvbWlzZVN0YXJ0ZWQoKX1cbiAgICAgIF9fY3VycmVudEl0ZW0udGhlbihyZXN1bHQgPT4ge1xuICAgICAgICAke2l0ZW1IYW5kbGVyfSgke0dMT0JBTF9FWEVDVVRJT05fQ09OVEVYVH0sIHJlc3VsdEFycmF5LCByZXN1bHQsICR7Y2hpbGRJbmRleGVzfSk7XG4gICAgICAgICR7cHJvbWlzZURvbmUoKX1cbiAgICAgIH0sIGVyciA9PiB7XG4gICAgICAgIHJlc3VsdEFycmF5LnB1c2gobnVsbCk7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAke2dldEVycm9yRGVzdGluYXRpb24oZmllbGRUeXBlKX0ucHVzaCgke2V4ZWN1dGlvbkVycm9yfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgJHtnZXRFcnJvckRlc3RpbmF0aW9uKGZpZWxkVHlwZSl9LnB1c2goJHtlbXB0eUVycm9yfSk7XG4gICAgICAgIH1cbiAgICAgICAgJHtwcm9taXNlRG9uZSgpfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAke2l0ZW1IYW5kbGVyfSgke0dMT0JBTF9FWEVDVVRJT05fQ09OVEVYVH0sIHJlc3VsdEFycmF5LCBfX2N1cnJlbnRJdGVtLCAke2NoaWxkSW5kZXhlc30pO1xuICAgIH1cbiAgfVxuICBgKTtcbiAgICByZXR1cm4gYCh0eXBlb2YgJHtuYW1lfSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgJHtuYW1lfVtTeW1ib2wuaXRlcmF0b3JdICE9PSBcImZ1bmN0aW9uXCIpID8gICR7ZXJyb3JDYXNlfSA6XG4gICR7R0xPQkFMX1NBRkVfTUFQX05BTUV9KCR7R0xPQkFMX0VYRUNVVElPTl9DT05URVhUfSwgJHtuYW1lfSwgJHtzYWZlTWFwSGFuZGxlcn0sICR7cGFyZW50SW5kZXhlc30pYDtcbn1cbi8qKlxuICogSW1wbGVtZW50cyBhIGdlbmVyaWMgbWFwIG9wZXJhdGlvbiBmb3IgYW55IGl0ZXJhYmxlLlxuICpcbiAqIElmIHRoZSBpdGVyYWJsZSBpcyBub3QgdmFsaWQsIG51bGwgaXMgcmV0dXJuZWQuXG4gKiBAcGFyYW0gY29udGV4dFxuICogQHBhcmFtIHtJdGVyYWJsZTxhbnk+IHwgc3RyaW5nfSBpdGVyYWJsZSBwb3NzaWJsZSBpdGVyYWJsZVxuICogQHBhcmFtIHsoYTogYW55KSA9PiBhbnl9IGNiIGNhbGxiYWNrIHRoYXQgcmVjZWl2ZXMgdGhlIGl0ZW0gYmVpbmcgaXRlcmF0ZWRcbiAqIEBwYXJhbSBpZHhcbiAqIEByZXR1cm5zIHthbnlbXX0gYSBuZXcgYXJyYXkgd2l0aCB0aGUgcmVzdWx0IG9mIHRoZSBjYWxsYmFja1xuICovXG5mdW5jdGlvbiBzYWZlTWFwKGNvbnRleHQsIGl0ZXJhYmxlLCBjYiwgLi4uaWR4KSB7XG4gICAgbGV0IGluZGV4ID0gMDtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGEgb2YgaXRlcmFibGUpIHtcbiAgICAgICAgY2IoY29udGV4dCwgYSwgaW5kZXgsIHJlc3VsdCwgLi4uaWR4KTtcbiAgICAgICAgKytpbmRleDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmNvbnN0IE1BR0lDX01JTlVTX0lORklOSVRZID0gXCJfX01BR0lDX01JTlVTX0lORklOSVRZX183MWQ0MzEwYV9kNGEzXzRhMDVfYjFmZV9lNjA3NzlkMjQ5OThcIjtcbmNvbnN0IE1BR0lDX1BMVVNfSU5GSU5JVFkgPSBcIl9fTUFHSUNfUExVU19JTkZJTklUWV9fYmIyMDFjMzlfMzMzM180Njk1X2I0YWRfN2YxNzIyZTdhYTdhXCI7XG5jb25zdCBNQUdJQ19OQU4gPSBcIl9fTUFHSUNfTkFOX181N2YyODZiOV80YzIwXzQ4N2ZfYjQwOV83OTgwNGRkY2I0ZjhcIjtcbmNvbnN0IE1BR0lDX0RBVEUgPSBcIl9fTUFHSUNfREFURV9fMzNhOWU3NmRfMDJlMF80MTI4XzhlOTJfMzUzMGFkM2RhNzRkXCI7XG5mdW5jdGlvbiBzcGVjaWFsVmFsdWVSZXBsYWNlcihrZXksIHZhbHVlKSB7XG4gICAgaWYgKE51bWJlci5pc05hTih2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIE1BR0lDX05BTjtcbiAgICB9XG4gICAgaWYgKHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgICAgICByZXR1cm4gTUFHSUNfUExVU19JTkZJTklUWTtcbiAgICB9XG4gICAgaWYgKHZhbHVlID09PSAtSW5maW5pdHkpIHtcbiAgICAgICAgcmV0dXJuIE1BR0lDX01JTlVTX0lORklOSVRZO1xuICAgIH1cbiAgICBpZiAodGhpc1trZXldIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICByZXR1cm4gTUFHSUNfREFURSArIHRoaXNba2V5XS5nZXRUaW1lKCk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIG9iamVjdFN0cmluZ2lmeSh2YWwpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsLCBzcGVjaWFsVmFsdWVSZXBsYWNlcilcbiAgICAgICAgLnJlcGxhY2UobmV3IFJlZ0V4cChgXCIke01BR0lDX05BTn1cImAsIFwiZ1wiKSwgXCJOYU5cIilcbiAgICAgICAgLnJlcGxhY2UobmV3IFJlZ0V4cChgXCIke01BR0lDX1BMVVNfSU5GSU5JVFl9XCJgLCBcImdcIiksIFwiSW5maW5pdHlcIilcbiAgICAgICAgLnJlcGxhY2UobmV3IFJlZ0V4cChgXCIke01BR0lDX01JTlVTX0lORklOSVRZfVwiYCwgXCJnXCIpLCBcIi1JbmZpbml0eVwiKVxuICAgICAgICAucmVwbGFjZShuZXcgUmVnRXhwKGBcIiR7TUFHSUNfREFURX0oW15cIl0rKVwiYCwgXCJnXCIpLCBcIm5ldyBEYXRlKCQxKVwiKTtcbn1cbi8qKlxuICogQ2FsY3VsYXRlcyBhIEdyYXBoUUxSZXNvbHZlSW5mbyBvYmplY3QgZm9yIHRoZSByZXNvbHZlciBjYWxscy5cbiAqXG4gKiBpZiB0aGUgcmVzb2x2ZXIgZG9lcyBub3QgdXNlLCBpdCByZXR1cm5zIG51bGwuXG4gKiBAcGFyYW0ge0NvbXBpbGF0aW9uQ29udGV4dH0gY29udGV4dCBjb21waWxhdGlvbiBjb250ZXh0IHRvIHN1Ym1pdCB0aGUgcmVzb2x2ZUluZm9SZXNvbHZlclxuICogQHBhcmFtIHBhcmVudFR5cGVcbiAqIEBwYXJhbSBmaWVsZFR5cGVcbiAqIEBwYXJhbSBmaWVsZE5hbWVcbiAqIEBwYXJhbSBmaWVsZE5vZGVzXG4gKiBAcGFyYW0gcmVzcG9uc2VQYXRoXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBhIGNhbGwgdG8gdGhlIHJlc29sdmUgaW5mbyBjcmVhdG9yIG9yIFwie31cIiBpZiB1bnVzZWRcbiAqL1xuZnVuY3Rpb24gZ2V0RXhlY3V0aW9uSW5mbyhjb250ZXh0LCBwYXJlbnRUeXBlLCBmaWVsZFR5cGUsIGZpZWxkTmFtZSwgZmllbGROb2RlcywgcmVzcG9uc2VQYXRoKSB7XG4gICAgY29uc3QgcmVzb2x2ZUluZm9OYW1lID0gY3JlYXRlUmVzb2x2ZUluZm9OYW1lKHJlc3BvbnNlUGF0aCk7XG4gICAgY29uc3QgeyBzY2hlbWEsIGZyYWdtZW50cywgb3BlcmF0aW9uIH0gPSBjb250ZXh0O1xuICAgIGNvbnRleHQucmVzb2x2ZUluZm9zW3Jlc29sdmVJbmZvTmFtZV0gPSAoMCwgcmVzb2x2ZV9pbmZvXzEuY3JlYXRlUmVzb2x2ZUluZm9UaHVuaykoe1xuICAgICAgICBzY2hlbWEsXG4gICAgICAgIGZyYWdtZW50cyxcbiAgICAgICAgb3BlcmF0aW9uLFxuICAgICAgICBwYXJlbnRUeXBlLFxuICAgICAgICBmaWVsZE5hbWUsXG4gICAgICAgIGZpZWxkVHlwZSxcbiAgICAgICAgZmllbGROb2Rlc1xuICAgIH0sIGNvbnRleHQub3B0aW9ucy5yZXNvbHZlckluZm9FbnJpY2hlcik7XG4gICAgcmV0dXJuIGAke0dMT0JBTF9FWEVDVVRJT05fQ09OVEVYVH0ucmVzb2x2ZUluZm9zLiR7cmVzb2x2ZUluZm9OYW1lfSgke0dMT0JBTF9ST09UX05BTUV9LCAke2V4cG9ydHMuR0xPQkFMX1ZBUklBQkxFU19OQU1FfSwgJHtzZXJpYWxpemVSZXNwb25zZVBhdGgocmVzcG9uc2VQYXRoKX0pYDtcbn1cbmZ1bmN0aW9uIGdldEFyZ3VtZW50c05hbWUocHJlZml4TmFtZSkge1xuICAgIHJldHVybiBgJHtwcmVmaXhOYW1lfUFyZ3NgO1xufVxuZnVuY3Rpb24gZ2V0VmFsaWRBcmd1bWVudHNWYXJOYW1lKHByZWZpeE5hbWUpIHtcbiAgICByZXR1cm4gYCR7cHJlZml4TmFtZX1WYWxpZEFyZ3NgO1xufVxuZnVuY3Rpb24gb2JqZWN0UGF0aCh0b3BMZXZlbCwgcGF0aCkge1xuICAgIGlmICghcGF0aCkge1xuICAgICAgICByZXR1cm4gdG9wTGV2ZWw7XG4gICAgfVxuICAgIGxldCBvYmplY3RQYXRoID0gdG9wTGV2ZWw7XG4gICAgY29uc3QgZmxhdHRlbmVkID0gKDAsIGFzdF8xLmZsYXR0ZW5QYXRoKShwYXRoKTtcbiAgICBmb3IgKGNvbnN0IHNlY3Rpb24gb2YgZmxhdHRlbmVkKSB7XG4gICAgICAgIGlmIChzZWN0aW9uLnR5cGUgPT09IFwibGl0ZXJhbFwiKSB7XG4gICAgICAgICAgICBvYmplY3RQYXRoICs9IGBbXCIke3NlY3Rpb24ua2V5fVwiXWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic2hvdWxkIG9ubHkgaGF2ZSByZWNlaXZlZCBsaXRlcmFsIHBhdGhzXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmplY3RQYXRoO1xufVxuLyoqXG4gKiBSZXR1cm5zIGEgc3RhdGljIG9iamVjdCB3aXRoIHRoZSBhbGwgdGhlIGFyZ3VtZW50cyBuZWVkZWQgZm9yIHRoZSByZXNvbHZlclxuICogQHBhcmFtIGNvbnRleHRcbiAqIEBwYXJhbSB7QXJndW1lbnRzfSBhcmdzXG4gKiBAcGFyYW0gdG9wTGV2ZWxBcmcgbmFtZSBvZiB0aGUgdG9wbGV2ZWxcbiAqIEBwYXJhbSB2YWxpZEFyZ3NcbiAqIEBwYXJhbSByZXR1cm5UeXBlXG4gKiBAcGFyYW0gcGF0aFxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gY29tcGlsZUFyZ3VtZW50cyhjb250ZXh0LCBhcmdzLCB0b3BMZXZlbEFyZywgdmFsaWRBcmdzLCByZXR1cm5UeXBlLCBwYXRoKSB7XG4gICAgLy8gZGVmYXVsdCB0byBhc3N1bWluZyBhcmd1bWVudHMgYXJlIHZhbGlkXG4gICAgbGV0IGJvZHkgPSBgXG4gIGxldCAke3ZhbGlkQXJnc30gPSB0cnVlO1xuICBjb25zdCAke3RvcExldmVsQXJnfSA9ICR7b2JqZWN0U3RyaW5naWZ5KGFyZ3MudmFsdWVzKX07XG4gIGA7XG4gICAgY29uc3QgZXJyb3JEZXN0aW5hdGlvbiA9IGdldEVycm9yRGVzdGluYXRpb24ocmV0dXJuVHlwZSk7XG4gICAgZm9yIChjb25zdCB2YXJpYWJsZSBvZiBhcmdzLm1pc3NpbmcpIHtcbiAgICAgICAgY29uc3QgdmFyTmFtZSA9IHZhcmlhYmxlLnZhbHVlTm9kZS5uYW1lLnZhbHVlO1xuICAgICAgICBib2R5ICs9IGBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKCR7ZXhwb3J0cy5HTE9CQUxfVkFSSUFCTEVTX05BTUV9LCBcIiR7dmFyTmFtZX1cIikpIHtgO1xuICAgICAgICBpZiAodmFyaWFibGUuYXJndW1lbnQgJiYgKDAsIGdyYXBocWxfMS5pc05vbk51bGxUeXBlKSh2YXJpYWJsZS5hcmd1bWVudC5kZWZpbml0aW9uLnR5cGUpKSB7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gYCdBcmd1bWVudCBcIiR7dmFyaWFibGUuYXJndW1lbnQuZGVmaW5pdGlvbi5uYW1lfVwiIG9mIG5vbi1udWxsIHR5cGUgXCIke3ZhcmlhYmxlLmFyZ3VtZW50LmRlZmluaXRpb24udHlwZS50b1N0cmluZygpfVwiIG11c3Qgbm90IGJlIG51bGwuJ2A7XG4gICAgICAgICAgICBib2R5ICs9IGBpZiAoJHtleHBvcnRzLkdMT0JBTF9WQVJJQUJMRVNfTkFNRX1bJyR7dmFyaWFibGUudmFsdWVOb2RlLm5hbWUudmFsdWV9J10gPT0gbnVsbCkge1xuICAgICAgJHtlcnJvckRlc3RpbmF0aW9ufS5wdXNoKCR7Y3JlYXRlRXJyb3JPYmplY3QoY29udGV4dCwgW3ZhcmlhYmxlLmFyZ3VtZW50Lm5vZGUudmFsdWVdLCBwYXRoLCBtZXNzYWdlKX0pO1xuICAgICAgJHt2YWxpZEFyZ3N9ID0gZmFsc2U7XG4gICAgICB9YDtcbiAgICAgICAgfVxuICAgICAgICBib2R5ICs9IGBcbiAgICAke29iamVjdFBhdGgodG9wTGV2ZWxBcmcsIHZhcmlhYmxlLnBhdGgpfSA9ICR7ZXhwb3J0cy5HTE9CQUxfVkFSSUFCTEVTX05BTUV9Wycke3ZhcmlhYmxlLnZhbHVlTm9kZS5uYW1lLnZhbHVlfSddO1xuICAgIH1gO1xuICAgICAgICAvLyBJZiB0aGVyZSBpcyBubyBkZWZhdWx0IHZhbHVlIGFuZCBubyB2YXJpYWJsZSBpbnB1dFxuICAgICAgICAvLyB0aHJvdyBhIGZpZWxkIGVycm9yXG4gICAgICAgIGlmICh2YXJpYWJsZS5hcmd1bWVudCAmJlxuICAgICAgICAgICAgKDAsIGdyYXBocWxfMS5pc05vbk51bGxUeXBlKSh2YXJpYWJsZS5hcmd1bWVudC5kZWZpbml0aW9uLnR5cGUpICYmXG4gICAgICAgICAgICB2YXJpYWJsZS5hcmd1bWVudC5kZWZpbml0aW9uLmRlZmF1bHRWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gYCdBcmd1bWVudCBcIiR7dmFyaWFibGUuYXJndW1lbnQuZGVmaW5pdGlvbi5uYW1lfVwiIG9mIHJlcXVpcmVkIHR5cGUgXCIke3ZhcmlhYmxlLmFyZ3VtZW50LmRlZmluaXRpb24udHlwZS50b1N0cmluZygpfVwiIHdhcyBwcm92aWRlZCB0aGUgdmFyaWFibGUgXCIkJHt2YXJOYW1lfVwiIHdoaWNoIHdhcyBub3QgcHJvdmlkZWQgYSBydW50aW1lIHZhbHVlLidgO1xuICAgICAgICAgICAgYm9keSArPSBgIGVsc2Uge1xuICAgICAgJHtlcnJvckRlc3RpbmF0aW9ufS5wdXNoKCR7Y3JlYXRlRXJyb3JPYmplY3QoY29udGV4dCwgW3ZhcmlhYmxlLmFyZ3VtZW50Lm5vZGUudmFsdWVdLCBwYXRoLCBtZXNzYWdlKX0pO1xuICAgICAgJHt2YWxpZEFyZ3N9ID0gZmFsc2U7XG4gICAgICAgIH1gO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBib2R5O1xufVxuLyoqXG4gKiAgU2FmZXR5IGNoZWNrcyBmb3IgcmVzb2x2ZXIgZXhlY3V0aW9uIGlzIGRvbmUgdmlhIHNpZGUgZWZmZWN0cyBldmVyeSB0aW1lIGEgcmVzb2x2ZXIgZnVuY3Rpb25cbiAqICBpcyBlbmNvdW50ZXJlZC5cbiAqXG4gKiAgVGhpcyBmdW5jdGlvbiBnZW5lcmF0ZXMgdGhlIGRlY2xhcmF0aW9ucywgc28gdGhlIHNpZGUgZWZmZWN0IGlzIHZhbGlkIGNvZGUuXG4gKlxuICogQHBhcmFtIHtDb21waWxhdGlvbkNvbnRleHR9IGNvbnRleHQgY29tcGlsYXRpb24gY29udGV4dFxuICogQHBhcmFtIHtib29sZWFufSBkZWZhdWx0VmFsdWUgdXN1YWxseSBmYWxzZSwgbWVhbnQgdG8gYmUgdHJ1ZSBhdCB0aGUgdG9wIGxldmVsXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBhIGxpc3Qgb2YgZGVjbGFyYXRpb25zIGVnOiB2YXIgX192YWxpZE5vZGUwID0gZmFsc2U7XFxudmFyIF9fdmFsaWROb2RlMSA9IGZhbHNlO1xuICovXG5mdW5jdGlvbiBnZW5lcmF0ZVVuaXF1ZURlY2xhcmF0aW9ucyhjb250ZXh0LCBkZWZhdWx0VmFsdWUgPSBmYWxzZSkge1xuICAgIHJldHVybiBjb250ZXh0LmRlZmVycmVkXG4gICAgICAgIC5tYXAoKF8sIGlkeCkgPT4gYFxuICAgICAgICBsZXQgJHtTQUZFVFlfQ0hFQ0tfUFJFRklYfSR7aWR4fSA9ICR7ZGVmYXVsdFZhbHVlfTtcbiAgICAgIGApXG4gICAgICAgIC5qb2luKFwiXFxuXCIpO1xufVxuZnVuY3Rpb24gY3JlYXRlU3ViQ29tcGlsYXRpb25Db250ZXh0KGNvbnRleHQpIHtcbiAgICByZXR1cm4geyAuLi5jb250ZXh0LCBkZWZlcnJlZDogW10gfTtcbn1cbmZ1bmN0aW9uIGlzUHJvbWlzZSh2YWx1ZSkge1xuICAgIHJldHVybiAodmFsdWUgIT0gbnVsbCAmJlxuICAgICAgICB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgdHlwZW9mIHZhbHVlLnRoZW4gPT09IFwiZnVuY3Rpb25cIik7XG59XG5leHBvcnRzLmlzUHJvbWlzZSA9IGlzUHJvbWlzZTtcbmZ1bmN0aW9uIGlzUHJvbWlzZUlubGluZXIodmFsdWUpIHtcbiAgICByZXR1cm4gYCR7dmFsdWV9ICE9IG51bGwgJiYgdHlwZW9mICR7dmFsdWV9ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiAke3ZhbHVlfS50aGVuID09PSBcImZ1bmN0aW9uXCJgO1xufVxuZXhwb3J0cy5pc1Byb21pc2VJbmxpbmVyID0gaXNQcm9taXNlSW5saW5lcjtcbi8qKlxuICogU2VyaWFsaXplcyB0aGUgcmVzcG9uc2UgcGF0aCBmb3IgYW4gZXJyb3IgcmVzcG9uc2UuXG4gKlxuICogQHBhcmFtIHtPYmplY3RQYXRoIHwgdW5kZWZpbmVkfSBwYXRoIHJlc3BvbnNlIHBhdGggb2YgYSBmaWVsZFxuICogQHJldHVybnMge3N0cmluZ30gZmlsdGVyZWQgc2VyaWFsaXphdGlvbiBvZiB0aGUgcmVzcG9uc2UgcGF0aFxuICovXG5mdW5jdGlvbiBzZXJpYWxpemVSZXNwb25zZVBhdGhBc0FycmF5KHBhdGgpIHtcbiAgICBjb25zdCBmbGF0dGVuZWQgPSAoMCwgYXN0XzEuZmxhdHRlblBhdGgpKHBhdGgpO1xuICAgIGxldCBzcmMgPSBcIltcIjtcbiAgICBmb3IgKGxldCBpID0gZmxhdHRlbmVkLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIC8vIG1ldGEgaXMgb25seSB1c2VkIGZvciB0aGUgZnVuY3Rpb24gbmFtZVxuICAgICAgICBpZiAoZmxhdHRlbmVkW2ldLnR5cGUgPT09IFwibWV0YVwiKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBzcmMgKz1cbiAgICAgICAgICAgIGZsYXR0ZW5lZFtpXS50eXBlID09PSBcImxpdGVyYWxcIlxuICAgICAgICAgICAgICAgID8gYFwiJHtmbGF0dGVuZWRbaV0ua2V5fVwiLGBcbiAgICAgICAgICAgICAgICA6IGAke2ZsYXR0ZW5lZFtpXS5rZXl9LGA7XG4gICAgfVxuICAgIHJldHVybiBzcmMgKyBcIl1cIjtcbn1cbmZ1bmN0aW9uIGdldEVycm9yRGVzdGluYXRpb24odHlwZSkge1xuICAgIHJldHVybiAoMCwgZ3JhcGhxbF8xLmlzTm9uTnVsbFR5cGUpKHR5cGUpID8gR0xPQkFMX05VTExfRVJST1JTX05BTUUgOiBHTE9CQUxfRVJST1JTX05BTUU7XG59XG5mdW5jdGlvbiBjcmVhdGVSZXNvbHZlSW5mb05hbWUocGF0aCkge1xuICAgIHJldHVybiAoKDAsIGFzdF8xLmZsYXR0ZW5QYXRoKShwYXRoKVxuICAgICAgICAubWFwKChwKSA9PiBwLmtleSlcbiAgICAgICAgLmpvaW4oXCJfXCIpICsgXCJJbmZvXCIpO1xufVxuLyoqXG4gKiBTZXJpYWxpemVzIHRoZSByZXNwb25zZSBwYXRoIGZvciB0aGUgcmVzb2x2ZSBpbmZvIGZ1bmN0aW9uXG4gKiBAcGFyYW0ge09iamVjdFBhdGggfCB1bmRlZmluZWR9IHBhdGggcmVzcG9uc2UgcGF0aCBvZiBhIGZpZWxkXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBmaWx0ZXJlZCBzZXJpYWxpemF0aW9uIG9mIHRoZSByZXNwb25zZSBwYXRoXG4gKi9cbmZ1bmN0aW9uIHNlcmlhbGl6ZVJlc3BvbnNlUGF0aChwYXRoKSB7XG4gICAgaWYgKCFwYXRoKSB7XG4gICAgICAgIHJldHVybiBcInVuZGVmaW5lZFwiO1xuICAgIH1cbiAgICBpZiAocGF0aC50eXBlID09PSBcIm1ldGFcIikge1xuICAgICAgICAvLyBtZXRhIGlzIGlnbm9yZWQgd2hpbGUgc2VyaWFsaXppbmcgZm9yIHRoZSByZXNvbHZlIGluZm8gZnVuY3Rpb25zXG4gICAgICAgIHJldHVybiBzZXJpYWxpemVSZXNwb25zZVBhdGgocGF0aC5wcmV2KTtcbiAgICB9XG4gICAgY29uc3QgbGl0ZXJhbFZhbHVlID0gYFwiJHtwYXRoLmtleX1cImA7XG4gICAgcmV0dXJuIGB7XG4gICAga2V5OiAgJHtwYXRoLnR5cGUgPT09IFwibGl0ZXJhbFwiID8gbGl0ZXJhbFZhbHVlIDogcGF0aC5rZXl9LFxuICAgIHByZXY6ICR7c2VyaWFsaXplUmVzcG9uc2VQYXRoKHBhdGgucHJldil9XG4gIH1gO1xufVxuLyoqXG4gKiBSZXR1cm5lZCBhIGJvdW5kIHNlcmlhbGl6YXRpb24gZnVuY3Rpb24gb2YgYSBzY2FsYXIgb3IgZW51bVxuICogQHBhcmFtIHtHcmFwaFFMU2NhbGFyVHlwZSB8IEdyYXBoUUxFbnVtVHlwZX0gc2NhbGFyXG4gKiBAcGFyYW0gY3VzdG9tU2VyaWFsaXplciBjdXN0b20gc2VyaWFsaXplclxuICogQHJldHVybnMgeyh2OiBhbnkpID0+IGFueX0gYm91bmQgc2VyaWFsaXphdGlvbkZ1bmN0aW9uXG4gKi9cbmZ1bmN0aW9uIGdldFNlcmlhbGl6ZXIoc2NhbGFyLCBjdXN0b21TZXJpYWxpemVyKSB7XG4gICAgY29uc3QgeyBuYW1lIH0gPSBzY2FsYXI7XG4gICAgY29uc3Qgc2VyaWFsaXplID0gY3VzdG9tU2VyaWFsaXplciB8fCAoKHZhbCkgPT4gc2NhbGFyLnNlcmlhbGl6ZSh2YWwpKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gbGVhZlNlcmlhbGl6ZXIoY29udGV4dCwgdiwgb25FcnJvciwgLi4uaWR4KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHNlcmlhbGl6ZSh2KTtcbiAgICAgICAgICAgIGlmIChpc0ludmFsaWQodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgb25FcnJvcihjb250ZXh0LCBgRXhwZWN0ZWQgYSB2YWx1ZSBvZiB0eXBlIFwiJHtuYW1lfVwiIGJ1dCByZWNlaXZlZDogJHt2fWAsIC4uLmlkeCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIG9uRXJyb3IoY29udGV4dCwgKGUgJiYgZS5tZXNzYWdlKSB8fFxuICAgICAgICAgICAgICAgIGBFeHBlY3RlZCBhIHZhbHVlIG9mIHR5cGUgXCIke25hbWV9XCIgYnV0IHJlY2VpdmVkIGFuIEVycm9yYCwgLi4uaWR4KTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbn1cbi8qKlxuICogRGVmYXVsdCBhYnN0cmFjdCB0eXBlIHJlc29sdmVyLlxuICpcbiAqIEl0IG9ubHkgaGFuZGxlIHN5bmMgdHlwZSByZXNvbHZpbmcuXG4gKiBAcGFyYW0gdmFsdWVcbiAqIEBwYXJhbSBjb250ZXh0VmFsdWVcbiAqIEBwYXJhbSB7R3JhcGhRTFJlc29sdmVJbmZvfSBpbmZvXG4gKiBAcGFyYW0ge0dyYXBoUUxBYnN0cmFjdFR5cGV9IGFic3RyYWN0VHlwZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZGVmYXVsdFJlc29sdmVUeXBlRm4odmFsdWUsIGNvbnRleHRWYWx1ZSwgaW5mbywgYWJzdHJhY3RUeXBlKSB7XG4gICAgLy8gRmlyc3QsIGxvb2sgZm9yIGBfX3R5cGVuYW1lYC5cbiAgICBpZiAodmFsdWUgIT0gbnVsbCAmJlxuICAgICAgICB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgdHlwZW9mIHZhbHVlLl9fdHlwZW5hbWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLl9fdHlwZW5hbWU7XG4gICAgfVxuICAgIC8vIE90aGVyd2lzZSwgdGVzdCBlYWNoIHBvc3NpYmxlIHR5cGUuXG4gICAgY29uc3QgcG9zc2libGVUeXBlcyA9IGluZm8uc2NoZW1hLmdldFBvc3NpYmxlVHlwZXMoYWJzdHJhY3RUeXBlKTtcbiAgICBmb3IgKGNvbnN0IHR5cGUgb2YgcG9zc2libGVUeXBlcykge1xuICAgICAgICBpZiAodHlwZS5pc1R5cGVPZikge1xuICAgICAgICAgICAgY29uc3QgaXNUeXBlT2ZSZXN1bHQgPSB0eXBlLmlzVHlwZU9mKHZhbHVlLCBjb250ZXh0VmFsdWUsIGluZm8pO1xuICAgICAgICAgICAgaWYgKGlzUHJvbWlzZShpc1R5cGVPZlJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFByb21pc2VzIGFyZSBub3Qgc3VwcG9ydGVkIGZvciByZXNvbHZpbmcgdHlwZSBvZiAke3ZhbHVlfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNUeXBlT2ZSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZS5uYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IHJlc29sdmUgdGhlIG9iamVjdCB0eXBlIGluIHBvc3NpYmxlIHR5cGVzIG9mICR7YWJzdHJhY3RUeXBlLm5hbWV9IGZvciB0aGUgdmFsdWU6IGAgK1xuICAgICAgICBpbnNwZWN0KHZhbHVlKSk7XG59XG4vKipcbiAqIENvbnN0cnVjdHMgYSBFeGVjdXRpb25Db250ZXh0IG9iamVjdCBmcm9tIHRoZSBhcmd1bWVudHMgcGFzc2VkIHRvXG4gKiBleGVjdXRlLCB3aGljaCB3ZSB3aWxsIHBhc3MgdGhyb3VnaG91dCB0aGUgb3RoZXIgZXhlY3V0aW9uIG1ldGhvZHMuXG4gKlxuICogVGhyb3dzIGEgR3JhcGhRTEVycm9yIGlmIGEgdmFsaWQgZXhlY3V0aW9uIGNvbnRleHQgY2Fubm90IGJlIGNyZWF0ZWQuXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkQ29tcGlsYXRpb25Db250ZXh0KHNjaGVtYSwgZG9jdW1lbnQsIG9wdGlvbnMsIG9wZXJhdGlvbk5hbWUpIHtcbiAgICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgICBsZXQgb3BlcmF0aW9uID0gdW5kZWZpbmVkO1xuICAgIGxldCBoYXNNdWx0aXBsZUFzc3VtZWRPcGVyYXRpb25zID0gZmFsc2U7XG4gICAgY29uc3QgZnJhZ21lbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBmb3IgKGNvbnN0IGRlZmluaXRpb24gb2YgZG9jdW1lbnQuZGVmaW5pdGlvbnMpIHtcbiAgICAgICAgc3dpdGNoIChkZWZpbml0aW9uLmtpbmQpIHtcbiAgICAgICAgICAgIGNhc2UgZ3JhcGhxbF8xLktpbmQuT1BFUkFUSU9OX0RFRklOSVRJT046XG4gICAgICAgICAgICAgICAgaWYgKCFvcGVyYXRpb25OYW1lICYmIG9wZXJhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBoYXNNdWx0aXBsZUFzc3VtZWRPcGVyYXRpb25zID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIW9wZXJhdGlvbk5hbWUgfHxcbiAgICAgICAgICAgICAgICAgICAgKGRlZmluaXRpb24ubmFtZSAmJiBkZWZpbml0aW9uLm5hbWUudmFsdWUgPT09IG9wZXJhdGlvbk5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbiA9IGRlZmluaXRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBncmFwaHFsXzEuS2luZC5GUkFHTUVOVF9ERUZJTklUSU9OOlxuICAgICAgICAgICAgICAgIGZyYWdtZW50c1tkZWZpbml0aW9uLm5hbWUudmFsdWVdID0gZGVmaW5pdGlvbjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIW9wZXJhdGlvbikge1xuICAgICAgICBpZiAob3BlcmF0aW9uTmFtZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGdyYXBocWxfMS5HcmFwaFFMRXJyb3IoYFVua25vd24gb3BlcmF0aW9uIG5hbWVkIFwiJHtvcGVyYXRpb25OYW1lfVwiLmApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGdyYXBocWxfMS5HcmFwaFFMRXJyb3IoXCJNdXN0IHByb3ZpZGUgYW4gb3BlcmF0aW9uLlwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChoYXNNdWx0aXBsZUFzc3VtZWRPcGVyYXRpb25zKSB7XG4gICAgICAgIHRocm93IG5ldyBncmFwaHFsXzEuR3JhcGhRTEVycm9yKFwiTXVzdCBwcm92aWRlIG9wZXJhdGlvbiBuYW1lIGlmIHF1ZXJ5IGNvbnRhaW5zIG11bHRpcGxlIG9wZXJhdGlvbnMuXCIpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBzY2hlbWEsXG4gICAgICAgIGZyYWdtZW50cyxcbiAgICAgICAgcm9vdFZhbHVlOiBudWxsLFxuICAgICAgICBjb250ZXh0VmFsdWU6IG51bGwsXG4gICAgICAgIG9wZXJhdGlvbixcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgcmVzb2x2ZXJzOiB7fSxcbiAgICAgICAgc2VyaWFsaXplcnM6IHt9LFxuICAgICAgICB0eXBlUmVzb2x2ZXJzOiB7fSxcbiAgICAgICAgaXNUeXBlT2ZzOiB7fSxcbiAgICAgICAgcmVzb2x2ZUluZm9zOiB7fSxcbiAgICAgICAgaG9pc3RlZEZ1bmN0aW9uczogW10sXG4gICAgICAgIGhvaXN0ZWRGdW5jdGlvbk5hbWVzOiBuZXcgTWFwKCksXG4gICAgICAgIGRlZmVycmVkOiBbXSxcbiAgICAgICAgZGVwdGg6IC0xLFxuICAgICAgICB2YXJpYWJsZVZhbHVlczoge30sXG4gICAgICAgIGVycm9yc1xuICAgIH07XG59XG5mdW5jdGlvbiBnZXRGaWVsZE5vZGVzTmFtZShub2Rlcykge1xuICAgIHJldHVybiBub2Rlcy5sZW5ndGggPiAxXG4gICAgICAgID8gXCIoXCIgKyBub2Rlcy5tYXAoKHsgbmFtZSB9KSA9PiBuYW1lLnZhbHVlKS5qb2luKFwiLFwiKSArIFwiKVwiXG4gICAgICAgIDogbm9kZXNbMF0ubmFtZS52YWx1ZTtcbn1cbmZ1bmN0aW9uIGdldEhvaXN0ZWRGdW5jdGlvbk5hbWUoY29udGV4dCwgbmFtZSkge1xuICAgIGNvbnN0IGNvdW50ID0gY29udGV4dC5ob2lzdGVkRnVuY3Rpb25OYW1lcy5nZXQobmFtZSk7XG4gICAgaWYgKGNvdW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29udGV4dC5ob2lzdGVkRnVuY3Rpb25OYW1lcy5zZXQobmFtZSwgMCk7XG4gICAgICAgIHJldHVybiBuYW1lO1xuICAgIH1cbiAgICBjb250ZXh0LmhvaXN0ZWRGdW5jdGlvbk5hbWVzLnNldChuYW1lLCBjb3VudCArIDEpO1xuICAgIHJldHVybiBgJHtuYW1lfSR7Y291bnQgKyAxfWA7XG59XG5mdW5jdGlvbiBjcmVhdGVFcnJvck9iamVjdChjb250ZXh0LCBub2RlcywgcGF0aCwgbWVzc2FnZSwgb3JpZ2luYWxFcnJvcikge1xuICAgIHJldHVybiBgbmV3ICR7R1JBUEhRTF9FUlJPUn0oJHttZXNzYWdlfSxcbiAgICAke0pTT04uc3RyaW5naWZ5KCgwLCBhc3RfMS5jb21wdXRlTG9jYXRpb25zKShub2RlcykpfSxcbiAgICAgICR7c2VyaWFsaXplUmVzcG9uc2VQYXRoQXNBcnJheShwYXRoKX0sXG4gICAgICAke29yaWdpbmFsRXJyb3IgfHwgXCJ1bmRlZmluZWRcIn0sXG4gICAgICAke2NvbnRleHQub3B0aW9ucy5kaXNhYmxpbmdDYXB0dXJpbmdTdGFja0Vycm9ycyA/IFwidHJ1ZVwiIDogXCJmYWxzZVwifSlgO1xufVxuZnVuY3Rpb24gZ2V0UmVzb2x2ZXJOYW1lKHBhcmVudE5hbWUsIG5hbWUpIHtcbiAgICByZXR1cm4gcGFyZW50TmFtZSArIG5hbWUgKyBcIlJlc29sdmVyXCI7XG59XG5mdW5jdGlvbiBnZXRUeXBlUmVzb2x2ZXJOYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gbmFtZSArIFwiVHlwZVJlc29sdmVyXCI7XG59XG5mdW5jdGlvbiBnZXRTZXJpYWxpemVyTmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIG5hbWUgKyBcIlNlcmlhbGl6ZXJcIjtcbn1cbmZ1bmN0aW9uIHByb21pc2VTdGFydGVkKCkge1xuICAgIHJldHVybiBgXG4gICAgIC8vIGluY3JlYXNlIHRoZSBwcm9taXNlIGNvdW50ZXJcbiAgICAgKyske0dMT0JBTF9QUk9NSVNFX0NPVU5URVJ9O1xuICBgO1xufVxuZnVuY3Rpb24gcHJvbWlzZURvbmUoKSB7XG4gICAgcmV0dXJuIGBcbiAgICAtLSR7R0xPQkFMX1BST01JU0VfQ09VTlRFUn07XG4gICAgaWYgKCR7R0xPQkFMX1BST01JU0VfQ09VTlRFUn0gPT09IDApIHtcbiAgICAgICR7R0xPQkFMX1JFU09MVkV9KCR7R0xPQkFMX0VYRUNVVElPTl9DT05URVhUfSk7XG4gICAgfVxuICBgO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplRXJyb3JzKGVycikge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGVycikpIHtcbiAgICAgICAgcmV0dXJuIGVyci5tYXAoKGUpID0+IG5vcm1hbGl6ZUVycm9yKGUpKTtcbiAgICB9XG4gICAgcmV0dXJuIFtub3JtYWxpemVFcnJvcihlcnIpXTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZUVycm9yKGVycikge1xuICAgIHJldHVybiBlcnIgaW5zdGFuY2VvZiBncmFwaHFsXzEuR3JhcGhRTEVycm9yXG4gICAgICAgID8gZXJyXG4gICAgICAgIDogbmV3IGVycm9yXzEuR3JhcGhRTEVycm9yKGVyci5tZXNzYWdlLCBlcnIubG9jYXRpb25zLCBlcnIucGF0aCwgZXJyKTtcbn1cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGEgdmFsdWUgaXMgdW5kZWZpbmVkLCBvciBOYU4uXG4gKi9cbmZ1bmN0aW9uIGlzSW52YWxpZCh2YWx1ZSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSAhPT0gdmFsdWU7XG59XG5mdW5jdGlvbiBnZXRQYXJlbnRBcmdJbmRleGVzKGNvbnRleHQpIHtcbiAgICBsZXQgYXJncyA9IFwiXCI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gY29udGV4dC5kZXB0aDsgKytpKSB7XG4gICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgYXJncyArPSBcIiwgXCI7XG4gICAgICAgIH1cbiAgICAgICAgYXJncyArPSBgaWR4JHtpfWA7XG4gICAgfVxuICAgIHJldHVybiBhcmdzO1xufVxuZnVuY3Rpb24gZ2V0SnNGaWVsZE5hbWUoZmllbGROYW1lKSB7XG4gICAgcmV0dXJuIGAke0xPQ0FMX0pTX0ZJRUxEX05BTUVfUFJFRklYfSR7ZmllbGROYW1lfWA7XG59XG5mdW5jdGlvbiBpc0FzeW5jSXRlcmFibGUodmFsKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBPYmplY3QodmFsKVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPT09IFwiZnVuY3Rpb25cIjtcbn1cbmV4cG9ydHMuaXNBc3luY0l0ZXJhYmxlID0gaXNBc3luY0l0ZXJhYmxlO1xuZnVuY3Rpb24gY29tcGlsZVN1YnNjcmlwdGlvbk9wZXJhdGlvbihjb250ZXh0LCB0eXBlLCBmaWVsZE1hcCwgcXVlcnlGbikge1xuICAgIGNvbnN0IGZpZWxkTm9kZXMgPSBPYmplY3QudmFsdWVzKGZpZWxkTWFwKVswXTtcbiAgICBjb25zdCBmaWVsZE5vZGUgPSBmaWVsZE5vZGVzWzBdO1xuICAgIGNvbnN0IGZpZWxkTmFtZSA9IGZpZWxkTm9kZS5uYW1lLnZhbHVlO1xuICAgIGNvbnN0IGZpZWxkID0gKDAsIGFzdF8xLnJlc29sdmVGaWVsZERlZikoY29udGV4dCwgdHlwZSwgZmllbGROb2Rlcyk7XG4gICAgaWYgKCFmaWVsZCkge1xuICAgICAgICB0aHJvdyBuZXcgZ3JhcGhxbF8xLkdyYXBoUUxFcnJvcihgVGhlIHN1YnNjcmlwdGlvbiBmaWVsZCBcIiR7ZmllbGROYW1lfVwiIGlzIG5vdCBkZWZpbmVkLmAsICgwLCBjb21wYXRfMS5nZXRHcmFwaFFMRXJyb3JPcHRpb25zKShmaWVsZE5vZGVzKSk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3BvbnNlUGF0aCA9ICgwLCBhc3RfMS5hZGRQYXRoKSh1bmRlZmluZWQsIGZpZWxkTmFtZSk7XG4gICAgY29uc3QgcmVzb2x2ZUluZm9OYW1lID0gY3JlYXRlUmVzb2x2ZUluZm9OYW1lKHJlc3BvbnNlUGF0aCk7XG4gICAgY29uc3Qgc3Vic2NyaWJlciA9IGZpZWxkLnN1YnNjcmliZTtcbiAgICBhc3luYyBmdW5jdGlvbiBleGVjdXRlU3Vic2NyaXB0aW9uKGV4ZWN1dGlvbkNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgcmVzb2x2ZUluZm8gPSBleGVjdXRpb25Db250ZXh0LnJlc29sdmVJbmZvc1tyZXNvbHZlSW5mb05hbWVdKGV4ZWN1dGlvbkNvbnRleHQucm9vdFZhbHVlLCBleGVjdXRpb25Db250ZXh0LnZhcmlhYmxlcywgcmVzcG9uc2VQYXRoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50U3RyZWFtID0gYXdhaXQgc3Vic2NyaWJlcj8uKGV4ZWN1dGlvbkNvbnRleHQucm9vdFZhbHVlLCBleGVjdXRpb25Db250ZXh0LnZhcmlhYmxlcywgZXhlY3V0aW9uQ29udGV4dC5jb250ZXh0LCByZXNvbHZlSW5mbyk7XG4gICAgICAgICAgICBpZiAoZXZlbnRTdHJlYW0gaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IGV2ZW50U3RyZWFtO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGV2ZW50U3RyZWFtO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgKDAsIGdyYXBocWxfMS5sb2NhdGVkRXJyb3IpKGVycm9yLCByZXNvbHZlSW5mby5maWVsZE5vZGVzLCAoMCwgUGF0aF8xLnBhdGhUb0FycmF5KShyZXNvbHZlSW5mby5wYXRoKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZnVuY3Rpb24gY3JlYXRlU291cmNlRXZlbnRTdHJlYW0oZXhlY3V0aW9uQ29udGV4dCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZXZlbnRTdHJlYW0gPSBhd2FpdCBleGVjdXRlU3Vic2NyaXB0aW9uKGV4ZWN1dGlvbkNvbnRleHQpO1xuICAgICAgICAgICAgLy8gQXNzZXJ0IGZpZWxkIHJldHVybmVkIGFuIGV2ZW50IHN0cmVhbSwgb3RoZXJ3aXNlIHlpZWxkIGFuIGVycm9yLlxuICAgICAgICAgICAgaWYgKCFpc0FzeW5jSXRlcmFibGUoZXZlbnRTdHJlYW0pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3Vic2NyaXB0aW9uIGZpZWxkIG11c3QgcmV0dXJuIEFzeW5jIEl0ZXJhYmxlLiBcIiArXG4gICAgICAgICAgICAgICAgICAgIGBSZWNlaXZlZDogJHtpbnNwZWN0KGV2ZW50U3RyZWFtKX0uYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZXZlbnRTdHJlYW07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAvLyBJZiBpdCBpcyBhIEdyYXBoUUxFcnJvciwgcmVwb3J0IGl0IGFzIGFuIEV4ZWN1dGlvblJlc3VsdCwgY29udGFpbmluZyBvbmx5IGVycm9ycyBhbmQgbm8gZGF0YS5cbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSB0cmVhdCB0aGUgZXJyb3IgYXMgYSBzeXN0ZW0tY2xhc3MgZXJyb3IgYW5kIHJlLXRocm93IGl0LlxuICAgICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgZ3JhcGhxbF8xLkdyYXBoUUxFcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGVycm9yczogW2Vycm9yXSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFzeW5jIGZ1bmN0aW9uIHN1YnNjcmliZShleGVjdXRpb25Db250ZXh0KSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdE9yU3RyZWFtID0gYXdhaXQgY3JlYXRlU291cmNlRXZlbnRTdHJlYW0oZXhlY3V0aW9uQ29udGV4dCk7XG4gICAgICAgIGlmICghaXNBc3luY0l0ZXJhYmxlKHJlc3VsdE9yU3RyZWFtKSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdE9yU3RyZWFtO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZvciBlYWNoIHBheWxvYWQgeWllbGRlZCBmcm9tIGEgc3Vic2NyaXB0aW9uLCBtYXAgaXQgb3ZlciB0aGUgbm9ybWFsXG4gICAgICAgIC8vIEdyYXBoUUwgYGV4ZWN1dGVgIGZ1bmN0aW9uLCB3aXRoIGBwYXlsb2FkYCBhcyB0aGUgcm9vdFZhbHVlLlxuICAgICAgICAvLyBUaGlzIGltcGxlbWVudHMgdGhlIFwiTWFwU291cmNlVG9SZXNwb25zZUV2ZW50XCIgYWxnb3JpdGhtIGRlc2NyaWJlZCBpblxuICAgICAgICAvLyB0aGUgR3JhcGhRTCBzcGVjaWZpY2F0aW9uLiBUaGUgYGV4ZWN1dGVgIGZ1bmN0aW9uIHByb3ZpZGVzIHRoZVxuICAgICAgICAvLyBcIkV4ZWN1dGVTdWJzY3JpcHRpb25FdmVudFwiIGFsZ29yaXRobSwgYXMgaXQgaXMgbmVhcmx5IGlkZW50aWNhbCB0byB0aGVcbiAgICAgICAgLy8gXCJFeGVjdXRlUXVlcnlcIiBhbGdvcml0aG0sIGZvciB3aGljaCBgZXhlY3V0ZWAgaXMgYWxzbyB1c2VkLlxuICAgICAgICAvLyBXZSB1c2Ugb3VyIGBxdWVyeWAgZnVuY3Rpb24gaW4gcGxhY2Ugb2YgYGV4ZWN1dGVgXG4gICAgICAgIGNvbnN0IG1hcFNvdXJjZVRvUmVzcG9uc2UgPSAocGF5bG9hZCkgPT4gcXVlcnlGbihwYXlsb2FkLCBleGVjdXRpb25Db250ZXh0LmNvbnRleHQsIGV4ZWN1dGlvbkNvbnRleHQudmFyaWFibGVzKTtcbiAgICAgICAgcmV0dXJuIG1hcEFzeW5jSXRlcmF0b3IocmVzdWx0T3JTdHJlYW0sIG1hcFNvdXJjZVRvUmVzcG9uc2UpO1xuICAgIH07XG59XG5mdW5jdGlvbiBjcmVhdGVCb3VuZFN1YnNjcmliZShjb21waWxhdGlvbkNvbnRleHQsIGRvY3VtZW50LCBmdW5jLCBnZXRWYXJpYWJsZVZhbHVlcywgb3BlcmF0aW9uTmFtZSkge1xuICAgIGNvbnN0IHsgcmVzb2x2ZXJzLCB0eXBlUmVzb2x2ZXJzLCBpc1R5cGVPZnMsIHNlcmlhbGl6ZXJzLCByZXNvbHZlSW5mb3MgfSA9IGNvbXBpbGF0aW9uQ29udGV4dDtcbiAgICBjb25zdCB0cmltbWVyID0gKDAsIG5vbl9udWxsXzEuY3JlYXRlTnVsbFRyaW1tZXIpKGNvbXBpbGF0aW9uQ29udGV4dCk7XG4gICAgY29uc3QgZm5OYW1lID0gb3BlcmF0aW9uTmFtZSB8fCBcInN1YnNjcmliZVwiO1xuICAgIGNvbnN0IHJldCA9IHtcbiAgICAgICAgYXN5bmMgW2ZuTmFtZV0ocm9vdFZhbHVlLCBjb250ZXh0LCB2YXJpYWJsZXMpIHtcbiAgICAgICAgICAgIC8vIHRoaXMgY2FuIGJlIHNoYXJlZCBhY3Jvc3MgaW4gYSBiYXRjaCByZXF1ZXN0XG4gICAgICAgICAgICBjb25zdCBwYXJzZWRWYXJpYWJsZXMgPSBnZXRWYXJpYWJsZVZhbHVlcyh2YXJpYWJsZXMgfHwge30pO1xuICAgICAgICAgICAgLy8gUmV0dXJuIGVhcmx5IGVycm9ycyBpZiB2YXJpYWJsZSBjb2VyY2luZyBmYWlsZWQuXG4gICAgICAgICAgICBpZiAoKDAsIHZhcmlhYmxlc18xLmZhaWxUb1BhcnNlVmFyaWFibGVzKShwYXJzZWRWYXJpYWJsZXMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZXJyb3JzOiBwYXJzZWRWYXJpYWJsZXMuZXJyb3JzIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBleGVjdXRpb25Db250ZXh0ID0ge1xuICAgICAgICAgICAgICAgIHJvb3RWYWx1ZSxcbiAgICAgICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgICAgICAgIHZhcmlhYmxlczogcGFyc2VkVmFyaWFibGVzLmNvZXJjZWQsXG4gICAgICAgICAgICAgICAgc2FmZU1hcCxcbiAgICAgICAgICAgICAgICBpbnNwZWN0LFxuICAgICAgICAgICAgICAgIEdyYXBoUUxFcnJvcjogZXJyb3JfMS5HcmFwaFFMRXJyb3IsXG4gICAgICAgICAgICAgICAgcmVzb2x2ZXJzLFxuICAgICAgICAgICAgICAgIHR5cGVSZXNvbHZlcnMsXG4gICAgICAgICAgICAgICAgaXNUeXBlT2ZzLFxuICAgICAgICAgICAgICAgIHNlcmlhbGl6ZXJzLFxuICAgICAgICAgICAgICAgIHJlc29sdmVJbmZvcyxcbiAgICAgICAgICAgICAgICB0cmltbWVyLFxuICAgICAgICAgICAgICAgIHByb21pc2VDb3VudGVyOiAwLFxuICAgICAgICAgICAgICAgIG51bGxFcnJvcnM6IFtdLFxuICAgICAgICAgICAgICAgIGVycm9yczogW10sXG4gICAgICAgICAgICAgICAgZGF0YToge31cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlbGVzcy1jYWxsXG4gICAgICAgICAgICByZXR1cm4gZnVuYy5jYWxsKG51bGwsIGV4ZWN1dGlvbkNvbnRleHQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gcmV0W2ZuTmFtZV07XG59XG4vKipcbiAqIEdpdmVuIGFuIEFzeW5jSXRlcmFibGUgYW5kIGEgY2FsbGJhY2sgZnVuY3Rpb24sIHJldHVybiBhbiBBc3luY0l0ZXJhdG9yXG4gKiB3aGljaCBwcm9kdWNlcyB2YWx1ZXMgbWFwcGVkIHZpYSBjYWxsaW5nIHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gbWFwQXN5bmNJdGVyYXRvcihpdGVyYWJsZSwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBpdGVyYXRvciA9IGl0ZXJhYmxlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpO1xuICAgIGFzeW5jIGZ1bmN0aW9uIG1hcFJlc3VsdChyZXN1bHQpIHtcbiAgICAgICAgaWYgKHJlc3VsdC5kb25lKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogYXdhaXQgY2FsbGJhY2socmVzdWx0LnZhbHVlKSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaXRlcmF0b3IucmV0dXJuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBpdGVyYXRvci5yZXR1cm4oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLyogaWdub3JlIGVycm9yICovXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYXN5bmMgbmV4dCgpIHtcbiAgICAgICAgICAgIHJldHVybiBtYXBSZXN1bHQoYXdhaXQgaXRlcmF0b3IubmV4dCgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgYXN5bmMgcmV0dXJuKCkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBpdGVyYXRvci5yZXR1cm4gPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgICAgICAgID8gbWFwUmVzdWx0KGF3YWl0IGl0ZXJhdG9yLnJldHVybigpKVxuICAgICAgICAgICAgICAgIDogeyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gICAgICAgIH0sXG4gICAgICAgIGFzeW5jIHRocm93KGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIGl0ZXJhdG9yLnRocm93ID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICAgICAgICA/IG1hcFJlc3VsdChhd2FpdCBpdGVyYXRvci50aHJvdyhlcnJvcikpXG4gICAgICAgICAgICAgICAgOiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgICAgIH0sXG4gICAgICAgIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1leGVjdXRpb24uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/graphql-jit/dist/esm/execution.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/graphql-jit/dist/esm/index.js":
/*!*****************************************************!*\
  !*** ../node_modules/graphql-jit/dist/esm/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isLeafField = exports.fieldExpansionEnricher = exports.isCompiledQuery = exports.compileQuery = void 0;\nvar execution_1 = __webpack_require__(/*! ./execution */ \"(ssr)/../node_modules/graphql-jit/dist/esm/execution.js\");\nObject.defineProperty(exports, \"compileQuery\", ({ enumerable: true, get: function () { return execution_1.compileQuery; } }));\nObject.defineProperty(exports, \"isCompiledQuery\", ({ enumerable: true, get: function () { return execution_1.isCompiledQuery; } }));\nvar resolve_info_1 = __webpack_require__(/*! ./resolve-info */ \"(ssr)/../node_modules/graphql-jit/dist/esm/resolve-info.js\");\nObject.defineProperty(exports, \"fieldExpansionEnricher\", ({ enumerable: true, get: function () { return resolve_info_1.fieldExpansionEnricher; } }));\nObject.defineProperty(exports, \"isLeafField\", ({ enumerable: true, get: function () { return resolve_info_1.isLeafField; } }));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL2dyYXBocWwtaml0L2Rpc3QvZXNtL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG1CQUFtQixHQUFHLDhCQUE4QixHQUFHLHVCQUF1QixHQUFHLG9CQUFvQjtBQUNyRyxrQkFBa0IsbUJBQU8sQ0FBQyw0RUFBYTtBQUN2QyxnREFBK0MsRUFBRSxxQ0FBcUMsb0NBQW9DLEVBQUM7QUFDM0gsbURBQWtELEVBQUUscUNBQXFDLHVDQUF1QyxFQUFDO0FBQ2pJLHFCQUFxQixtQkFBTyxDQUFDLGtGQUFnQjtBQUM3QywwREFBeUQsRUFBRSxxQ0FBcUMsaURBQWlELEVBQUM7QUFDbEosK0NBQThDLEVBQUUscUNBQXFDLHNDQUFzQyxFQUFDO0FBQzVIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGVkZ2l0eS15aWVsZC1mcm9udGVuZC8uLi9ub2RlX21vZHVsZXMvZ3JhcGhxbC1qaXQvZGlzdC9lc20vaW5kZXguanM/ODAxYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaXNMZWFmRmllbGQgPSBleHBvcnRzLmZpZWxkRXhwYW5zaW9uRW5yaWNoZXIgPSBleHBvcnRzLmlzQ29tcGlsZWRRdWVyeSA9IGV4cG9ydHMuY29tcGlsZVF1ZXJ5ID0gdm9pZCAwO1xudmFyIGV4ZWN1dGlvbl8xID0gcmVxdWlyZShcIi4vZXhlY3V0aW9uXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY29tcGlsZVF1ZXJ5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBleGVjdXRpb25fMS5jb21waWxlUXVlcnk7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc0NvbXBpbGVkUXVlcnlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGV4ZWN1dGlvbl8xLmlzQ29tcGlsZWRRdWVyeTsgfSB9KTtcbnZhciByZXNvbHZlX2luZm9fMSA9IHJlcXVpcmUoXCIuL3Jlc29sdmUtaW5mb1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImZpZWxkRXhwYW5zaW9uRW5yaWNoZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlc29sdmVfaW5mb18xLmZpZWxkRXhwYW5zaW9uRW5yaWNoZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc0xlYWZGaWVsZFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVzb2x2ZV9pbmZvXzEuaXNMZWFmRmllbGQ7IH0gfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/graphql-jit/dist/esm/index.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/graphql-jit/dist/esm/inspect.js":
/*!*******************************************************!*\
  !*** ../node_modules/graphql-jit/dist/esm/inspect.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/**\n * Based on https://github.com/graphql/graphql-js/blob/master/src/jsutils/inspect.js\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.nodejsCustomInspectSymbol = void 0;\nexports.nodejsCustomInspectSymbol = Symbol.for(\"nodejs.util.inspect.custom\");\nfunction createInspect(maxArrayLength = 10, maxRecursiveDepth = 2) {\n    /**\n     * Used to print values in error messages.\n     */\n    return function inspect(value) {\n        return formatValue(value, []);\n    };\n    function formatValue(value, seenValues) {\n        switch (typeof value) {\n            case \"string\":\n                return JSON.stringify(value);\n            case \"function\":\n                return value.name ? `[function ${value.name}]` : \"[function]\";\n            case \"object\":\n                return formatObjectValue(value, seenValues);\n            default:\n                return String(value);\n        }\n    }\n    function formatObjectValue(value, previouslySeenValues) {\n        if (previouslySeenValues.indexOf(value) !== -1) {\n            return \"[Circular]\";\n        }\n        const seenValues = [...previouslySeenValues, value];\n        if (value) {\n            const customInspectFn = getCustomFn(value);\n            if (customInspectFn) {\n                // $FlowFixMe(>=0.90.0)\n                const customValue = customInspectFn.call(value);\n                // check for infinite recursion\n                if (customValue !== value) {\n                    return typeof customValue === \"string\"\n                        ? customValue\n                        : formatValue(customValue, seenValues);\n                }\n            }\n            else if (Array.isArray(value)) {\n                return formatArray(value, seenValues);\n            }\n            return formatObject(value, seenValues);\n        }\n        return String(value);\n    }\n    function formatObject(object, seenValues) {\n        const keys = Object.keys(object);\n        if (keys.length === 0) {\n            return \"{}\";\n        }\n        if (seenValues.length > maxRecursiveDepth) {\n            return \"[\" + getObjectTag(object) + \"]\";\n        }\n        const properties = keys.map((key) => {\n            const value = formatValue(object[key], seenValues);\n            return key + \": \" + value;\n        });\n        return \"{ \" + properties.join(\", \") + \" }\";\n    }\n    function formatArray(array, seenValues) {\n        if (array.length === 0) {\n            return \"[]\";\n        }\n        if (seenValues.length > maxRecursiveDepth) {\n            return \"[Array]\";\n        }\n        const len = Math.min(maxArrayLength, array.length);\n        const remaining = array.length - len;\n        const items = [];\n        for (let i = 0; i < len; ++i) {\n            items.push(formatValue(array[i], seenValues));\n        }\n        if (remaining === 1) {\n            items.push(\"... 1 more item\");\n        }\n        else if (remaining > 1) {\n            items.push(`... ${remaining} more items`);\n        }\n        return \"[\" + items.join(\", \") + \"]\";\n    }\n    function getCustomFn(object) {\n        const customInspectFn = object[String(exports.nodejsCustomInspectSymbol)];\n        if (typeof customInspectFn === \"function\") {\n            return customInspectFn;\n        }\n        if (typeof object.inspect === \"function\") {\n            return object.inspect;\n        }\n    }\n    function getObjectTag(object) {\n        const tag = Object.prototype.toString\n            .call(object)\n            .replace(/^\\[object /, \"\")\n            .replace(/]$/, \"\");\n        if (tag === \"Object\" && typeof object.constructor === \"function\") {\n            const name = object.constructor.name;\n            if (typeof name === \"string\") {\n                return name;\n            }\n        }\n        return tag;\n    }\n}\nexports[\"default\"] = createInspect;\n//# sourceMappingURL=inspect.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL2dyYXBocWwtaml0L2Rpc3QvZXNtL2luc3BlY3QuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUNBQWlDO0FBQ2pDLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsV0FBVztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsa0JBQWtCLCtCQUErQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFNBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFdBQVc7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sZWRnaXR5LXlpZWxkLWZyb250ZW5kLy4uL25vZGVfbW9kdWxlcy9ncmFwaHFsLWppdC9kaXN0L2VzbS9pbnNwZWN0LmpzPzBjMjEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9ncmFwaHFsL2dyYXBocWwtanMvYmxvYi9tYXN0ZXIvc3JjL2pzdXRpbHMvaW5zcGVjdC5qc1xuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLm5vZGVqc0N1c3RvbUluc3BlY3RTeW1ib2wgPSB2b2lkIDA7XG5leHBvcnRzLm5vZGVqc0N1c3RvbUluc3BlY3RTeW1ib2wgPSBTeW1ib2wuZm9yKFwibm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b21cIik7XG5mdW5jdGlvbiBjcmVhdGVJbnNwZWN0KG1heEFycmF5TGVuZ3RoID0gMTAsIG1heFJlY3Vyc2l2ZURlcHRoID0gMikge1xuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gcHJpbnQgdmFsdWVzIGluIGVycm9yIG1lc3NhZ2VzLlxuICAgICAqL1xuICAgIHJldHVybiBmdW5jdGlvbiBpbnNwZWN0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBmb3JtYXRWYWx1ZSh2YWx1ZSwgW10pO1xuICAgIH07XG4gICAgZnVuY3Rpb24gZm9ybWF0VmFsdWUodmFsdWUsIHNlZW5WYWx1ZXMpIHtcbiAgICAgICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgICAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLm5hbWUgPyBgW2Z1bmN0aW9uICR7dmFsdWUubmFtZX1dYCA6IFwiW2Z1bmN0aW9uXVwiO1xuICAgICAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBmb3JtYXRPYmplY3RWYWx1ZSh2YWx1ZSwgc2VlblZhbHVlcyk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBTdHJpbmcodmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZvcm1hdE9iamVjdFZhbHVlKHZhbHVlLCBwcmV2aW91c2x5U2VlblZhbHVlcykge1xuICAgICAgICBpZiAocHJldmlvdXNseVNlZW5WYWx1ZXMuaW5kZXhPZih2YWx1ZSkgIT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJbQ2lyY3VsYXJdXCI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VlblZhbHVlcyA9IFsuLi5wcmV2aW91c2x5U2VlblZhbHVlcywgdmFsdWVdO1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGN1c3RvbUluc3BlY3RGbiA9IGdldEN1c3RvbUZuKHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChjdXN0b21JbnNwZWN0Rm4pIHtcbiAgICAgICAgICAgICAgICAvLyAkRmxvd0ZpeE1lKD49MC45MC4wKVxuICAgICAgICAgICAgICAgIGNvbnN0IGN1c3RvbVZhbHVlID0gY3VzdG9tSW5zcGVjdEZuLmNhbGwodmFsdWUpO1xuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGZvciBpbmZpbml0ZSByZWN1cnNpb25cbiAgICAgICAgICAgICAgICBpZiAoY3VzdG9tVmFsdWUgIT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2YgY3VzdG9tVmFsdWUgPT09IFwic3RyaW5nXCJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gY3VzdG9tVmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIDogZm9ybWF0VmFsdWUoY3VzdG9tVmFsdWUsIHNlZW5WYWx1ZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvcm1hdEFycmF5KHZhbHVlLCBzZWVuVmFsdWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmb3JtYXRPYmplY3QodmFsdWUsIHNlZW5WYWx1ZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTdHJpbmcodmFsdWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmb3JtYXRPYmplY3Qob2JqZWN0LCBzZWVuVmFsdWVzKSB7XG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuICAgICAgICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBcInt9XCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlZW5WYWx1ZXMubGVuZ3RoID4gbWF4UmVjdXJzaXZlRGVwdGgpIHtcbiAgICAgICAgICAgIHJldHVybiBcIltcIiArIGdldE9iamVjdFRhZyhvYmplY3QpICsgXCJdXCI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJvcGVydGllcyA9IGtleXMubWFwKChrZXkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZm9ybWF0VmFsdWUob2JqZWN0W2tleV0sIHNlZW5WYWx1ZXMpO1xuICAgICAgICAgICAgcmV0dXJuIGtleSArIFwiOiBcIiArIHZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFwieyBcIiArIHByb3BlcnRpZXMuam9pbihcIiwgXCIpICsgXCIgfVwiO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmb3JtYXRBcnJheShhcnJheSwgc2VlblZhbHVlcykge1xuICAgICAgICBpZiAoYXJyYXkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJbXVwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWVuVmFsdWVzLmxlbmd0aCA+IG1heFJlY3Vyc2l2ZURlcHRoKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJbQXJyYXldXCI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGVuID0gTWF0aC5taW4obWF4QXJyYXlMZW5ndGgsIGFycmF5Lmxlbmd0aCk7XG4gICAgICAgIGNvbnN0IHJlbWFpbmluZyA9IGFycmF5Lmxlbmd0aCAtIGxlbjtcbiAgICAgICAgY29uc3QgaXRlbXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgaXRlbXMucHVzaChmb3JtYXRWYWx1ZShhcnJheVtpXSwgc2VlblZhbHVlcykpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZW1haW5pbmcgPT09IDEpIHtcbiAgICAgICAgICAgIGl0ZW1zLnB1c2goXCIuLi4gMSBtb3JlIGl0ZW1cIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVtYWluaW5nID4gMSkge1xuICAgICAgICAgICAgaXRlbXMucHVzaChgLi4uICR7cmVtYWluaW5nfSBtb3JlIGl0ZW1zYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwiW1wiICsgaXRlbXMuam9pbihcIiwgXCIpICsgXCJdXCI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldEN1c3RvbUZuKG9iamVjdCkge1xuICAgICAgICBjb25zdCBjdXN0b21JbnNwZWN0Rm4gPSBvYmplY3RbU3RyaW5nKGV4cG9ydHMubm9kZWpzQ3VzdG9tSW5zcGVjdFN5bWJvbCldO1xuICAgICAgICBpZiAodHlwZW9mIGN1c3RvbUluc3BlY3RGbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gY3VzdG9tSW5zcGVjdEZuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0Lmluc3BlY3QgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIG9iamVjdC5pbnNwZWN0O1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldE9iamVjdFRhZyhvYmplY3QpIHtcbiAgICAgICAgY29uc3QgdGFnID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ1xuICAgICAgICAgICAgLmNhbGwob2JqZWN0KVxuICAgICAgICAgICAgLnJlcGxhY2UoL15cXFtvYmplY3QgLywgXCJcIilcbiAgICAgICAgICAgIC5yZXBsYWNlKC9dJC8sIFwiXCIpO1xuICAgICAgICBpZiAodGFnID09PSBcIk9iamVjdFwiICYmIHR5cGVvZiBvYmplY3QuY29uc3RydWN0b3IgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IG9iamVjdC5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhZztcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBjcmVhdGVJbnNwZWN0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5zcGVjdC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/graphql-jit/dist/esm/inspect.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/graphql-jit/dist/esm/json.js":
/*!****************************************************!*\
  !*** ../node_modules/graphql-jit/dist/esm/json.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.queryToJSONSchema = void 0;\n/**\n * Mapping between GQL primitive types and JSON Schema property types\n *\n * @type       {<type>}\n */\nconst graphql_1 = __webpack_require__(/*! graphql */ \"(ssr)/../node_modules/graphql/index.mjs\");\nconst ast_1 = __webpack_require__(/*! ./ast */ \"(ssr)/../node_modules/graphql-jit/dist/esm/ast.js\");\nconst compat_1 = __webpack_require__(/*! ./compat */ \"(ssr)/../node_modules/graphql-jit/dist/esm/compat.js\");\nconst PRIMITIVES = {\n    Int: \"integer\",\n    Float: \"number\",\n    String: \"string\",\n    Boolean: \"boolean\",\n    ID: \"string\"\n};\n/**\n * GQL -> JSON Schema transform\n *\n * @param compilationContext\n * @return     {object}  A plain JavaScript object which conforms to JSON Schema\n */\nfunction queryToJSONSchema(compilationContext) {\n    const type = (0, compat_1.getOperationRootType)(compilationContext.schema, compilationContext.operation);\n    const fields = (0, ast_1.collectFields)(compilationContext, type, compilationContext.operation.selectionSet, Object.create(null), Object.create(null));\n    const fieldProperties = Object.create(null);\n    for (const responseName of Object.keys(fields)) {\n        const fieldType = (0, ast_1.resolveFieldDef)(compilationContext, type, fields[responseName]);\n        if (!fieldType) {\n            // if field does not exist, it should be ignored for compatibility concerns.\n            // Usually, validation would stop it before getting here but this could be an old query\n            continue;\n        }\n        fieldProperties[responseName] = transformNode(compilationContext, fields[responseName], fieldType.type);\n    }\n    return {\n        type: \"object\",\n        properties: {\n            data: {\n                type: \"object\",\n                properties: fieldProperties,\n                nullable: true\n            },\n            errors: {\n                type: \"array\",\n                items: {\n                    type: \"object\",\n                    additionalProperties: true,\n                    properties: {\n                        message: {\n                            type: \"string\"\n                        },\n                        path: {\n                            type: \"array\",\n                            items: {\n                                type: [\"string\", \"number\"]\n                            }\n                        },\n                        locations: {\n                            type: \"array\",\n                            items: {\n                                type: \"object\",\n                                properties: {\n                                    line: {\n                                        type: \"number\"\n                                    },\n                                    column: {\n                                        type: \"number\"\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    };\n}\nexports.queryToJSONSchema = queryToJSONSchema;\nfunction transformNode(compilationContext, fieldNodes, type) {\n    if ((0, graphql_1.isObjectType)(type)) {\n        const subfields = (0, ast_1.collectSubfields)(compilationContext, type, fieldNodes);\n        const properties = Object.create(null);\n        for (const responseName of Object.keys(subfields)) {\n            const fieldType = (0, ast_1.resolveFieldDef)(compilationContext, type, subfields[responseName]);\n            if (!fieldType) {\n                // if field does not exist, it should be ignored for compatibility concerns.\n                // Usually, validation would stop it before getting here but this could be an old query\n                continue;\n            }\n            properties[responseName] = transformNode(compilationContext, subfields[responseName], fieldType.type);\n        }\n        return {\n            type: \"object\",\n            properties,\n            nullable: true\n        };\n    }\n    if ((0, graphql_1.isListType)(type)) {\n        return {\n            type: \"array\",\n            items: transformNode(compilationContext, fieldNodes, type.ofType),\n            nullable: true\n        };\n    }\n    if ((0, graphql_1.isNonNullType)(type)) {\n        const nullable = transformNode(compilationContext, fieldNodes, type.ofType);\n        nullable.nullable = false;\n        return nullable;\n    }\n    if ((0, graphql_1.isEnumType)(type)) {\n        return {\n            type: \"string\",\n            nullable: true\n        };\n    }\n    if ((0, graphql_1.isScalarType)(type)) {\n        const jsonSchemaType = PRIMITIVES[type.name];\n        if (!jsonSchemaType) {\n            throw new Error(`Got unexpected PRIMITIVES type: ${type.name}`);\n        }\n        return {\n            type: jsonSchemaType,\n            nullable: true\n        };\n    }\n    if ((0, graphql_1.isAbstractType)(type)) {\n        return compilationContext.schema.getPossibleTypes(type).reduce((res, t) => {\n            const jsonSchema = transformNode(compilationContext, fieldNodes, t);\n            res.properties = {\n                ...res.properties,\n                ...jsonSchema.properties\n            };\n            return res;\n        }, {\n            type: \"object\",\n            properties: {},\n            nullable: true\n        });\n    }\n    throw new Error(`Got unhandled type: ${type.name}`);\n}\n//# sourceMappingURL=json.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL2dyYXBocWwtaml0L2Rpc3QvZXNtL2pzb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLGtCQUFrQixtQkFBTyxDQUFDLHdEQUFTO0FBQ25DLGNBQWMsbUJBQU8sQ0FBQyxnRUFBTztBQUM3QixpQkFBaUIsbUJBQU8sQ0FBQyxzRUFBVTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsVUFBVTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0EsU0FBUztBQUNUO0FBQ0EsMkNBQTJDLFVBQVU7QUFDckQ7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xlZGdpdHkteWllbGQtZnJvbnRlbmQvLi4vbm9kZV9tb2R1bGVzL2dyYXBocWwtaml0L2Rpc3QvZXNtL2pzb24uanM/MjVjYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucXVlcnlUb0pTT05TY2hlbWEgPSB2b2lkIDA7XG4vKipcbiAqIE1hcHBpbmcgYmV0d2VlbiBHUUwgcHJpbWl0aXZlIHR5cGVzIGFuZCBKU09OIFNjaGVtYSBwcm9wZXJ0eSB0eXBlc1xuICpcbiAqIEB0eXBlICAgICAgIHs8dHlwZT59XG4gKi9cbmNvbnN0IGdyYXBocWxfMSA9IHJlcXVpcmUoXCJncmFwaHFsXCIpO1xuY29uc3QgYXN0XzEgPSByZXF1aXJlKFwiLi9hc3RcIik7XG5jb25zdCBjb21wYXRfMSA9IHJlcXVpcmUoXCIuL2NvbXBhdFwiKTtcbmNvbnN0IFBSSU1JVElWRVMgPSB7XG4gICAgSW50OiBcImludGVnZXJcIixcbiAgICBGbG9hdDogXCJudW1iZXJcIixcbiAgICBTdHJpbmc6IFwic3RyaW5nXCIsXG4gICAgQm9vbGVhbjogXCJib29sZWFuXCIsXG4gICAgSUQ6IFwic3RyaW5nXCJcbn07XG4vKipcbiAqIEdRTCAtPiBKU09OIFNjaGVtYSB0cmFuc2Zvcm1cbiAqXG4gKiBAcGFyYW0gY29tcGlsYXRpb25Db250ZXh0XG4gKiBAcmV0dXJuICAgICB7b2JqZWN0fSAgQSBwbGFpbiBKYXZhU2NyaXB0IG9iamVjdCB3aGljaCBjb25mb3JtcyB0byBKU09OIFNjaGVtYVxuICovXG5mdW5jdGlvbiBxdWVyeVRvSlNPTlNjaGVtYShjb21waWxhdGlvbkNvbnRleHQpIHtcbiAgICBjb25zdCB0eXBlID0gKDAsIGNvbXBhdF8xLmdldE9wZXJhdGlvblJvb3RUeXBlKShjb21waWxhdGlvbkNvbnRleHQuc2NoZW1hLCBjb21waWxhdGlvbkNvbnRleHQub3BlcmF0aW9uKTtcbiAgICBjb25zdCBmaWVsZHMgPSAoMCwgYXN0XzEuY29sbGVjdEZpZWxkcykoY29tcGlsYXRpb25Db250ZXh0LCB0eXBlLCBjb21waWxhdGlvbkNvbnRleHQub3BlcmF0aW9uLnNlbGVjdGlvblNldCwgT2JqZWN0LmNyZWF0ZShudWxsKSwgT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gICAgY29uc3QgZmllbGRQcm9wZXJ0aWVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBmb3IgKGNvbnN0IHJlc3BvbnNlTmFtZSBvZiBPYmplY3Qua2V5cyhmaWVsZHMpKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkVHlwZSA9ICgwLCBhc3RfMS5yZXNvbHZlRmllbGREZWYpKGNvbXBpbGF0aW9uQ29udGV4dCwgdHlwZSwgZmllbGRzW3Jlc3BvbnNlTmFtZV0pO1xuICAgICAgICBpZiAoIWZpZWxkVHlwZSkge1xuICAgICAgICAgICAgLy8gaWYgZmllbGQgZG9lcyBub3QgZXhpc3QsIGl0IHNob3VsZCBiZSBpZ25vcmVkIGZvciBjb21wYXRpYmlsaXR5IGNvbmNlcm5zLlxuICAgICAgICAgICAgLy8gVXN1YWxseSwgdmFsaWRhdGlvbiB3b3VsZCBzdG9wIGl0IGJlZm9yZSBnZXR0aW5nIGhlcmUgYnV0IHRoaXMgY291bGQgYmUgYW4gb2xkIHF1ZXJ5XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBmaWVsZFByb3BlcnRpZXNbcmVzcG9uc2VOYW1lXSA9IHRyYW5zZm9ybU5vZGUoY29tcGlsYXRpb25Db250ZXh0LCBmaWVsZHNbcmVzcG9uc2VOYW1lXSwgZmllbGRUeXBlLnR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBmaWVsZFByb3BlcnRpZXMsXG4gICAgICAgICAgICAgICAgbnVsbGFibGU6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlcnJvcnM6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgICAgICAgaXRlbXM6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgICAgICAgICAgICAgYWRkaXRpb25hbFByb3BlcnRpZXM6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBbXCJzdHJpbmdcIiwgXCJudW1iZXJcIl1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYXRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIm51bWJlclwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJudW1iZXJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbn1cbmV4cG9ydHMucXVlcnlUb0pTT05TY2hlbWEgPSBxdWVyeVRvSlNPTlNjaGVtYTtcbmZ1bmN0aW9uIHRyYW5zZm9ybU5vZGUoY29tcGlsYXRpb25Db250ZXh0LCBmaWVsZE5vZGVzLCB0eXBlKSB7XG4gICAgaWYgKCgwLCBncmFwaHFsXzEuaXNPYmplY3RUeXBlKSh0eXBlKSkge1xuICAgICAgICBjb25zdCBzdWJmaWVsZHMgPSAoMCwgYXN0XzEuY29sbGVjdFN1YmZpZWxkcykoY29tcGlsYXRpb25Db250ZXh0LCB0eXBlLCBmaWVsZE5vZGVzKTtcbiAgICAgICAgY29uc3QgcHJvcGVydGllcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGZvciAoY29uc3QgcmVzcG9uc2VOYW1lIG9mIE9iamVjdC5rZXlzKHN1YmZpZWxkcykpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkVHlwZSA9ICgwLCBhc3RfMS5yZXNvbHZlRmllbGREZWYpKGNvbXBpbGF0aW9uQ29udGV4dCwgdHlwZSwgc3ViZmllbGRzW3Jlc3BvbnNlTmFtZV0pO1xuICAgICAgICAgICAgaWYgKCFmaWVsZFR5cGUpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiBmaWVsZCBkb2VzIG5vdCBleGlzdCwgaXQgc2hvdWxkIGJlIGlnbm9yZWQgZm9yIGNvbXBhdGliaWxpdHkgY29uY2VybnMuXG4gICAgICAgICAgICAgICAgLy8gVXN1YWxseSwgdmFsaWRhdGlvbiB3b3VsZCBzdG9wIGl0IGJlZm9yZSBnZXR0aW5nIGhlcmUgYnV0IHRoaXMgY291bGQgYmUgYW4gb2xkIHF1ZXJ5XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcm9wZXJ0aWVzW3Jlc3BvbnNlTmFtZV0gPSB0cmFuc2Zvcm1Ob2RlKGNvbXBpbGF0aW9uQ29udGV4dCwgc3ViZmllbGRzW3Jlc3BvbnNlTmFtZV0sIGZpZWxkVHlwZS50eXBlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgICAgIHByb3BlcnRpZXMsXG4gICAgICAgICAgICBudWxsYWJsZTogdHJ1ZVxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAoKDAsIGdyYXBocWxfMS5pc0xpc3RUeXBlKSh0eXBlKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgICAgICAgaXRlbXM6IHRyYW5zZm9ybU5vZGUoY29tcGlsYXRpb25Db250ZXh0LCBmaWVsZE5vZGVzLCB0eXBlLm9mVHlwZSksXG4gICAgICAgICAgICBudWxsYWJsZTogdHJ1ZVxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAoKDAsIGdyYXBocWxfMS5pc05vbk51bGxUeXBlKSh0eXBlKSkge1xuICAgICAgICBjb25zdCBudWxsYWJsZSA9IHRyYW5zZm9ybU5vZGUoY29tcGlsYXRpb25Db250ZXh0LCBmaWVsZE5vZGVzLCB0eXBlLm9mVHlwZSk7XG4gICAgICAgIG51bGxhYmxlLm51bGxhYmxlID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBudWxsYWJsZTtcbiAgICB9XG4gICAgaWYgKCgwLCBncmFwaHFsXzEuaXNFbnVtVHlwZSkodHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICBudWxsYWJsZTogdHJ1ZVxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAoKDAsIGdyYXBocWxfMS5pc1NjYWxhclR5cGUpKHR5cGUpKSB7XG4gICAgICAgIGNvbnN0IGpzb25TY2hlbWFUeXBlID0gUFJJTUlUSVZFU1t0eXBlLm5hbWVdO1xuICAgICAgICBpZiAoIWpzb25TY2hlbWFUeXBlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEdvdCB1bmV4cGVjdGVkIFBSSU1JVElWRVMgdHlwZTogJHt0eXBlLm5hbWV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IGpzb25TY2hlbWFUeXBlLFxuICAgICAgICAgICAgbnVsbGFibGU6IHRydWVcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKCgwLCBncmFwaHFsXzEuaXNBYnN0cmFjdFR5cGUpKHR5cGUpKSB7XG4gICAgICAgIHJldHVybiBjb21waWxhdGlvbkNvbnRleHQuc2NoZW1hLmdldFBvc3NpYmxlVHlwZXModHlwZSkucmVkdWNlKChyZXMsIHQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGpzb25TY2hlbWEgPSB0cmFuc2Zvcm1Ob2RlKGNvbXBpbGF0aW9uQ29udGV4dCwgZmllbGROb2RlcywgdCk7XG4gICAgICAgICAgICByZXMucHJvcGVydGllcyA9IHtcbiAgICAgICAgICAgICAgICAuLi5yZXMucHJvcGVydGllcyxcbiAgICAgICAgICAgICAgICAuLi5qc29uU2NoZW1hLnByb3BlcnRpZXNcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgICAgICAgcHJvcGVydGllczoge30sXG4gICAgICAgICAgICBudWxsYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBHb3QgdW5oYW5kbGVkIHR5cGU6ICR7dHlwZS5uYW1lfWApO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9anNvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/graphql-jit/dist/esm/json.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/graphql-jit/dist/esm/memoize.js":
/*!*******************************************************!*\
  !*** ../node_modules/graphql-jit/dist/esm/memoize.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.memoize4 = exports.memoize3 = exports.memoize2 = void 0;\nconst lodash_memoize_1 = __importDefault(__webpack_require__(/*! lodash.memoize */ \"(ssr)/../node_modules/lodash.memoize/index.js\"));\nfunction uncurry2(fn) {\n    return (a, b) => fn(a)(b);\n}\nfunction uncurry3(fn) {\n    return (a, b, c) => fn(a)(b)(c);\n}\nfunction uncurry4(fn) {\n    return (a, b, c, d) => fn(a)(b)(c)(d);\n}\nfunction memoize2(fn) {\n    return uncurry2((0, lodash_memoize_1.default)((a) => (0, lodash_memoize_1.default)((b) => fn(a, b))));\n}\nexports.memoize2 = memoize2;\nfunction memoize3(fn) {\n    return uncurry3((0, lodash_memoize_1.default)((a) => (0, lodash_memoize_1.default)((b) => (0, lodash_memoize_1.default)((c) => fn(a, b, c)))));\n}\nexports.memoize3 = memoize3;\nfunction memoize4(fn) {\n    return uncurry4((0, lodash_memoize_1.default)((a) => (0, lodash_memoize_1.default)((b) => (0, lodash_memoize_1.default)((c) => (0, lodash_memoize_1.default)((d) => fn(a, b, c, d))))));\n}\nexports.memoize4 = memoize4;\n//# sourceMappingURL=memoize.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL2dyYXBocWwtaml0L2Rpc3QvZXNtL21lbW9pemUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQkFBZ0IsR0FBRyxnQkFBZ0IsR0FBRyxnQkFBZ0I7QUFDdEQseUNBQXlDLG1CQUFPLENBQUMscUVBQWdCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGVkZ2l0eS15aWVsZC1mcm9udGVuZC8uLi9ub2RlX21vZHVsZXMvZ3JhcGhxbC1qaXQvZGlzdC9lc20vbWVtb2l6ZS5qcz8xMjA5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5tZW1vaXplNCA9IGV4cG9ydHMubWVtb2l6ZTMgPSBleHBvcnRzLm1lbW9pemUyID0gdm9pZCAwO1xuY29uc3QgbG9kYXNoX21lbW9pemVfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibG9kYXNoLm1lbW9pemVcIikpO1xuZnVuY3Rpb24gdW5jdXJyeTIoZm4pIHtcbiAgICByZXR1cm4gKGEsIGIpID0+IGZuKGEpKGIpO1xufVxuZnVuY3Rpb24gdW5jdXJyeTMoZm4pIHtcbiAgICByZXR1cm4gKGEsIGIsIGMpID0+IGZuKGEpKGIpKGMpO1xufVxuZnVuY3Rpb24gdW5jdXJyeTQoZm4pIHtcbiAgICByZXR1cm4gKGEsIGIsIGMsIGQpID0+IGZuKGEpKGIpKGMpKGQpO1xufVxuZnVuY3Rpb24gbWVtb2l6ZTIoZm4pIHtcbiAgICByZXR1cm4gdW5jdXJyeTIoKDAsIGxvZGFzaF9tZW1vaXplXzEuZGVmYXVsdCkoKGEpID0+ICgwLCBsb2Rhc2hfbWVtb2l6ZV8xLmRlZmF1bHQpKChiKSA9PiBmbihhLCBiKSkpKTtcbn1cbmV4cG9ydHMubWVtb2l6ZTIgPSBtZW1vaXplMjtcbmZ1bmN0aW9uIG1lbW9pemUzKGZuKSB7XG4gICAgcmV0dXJuIHVuY3VycnkzKCgwLCBsb2Rhc2hfbWVtb2l6ZV8xLmRlZmF1bHQpKChhKSA9PiAoMCwgbG9kYXNoX21lbW9pemVfMS5kZWZhdWx0KSgoYikgPT4gKDAsIGxvZGFzaF9tZW1vaXplXzEuZGVmYXVsdCkoKGMpID0+IGZuKGEsIGIsIGMpKSkpKTtcbn1cbmV4cG9ydHMubWVtb2l6ZTMgPSBtZW1vaXplMztcbmZ1bmN0aW9uIG1lbW9pemU0KGZuKSB7XG4gICAgcmV0dXJuIHVuY3Vycnk0KCgwLCBsb2Rhc2hfbWVtb2l6ZV8xLmRlZmF1bHQpKChhKSA9PiAoMCwgbG9kYXNoX21lbW9pemVfMS5kZWZhdWx0KSgoYikgPT4gKDAsIGxvZGFzaF9tZW1vaXplXzEuZGVmYXVsdCkoKGMpID0+ICgwLCBsb2Rhc2hfbWVtb2l6ZV8xLmRlZmF1bHQpKChkKSA9PiBmbihhLCBiLCBjLCBkKSkpKSkpO1xufVxuZXhwb3J0cy5tZW1vaXplNCA9IG1lbW9pemU0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWVtb2l6ZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/graphql-jit/dist/esm/memoize.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/graphql-jit/dist/esm/non-null.js":
/*!********************************************************!*\
  !*** ../node_modules/graphql-jit/dist/esm/non-null.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createNullTrimmer = void 0;\nconst graphql_1 = __webpack_require__(/*! graphql */ \"(ssr)/../node_modules/graphql/index.mjs\");\nconst type_1 = __webpack_require__(/*! graphql/type */ \"(ssr)/../node_modules/graphql/type/index.js\");\nconst lodash_merge_1 = __importDefault(__webpack_require__(/*! lodash.merge */ \"(ssr)/../node_modules/lodash.merge/index.js\"));\nconst ast_1 = __webpack_require__(/*! ./ast */ \"(ssr)/../node_modules/graphql-jit/dist/esm/ast.js\");\nconst compat_1 = __webpack_require__(/*! ./compat */ \"(ssr)/../node_modules/graphql-jit/dist/esm/compat.js\");\n/**\n *\n * @param {CompilationContext} compilationContext\n * @returns {(data: any, errors: GraphQLError[]) => {data: any; errors: GraphQLError[]}}\n */\nfunction createNullTrimmer(compilationContext) {\n    return trimData(parseQueryNullables(compilationContext));\n}\nexports.createNullTrimmer = createNullTrimmer;\n/**\n * Trims a data response according to the field errors in non null fields.\n *\n * Errors are filtered to ensure a single field error per field.\n *\n * @param {QueryMetadata} nullable Description of the query and their nullability\n * @returns {(data: any, errors: GraphQLError[]) => {data: any; errors: GraphQLError[]}}\n * the trimmed data and a filtered list of errors.\n */\nfunction trimData(nullable) {\n    return (data, errors) => {\n        const finalErrors = [];\n        const processedErrors = new Set();\n        for (const error of errors) {\n            if (!error.path) {\n                // should never happen, it is a bug if it does\n                throw new Error(\"no path available for tree trimming\");\n            }\n            if (processedErrors.has(error.path.join(\".\"))) {\n                // there can be multiple field errors in some scenario\n                // there is no need to continue processing and it should not be part of the final response\n                continue;\n            }\n            const ancestors = findNullableAncestor(nullable, error.path);\n            // The top level field is always nullable\n            // http://facebook.github.io/graphql/June2018/#sec-Errors-and-Non-Nullability\n            //\n            // There is no mention if the following errors need to be present in the response.\n            // For now we assume this is not needed.\n            if (ancestors.length === 0) {\n                data = null;\n                finalErrors.push(error);\n                break;\n            }\n            removeBranch(data, ancestors);\n            processedErrors.add(error.path.join(\".\"));\n            finalErrors.push(error);\n        }\n        return { data, errors: finalErrors };\n    };\n}\n/**\n * Removes a branch out of the response data by mutating the original object.\n *\n * @param tree response data\n * @param {Array<number | string>} branch array with the path that should be trimmed\n */\nfunction removeBranch(tree, branch) {\n    for (let i = 0; i < branch.length - 1; ++i) {\n        // if ancestor has already been removed, there's nothing to do\n        if (tree[branch[i]] === null) {\n            return;\n        }\n        tree = tree[branch[i]];\n    }\n    const toNull = branch[branch.length - 1];\n    tree[toNull] = null;\n}\n/**\n * Name of the child used in array to contain the description.\n *\n * Only used for list to contain the child description.\n */\nconst ARRAY_CHILD_NAME = \"index\";\n/**\n *\n * @param {QueryMetadata} nullable Description of the query and their nullability\n * @param {ReadonlyArray<string | number>} paths path of the error location\n * @returns {Array<string | number>} path of the branch to be made null\n */\nfunction findNullableAncestor(nullable, paths) {\n    let lastNullable = 0;\n    for (let i = 0; i < paths.length; ++i) {\n        const path = paths[i];\n        const child = nullable.children[typeof path === \"string\" ? path : ARRAY_CHILD_NAME];\n        if (!child) {\n            // Stopping the search since we reached a leaf node,\n            // the loop should be on its final iteration\n            break;\n        }\n        if (child.isNullable) {\n            lastNullable = i + 1;\n        }\n        nullable = child;\n    }\n    return paths.slice(0, lastNullable);\n}\n/**\n * Produce a description of the query regarding its nullability.\n *\n * Leaf nodes are not present in this representation since they are not\n * interesting for removing branches of the response tree.\n *\n * The structure is recursive like the query.\n * @param {CompilationContext} compilationContext Execution content\n * @returns {QueryMetadata} description of the query\n */\nfunction parseQueryNullables(compilationContext) {\n    const type = (0, compat_1.getOperationRootType)(compilationContext.schema, compilationContext.operation);\n    const fields = (0, ast_1.collectFields)(compilationContext, type, compilationContext.operation.selectionSet, Object.create(null), Object.create(null));\n    const properties = Object.create(null);\n    for (const responseName of Object.keys(fields)) {\n        const fieldType = (0, ast_1.resolveFieldDef)(compilationContext, type, fields[responseName]);\n        if (!fieldType) {\n            // if field does not exist, it should be ignored for compatibility concerns.\n            // Usually, validation would stop it before getting here but this could be an old query\n            continue;\n        }\n        const property = transformNode(compilationContext, fields[responseName], fieldType.type);\n        if (property != null) {\n            properties[responseName] = property;\n        }\n    }\n    return {\n        isNullable: true,\n        children: properties\n    };\n}\n/**\n * Processes a single node to produce a description of itself and its children.\n *\n * Leaf nodes are ignore and removed from the description\n * @param {CompilationContext} compilationContext\n * @param {FieldNode[]} fieldNodes list of fields\n * @param {GraphQLType} type Current type being processed.\n * @returns {QueryMetadata | null} null if node is a leaf, otherwise a description of the node and its children.\n */\nfunction transformNode(compilationContext, fieldNodes, type) {\n    if ((0, graphql_1.isNonNullType)(type)) {\n        const nullable = transformNode(compilationContext, fieldNodes, type.ofType);\n        if (nullable != null) {\n            nullable.isNullable = false;\n            return nullable;\n        }\n        return null;\n    }\n    if ((0, graphql_1.isObjectType)(type)) {\n        const subfields = (0, ast_1.collectSubfields)(compilationContext, type, fieldNodes);\n        const properties = Object.create(null);\n        for (const responseName of Object.keys(subfields)) {\n            const fieldType = (0, ast_1.resolveFieldDef)(compilationContext, type, subfields[responseName]);\n            if (!fieldType) {\n                // if field does not exist, it should be ignored for compatibility concerns.\n                // Usually, validation would stop it before getting here but this could be an old query\n                continue;\n            }\n            const property = transformNode(compilationContext, subfields[responseName], fieldType.type);\n            if (property != null) {\n                properties[responseName] = property;\n            }\n        }\n        return {\n            isNullable: true,\n            children: properties\n        };\n    }\n    if ((0, graphql_1.isListType)(type)) {\n        const child = transformNode(compilationContext, fieldNodes, type.ofType);\n        if (child != null) {\n            return {\n                isNullable: true,\n                children: { [ARRAY_CHILD_NAME]: child }\n            };\n        }\n        return {\n            isNullable: true,\n            children: {}\n        };\n    }\n    if ((0, type_1.isAbstractType)(type)) {\n        return compilationContext.schema.getPossibleTypes(type).reduce((res, t) => {\n            const property = transformNode(compilationContext, fieldNodes, t);\n            if (property != null) {\n                // We do a deep merge because children can have subset of properties\n                // TODO: Possible bug: two object with different nullability on objects.\n                res.children = (0, lodash_merge_1.default)(res.children, property.children);\n            }\n            return res;\n        }, {\n            isNullable: true,\n            children: {}\n        });\n    }\n    // Scalars and enum are ignored since they are leaf values\n    return null;\n}\n//# sourceMappingURL=non-null.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL2dyYXBocWwtaml0L2Rpc3QvZXNtL25vbi1udWxsLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QseUJBQXlCO0FBQ3pCLGtCQUFrQixtQkFBTyxDQUFDLHdEQUFTO0FBQ25DLGVBQWUsbUJBQU8sQ0FBQyxpRUFBYztBQUNyQyx1Q0FBdUMsbUJBQU8sQ0FBQyxpRUFBYztBQUM3RCxjQUFjLG1CQUFPLENBQUMsZ0VBQU87QUFDN0IsaUJBQWlCLG1CQUFPLENBQUMsc0VBQVU7QUFDbkM7QUFDQTtBQUNBLFdBQVcsb0JBQW9CO0FBQy9CLGFBQWEsd0NBQXdDLFdBQVc7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixhQUFhLHdDQUF3QyxXQUFXO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsd0JBQXdCO0FBQ25DO0FBQ0E7QUFDQSxvQkFBb0IsdUJBQXVCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsV0FBVyxnQ0FBZ0M7QUFDM0MsYUFBYSx3QkFBd0I7QUFDckM7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG9CQUFvQjtBQUMvQixhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsb0JBQW9CO0FBQy9CLFdBQVcsYUFBYTtBQUN4QixXQUFXLGFBQWE7QUFDeEIsYUFBYSxzQkFBc0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sZWRnaXR5LXlpZWxkLWZyb250ZW5kLy4uL25vZGVfbW9kdWxlcy9ncmFwaHFsLWppdC9kaXN0L2VzbS9ub24tbnVsbC5qcz8xZGI4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jcmVhdGVOdWxsVHJpbW1lciA9IHZvaWQgMDtcbmNvbnN0IGdyYXBocWxfMSA9IHJlcXVpcmUoXCJncmFwaHFsXCIpO1xuY29uc3QgdHlwZV8xID0gcmVxdWlyZShcImdyYXBocWwvdHlwZVwiKTtcbmNvbnN0IGxvZGFzaF9tZXJnZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gubWVyZ2VcIikpO1xuY29uc3QgYXN0XzEgPSByZXF1aXJlKFwiLi9hc3RcIik7XG5jb25zdCBjb21wYXRfMSA9IHJlcXVpcmUoXCIuL2NvbXBhdFwiKTtcbi8qKlxuICpcbiAqIEBwYXJhbSB7Q29tcGlsYXRpb25Db250ZXh0fSBjb21waWxhdGlvbkNvbnRleHRcbiAqIEByZXR1cm5zIHsoZGF0YTogYW55LCBlcnJvcnM6IEdyYXBoUUxFcnJvcltdKSA9PiB7ZGF0YTogYW55OyBlcnJvcnM6IEdyYXBoUUxFcnJvcltdfX1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlTnVsbFRyaW1tZXIoY29tcGlsYXRpb25Db250ZXh0KSB7XG4gICAgcmV0dXJuIHRyaW1EYXRhKHBhcnNlUXVlcnlOdWxsYWJsZXMoY29tcGlsYXRpb25Db250ZXh0KSk7XG59XG5leHBvcnRzLmNyZWF0ZU51bGxUcmltbWVyID0gY3JlYXRlTnVsbFRyaW1tZXI7XG4vKipcbiAqIFRyaW1zIGEgZGF0YSByZXNwb25zZSBhY2NvcmRpbmcgdG8gdGhlIGZpZWxkIGVycm9ycyBpbiBub24gbnVsbCBmaWVsZHMuXG4gKlxuICogRXJyb3JzIGFyZSBmaWx0ZXJlZCB0byBlbnN1cmUgYSBzaW5nbGUgZmllbGQgZXJyb3IgcGVyIGZpZWxkLlxuICpcbiAqIEBwYXJhbSB7UXVlcnlNZXRhZGF0YX0gbnVsbGFibGUgRGVzY3JpcHRpb24gb2YgdGhlIHF1ZXJ5IGFuZCB0aGVpciBudWxsYWJpbGl0eVxuICogQHJldHVybnMgeyhkYXRhOiBhbnksIGVycm9yczogR3JhcGhRTEVycm9yW10pID0+IHtkYXRhOiBhbnk7IGVycm9yczogR3JhcGhRTEVycm9yW119fVxuICogdGhlIHRyaW1tZWQgZGF0YSBhbmQgYSBmaWx0ZXJlZCBsaXN0IG9mIGVycm9ycy5cbiAqL1xuZnVuY3Rpb24gdHJpbURhdGEobnVsbGFibGUpIHtcbiAgICByZXR1cm4gKGRhdGEsIGVycm9ycykgPT4ge1xuICAgICAgICBjb25zdCBmaW5hbEVycm9ycyA9IFtdO1xuICAgICAgICBjb25zdCBwcm9jZXNzZWRFcnJvcnMgPSBuZXcgU2V0KCk7XG4gICAgICAgIGZvciAoY29uc3QgZXJyb3Igb2YgZXJyb3JzKSB7XG4gICAgICAgICAgICBpZiAoIWVycm9yLnBhdGgpIHtcbiAgICAgICAgICAgICAgICAvLyBzaG91bGQgbmV2ZXIgaGFwcGVuLCBpdCBpcyBhIGJ1ZyBpZiBpdCBkb2VzXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm8gcGF0aCBhdmFpbGFibGUgZm9yIHRyZWUgdHJpbW1pbmdcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJvY2Vzc2VkRXJyb3JzLmhhcyhlcnJvci5wYXRoLmpvaW4oXCIuXCIpKSkge1xuICAgICAgICAgICAgICAgIC8vIHRoZXJlIGNhbiBiZSBtdWx0aXBsZSBmaWVsZCBlcnJvcnMgaW4gc29tZSBzY2VuYXJpb1xuICAgICAgICAgICAgICAgIC8vIHRoZXJlIGlzIG5vIG5lZWQgdG8gY29udGludWUgcHJvY2Vzc2luZyBhbmQgaXQgc2hvdWxkIG5vdCBiZSBwYXJ0IG9mIHRoZSBmaW5hbCByZXNwb25zZVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYW5jZXN0b3JzID0gZmluZE51bGxhYmxlQW5jZXN0b3IobnVsbGFibGUsIGVycm9yLnBhdGgpO1xuICAgICAgICAgICAgLy8gVGhlIHRvcCBsZXZlbCBmaWVsZCBpcyBhbHdheXMgbnVsbGFibGVcbiAgICAgICAgICAgIC8vIGh0dHA6Ly9mYWNlYm9vay5naXRodWIuaW8vZ3JhcGhxbC9KdW5lMjAxOC8jc2VjLUVycm9ycy1hbmQtTm9uLU51bGxhYmlsaXR5XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gVGhlcmUgaXMgbm8gbWVudGlvbiBpZiB0aGUgZm9sbG93aW5nIGVycm9ycyBuZWVkIHRvIGJlIHByZXNlbnQgaW4gdGhlIHJlc3BvbnNlLlxuICAgICAgICAgICAgLy8gRm9yIG5vdyB3ZSBhc3N1bWUgdGhpcyBpcyBub3QgbmVlZGVkLlxuICAgICAgICAgICAgaWYgKGFuY2VzdG9ycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gbnVsbDtcbiAgICAgICAgICAgICAgICBmaW5hbEVycm9ycy5wdXNoKGVycm9yKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlbW92ZUJyYW5jaChkYXRhLCBhbmNlc3RvcnMpO1xuICAgICAgICAgICAgcHJvY2Vzc2VkRXJyb3JzLmFkZChlcnJvci5wYXRoLmpvaW4oXCIuXCIpKTtcbiAgICAgICAgICAgIGZpbmFsRXJyb3JzLnB1c2goZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGRhdGEsIGVycm9yczogZmluYWxFcnJvcnMgfTtcbiAgICB9O1xufVxuLyoqXG4gKiBSZW1vdmVzIGEgYnJhbmNoIG91dCBvZiB0aGUgcmVzcG9uc2UgZGF0YSBieSBtdXRhdGluZyB0aGUgb3JpZ2luYWwgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB0cmVlIHJlc3BvbnNlIGRhdGFcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyIHwgc3RyaW5nPn0gYnJhbmNoIGFycmF5IHdpdGggdGhlIHBhdGggdGhhdCBzaG91bGQgYmUgdHJpbW1lZFxuICovXG5mdW5jdGlvbiByZW1vdmVCcmFuY2godHJlZSwgYnJhbmNoKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBicmFuY2gubGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgICAgIC8vIGlmIGFuY2VzdG9yIGhhcyBhbHJlYWR5IGJlZW4gcmVtb3ZlZCwgdGhlcmUncyBub3RoaW5nIHRvIGRvXG4gICAgICAgIGlmICh0cmVlW2JyYW5jaFtpXV0gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0cmVlID0gdHJlZVticmFuY2hbaV1dO1xuICAgIH1cbiAgICBjb25zdCB0b051bGwgPSBicmFuY2hbYnJhbmNoLmxlbmd0aCAtIDFdO1xuICAgIHRyZWVbdG9OdWxsXSA9IG51bGw7XG59XG4vKipcbiAqIE5hbWUgb2YgdGhlIGNoaWxkIHVzZWQgaW4gYXJyYXkgdG8gY29udGFpbiB0aGUgZGVzY3JpcHRpb24uXG4gKlxuICogT25seSB1c2VkIGZvciBsaXN0IHRvIGNvbnRhaW4gdGhlIGNoaWxkIGRlc2NyaXB0aW9uLlxuICovXG5jb25zdCBBUlJBWV9DSElMRF9OQU1FID0gXCJpbmRleFwiO1xuLyoqXG4gKlxuICogQHBhcmFtIHtRdWVyeU1ldGFkYXRhfSBudWxsYWJsZSBEZXNjcmlwdGlvbiBvZiB0aGUgcXVlcnkgYW5kIHRoZWlyIG51bGxhYmlsaXR5XG4gKiBAcGFyYW0ge1JlYWRvbmx5QXJyYXk8c3RyaW5nIHwgbnVtYmVyPn0gcGF0aHMgcGF0aCBvZiB0aGUgZXJyb3IgbG9jYXRpb25cbiAqIEByZXR1cm5zIHtBcnJheTxzdHJpbmcgfCBudW1iZXI+fSBwYXRoIG9mIHRoZSBicmFuY2ggdG8gYmUgbWFkZSBudWxsXG4gKi9cbmZ1bmN0aW9uIGZpbmROdWxsYWJsZUFuY2VzdG9yKG51bGxhYmxlLCBwYXRocykge1xuICAgIGxldCBsYXN0TnVsbGFibGUgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgcGF0aCA9IHBhdGhzW2ldO1xuICAgICAgICBjb25zdCBjaGlsZCA9IG51bGxhYmxlLmNoaWxkcmVuW3R5cGVvZiBwYXRoID09PSBcInN0cmluZ1wiID8gcGF0aCA6IEFSUkFZX0NISUxEX05BTUVdO1xuICAgICAgICBpZiAoIWNoaWxkKSB7XG4gICAgICAgICAgICAvLyBTdG9wcGluZyB0aGUgc2VhcmNoIHNpbmNlIHdlIHJlYWNoZWQgYSBsZWFmIG5vZGUsXG4gICAgICAgICAgICAvLyB0aGUgbG9vcCBzaG91bGQgYmUgb24gaXRzIGZpbmFsIGl0ZXJhdGlvblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoaWxkLmlzTnVsbGFibGUpIHtcbiAgICAgICAgICAgIGxhc3ROdWxsYWJsZSA9IGkgKyAxO1xuICAgICAgICB9XG4gICAgICAgIG51bGxhYmxlID0gY2hpbGQ7XG4gICAgfVxuICAgIHJldHVybiBwYXRocy5zbGljZSgwLCBsYXN0TnVsbGFibGUpO1xufVxuLyoqXG4gKiBQcm9kdWNlIGEgZGVzY3JpcHRpb24gb2YgdGhlIHF1ZXJ5IHJlZ2FyZGluZyBpdHMgbnVsbGFiaWxpdHkuXG4gKlxuICogTGVhZiBub2RlcyBhcmUgbm90IHByZXNlbnQgaW4gdGhpcyByZXByZXNlbnRhdGlvbiBzaW5jZSB0aGV5IGFyZSBub3RcbiAqIGludGVyZXN0aW5nIGZvciByZW1vdmluZyBicmFuY2hlcyBvZiB0aGUgcmVzcG9uc2UgdHJlZS5cbiAqXG4gKiBUaGUgc3RydWN0dXJlIGlzIHJlY3Vyc2l2ZSBsaWtlIHRoZSBxdWVyeS5cbiAqIEBwYXJhbSB7Q29tcGlsYXRpb25Db250ZXh0fSBjb21waWxhdGlvbkNvbnRleHQgRXhlY3V0aW9uIGNvbnRlbnRcbiAqIEByZXR1cm5zIHtRdWVyeU1ldGFkYXRhfSBkZXNjcmlwdGlvbiBvZiB0aGUgcXVlcnlcbiAqL1xuZnVuY3Rpb24gcGFyc2VRdWVyeU51bGxhYmxlcyhjb21waWxhdGlvbkNvbnRleHQpIHtcbiAgICBjb25zdCB0eXBlID0gKDAsIGNvbXBhdF8xLmdldE9wZXJhdGlvblJvb3RUeXBlKShjb21waWxhdGlvbkNvbnRleHQuc2NoZW1hLCBjb21waWxhdGlvbkNvbnRleHQub3BlcmF0aW9uKTtcbiAgICBjb25zdCBmaWVsZHMgPSAoMCwgYXN0XzEuY29sbGVjdEZpZWxkcykoY29tcGlsYXRpb25Db250ZXh0LCB0eXBlLCBjb21waWxhdGlvbkNvbnRleHQub3BlcmF0aW9uLnNlbGVjdGlvblNldCwgT2JqZWN0LmNyZWF0ZShudWxsKSwgT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gICAgY29uc3QgcHJvcGVydGllcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgZm9yIChjb25zdCByZXNwb25zZU5hbWUgb2YgT2JqZWN0LmtleXMoZmllbGRzKSkge1xuICAgICAgICBjb25zdCBmaWVsZFR5cGUgPSAoMCwgYXN0XzEucmVzb2x2ZUZpZWxkRGVmKShjb21waWxhdGlvbkNvbnRleHQsIHR5cGUsIGZpZWxkc1tyZXNwb25zZU5hbWVdKTtcbiAgICAgICAgaWYgKCFmaWVsZFR5cGUpIHtcbiAgICAgICAgICAgIC8vIGlmIGZpZWxkIGRvZXMgbm90IGV4aXN0LCBpdCBzaG91bGQgYmUgaWdub3JlZCBmb3IgY29tcGF0aWJpbGl0eSBjb25jZXJucy5cbiAgICAgICAgICAgIC8vIFVzdWFsbHksIHZhbGlkYXRpb24gd291bGQgc3RvcCBpdCBiZWZvcmUgZ2V0dGluZyBoZXJlIGJ1dCB0aGlzIGNvdWxkIGJlIGFuIG9sZCBxdWVyeVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJvcGVydHkgPSB0cmFuc2Zvcm1Ob2RlKGNvbXBpbGF0aW9uQ29udGV4dCwgZmllbGRzW3Jlc3BvbnNlTmFtZV0sIGZpZWxkVHlwZS50eXBlKTtcbiAgICAgICAgaWYgKHByb3BlcnR5ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHByb3BlcnRpZXNbcmVzcG9uc2VOYW1lXSA9IHByb3BlcnR5O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGlzTnVsbGFibGU6IHRydWUsXG4gICAgICAgIGNoaWxkcmVuOiBwcm9wZXJ0aWVzXG4gICAgfTtcbn1cbi8qKlxuICogUHJvY2Vzc2VzIGEgc2luZ2xlIG5vZGUgdG8gcHJvZHVjZSBhIGRlc2NyaXB0aW9uIG9mIGl0c2VsZiBhbmQgaXRzIGNoaWxkcmVuLlxuICpcbiAqIExlYWYgbm9kZXMgYXJlIGlnbm9yZSBhbmQgcmVtb3ZlZCBmcm9tIHRoZSBkZXNjcmlwdGlvblxuICogQHBhcmFtIHtDb21waWxhdGlvbkNvbnRleHR9IGNvbXBpbGF0aW9uQ29udGV4dFxuICogQHBhcmFtIHtGaWVsZE5vZGVbXX0gZmllbGROb2RlcyBsaXN0IG9mIGZpZWxkc1xuICogQHBhcmFtIHtHcmFwaFFMVHlwZX0gdHlwZSBDdXJyZW50IHR5cGUgYmVpbmcgcHJvY2Vzc2VkLlxuICogQHJldHVybnMge1F1ZXJ5TWV0YWRhdGEgfCBudWxsfSBudWxsIGlmIG5vZGUgaXMgYSBsZWFmLCBvdGhlcndpc2UgYSBkZXNjcmlwdGlvbiBvZiB0aGUgbm9kZSBhbmQgaXRzIGNoaWxkcmVuLlxuICovXG5mdW5jdGlvbiB0cmFuc2Zvcm1Ob2RlKGNvbXBpbGF0aW9uQ29udGV4dCwgZmllbGROb2RlcywgdHlwZSkge1xuICAgIGlmICgoMCwgZ3JhcGhxbF8xLmlzTm9uTnVsbFR5cGUpKHR5cGUpKSB7XG4gICAgICAgIGNvbnN0IG51bGxhYmxlID0gdHJhbnNmb3JtTm9kZShjb21waWxhdGlvbkNvbnRleHQsIGZpZWxkTm9kZXMsIHR5cGUub2ZUeXBlKTtcbiAgICAgICAgaWYgKG51bGxhYmxlICE9IG51bGwpIHtcbiAgICAgICAgICAgIG51bGxhYmxlLmlzTnVsbGFibGUgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiBudWxsYWJsZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKCgwLCBncmFwaHFsXzEuaXNPYmplY3RUeXBlKSh0eXBlKSkge1xuICAgICAgICBjb25zdCBzdWJmaWVsZHMgPSAoMCwgYXN0XzEuY29sbGVjdFN1YmZpZWxkcykoY29tcGlsYXRpb25Db250ZXh0LCB0eXBlLCBmaWVsZE5vZGVzKTtcbiAgICAgICAgY29uc3QgcHJvcGVydGllcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGZvciAoY29uc3QgcmVzcG9uc2VOYW1lIG9mIE9iamVjdC5rZXlzKHN1YmZpZWxkcykpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkVHlwZSA9ICgwLCBhc3RfMS5yZXNvbHZlRmllbGREZWYpKGNvbXBpbGF0aW9uQ29udGV4dCwgdHlwZSwgc3ViZmllbGRzW3Jlc3BvbnNlTmFtZV0pO1xuICAgICAgICAgICAgaWYgKCFmaWVsZFR5cGUpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiBmaWVsZCBkb2VzIG5vdCBleGlzdCwgaXQgc2hvdWxkIGJlIGlnbm9yZWQgZm9yIGNvbXBhdGliaWxpdHkgY29uY2VybnMuXG4gICAgICAgICAgICAgICAgLy8gVXN1YWxseSwgdmFsaWRhdGlvbiB3b3VsZCBzdG9wIGl0IGJlZm9yZSBnZXR0aW5nIGhlcmUgYnV0IHRoaXMgY291bGQgYmUgYW4gb2xkIHF1ZXJ5XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwcm9wZXJ0eSA9IHRyYW5zZm9ybU5vZGUoY29tcGlsYXRpb25Db250ZXh0LCBzdWJmaWVsZHNbcmVzcG9uc2VOYW1lXSwgZmllbGRUeXBlLnR5cGUpO1xuICAgICAgICAgICAgaWYgKHByb3BlcnR5ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzW3Jlc3BvbnNlTmFtZV0gPSBwcm9wZXJ0eTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaXNOdWxsYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNoaWxkcmVuOiBwcm9wZXJ0aWVzXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmICgoMCwgZ3JhcGhxbF8xLmlzTGlzdFR5cGUpKHR5cGUpKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkID0gdHJhbnNmb3JtTm9kZShjb21waWxhdGlvbkNvbnRleHQsIGZpZWxkTm9kZXMsIHR5cGUub2ZUeXBlKTtcbiAgICAgICAgaWYgKGNoaWxkICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaXNOdWxsYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogeyBbQVJSQVlfQ0hJTERfTkFNRV06IGNoaWxkIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlzTnVsbGFibGU6IHRydWUsXG4gICAgICAgICAgICBjaGlsZHJlbjoge31cbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKCgwLCB0eXBlXzEuaXNBYnN0cmFjdFR5cGUpKHR5cGUpKSB7XG4gICAgICAgIHJldHVybiBjb21waWxhdGlvbkNvbnRleHQuc2NoZW1hLmdldFBvc3NpYmxlVHlwZXModHlwZSkucmVkdWNlKChyZXMsIHQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHByb3BlcnR5ID0gdHJhbnNmb3JtTm9kZShjb21waWxhdGlvbkNvbnRleHQsIGZpZWxkTm9kZXMsIHQpO1xuICAgICAgICAgICAgaWYgKHByb3BlcnR5ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBkbyBhIGRlZXAgbWVyZ2UgYmVjYXVzZSBjaGlsZHJlbiBjYW4gaGF2ZSBzdWJzZXQgb2YgcHJvcGVydGllc1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IFBvc3NpYmxlIGJ1ZzogdHdvIG9iamVjdCB3aXRoIGRpZmZlcmVudCBudWxsYWJpbGl0eSBvbiBvYmplY3RzLlxuICAgICAgICAgICAgICAgIHJlcy5jaGlsZHJlbiA9ICgwLCBsb2Rhc2hfbWVyZ2VfMS5kZWZhdWx0KShyZXMuY2hpbGRyZW4sIHByb3BlcnR5LmNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIGlzTnVsbGFibGU6IHRydWUsXG4gICAgICAgICAgICBjaGlsZHJlbjoge31cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIFNjYWxhcnMgYW5kIGVudW0gYXJlIGlnbm9yZWQgc2luY2UgdGhleSBhcmUgbGVhZiB2YWx1ZXNcbiAgICByZXR1cm4gbnVsbDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5vbi1udWxsLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/graphql-jit/dist/esm/non-null.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/graphql-jit/dist/esm/resolve-info.js":
/*!************************************************************!*\
  !*** ../node_modules/graphql-jit/dist/esm/resolve-info.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.fieldExpansionEnricher = exports.createResolveInfoThunk = exports.isLeafField = void 0;\nconst generate_function_1 = __importDefault(__webpack_require__(/*! generate-function */ \"(ssr)/../node_modules/generate-function/index.js\"));\nconst graphql_1 = __webpack_require__(/*! graphql */ \"(ssr)/../node_modules/graphql/index.mjs\");\nconst lodash_memoize_1 = __importDefault(__webpack_require__(/*! lodash.memoize */ \"(ssr)/../node_modules/lodash.memoize/index.js\"));\nconst lodash_mergewith_1 = __importDefault(__webpack_require__(/*! lodash.mergewith */ \"(ssr)/../node_modules/lodash.mergewith/index.js\"));\nconst memoize_1 = __webpack_require__(/*! ./memoize */ \"(ssr)/../node_modules/graphql-jit/dist/esm/memoize.js\");\nconst LeafFieldSymbol = Symbol(\"LeafFieldSymbol\");\nfunction createLeafField(props) {\n    return {\n        [LeafFieldSymbol]: true,\n        ...props\n    };\n}\nfunction isLeafField(obj) {\n    return (obj != null && Object.prototype.hasOwnProperty.call(obj, LeafFieldSymbol));\n}\nexports.isLeafField = isLeafField;\n/**\n * Compute the GraphQLJitResolveInfo's `fieldExpansion` and return a function\n * that returns the computed resolveInfo. This thunk is registered in\n * context.dependencies for the field's resolveInfoName\n */\nfunction createResolveInfoThunk({ schema, fragments, operation, parentType, fieldName, fieldType, fieldNodes }, enricher) {\n    let enrichedInfo = {};\n    if (typeof enricher === \"function\") {\n        enrichedInfo =\n            enricher({\n                fieldName,\n                fieldNodes,\n                returnType: fieldType,\n                parentType,\n                schema,\n                fragments,\n                operation\n            }) || {};\n        if (typeof enrichedInfo !== \"object\" || Array.isArray(enrichedInfo)) {\n            enrichedInfo = {};\n        }\n    }\n    const gen = (0, generate_function_1.default)();\n    gen(`return function getGraphQLResolveInfo(rootValue, variableValues, path) {\n      return {\n          fieldName,\n          fieldNodes,\n          returnType: fieldType,\n          parentType,\n          path,\n          schema,\n          fragments,\n          rootValue,\n          operation,\n          variableValues,`);\n    Object.keys(enrichedInfo).forEach((key) => {\n        gen(`${key}: enrichedInfo[\"${key}\"],\\n`);\n    });\n    gen(`};};`);\n    // eslint-disable-next-line\n    return new Function(\"fieldName\", \"fieldNodes\", \"fieldType\", \"parentType\", \"schema\", \"fragments\", \"operation\", \"enrichedInfo\", gen.toString()).call(null, fieldName, fieldNodes, fieldType, parentType, schema, fragments, operation, enrichedInfo);\n}\nexports.createResolveInfoThunk = createResolveInfoThunk;\nfunction fieldExpansionEnricher(input) {\n    const { schema, fragments, returnType, fieldNodes } = input;\n    const fieldExpansion = {};\n    for (const fieldNode of fieldNodes) {\n        deepMerge(fieldExpansion, memoizedExpandFieldNode(schema, fragments, fieldNode, returnType));\n    }\n    return {\n        fieldExpansion\n    };\n}\nexports.fieldExpansionEnricher = fieldExpansionEnricher;\nconst MEMOIZATION = true;\nconst memoizedGetReturnType = MEMOIZATION\n    ? (0, memoize_1.memoize2)(getReturnType)\n    : getReturnType;\nconst memoizedHasField = MEMOIZATION ? (0, memoize_1.memoize2)(hasField) : hasField;\nconst memoizedResolveEndType = MEMOIZATION\n    ? (0, lodash_memoize_1.default)(resolveEndType)\n    : resolveEndType;\nconst memoizedGetPossibleTypes = MEMOIZATION\n    ? (0, memoize_1.memoize2)(getPossibleTypes)\n    : getPossibleTypes;\nconst memoizedExpandFieldNodeType = MEMOIZATION\n    ? (0, memoize_1.memoize4)(expandFieldNodeType)\n    : expandFieldNodeType;\nconst memoizedExpandFieldNode = MEMOIZATION\n    ? (0, memoize_1.memoize4)(expandFieldNode)\n    : expandFieldNode;\nfunction expandFieldNode(schema, fragments, node, fieldType) {\n    if (node.selectionSet == null) {\n        return createLeafField({});\n    }\n    // there is a selectionSet which makes the fieldType a CompositeType\n    const typ = memoizedResolveEndType(fieldType);\n    const possibleTypes = memoizedGetPossibleTypes(schema, typ);\n    const fieldExpansion = {};\n    for (const possibleType of possibleTypes) {\n        if (!(0, graphql_1.isUnionType)(possibleType)) {\n            fieldExpansion[possibleType.name] = memoizedExpandFieldNodeType(schema, fragments, possibleType, node.selectionSet);\n        }\n    }\n    return fieldExpansion;\n}\nfunction expandFieldNodeType(schema, fragments, parentType, selectionSet) {\n    const typeExpansion = {};\n    for (const selection of selectionSet.selections) {\n        if (selection.kind === graphql_1.Kind.FIELD) {\n            if (!(0, graphql_1.isUnionType)(parentType) &&\n                memoizedHasField(parentType, selection.name.value)) {\n                typeExpansion[selection.name.value] = memoizedExpandFieldNode(schema, fragments, selection, memoizedGetReturnType(parentType, selection.name.value));\n            }\n        }\n        else {\n            const selectionSet = selection.kind === graphql_1.Kind.INLINE_FRAGMENT\n                ? selection.selectionSet\n                : fragments[selection.name.value].selectionSet;\n            const nextType = selection.kind === graphql_1.Kind.INLINE_FRAGMENT\n                ? selection.typeCondition\n                    ? schema.getType(selection.typeCondition.name.value)\n                    : parentType\n                : schema.getType(fragments[selection.name.value].typeCondition.name.value);\n            /**\n             * nextType (comes from query) is the type extracted from the fragment\n             * parentType (comes from schema) is the possibleType for which we are filling fields\n             *\n             * if the type from query (nextType) is the same as the type we are filling (parentType)\n             * or\n             * if the type from query (nextType) is an abstract type - this case is when we jump\n             * to a super type or sub type. Here we maintain the context (parentType) for which\n             * we are filling the fields. The super type / sub type will be filled in its own\n             * pass.\n             */\n            if (nextType === parentType || (0, graphql_1.isAbstractType)(nextType)) {\n                deepMerge(typeExpansion, memoizedExpandFieldNodeType(schema, fragments, parentType, selectionSet));\n            }\n        }\n    }\n    return typeExpansion;\n}\n/**\n * Returns a list of Possible types that one can get to from the\n * resolvedType. As an analogy, these are the same types that one\n * can use in a fragment's typeCondition.\n *\n * Note: This is different from schema.getPossibleTypes() that this\n * returns all possible types and not just the ones from the type definition.\n *\n * Example:\n * interface Node {\n *   id: ID!\n * }\n * type User implements Node {\n *   id: ID!\n *   name: String\n * }\n * type Article implements Node {\n *   id: ID!\n *   title: String\n * }\n * union Card = User | Article\n *\n * - schema.getPossibleTypes(Card) would give [User, Article]\n * - This function getPossibleTypes(schema, Card) would give [User, Article, Node]\n *\n */\nfunction getPossibleTypes(schema, compositeType) {\n    if ((0, graphql_1.isObjectType)(compositeType)) {\n        return [compositeType];\n    }\n    const possibleTypes = [];\n    const types = schema.getTypeMap();\n    for (const typeName in types) {\n        if (Object.prototype.hasOwnProperty.call(types, typeName)) {\n            const typ = types[typeName];\n            if ((0, graphql_1.isCompositeType)(typ) && (0, graphql_1.doTypesOverlap)(schema, typ, compositeType)) {\n                possibleTypes.push(typ);\n            }\n        }\n    }\n    return possibleTypes;\n}\n/**\n * Given an (Object|Interface)Type, and a fieldName, find the\n * appropriate `end` return type for the field in the Composite Type.\n *\n * Note: The `end` return type is the type by unwrapping non-null types\n * and list types. Check `resolveEndType`\n */\nfunction getReturnType(parentType, fieldName) {\n    const fields = parentType.getFields();\n    if (!Object.prototype.hasOwnProperty.call(fields, fieldName)) {\n        throw new graphql_1.GraphQLError(`Field \"${fieldName}\" does not exist in \"${parentType.name}\"`);\n    }\n    const outputType = fields[fieldName].type;\n    return memoizedResolveEndType(outputType);\n}\n/**\n * Resolve to the end type of the Output type unwrapping non-null types and lists\n */\nfunction resolveEndType(typ) {\n    if ((0, graphql_1.isListType)(typ) || (0, graphql_1.isNonNullType)(typ)) {\n        return memoizedResolveEndType(typ.ofType);\n    }\n    return typ;\n}\nfunction hasField(typ, fieldName) {\n    return Object.prototype.hasOwnProperty.call(typ.getFields(), fieldName);\n}\n// This is because lodash does not support merging keys\n// which are symbols. We require them for leaf fields\nfunction deepMerge(obj, src) {\n    (0, lodash_mergewith_1.default)(obj, src, (objValue, srcValue) => {\n        if (isLeafField(objValue)) {\n            if (isLeafField(srcValue)) {\n                return {\n                    ...objValue,\n                    ...srcValue\n                };\n            }\n            return objValue;\n        }\n        else if (isLeafField(srcValue)) {\n            return srcValue;\n        }\n        return undefined;\n    });\n}\n//# sourceMappingURL=resolve-info.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL2dyYXBocWwtaml0L2Rpc3QvZXNtL3Jlc29sdmUtaW5mby5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDhCQUE4QixHQUFHLDhCQUE4QixHQUFHLG1CQUFtQjtBQUNyRiw0Q0FBNEMsbUJBQU8sQ0FBQywyRUFBbUI7QUFDdkUsa0JBQWtCLG1CQUFPLENBQUMsd0RBQVM7QUFDbkMseUNBQXlDLG1CQUFPLENBQUMscUVBQWdCO0FBQ2pFLDJDQUEyQyxtQkFBTyxDQUFDLHlFQUFrQjtBQUNyRSxrQkFBa0IsbUJBQU8sQ0FBQyx3RUFBVztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLDRFQUE0RTtBQUM5RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsSUFBSSxrQkFBa0IsSUFBSTtBQUN6QyxLQUFLO0FBQ0wsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBLFlBQVksNENBQTRDO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsVUFBVSx1QkFBdUIsZ0JBQWdCO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGVkZ2l0eS15aWVsZC1mcm9udGVuZC8uLi9ub2RlX21vZHVsZXMvZ3JhcGhxbC1qaXQvZGlzdC9lc20vcmVzb2x2ZS1pbmZvLmpzPzY2MWQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmZpZWxkRXhwYW5zaW9uRW5yaWNoZXIgPSBleHBvcnRzLmNyZWF0ZVJlc29sdmVJbmZvVGh1bmsgPSBleHBvcnRzLmlzTGVhZkZpZWxkID0gdm9pZCAwO1xuY29uc3QgZ2VuZXJhdGVfZnVuY3Rpb25fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZ2VuZXJhdGUtZnVuY3Rpb25cIikpO1xuY29uc3QgZ3JhcGhxbF8xID0gcmVxdWlyZShcImdyYXBocWxcIik7XG5jb25zdCBsb2Rhc2hfbWVtb2l6ZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gubWVtb2l6ZVwiKSk7XG5jb25zdCBsb2Rhc2hfbWVyZ2V3aXRoXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImxvZGFzaC5tZXJnZXdpdGhcIikpO1xuY29uc3QgbWVtb2l6ZV8xID0gcmVxdWlyZShcIi4vbWVtb2l6ZVwiKTtcbmNvbnN0IExlYWZGaWVsZFN5bWJvbCA9IFN5bWJvbChcIkxlYWZGaWVsZFN5bWJvbFwiKTtcbmZ1bmN0aW9uIGNyZWF0ZUxlYWZGaWVsZChwcm9wcykge1xuICAgIHJldHVybiB7XG4gICAgICAgIFtMZWFmRmllbGRTeW1ib2xdOiB0cnVlLFxuICAgICAgICAuLi5wcm9wc1xuICAgIH07XG59XG5mdW5jdGlvbiBpc0xlYWZGaWVsZChvYmopIHtcbiAgICByZXR1cm4gKG9iaiAhPSBudWxsICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIExlYWZGaWVsZFN5bWJvbCkpO1xufVxuZXhwb3J0cy5pc0xlYWZGaWVsZCA9IGlzTGVhZkZpZWxkO1xuLyoqXG4gKiBDb21wdXRlIHRoZSBHcmFwaFFMSml0UmVzb2x2ZUluZm8ncyBgZmllbGRFeHBhbnNpb25gIGFuZCByZXR1cm4gYSBmdW5jdGlvblxuICogdGhhdCByZXR1cm5zIHRoZSBjb21wdXRlZCByZXNvbHZlSW5mby4gVGhpcyB0aHVuayBpcyByZWdpc3RlcmVkIGluXG4gKiBjb250ZXh0LmRlcGVuZGVuY2llcyBmb3IgdGhlIGZpZWxkJ3MgcmVzb2x2ZUluZm9OYW1lXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVJlc29sdmVJbmZvVGh1bmsoeyBzY2hlbWEsIGZyYWdtZW50cywgb3BlcmF0aW9uLCBwYXJlbnRUeXBlLCBmaWVsZE5hbWUsIGZpZWxkVHlwZSwgZmllbGROb2RlcyB9LCBlbnJpY2hlcikge1xuICAgIGxldCBlbnJpY2hlZEluZm8gPSB7fTtcbiAgICBpZiAodHlwZW9mIGVucmljaGVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgZW5yaWNoZWRJbmZvID1cbiAgICAgICAgICAgIGVucmljaGVyKHtcbiAgICAgICAgICAgICAgICBmaWVsZE5hbWUsXG4gICAgICAgICAgICAgICAgZmllbGROb2RlcyxcbiAgICAgICAgICAgICAgICByZXR1cm5UeXBlOiBmaWVsZFR5cGUsXG4gICAgICAgICAgICAgICAgcGFyZW50VHlwZSxcbiAgICAgICAgICAgICAgICBzY2hlbWEsXG4gICAgICAgICAgICAgICAgZnJhZ21lbnRzLFxuICAgICAgICAgICAgICAgIG9wZXJhdGlvblxuICAgICAgICAgICAgfSkgfHwge307XG4gICAgICAgIGlmICh0eXBlb2YgZW5yaWNoZWRJbmZvICE9PSBcIm9iamVjdFwiIHx8IEFycmF5LmlzQXJyYXkoZW5yaWNoZWRJbmZvKSkge1xuICAgICAgICAgICAgZW5yaWNoZWRJbmZvID0ge307XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZ2VuID0gKDAsIGdlbmVyYXRlX2Z1bmN0aW9uXzEuZGVmYXVsdCkoKTtcbiAgICBnZW4oYHJldHVybiBmdW5jdGlvbiBnZXRHcmFwaFFMUmVzb2x2ZUluZm8ocm9vdFZhbHVlLCB2YXJpYWJsZVZhbHVlcywgcGF0aCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBmaWVsZE5hbWUsXG4gICAgICAgICAgZmllbGROb2RlcyxcbiAgICAgICAgICByZXR1cm5UeXBlOiBmaWVsZFR5cGUsXG4gICAgICAgICAgcGFyZW50VHlwZSxcbiAgICAgICAgICBwYXRoLFxuICAgICAgICAgIHNjaGVtYSxcbiAgICAgICAgICBmcmFnbWVudHMsXG4gICAgICAgICAgcm9vdFZhbHVlLFxuICAgICAgICAgIG9wZXJhdGlvbixcbiAgICAgICAgICB2YXJpYWJsZVZhbHVlcyxgKTtcbiAgICBPYmplY3Qua2V5cyhlbnJpY2hlZEluZm8pLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICBnZW4oYCR7a2V5fTogZW5yaWNoZWRJbmZvW1wiJHtrZXl9XCJdLFxcbmApO1xuICAgIH0pO1xuICAgIGdlbihgfTt9O2ApO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgIHJldHVybiBuZXcgRnVuY3Rpb24oXCJmaWVsZE5hbWVcIiwgXCJmaWVsZE5vZGVzXCIsIFwiZmllbGRUeXBlXCIsIFwicGFyZW50VHlwZVwiLCBcInNjaGVtYVwiLCBcImZyYWdtZW50c1wiLCBcIm9wZXJhdGlvblwiLCBcImVucmljaGVkSW5mb1wiLCBnZW4udG9TdHJpbmcoKSkuY2FsbChudWxsLCBmaWVsZE5hbWUsIGZpZWxkTm9kZXMsIGZpZWxkVHlwZSwgcGFyZW50VHlwZSwgc2NoZW1hLCBmcmFnbWVudHMsIG9wZXJhdGlvbiwgZW5yaWNoZWRJbmZvKTtcbn1cbmV4cG9ydHMuY3JlYXRlUmVzb2x2ZUluZm9UaHVuayA9IGNyZWF0ZVJlc29sdmVJbmZvVGh1bms7XG5mdW5jdGlvbiBmaWVsZEV4cGFuc2lvbkVucmljaGVyKGlucHV0KSB7XG4gICAgY29uc3QgeyBzY2hlbWEsIGZyYWdtZW50cywgcmV0dXJuVHlwZSwgZmllbGROb2RlcyB9ID0gaW5wdXQ7XG4gICAgY29uc3QgZmllbGRFeHBhbnNpb24gPSB7fTtcbiAgICBmb3IgKGNvbnN0IGZpZWxkTm9kZSBvZiBmaWVsZE5vZGVzKSB7XG4gICAgICAgIGRlZXBNZXJnZShmaWVsZEV4cGFuc2lvbiwgbWVtb2l6ZWRFeHBhbmRGaWVsZE5vZGUoc2NoZW1hLCBmcmFnbWVudHMsIGZpZWxkTm9kZSwgcmV0dXJuVHlwZSkpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBmaWVsZEV4cGFuc2lvblxuICAgIH07XG59XG5leHBvcnRzLmZpZWxkRXhwYW5zaW9uRW5yaWNoZXIgPSBmaWVsZEV4cGFuc2lvbkVucmljaGVyO1xuY29uc3QgTUVNT0laQVRJT04gPSB0cnVlO1xuY29uc3QgbWVtb2l6ZWRHZXRSZXR1cm5UeXBlID0gTUVNT0laQVRJT05cbiAgICA/ICgwLCBtZW1vaXplXzEubWVtb2l6ZTIpKGdldFJldHVyblR5cGUpXG4gICAgOiBnZXRSZXR1cm5UeXBlO1xuY29uc3QgbWVtb2l6ZWRIYXNGaWVsZCA9IE1FTU9JWkFUSU9OID8gKDAsIG1lbW9pemVfMS5tZW1vaXplMikoaGFzRmllbGQpIDogaGFzRmllbGQ7XG5jb25zdCBtZW1vaXplZFJlc29sdmVFbmRUeXBlID0gTUVNT0laQVRJT05cbiAgICA/ICgwLCBsb2Rhc2hfbWVtb2l6ZV8xLmRlZmF1bHQpKHJlc29sdmVFbmRUeXBlKVxuICAgIDogcmVzb2x2ZUVuZFR5cGU7XG5jb25zdCBtZW1vaXplZEdldFBvc3NpYmxlVHlwZXMgPSBNRU1PSVpBVElPTlxuICAgID8gKDAsIG1lbW9pemVfMS5tZW1vaXplMikoZ2V0UG9zc2libGVUeXBlcylcbiAgICA6IGdldFBvc3NpYmxlVHlwZXM7XG5jb25zdCBtZW1vaXplZEV4cGFuZEZpZWxkTm9kZVR5cGUgPSBNRU1PSVpBVElPTlxuICAgID8gKDAsIG1lbW9pemVfMS5tZW1vaXplNCkoZXhwYW5kRmllbGROb2RlVHlwZSlcbiAgICA6IGV4cGFuZEZpZWxkTm9kZVR5cGU7XG5jb25zdCBtZW1vaXplZEV4cGFuZEZpZWxkTm9kZSA9IE1FTU9JWkFUSU9OXG4gICAgPyAoMCwgbWVtb2l6ZV8xLm1lbW9pemU0KShleHBhbmRGaWVsZE5vZGUpXG4gICAgOiBleHBhbmRGaWVsZE5vZGU7XG5mdW5jdGlvbiBleHBhbmRGaWVsZE5vZGUoc2NoZW1hLCBmcmFnbWVudHMsIG5vZGUsIGZpZWxkVHlwZSkge1xuICAgIGlmIChub2RlLnNlbGVjdGlvblNldCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVMZWFmRmllbGQoe30pO1xuICAgIH1cbiAgICAvLyB0aGVyZSBpcyBhIHNlbGVjdGlvblNldCB3aGljaCBtYWtlcyB0aGUgZmllbGRUeXBlIGEgQ29tcG9zaXRlVHlwZVxuICAgIGNvbnN0IHR5cCA9IG1lbW9pemVkUmVzb2x2ZUVuZFR5cGUoZmllbGRUeXBlKTtcbiAgICBjb25zdCBwb3NzaWJsZVR5cGVzID0gbWVtb2l6ZWRHZXRQb3NzaWJsZVR5cGVzKHNjaGVtYSwgdHlwKTtcbiAgICBjb25zdCBmaWVsZEV4cGFuc2lvbiA9IHt9O1xuICAgIGZvciAoY29uc3QgcG9zc2libGVUeXBlIG9mIHBvc3NpYmxlVHlwZXMpIHtcbiAgICAgICAgaWYgKCEoMCwgZ3JhcGhxbF8xLmlzVW5pb25UeXBlKShwb3NzaWJsZVR5cGUpKSB7XG4gICAgICAgICAgICBmaWVsZEV4cGFuc2lvbltwb3NzaWJsZVR5cGUubmFtZV0gPSBtZW1vaXplZEV4cGFuZEZpZWxkTm9kZVR5cGUoc2NoZW1hLCBmcmFnbWVudHMsIHBvc3NpYmxlVHlwZSwgbm9kZS5zZWxlY3Rpb25TZXQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmaWVsZEV4cGFuc2lvbjtcbn1cbmZ1bmN0aW9uIGV4cGFuZEZpZWxkTm9kZVR5cGUoc2NoZW1hLCBmcmFnbWVudHMsIHBhcmVudFR5cGUsIHNlbGVjdGlvblNldCkge1xuICAgIGNvbnN0IHR5cGVFeHBhbnNpb24gPSB7fTtcbiAgICBmb3IgKGNvbnN0IHNlbGVjdGlvbiBvZiBzZWxlY3Rpb25TZXQuc2VsZWN0aW9ucykge1xuICAgICAgICBpZiAoc2VsZWN0aW9uLmtpbmQgPT09IGdyYXBocWxfMS5LaW5kLkZJRUxEKSB7XG4gICAgICAgICAgICBpZiAoISgwLCBncmFwaHFsXzEuaXNVbmlvblR5cGUpKHBhcmVudFR5cGUpICYmXG4gICAgICAgICAgICAgICAgbWVtb2l6ZWRIYXNGaWVsZChwYXJlbnRUeXBlLCBzZWxlY3Rpb24ubmFtZS52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0eXBlRXhwYW5zaW9uW3NlbGVjdGlvbi5uYW1lLnZhbHVlXSA9IG1lbW9pemVkRXhwYW5kRmllbGROb2RlKHNjaGVtYSwgZnJhZ21lbnRzLCBzZWxlY3Rpb24sIG1lbW9pemVkR2V0UmV0dXJuVHlwZShwYXJlbnRUeXBlLCBzZWxlY3Rpb24ubmFtZS52YWx1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgc2VsZWN0aW9uU2V0ID0gc2VsZWN0aW9uLmtpbmQgPT09IGdyYXBocWxfMS5LaW5kLklOTElORV9GUkFHTUVOVFxuICAgICAgICAgICAgICAgID8gc2VsZWN0aW9uLnNlbGVjdGlvblNldFxuICAgICAgICAgICAgICAgIDogZnJhZ21lbnRzW3NlbGVjdGlvbi5uYW1lLnZhbHVlXS5zZWxlY3Rpb25TZXQ7XG4gICAgICAgICAgICBjb25zdCBuZXh0VHlwZSA9IHNlbGVjdGlvbi5raW5kID09PSBncmFwaHFsXzEuS2luZC5JTkxJTkVfRlJBR01FTlRcbiAgICAgICAgICAgICAgICA/IHNlbGVjdGlvbi50eXBlQ29uZGl0aW9uXG4gICAgICAgICAgICAgICAgICAgID8gc2NoZW1hLmdldFR5cGUoc2VsZWN0aW9uLnR5cGVDb25kaXRpb24ubmFtZS52YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgOiBwYXJlbnRUeXBlXG4gICAgICAgICAgICAgICAgOiBzY2hlbWEuZ2V0VHlwZShmcmFnbWVudHNbc2VsZWN0aW9uLm5hbWUudmFsdWVdLnR5cGVDb25kaXRpb24ubmFtZS52YWx1ZSk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIG5leHRUeXBlIChjb21lcyBmcm9tIHF1ZXJ5KSBpcyB0aGUgdHlwZSBleHRyYWN0ZWQgZnJvbSB0aGUgZnJhZ21lbnRcbiAgICAgICAgICAgICAqIHBhcmVudFR5cGUgKGNvbWVzIGZyb20gc2NoZW1hKSBpcyB0aGUgcG9zc2libGVUeXBlIGZvciB3aGljaCB3ZSBhcmUgZmlsbGluZyBmaWVsZHNcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBpZiB0aGUgdHlwZSBmcm9tIHF1ZXJ5IChuZXh0VHlwZSkgaXMgdGhlIHNhbWUgYXMgdGhlIHR5cGUgd2UgYXJlIGZpbGxpbmcgKHBhcmVudFR5cGUpXG4gICAgICAgICAgICAgKiBvclxuICAgICAgICAgICAgICogaWYgdGhlIHR5cGUgZnJvbSBxdWVyeSAobmV4dFR5cGUpIGlzIGFuIGFic3RyYWN0IHR5cGUgLSB0aGlzIGNhc2UgaXMgd2hlbiB3ZSBqdW1wXG4gICAgICAgICAgICAgKiB0byBhIHN1cGVyIHR5cGUgb3Igc3ViIHR5cGUuIEhlcmUgd2UgbWFpbnRhaW4gdGhlIGNvbnRleHQgKHBhcmVudFR5cGUpIGZvciB3aGljaFxuICAgICAgICAgICAgICogd2UgYXJlIGZpbGxpbmcgdGhlIGZpZWxkcy4gVGhlIHN1cGVyIHR5cGUgLyBzdWIgdHlwZSB3aWxsIGJlIGZpbGxlZCBpbiBpdHMgb3duXG4gICAgICAgICAgICAgKiBwYXNzLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAobmV4dFR5cGUgPT09IHBhcmVudFR5cGUgfHwgKDAsIGdyYXBocWxfMS5pc0Fic3RyYWN0VHlwZSkobmV4dFR5cGUpKSB7XG4gICAgICAgICAgICAgICAgZGVlcE1lcmdlKHR5cGVFeHBhbnNpb24sIG1lbW9pemVkRXhwYW5kRmllbGROb2RlVHlwZShzY2hlbWEsIGZyYWdtZW50cywgcGFyZW50VHlwZSwgc2VsZWN0aW9uU2V0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHR5cGVFeHBhbnNpb247XG59XG4vKipcbiAqIFJldHVybnMgYSBsaXN0IG9mIFBvc3NpYmxlIHR5cGVzIHRoYXQgb25lIGNhbiBnZXQgdG8gZnJvbSB0aGVcbiAqIHJlc29sdmVkVHlwZS4gQXMgYW4gYW5hbG9neSwgdGhlc2UgYXJlIHRoZSBzYW1lIHR5cGVzIHRoYXQgb25lXG4gKiBjYW4gdXNlIGluIGEgZnJhZ21lbnQncyB0eXBlQ29uZGl0aW9uLlxuICpcbiAqIE5vdGU6IFRoaXMgaXMgZGlmZmVyZW50IGZyb20gc2NoZW1hLmdldFBvc3NpYmxlVHlwZXMoKSB0aGF0IHRoaXNcbiAqIHJldHVybnMgYWxsIHBvc3NpYmxlIHR5cGVzIGFuZCBub3QganVzdCB0aGUgb25lcyBmcm9tIHRoZSB0eXBlIGRlZmluaXRpb24uXG4gKlxuICogRXhhbXBsZTpcbiAqIGludGVyZmFjZSBOb2RlIHtcbiAqICAgaWQ6IElEIVxuICogfVxuICogdHlwZSBVc2VyIGltcGxlbWVudHMgTm9kZSB7XG4gKiAgIGlkOiBJRCFcbiAqICAgbmFtZTogU3RyaW5nXG4gKiB9XG4gKiB0eXBlIEFydGljbGUgaW1wbGVtZW50cyBOb2RlIHtcbiAqICAgaWQ6IElEIVxuICogICB0aXRsZTogU3RyaW5nXG4gKiB9XG4gKiB1bmlvbiBDYXJkID0gVXNlciB8IEFydGljbGVcbiAqXG4gKiAtIHNjaGVtYS5nZXRQb3NzaWJsZVR5cGVzKENhcmQpIHdvdWxkIGdpdmUgW1VzZXIsIEFydGljbGVdXG4gKiAtIFRoaXMgZnVuY3Rpb24gZ2V0UG9zc2libGVUeXBlcyhzY2hlbWEsIENhcmQpIHdvdWxkIGdpdmUgW1VzZXIsIEFydGljbGUsIE5vZGVdXG4gKlxuICovXG5mdW5jdGlvbiBnZXRQb3NzaWJsZVR5cGVzKHNjaGVtYSwgY29tcG9zaXRlVHlwZSkge1xuICAgIGlmICgoMCwgZ3JhcGhxbF8xLmlzT2JqZWN0VHlwZSkoY29tcG9zaXRlVHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIFtjb21wb3NpdGVUeXBlXTtcbiAgICB9XG4gICAgY29uc3QgcG9zc2libGVUeXBlcyA9IFtdO1xuICAgIGNvbnN0IHR5cGVzID0gc2NoZW1hLmdldFR5cGVNYXAoKTtcbiAgICBmb3IgKGNvbnN0IHR5cGVOYW1lIGluIHR5cGVzKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodHlwZXMsIHR5cGVOYW1lKSkge1xuICAgICAgICAgICAgY29uc3QgdHlwID0gdHlwZXNbdHlwZU5hbWVdO1xuICAgICAgICAgICAgaWYgKCgwLCBncmFwaHFsXzEuaXNDb21wb3NpdGVUeXBlKSh0eXApICYmICgwLCBncmFwaHFsXzEuZG9UeXBlc092ZXJsYXApKHNjaGVtYSwgdHlwLCBjb21wb3NpdGVUeXBlKSkge1xuICAgICAgICAgICAgICAgIHBvc3NpYmxlVHlwZXMucHVzaCh0eXApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwb3NzaWJsZVR5cGVzO1xufVxuLyoqXG4gKiBHaXZlbiBhbiAoT2JqZWN0fEludGVyZmFjZSlUeXBlLCBhbmQgYSBmaWVsZE5hbWUsIGZpbmQgdGhlXG4gKiBhcHByb3ByaWF0ZSBgZW5kYCByZXR1cm4gdHlwZSBmb3IgdGhlIGZpZWxkIGluIHRoZSBDb21wb3NpdGUgVHlwZS5cbiAqXG4gKiBOb3RlOiBUaGUgYGVuZGAgcmV0dXJuIHR5cGUgaXMgdGhlIHR5cGUgYnkgdW53cmFwcGluZyBub24tbnVsbCB0eXBlc1xuICogYW5kIGxpc3QgdHlwZXMuIENoZWNrIGByZXNvbHZlRW5kVHlwZWBcbiAqL1xuZnVuY3Rpb24gZ2V0UmV0dXJuVHlwZShwYXJlbnRUeXBlLCBmaWVsZE5hbWUpIHtcbiAgICBjb25zdCBmaWVsZHMgPSBwYXJlbnRUeXBlLmdldEZpZWxkcygpO1xuICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGZpZWxkcywgZmllbGROYW1lKSkge1xuICAgICAgICB0aHJvdyBuZXcgZ3JhcGhxbF8xLkdyYXBoUUxFcnJvcihgRmllbGQgXCIke2ZpZWxkTmFtZX1cIiBkb2VzIG5vdCBleGlzdCBpbiBcIiR7cGFyZW50VHlwZS5uYW1lfVwiYCk7XG4gICAgfVxuICAgIGNvbnN0IG91dHB1dFR5cGUgPSBmaWVsZHNbZmllbGROYW1lXS50eXBlO1xuICAgIHJldHVybiBtZW1vaXplZFJlc29sdmVFbmRUeXBlKG91dHB1dFR5cGUpO1xufVxuLyoqXG4gKiBSZXNvbHZlIHRvIHRoZSBlbmQgdHlwZSBvZiB0aGUgT3V0cHV0IHR5cGUgdW53cmFwcGluZyBub24tbnVsbCB0eXBlcyBhbmQgbGlzdHNcbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZUVuZFR5cGUodHlwKSB7XG4gICAgaWYgKCgwLCBncmFwaHFsXzEuaXNMaXN0VHlwZSkodHlwKSB8fCAoMCwgZ3JhcGhxbF8xLmlzTm9uTnVsbFR5cGUpKHR5cCkpIHtcbiAgICAgICAgcmV0dXJuIG1lbW9pemVkUmVzb2x2ZUVuZFR5cGUodHlwLm9mVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0eXA7XG59XG5mdW5jdGlvbiBoYXNGaWVsZCh0eXAsIGZpZWxkTmFtZSkge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodHlwLmdldEZpZWxkcygpLCBmaWVsZE5hbWUpO1xufVxuLy8gVGhpcyBpcyBiZWNhdXNlIGxvZGFzaCBkb2VzIG5vdCBzdXBwb3J0IG1lcmdpbmcga2V5c1xuLy8gd2hpY2ggYXJlIHN5bWJvbHMuIFdlIHJlcXVpcmUgdGhlbSBmb3IgbGVhZiBmaWVsZHNcbmZ1bmN0aW9uIGRlZXBNZXJnZShvYmosIHNyYykge1xuICAgICgwLCBsb2Rhc2hfbWVyZ2V3aXRoXzEuZGVmYXVsdCkob2JqLCBzcmMsIChvYmpWYWx1ZSwgc3JjVmFsdWUpID0+IHtcbiAgICAgICAgaWYgKGlzTGVhZkZpZWxkKG9ialZhbHVlKSkge1xuICAgICAgICAgICAgaWYgKGlzTGVhZkZpZWxkKHNyY1ZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLm9ialZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAuLi5zcmNWYWx1ZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb2JqVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNMZWFmRmllbGQoc3JjVmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gc3JjVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlc29sdmUtaW5mby5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/graphql-jit/dist/esm/resolve-info.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/graphql-jit/dist/esm/variables.js":
/*!*********************************************************!*\
  !*** ../node_modules/graphql-jit/dist/esm/variables.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.compileVariableParsing = exports.failToParseVariables = void 0;\nconst generate_function_1 = __importDefault(__webpack_require__(/*! generate-function */ \"(ssr)/../node_modules/generate-function/index.js\"));\nconst graphql_1 = __webpack_require__(/*! graphql */ \"(ssr)/../node_modules/graphql/index.mjs\");\nconst ast_1 = __webpack_require__(/*! ./ast */ \"(ssr)/../node_modules/graphql-jit/dist/esm/ast.js\");\nconst error_1 = __webpack_require__(/*! ./error */ \"(ssr)/../node_modules/graphql-jit/dist/esm/error.js\");\nconst inspect_1 = __importDefault(__webpack_require__(/*! ./inspect */ \"(ssr)/../node_modules/graphql-jit/dist/esm/inspect.js\"));\nconst inspect = (0, inspect_1.default)();\nfunction failToParseVariables(x) {\n    return x.errors;\n}\nexports.failToParseVariables = failToParseVariables;\nfunction createSubCompilationContext(context) {\n    return { ...context };\n}\nfunction compileVariableParsing(schema, varDefNodes) {\n    const errors = [];\n    const coercedValues = Object.create(null);\n    let mainBody = \"\";\n    const dependencies = new Map();\n    for (const varDefNode of varDefNodes) {\n        const context = {\n            varDefNode,\n            depth: 0,\n            inputPath: (0, ast_1.addPath)(undefined, \"input\"),\n            responsePath: (0, ast_1.addPath)(undefined, \"coerced\"),\n            dependencies\n        };\n        const varName = varDefNode.variable.name.value;\n        const varType = (0, graphql_1.typeFromAST)(schema, varDefNode.type);\n        if (!varType || !(0, graphql_1.isInputType)(varType)) {\n            // Must use input types for variables. This should be caught during\n            // validation, however is checked again here for safety.\n            errors.push(new error_1.GraphQLError(`Variable \"$${varName}\" expected value of type ` +\n                `\"${varType || (0, graphql_1.print)(varDefNode.type)}\" which cannot be used as an input type.`, (0, ast_1.computeLocations)([varDefNode.type])));\n            continue;\n        }\n        // Ensure a constant shape of the input map\n        coercedValues[varName] = undefined;\n        const hasValueName = hasValue((0, ast_1.addPath)(context.inputPath, varName));\n        mainBody += `const ${hasValueName} = Object.prototype.hasOwnProperty.call(${getObjectPath(context.inputPath)}, \"${varName}\");\\n`;\n        context.inputPath = (0, ast_1.addPath)(context.inputPath, varName);\n        context.responsePath = (0, ast_1.addPath)(context.responsePath, varName);\n        mainBody += generateInput(context, varType, varName, hasValueName, (0, graphql_1.valueFromAST)(varDefNode.defaultValue, varType), false);\n    }\n    if (errors.length > 0) {\n        throw errors;\n    }\n    const gen = (0, generate_function_1.default)();\n    gen(`\n    return function getVariables(input) {\n      const errors = [];\n      const coerced = ${JSON.stringify(coercedValues)}\n      ${mainBody}\n      if (errors.length > 0) {\n        return {errors, coerced: undefined};\n      }\n      return {errors: undefined, coerced};\n    }\n  `);\n    // eslint-disable-next-line\n    return Function.apply(null, [\"GraphQLJITError\", \"inspect\"]\n        .concat(Array.from(dependencies.keys()))\n        .concat(gen.toString())).apply(null, [error_1.GraphQLError, inspect].concat(Array.from(dependencies.values())));\n}\nexports.compileVariableParsing = compileVariableParsing;\n// Int Scalars represent 32 bits\n// https://graphql.github.io/graphql-spec/June2018/#sec-Int\nconst MAX_32BIT_INT = 2147483647;\nconst MIN_32BIT_INT = -2147483648;\nfunction generateInput(context, varType, varName, hasValueName, defaultValue, wrapInList) {\n    const currentOutput = getObjectPath(context.responsePath);\n    const currentInput = getObjectPath(context.inputPath);\n    const errorLocation = printErrorLocation((0, ast_1.computeLocations)([context.varDefNode]));\n    const gen = (0, generate_function_1.default)();\n    gen(`if (${currentInput} == null) {`);\n    if ((0, graphql_1.isNonNullType)(varType)) {\n        let nonNullMessage;\n        let omittedMessage;\n        if (context.errorMessage) {\n            const objectPath = printObjectPath(context.responsePath);\n            nonNullMessage = `${context.errorMessage} + \\`Expected non-nullable type ${varType} not to be null at ${objectPath}.\\``;\n            omittedMessage = `${context.errorMessage} + \\`Field ${objectPath} of required type ${varType} was not provided.\\``;\n        }\n        else {\n            nonNullMessage = `'Variable \"$${varName}\" of non-null type \"${varType}\" must not be null.'`;\n            omittedMessage = `'Variable \"$${varName}\" of required type \"${varType}\" was not provided.'`;\n        }\n        varType = varType.ofType;\n        gen(`\n      if (${currentOutput} == null) {\n        errors.push(new GraphQLJITError(${hasValueName} ? ${nonNullMessage} : ${omittedMessage}, ${errorLocation}));\n      }\n    `);\n    }\n    else {\n        gen(`\n      if (${hasValueName}) { ${currentOutput} = null; }\n    `);\n        if (defaultValue !== undefined) {\n            gen(`else { ${currentOutput} = ${JSON.stringify(defaultValue)} }`);\n        }\n    }\n    gen(`} else {`);\n    if ((0, graphql_1.isScalarType)(varType)) {\n        switch (varType.name) {\n            case graphql_1.GraphQLID.name:\n                gen(`\n          if (typeof ${currentInput} === \"string\") {\n            ${currentOutput} = ${currentInput};\n          } else if (Number.isInteger(${currentInput})) {\n            ${currentOutput} = ${currentInput}.toString();\n          } else {\n            errors.push(new GraphQLJITError('Variable \"$${varName}\" got invalid value ' +\n              inspect(${currentInput}) + \"; \" +\n              'Expected type ${varType.name}; ' +\n              '${varType.name} cannot represent value: ' +\n              inspect(${currentInput}), ${errorLocation})\n            );\n          }\n        `);\n                break;\n            case graphql_1.GraphQLString.name:\n                gen(`\n          if (typeof ${currentInput} === \"string\") {\n              ${currentOutput} = ${currentInput};\n          } else {\n            errors.push(new GraphQLJITError('Variable \"$${varName}\" got invalid value ' +\n              inspect(${currentInput}) + \"; \" +\n              'Expected type ${varType.name}; ' +\n              '${varType.name} cannot represent a non string value: ' +\n              inspect(${currentInput}), ${errorLocation})\n            );\n          }\n        `);\n                break;\n            case graphql_1.GraphQLBoolean.name:\n                gen(`\n        if (typeof ${currentInput} === \"boolean\") {\n            ${currentOutput} = ${currentInput};\n        } else {\n          errors.push(new GraphQLJITError('Variable \"$${varName}\" got invalid value ' +\n          inspect(${currentInput}) + \"; \" +\n          'Expected type ${varType.name}; ' +\n          '${varType.name} cannot represent a non boolean value: ' +\n          inspect(${currentInput}), ${errorLocation}));\n        }\n        `);\n                break;\n            case graphql_1.GraphQLInt.name:\n                gen(`\n        if (Number.isInteger(${currentInput})) {\n          if (${currentInput} > ${MAX_32BIT_INT} || ${currentInput} < ${MIN_32BIT_INT}) {\n            errors.push(new GraphQLJITError('Variable \"$${varName}\" got invalid value ' +\n            inspect(${currentInput}) + \"; \" +\n            'Expected type ${varType.name}; ' +\n            '${varType.name} cannot represent non 32-bit signed integer value: ' +\n            inspect(${currentInput}), ${errorLocation}));\n          } else {\n            ${currentOutput} = ${currentInput};\n          }\n        } else {\n          errors.push(new GraphQLJITError('Variable \"$${varName}\" got invalid value ' +\n            inspect(${currentInput}) + \"; \" +\n            'Expected type ${varType.name}; ' +\n            '${varType.name} cannot represent non-integer value: ' +\n            inspect(${currentInput}), ${errorLocation})\n          );\n        }\n        `);\n                break;\n            case graphql_1.GraphQLFloat.name:\n                gen(`\n        if (Number.isFinite(${currentInput})) {\n            ${currentOutput} = ${currentInput};\n        } else {\n          errors.push(new GraphQLJITError('Variable \"$${varName}\" got invalid value ' +\n            inspect(${currentInput}) + \"; \" +\n            'Expected type ${varType.name}; ' +\n            '${varType.name} cannot represent non numeric value: ' +\n            inspect(${currentInput}), ${errorLocation})\n          );\n        }\n        `);\n                break;\n            default:\n                context.dependencies.set(`${varType.name}parseValue`, varType.parseValue.bind(varType));\n                gen(`\n          try {\n            const parseResult = ${varType.name}parseValue(${currentInput});\n            if (parseResult === undefined || parseResult !== parseResult) {\n              errors.push(new GraphQLJITError('Variable \"$${varName}\" got invalid value ' +\n              inspect(${currentInput}) + \"; \" +\n              'Expected type ${varType.name}.', ${errorLocation}));\n            }\n            ${currentOutput} = parseResult;\n          } catch (error) {\n            errors.push(new GraphQLJITError('Variable \"$${varName}\" got invalid value ' +\n              inspect(${currentInput}) + \"; \" +\n              'Expected type ${varType.name}.', ${errorLocation}, undefined, error)\n            );\n          }\n        `);\n        }\n    }\n    else if ((0, graphql_1.isEnumType)(varType)) {\n        context.dependencies.set(`${varType.name}getValue`, varType.getValue.bind(varType));\n        gen(`\n      if (typeof ${currentInput} === \"string\") {\n        const enumValue = ${varType.name}getValue(${currentInput});\n        if (enumValue) {\n          ${currentOutput} = enumValue.value;\n        } else {\n          errors.push(\n            new GraphQLJITError('Variable \"$${varName}\" got invalid value ' +\n            inspect(${currentInput}) + \"; \" +\n            'Expected type ${varType.name}.', ${errorLocation})\n          );\n        }\n      } else {\n        errors.push(\n          new GraphQLJITError('Variable \"$${varName}\" got invalid value ' +\n          inspect(${currentInput}) + \"; \" +\n          'Expected type ${varType.name}.', ${errorLocation})\n        );\n      }\n      `);\n    }\n    else if ((0, graphql_1.isListType)(varType)) {\n        context.errorMessage = `'Variable \"$${varName}\" got invalid value ' + inspect(${currentInput}) + '; '`;\n        const hasValueName = hasValue(context.inputPath);\n        const index = `idx${context.depth}`;\n        const subContext = createSubCompilationContext(context);\n        subContext.responsePath = (0, ast_1.addPath)(subContext.responsePath, index, \"variable\");\n        subContext.inputPath = (0, ast_1.addPath)(subContext.inputPath, index, \"variable\");\n        subContext.depth++;\n        gen(`\n      if (Array.isArray(${currentInput})) {\n        ${currentOutput} = [];\n        for (let ${index} = 0; ${index} < ${currentInput}.length; ++${index}) {\n          const ${hasValueName} =\n          ${getObjectPath(subContext.inputPath)} !== undefined;\n          ${generateInput(subContext, varType.ofType, varName, hasValueName, undefined, false)}\n        }\n      } else {\n        ${generateInput(context, varType.ofType, varName, hasValueName, undefined, true)}\n      }\n    `);\n    }\n    else if ((0, graphql_1.isInputType)(varType)) {\n        gen(`\n      if (typeof ${currentInput} !== 'object') {\n        errors.push(new GraphQLJITError('Variable \"$${varName}\" got invalid value ' +\n        inspect(${currentInput}) + \"; \" +\n        'Expected type ${varType.name} to be an object.', ${errorLocation}));\n      } else {\n        ${currentOutput} = {};\n    `);\n        const fields = varType.getFields();\n        const allowedFields = [];\n        for (const field of Object.values(fields)) {\n            const subContext = createSubCompilationContext(context);\n            allowedFields.push(field.name);\n            const hasValueName = hasValue((0, ast_1.addPath)(subContext.inputPath, field.name));\n            gen(`\n        const ${hasValueName} = Object.prototype.hasOwnProperty.call(\n          ${getObjectPath(subContext.inputPath)}, \"${field.name}\"\n        );\n      `);\n            subContext.inputPath = (0, ast_1.addPath)(subContext.inputPath, field.name);\n            subContext.responsePath = (0, ast_1.addPath)(subContext.responsePath, field.name);\n            subContext.errorMessage = `'Variable \"$${varName}\" got invalid value ' + inspect(${currentInput}) + '; '`;\n            gen(`\n        ${generateInput(subContext, field.type, field.name, hasValueName, field.defaultValue, false)}\n      `);\n        }\n        gen(`\n      const allowedFields = ${JSON.stringify(allowedFields)};\n      for (const fieldName of Object.keys(${currentInput})) {\n        if (!allowedFields.includes(fieldName)) {\n          errors.push(new GraphQLJITError('Variable \"$${varName}\" got invalid value ' +\n            inspect(${currentInput}) + \"; \" +\n            'Field \"' + fieldName + '\" is not defined by type ${varType.name}.', ${errorLocation}));\n          break;\n        }\n      }\n    }`);\n    }\n    else {\n        /* istanbul ignore next line */\n        throw new Error(`unknown type: ${varType}`);\n    }\n    if (wrapInList) {\n        gen(`${currentOutput} = [${currentOutput}];`);\n    }\n    gen(`}`);\n    return gen.toString();\n}\nfunction hasValue(path) {\n    const flattened = [];\n    let curr = path;\n    while (curr) {\n        flattened.push(curr.key);\n        curr = curr.prev;\n    }\n    return `hasValue${flattened.join(\"_\")}`;\n}\nfunction printErrorLocation(location) {\n    return JSON.stringify(location);\n}\nfunction getObjectPath(path) {\n    const flattened = [];\n    let curr = path;\n    while (curr) {\n        flattened.unshift({ key: curr.key, type: curr.type });\n        curr = curr.prev;\n    }\n    let name = flattened[0].key;\n    for (let i = 1; i < flattened.length; ++i) {\n        name +=\n            flattened[i].type === \"literal\"\n                ? `[\"${flattened[i].key}\"]`\n                : `[${flattened[i].key}]`;\n    }\n    return name;\n}\nfunction printObjectPath(path) {\n    const flattened = [];\n    let curr = path;\n    while (curr) {\n        flattened.unshift({ key: curr.key, type: curr.type });\n        curr = curr.prev;\n    }\n    const initialIndex = Math.min(flattened.length - 1, 1);\n    let name = \"value\";\n    for (let i = initialIndex + 1; i < flattened.length; ++i) {\n        name +=\n            flattened[i].type === \"literal\"\n                ? `.${flattened[i].key}`\n                : `[$\\{${flattened[i].key}}]`;\n    }\n    return name;\n}\n//# sourceMappingURL=variables.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL2dyYXBocWwtaml0L2Rpc3QvZXNtL3ZhcmlhYmxlcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDhCQUE4QixHQUFHLDRCQUE0QjtBQUM3RCw0Q0FBNEMsbUJBQU8sQ0FBQywyRUFBbUI7QUFDdkUsa0JBQWtCLG1CQUFPLENBQUMsd0RBQVM7QUFDbkMsY0FBYyxtQkFBTyxDQUFDLGdFQUFPO0FBQzdCLGdCQUFnQixtQkFBTyxDQUFDLG9FQUFTO0FBQ2pDLGtDQUFrQyxtQkFBTyxDQUFDLHdFQUFXO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELFFBQVE7QUFDdkUsb0JBQW9CLGlEQUFpRDtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGNBQWMseUNBQXlDLGlDQUFpQyxLQUFLLFFBQVEsR0FBRztBQUNySTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCLFFBQVE7QUFDUjtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWMsVUFBVTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHNCQUFzQixpQ0FBaUMsU0FBUyxvQkFBb0IsV0FBVztBQUMvSCxnQ0FBZ0Msc0JBQXNCLFlBQVksWUFBWSxtQkFB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QUFDakQ7QUFDQTtBQUNBLGVBQWUsZUFBZSxLQUFLLGNBQWMsRUFBRTtBQUNuRDtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isb0JBQW9CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZ0NBQWdDO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBLHVCQUF1QixpQkFBaUI7QUFDeEMsc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixnQ0FBZ0M7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsc0JBQXNCO0FBQ3pEO0FBQ0E7QUFDQSxzQkFBc0IsaUJBQWlCO0FBQ3ZDLHVCQUF1QixFQUFFLGtCQUFrQjtBQUMzQztBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xlZGdpdHkteWllbGQtZnJvbnRlbmQvLi4vbm9kZV9tb2R1bGVzL2dyYXBocWwtaml0L2Rpc3QvZXNtL3ZhcmlhYmxlcy5qcz9iOWZlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jb21waWxlVmFyaWFibGVQYXJzaW5nID0gZXhwb3J0cy5mYWlsVG9QYXJzZVZhcmlhYmxlcyA9IHZvaWQgMDtcbmNvbnN0IGdlbmVyYXRlX2Z1bmN0aW9uXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImdlbmVyYXRlLWZ1bmN0aW9uXCIpKTtcbmNvbnN0IGdyYXBocWxfMSA9IHJlcXVpcmUoXCJncmFwaHFsXCIpO1xuY29uc3QgYXN0XzEgPSByZXF1aXJlKFwiLi9hc3RcIik7XG5jb25zdCBlcnJvcl8xID0gcmVxdWlyZShcIi4vZXJyb3JcIik7XG5jb25zdCBpbnNwZWN0XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vaW5zcGVjdFwiKSk7XG5jb25zdCBpbnNwZWN0ID0gKDAsIGluc3BlY3RfMS5kZWZhdWx0KSgpO1xuZnVuY3Rpb24gZmFpbFRvUGFyc2VWYXJpYWJsZXMoeCkge1xuICAgIHJldHVybiB4LmVycm9ycztcbn1cbmV4cG9ydHMuZmFpbFRvUGFyc2VWYXJpYWJsZXMgPSBmYWlsVG9QYXJzZVZhcmlhYmxlcztcbmZ1bmN0aW9uIGNyZWF0ZVN1YkNvbXBpbGF0aW9uQ29udGV4dChjb250ZXh0KSB7XG4gICAgcmV0dXJuIHsgLi4uY29udGV4dCB9O1xufVxuZnVuY3Rpb24gY29tcGlsZVZhcmlhYmxlUGFyc2luZyhzY2hlbWEsIHZhckRlZk5vZGVzKSB7XG4gICAgY29uc3QgZXJyb3JzID0gW107XG4gICAgY29uc3QgY29lcmNlZFZhbHVlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgbGV0IG1haW5Cb2R5ID0gXCJcIjtcbiAgICBjb25zdCBkZXBlbmRlbmNpZXMgPSBuZXcgTWFwKCk7XG4gICAgZm9yIChjb25zdCB2YXJEZWZOb2RlIG9mIHZhckRlZk5vZGVzKSB7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICAgICAgICB2YXJEZWZOb2RlLFxuICAgICAgICAgICAgZGVwdGg6IDAsXG4gICAgICAgICAgICBpbnB1dFBhdGg6ICgwLCBhc3RfMS5hZGRQYXRoKSh1bmRlZmluZWQsIFwiaW5wdXRcIiksXG4gICAgICAgICAgICByZXNwb25zZVBhdGg6ICgwLCBhc3RfMS5hZGRQYXRoKSh1bmRlZmluZWQsIFwiY29lcmNlZFwiKSxcbiAgICAgICAgICAgIGRlcGVuZGVuY2llc1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCB2YXJOYW1lID0gdmFyRGVmTm9kZS52YXJpYWJsZS5uYW1lLnZhbHVlO1xuICAgICAgICBjb25zdCB2YXJUeXBlID0gKDAsIGdyYXBocWxfMS50eXBlRnJvbUFTVCkoc2NoZW1hLCB2YXJEZWZOb2RlLnR5cGUpO1xuICAgICAgICBpZiAoIXZhclR5cGUgfHwgISgwLCBncmFwaHFsXzEuaXNJbnB1dFR5cGUpKHZhclR5cGUpKSB7XG4gICAgICAgICAgICAvLyBNdXN0IHVzZSBpbnB1dCB0eXBlcyBmb3IgdmFyaWFibGVzLiBUaGlzIHNob3VsZCBiZSBjYXVnaHQgZHVyaW5nXG4gICAgICAgICAgICAvLyB2YWxpZGF0aW9uLCBob3dldmVyIGlzIGNoZWNrZWQgYWdhaW4gaGVyZSBmb3Igc2FmZXR5LlxuICAgICAgICAgICAgZXJyb3JzLnB1c2gobmV3IGVycm9yXzEuR3JhcGhRTEVycm9yKGBWYXJpYWJsZSBcIiQke3Zhck5hbWV9XCIgZXhwZWN0ZWQgdmFsdWUgb2YgdHlwZSBgICtcbiAgICAgICAgICAgICAgICBgXCIke3ZhclR5cGUgfHwgKDAsIGdyYXBocWxfMS5wcmludCkodmFyRGVmTm9kZS50eXBlKX1cIiB3aGljaCBjYW5ub3QgYmUgdXNlZCBhcyBhbiBpbnB1dCB0eXBlLmAsICgwLCBhc3RfMS5jb21wdXRlTG9jYXRpb25zKShbdmFyRGVmTm9kZS50eXBlXSkpKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIEVuc3VyZSBhIGNvbnN0YW50IHNoYXBlIG9mIHRoZSBpbnB1dCBtYXBcbiAgICAgICAgY29lcmNlZFZhbHVlc1t2YXJOYW1lXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgaGFzVmFsdWVOYW1lID0gaGFzVmFsdWUoKDAsIGFzdF8xLmFkZFBhdGgpKGNvbnRleHQuaW5wdXRQYXRoLCB2YXJOYW1lKSk7XG4gICAgICAgIG1haW5Cb2R5ICs9IGBjb25zdCAke2hhc1ZhbHVlTmFtZX0gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoJHtnZXRPYmplY3RQYXRoKGNvbnRleHQuaW5wdXRQYXRoKX0sIFwiJHt2YXJOYW1lfVwiKTtcXG5gO1xuICAgICAgICBjb250ZXh0LmlucHV0UGF0aCA9ICgwLCBhc3RfMS5hZGRQYXRoKShjb250ZXh0LmlucHV0UGF0aCwgdmFyTmFtZSk7XG4gICAgICAgIGNvbnRleHQucmVzcG9uc2VQYXRoID0gKDAsIGFzdF8xLmFkZFBhdGgpKGNvbnRleHQucmVzcG9uc2VQYXRoLCB2YXJOYW1lKTtcbiAgICAgICAgbWFpbkJvZHkgKz0gZ2VuZXJhdGVJbnB1dChjb250ZXh0LCB2YXJUeXBlLCB2YXJOYW1lLCBoYXNWYWx1ZU5hbWUsICgwLCBncmFwaHFsXzEudmFsdWVGcm9tQVNUKSh2YXJEZWZOb2RlLmRlZmF1bHRWYWx1ZSwgdmFyVHlwZSksIGZhbHNlKTtcbiAgICB9XG4gICAgaWYgKGVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRocm93IGVycm9ycztcbiAgICB9XG4gICAgY29uc3QgZ2VuID0gKDAsIGdlbmVyYXRlX2Z1bmN0aW9uXzEuZGVmYXVsdCkoKTtcbiAgICBnZW4oYFxuICAgIHJldHVybiBmdW5jdGlvbiBnZXRWYXJpYWJsZXMoaW5wdXQpIHtcbiAgICAgIGNvbnN0IGVycm9ycyA9IFtdO1xuICAgICAgY29uc3QgY29lcmNlZCA9ICR7SlNPTi5zdHJpbmdpZnkoY29lcmNlZFZhbHVlcyl9XG4gICAgICAke21haW5Cb2R5fVxuICAgICAgaWYgKGVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiB7ZXJyb3JzLCBjb2VyY2VkOiB1bmRlZmluZWR9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtlcnJvcnM6IHVuZGVmaW5lZCwgY29lcmNlZH07XG4gICAgfVxuICBgKTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICByZXR1cm4gRnVuY3Rpb24uYXBwbHkobnVsbCwgW1wiR3JhcGhRTEpJVEVycm9yXCIsIFwiaW5zcGVjdFwiXVxuICAgICAgICAuY29uY2F0KEFycmF5LmZyb20oZGVwZW5kZW5jaWVzLmtleXMoKSkpXG4gICAgICAgIC5jb25jYXQoZ2VuLnRvU3RyaW5nKCkpKS5hcHBseShudWxsLCBbZXJyb3JfMS5HcmFwaFFMRXJyb3IsIGluc3BlY3RdLmNvbmNhdChBcnJheS5mcm9tKGRlcGVuZGVuY2llcy52YWx1ZXMoKSkpKTtcbn1cbmV4cG9ydHMuY29tcGlsZVZhcmlhYmxlUGFyc2luZyA9IGNvbXBpbGVWYXJpYWJsZVBhcnNpbmc7XG4vLyBJbnQgU2NhbGFycyByZXByZXNlbnQgMzIgYml0c1xuLy8gaHR0cHM6Ly9ncmFwaHFsLmdpdGh1Yi5pby9ncmFwaHFsLXNwZWMvSnVuZTIwMTgvI3NlYy1JbnRcbmNvbnN0IE1BWF8zMkJJVF9JTlQgPSAyMTQ3NDgzNjQ3O1xuY29uc3QgTUlOXzMyQklUX0lOVCA9IC0yMTQ3NDgzNjQ4O1xuZnVuY3Rpb24gZ2VuZXJhdGVJbnB1dChjb250ZXh0LCB2YXJUeXBlLCB2YXJOYW1lLCBoYXNWYWx1ZU5hbWUsIGRlZmF1bHRWYWx1ZSwgd3JhcEluTGlzdCkge1xuICAgIGNvbnN0IGN1cnJlbnRPdXRwdXQgPSBnZXRPYmplY3RQYXRoKGNvbnRleHQucmVzcG9uc2VQYXRoKTtcbiAgICBjb25zdCBjdXJyZW50SW5wdXQgPSBnZXRPYmplY3RQYXRoKGNvbnRleHQuaW5wdXRQYXRoKTtcbiAgICBjb25zdCBlcnJvckxvY2F0aW9uID0gcHJpbnRFcnJvckxvY2F0aW9uKCgwLCBhc3RfMS5jb21wdXRlTG9jYXRpb25zKShbY29udGV4dC52YXJEZWZOb2RlXSkpO1xuICAgIGNvbnN0IGdlbiA9ICgwLCBnZW5lcmF0ZV9mdW5jdGlvbl8xLmRlZmF1bHQpKCk7XG4gICAgZ2VuKGBpZiAoJHtjdXJyZW50SW5wdXR9ID09IG51bGwpIHtgKTtcbiAgICBpZiAoKDAsIGdyYXBocWxfMS5pc05vbk51bGxUeXBlKSh2YXJUeXBlKSkge1xuICAgICAgICBsZXQgbm9uTnVsbE1lc3NhZ2U7XG4gICAgICAgIGxldCBvbWl0dGVkTWVzc2FnZTtcbiAgICAgICAgaWYgKGNvbnRleHQuZXJyb3JNZXNzYWdlKSB7XG4gICAgICAgICAgICBjb25zdCBvYmplY3RQYXRoID0gcHJpbnRPYmplY3RQYXRoKGNvbnRleHQucmVzcG9uc2VQYXRoKTtcbiAgICAgICAgICAgIG5vbk51bGxNZXNzYWdlID0gYCR7Y29udGV4dC5lcnJvck1lc3NhZ2V9ICsgXFxgRXhwZWN0ZWQgbm9uLW51bGxhYmxlIHR5cGUgJHt2YXJUeXBlfSBub3QgdG8gYmUgbnVsbCBhdCAke29iamVjdFBhdGh9LlxcYGA7XG4gICAgICAgICAgICBvbWl0dGVkTWVzc2FnZSA9IGAke2NvbnRleHQuZXJyb3JNZXNzYWdlfSArIFxcYEZpZWxkICR7b2JqZWN0UGF0aH0gb2YgcmVxdWlyZWQgdHlwZSAke3ZhclR5cGV9IHdhcyBub3QgcHJvdmlkZWQuXFxgYDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5vbk51bGxNZXNzYWdlID0gYCdWYXJpYWJsZSBcIiQke3Zhck5hbWV9XCIgb2Ygbm9uLW51bGwgdHlwZSBcIiR7dmFyVHlwZX1cIiBtdXN0IG5vdCBiZSBudWxsLidgO1xuICAgICAgICAgICAgb21pdHRlZE1lc3NhZ2UgPSBgJ1ZhcmlhYmxlIFwiJCR7dmFyTmFtZX1cIiBvZiByZXF1aXJlZCB0eXBlIFwiJHt2YXJUeXBlfVwiIHdhcyBub3QgcHJvdmlkZWQuJ2A7XG4gICAgICAgIH1cbiAgICAgICAgdmFyVHlwZSA9IHZhclR5cGUub2ZUeXBlO1xuICAgICAgICBnZW4oYFxuICAgICAgaWYgKCR7Y3VycmVudE91dHB1dH0gPT0gbnVsbCkge1xuICAgICAgICBlcnJvcnMucHVzaChuZXcgR3JhcGhRTEpJVEVycm9yKCR7aGFzVmFsdWVOYW1lfSA/ICR7bm9uTnVsbE1lc3NhZ2V9IDogJHtvbWl0dGVkTWVzc2FnZX0sICR7ZXJyb3JMb2NhdGlvbn0pKTtcbiAgICAgIH1cbiAgICBgKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGdlbihgXG4gICAgICBpZiAoJHtoYXNWYWx1ZU5hbWV9KSB7ICR7Y3VycmVudE91dHB1dH0gPSBudWxsOyB9XG4gICAgYCk7XG4gICAgICAgIGlmIChkZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZ2VuKGBlbHNlIHsgJHtjdXJyZW50T3V0cHV0fSA9ICR7SlNPTi5zdHJpbmdpZnkoZGVmYXVsdFZhbHVlKX0gfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdlbihgfSBlbHNlIHtgKTtcbiAgICBpZiAoKDAsIGdyYXBocWxfMS5pc1NjYWxhclR5cGUpKHZhclR5cGUpKSB7XG4gICAgICAgIHN3aXRjaCAodmFyVHlwZS5uYW1lKSB7XG4gICAgICAgICAgICBjYXNlIGdyYXBocWxfMS5HcmFwaFFMSUQubmFtZTpcbiAgICAgICAgICAgICAgICBnZW4oYFxuICAgICAgICAgIGlmICh0eXBlb2YgJHtjdXJyZW50SW5wdXR9ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAke2N1cnJlbnRPdXRwdXR9ID0gJHtjdXJyZW50SW5wdXR9O1xuICAgICAgICAgIH0gZWxzZSBpZiAoTnVtYmVyLmlzSW50ZWdlcigke2N1cnJlbnRJbnB1dH0pKSB7XG4gICAgICAgICAgICAke2N1cnJlbnRPdXRwdXR9ID0gJHtjdXJyZW50SW5wdXR9LnRvU3RyaW5nKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBHcmFwaFFMSklURXJyb3IoJ1ZhcmlhYmxlIFwiJCR7dmFyTmFtZX1cIiBnb3QgaW52YWxpZCB2YWx1ZSAnICtcbiAgICAgICAgICAgICAgaW5zcGVjdCgke2N1cnJlbnRJbnB1dH0pICsgXCI7IFwiICtcbiAgICAgICAgICAgICAgJ0V4cGVjdGVkIHR5cGUgJHt2YXJUeXBlLm5hbWV9OyAnICtcbiAgICAgICAgICAgICAgJyR7dmFyVHlwZS5uYW1lfSBjYW5ub3QgcmVwcmVzZW50IHZhbHVlOiAnICtcbiAgICAgICAgICAgICAgaW5zcGVjdCgke2N1cnJlbnRJbnB1dH0pLCAke2Vycm9yTG9jYXRpb259KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIGApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBncmFwaHFsXzEuR3JhcGhRTFN0cmluZy5uYW1lOlxuICAgICAgICAgICAgICAgIGdlbihgXG4gICAgICAgICAgaWYgKHR5cGVvZiAke2N1cnJlbnRJbnB1dH0gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgJHtjdXJyZW50T3V0cHV0fSA9ICR7Y3VycmVudElucHV0fTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2gobmV3IEdyYXBoUUxKSVRFcnJvcignVmFyaWFibGUgXCIkJHt2YXJOYW1lfVwiIGdvdCBpbnZhbGlkIHZhbHVlICcgK1xuICAgICAgICAgICAgICBpbnNwZWN0KCR7Y3VycmVudElucHV0fSkgKyBcIjsgXCIgK1xuICAgICAgICAgICAgICAnRXhwZWN0ZWQgdHlwZSAke3ZhclR5cGUubmFtZX07ICcgK1xuICAgICAgICAgICAgICAnJHt2YXJUeXBlLm5hbWV9IGNhbm5vdCByZXByZXNlbnQgYSBub24gc3RyaW5nIHZhbHVlOiAnICtcbiAgICAgICAgICAgICAgaW5zcGVjdCgke2N1cnJlbnRJbnB1dH0pLCAke2Vycm9yTG9jYXRpb259KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIGApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBncmFwaHFsXzEuR3JhcGhRTEJvb2xlYW4ubmFtZTpcbiAgICAgICAgICAgICAgICBnZW4oYFxuICAgICAgICBpZiAodHlwZW9mICR7Y3VycmVudElucHV0fSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgICR7Y3VycmVudE91dHB1dH0gPSAke2N1cnJlbnRJbnB1dH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXJyb3JzLnB1c2gobmV3IEdyYXBoUUxKSVRFcnJvcignVmFyaWFibGUgXCIkJHt2YXJOYW1lfVwiIGdvdCBpbnZhbGlkIHZhbHVlICcgK1xuICAgICAgICAgIGluc3BlY3QoJHtjdXJyZW50SW5wdXR9KSArIFwiOyBcIiArXG4gICAgICAgICAgJ0V4cGVjdGVkIHR5cGUgJHt2YXJUeXBlLm5hbWV9OyAnICtcbiAgICAgICAgICAnJHt2YXJUeXBlLm5hbWV9IGNhbm5vdCByZXByZXNlbnQgYSBub24gYm9vbGVhbiB2YWx1ZTogJyArXG4gICAgICAgICAgaW5zcGVjdCgke2N1cnJlbnRJbnB1dH0pLCAke2Vycm9yTG9jYXRpb259KSk7XG4gICAgICAgIH1cbiAgICAgICAgYCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGdyYXBocWxfMS5HcmFwaFFMSW50Lm5hbWU6XG4gICAgICAgICAgICAgICAgZ2VuKGBcbiAgICAgICAgaWYgKE51bWJlci5pc0ludGVnZXIoJHtjdXJyZW50SW5wdXR9KSkge1xuICAgICAgICAgIGlmICgke2N1cnJlbnRJbnB1dH0gPiAke01BWF8zMkJJVF9JTlR9IHx8ICR7Y3VycmVudElucHV0fSA8ICR7TUlOXzMyQklUX0lOVH0pIHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBHcmFwaFFMSklURXJyb3IoJ1ZhcmlhYmxlIFwiJCR7dmFyTmFtZX1cIiBnb3QgaW52YWxpZCB2YWx1ZSAnICtcbiAgICAgICAgICAgIGluc3BlY3QoJHtjdXJyZW50SW5wdXR9KSArIFwiOyBcIiArXG4gICAgICAgICAgICAnRXhwZWN0ZWQgdHlwZSAke3ZhclR5cGUubmFtZX07ICcgK1xuICAgICAgICAgICAgJyR7dmFyVHlwZS5uYW1lfSBjYW5ub3QgcmVwcmVzZW50IG5vbiAzMi1iaXQgc2lnbmVkIGludGVnZXIgdmFsdWU6ICcgK1xuICAgICAgICAgICAgaW5zcGVjdCgke2N1cnJlbnRJbnB1dH0pLCAke2Vycm9yTG9jYXRpb259KSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICR7Y3VycmVudE91dHB1dH0gPSAke2N1cnJlbnRJbnB1dH07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBHcmFwaFFMSklURXJyb3IoJ1ZhcmlhYmxlIFwiJCR7dmFyTmFtZX1cIiBnb3QgaW52YWxpZCB2YWx1ZSAnICtcbiAgICAgICAgICAgIGluc3BlY3QoJHtjdXJyZW50SW5wdXR9KSArIFwiOyBcIiArXG4gICAgICAgICAgICAnRXhwZWN0ZWQgdHlwZSAke3ZhclR5cGUubmFtZX07ICcgK1xuICAgICAgICAgICAgJyR7dmFyVHlwZS5uYW1lfSBjYW5ub3QgcmVwcmVzZW50IG5vbi1pbnRlZ2VyIHZhbHVlOiAnICtcbiAgICAgICAgICAgIGluc3BlY3QoJHtjdXJyZW50SW5wdXR9KSwgJHtlcnJvckxvY2F0aW9ufSlcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBncmFwaHFsXzEuR3JhcGhRTEZsb2F0Lm5hbWU6XG4gICAgICAgICAgICAgICAgZ2VuKGBcbiAgICAgICAgaWYgKE51bWJlci5pc0Zpbml0ZSgke2N1cnJlbnRJbnB1dH0pKSB7XG4gICAgICAgICAgICAke2N1cnJlbnRPdXRwdXR9ID0gJHtjdXJyZW50SW5wdXR9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBHcmFwaFFMSklURXJyb3IoJ1ZhcmlhYmxlIFwiJCR7dmFyTmFtZX1cIiBnb3QgaW52YWxpZCB2YWx1ZSAnICtcbiAgICAgICAgICAgIGluc3BlY3QoJHtjdXJyZW50SW5wdXR9KSArIFwiOyBcIiArXG4gICAgICAgICAgICAnRXhwZWN0ZWQgdHlwZSAke3ZhclR5cGUubmFtZX07ICcgK1xuICAgICAgICAgICAgJyR7dmFyVHlwZS5uYW1lfSBjYW5ub3QgcmVwcmVzZW50IG5vbiBudW1lcmljIHZhbHVlOiAnICtcbiAgICAgICAgICAgIGluc3BlY3QoJHtjdXJyZW50SW5wdXR9KSwgJHtlcnJvckxvY2F0aW9ufSlcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBjb250ZXh0LmRlcGVuZGVuY2llcy5zZXQoYCR7dmFyVHlwZS5uYW1lfXBhcnNlVmFsdWVgLCB2YXJUeXBlLnBhcnNlVmFsdWUuYmluZCh2YXJUeXBlKSk7XG4gICAgICAgICAgICAgICAgZ2VuKGBcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcGFyc2VSZXN1bHQgPSAke3ZhclR5cGUubmFtZX1wYXJzZVZhbHVlKCR7Y3VycmVudElucHV0fSk7XG4gICAgICAgICAgICBpZiAocGFyc2VSZXN1bHQgPT09IHVuZGVmaW5lZCB8fCBwYXJzZVJlc3VsdCAhPT0gcGFyc2VSZXN1bHQpIHtcbiAgICAgICAgICAgICAgZXJyb3JzLnB1c2gobmV3IEdyYXBoUUxKSVRFcnJvcignVmFyaWFibGUgXCIkJHt2YXJOYW1lfVwiIGdvdCBpbnZhbGlkIHZhbHVlICcgK1xuICAgICAgICAgICAgICBpbnNwZWN0KCR7Y3VycmVudElucHV0fSkgKyBcIjsgXCIgK1xuICAgICAgICAgICAgICAnRXhwZWN0ZWQgdHlwZSAke3ZhclR5cGUubmFtZX0uJywgJHtlcnJvckxvY2F0aW9ufSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgJHtjdXJyZW50T3V0cHV0fSA9IHBhcnNlUmVzdWx0O1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgR3JhcGhRTEpJVEVycm9yKCdWYXJpYWJsZSBcIiQke3Zhck5hbWV9XCIgZ290IGludmFsaWQgdmFsdWUgJyArXG4gICAgICAgICAgICAgIGluc3BlY3QoJHtjdXJyZW50SW5wdXR9KSArIFwiOyBcIiArXG4gICAgICAgICAgICAgICdFeHBlY3RlZCB0eXBlICR7dmFyVHlwZS5uYW1lfS4nLCAke2Vycm9yTG9jYXRpb259LCB1bmRlZmluZWQsIGVycm9yKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIGApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKCgwLCBncmFwaHFsXzEuaXNFbnVtVHlwZSkodmFyVHlwZSkpIHtcbiAgICAgICAgY29udGV4dC5kZXBlbmRlbmNpZXMuc2V0KGAke3ZhclR5cGUubmFtZX1nZXRWYWx1ZWAsIHZhclR5cGUuZ2V0VmFsdWUuYmluZCh2YXJUeXBlKSk7XG4gICAgICAgIGdlbihgXG4gICAgICBpZiAodHlwZW9mICR7Y3VycmVudElucHV0fSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBjb25zdCBlbnVtVmFsdWUgPSAke3ZhclR5cGUubmFtZX1nZXRWYWx1ZSgke2N1cnJlbnRJbnB1dH0pO1xuICAgICAgICBpZiAoZW51bVZhbHVlKSB7XG4gICAgICAgICAgJHtjdXJyZW50T3V0cHV0fSA9IGVudW1WYWx1ZS52YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlcnJvcnMucHVzaChcbiAgICAgICAgICAgIG5ldyBHcmFwaFFMSklURXJyb3IoJ1ZhcmlhYmxlIFwiJCR7dmFyTmFtZX1cIiBnb3QgaW52YWxpZCB2YWx1ZSAnICtcbiAgICAgICAgICAgIGluc3BlY3QoJHtjdXJyZW50SW5wdXR9KSArIFwiOyBcIiArXG4gICAgICAgICAgICAnRXhwZWN0ZWQgdHlwZSAke3ZhclR5cGUubmFtZX0uJywgJHtlcnJvckxvY2F0aW9ufSlcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlcnJvcnMucHVzaChcbiAgICAgICAgICBuZXcgR3JhcGhRTEpJVEVycm9yKCdWYXJpYWJsZSBcIiQke3Zhck5hbWV9XCIgZ290IGludmFsaWQgdmFsdWUgJyArXG4gICAgICAgICAgaW5zcGVjdCgke2N1cnJlbnRJbnB1dH0pICsgXCI7IFwiICtcbiAgICAgICAgICAnRXhwZWN0ZWQgdHlwZSAke3ZhclR5cGUubmFtZX0uJywgJHtlcnJvckxvY2F0aW9ufSlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGApO1xuICAgIH1cbiAgICBlbHNlIGlmICgoMCwgZ3JhcGhxbF8xLmlzTGlzdFR5cGUpKHZhclR5cGUpKSB7XG4gICAgICAgIGNvbnRleHQuZXJyb3JNZXNzYWdlID0gYCdWYXJpYWJsZSBcIiQke3Zhck5hbWV9XCIgZ290IGludmFsaWQgdmFsdWUgJyArIGluc3BlY3QoJHtjdXJyZW50SW5wdXR9KSArICc7ICdgO1xuICAgICAgICBjb25zdCBoYXNWYWx1ZU5hbWUgPSBoYXNWYWx1ZShjb250ZXh0LmlucHV0UGF0aCk7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gYGlkeCR7Y29udGV4dC5kZXB0aH1gO1xuICAgICAgICBjb25zdCBzdWJDb250ZXh0ID0gY3JlYXRlU3ViQ29tcGlsYXRpb25Db250ZXh0KGNvbnRleHQpO1xuICAgICAgICBzdWJDb250ZXh0LnJlc3BvbnNlUGF0aCA9ICgwLCBhc3RfMS5hZGRQYXRoKShzdWJDb250ZXh0LnJlc3BvbnNlUGF0aCwgaW5kZXgsIFwidmFyaWFibGVcIik7XG4gICAgICAgIHN1YkNvbnRleHQuaW5wdXRQYXRoID0gKDAsIGFzdF8xLmFkZFBhdGgpKHN1YkNvbnRleHQuaW5wdXRQYXRoLCBpbmRleCwgXCJ2YXJpYWJsZVwiKTtcbiAgICAgICAgc3ViQ29udGV4dC5kZXB0aCsrO1xuICAgICAgICBnZW4oYFxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoJHtjdXJyZW50SW5wdXR9KSkge1xuICAgICAgICAke2N1cnJlbnRPdXRwdXR9ID0gW107XG4gICAgICAgIGZvciAobGV0ICR7aW5kZXh9ID0gMDsgJHtpbmRleH0gPCAke2N1cnJlbnRJbnB1dH0ubGVuZ3RoOyArKyR7aW5kZXh9KSB7XG4gICAgICAgICAgY29uc3QgJHtoYXNWYWx1ZU5hbWV9ID1cbiAgICAgICAgICAke2dldE9iamVjdFBhdGgoc3ViQ29udGV4dC5pbnB1dFBhdGgpfSAhPT0gdW5kZWZpbmVkO1xuICAgICAgICAgICR7Z2VuZXJhdGVJbnB1dChzdWJDb250ZXh0LCB2YXJUeXBlLm9mVHlwZSwgdmFyTmFtZSwgaGFzVmFsdWVOYW1lLCB1bmRlZmluZWQsIGZhbHNlKX1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJHtnZW5lcmF0ZUlucHV0KGNvbnRleHQsIHZhclR5cGUub2ZUeXBlLCB2YXJOYW1lLCBoYXNWYWx1ZU5hbWUsIHVuZGVmaW5lZCwgdHJ1ZSl9XG4gICAgICB9XG4gICAgYCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCgwLCBncmFwaHFsXzEuaXNJbnB1dFR5cGUpKHZhclR5cGUpKSB7XG4gICAgICAgIGdlbihgXG4gICAgICBpZiAodHlwZW9mICR7Y3VycmVudElucHV0fSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgZXJyb3JzLnB1c2gobmV3IEdyYXBoUUxKSVRFcnJvcignVmFyaWFibGUgXCIkJHt2YXJOYW1lfVwiIGdvdCBpbnZhbGlkIHZhbHVlICcgK1xuICAgICAgICBpbnNwZWN0KCR7Y3VycmVudElucHV0fSkgKyBcIjsgXCIgK1xuICAgICAgICAnRXhwZWN0ZWQgdHlwZSAke3ZhclR5cGUubmFtZX0gdG8gYmUgYW4gb2JqZWN0LicsICR7ZXJyb3JMb2NhdGlvbn0pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICR7Y3VycmVudE91dHB1dH0gPSB7fTtcbiAgICBgKTtcbiAgICAgICAgY29uc3QgZmllbGRzID0gdmFyVHlwZS5nZXRGaWVsZHMoKTtcbiAgICAgICAgY29uc3QgYWxsb3dlZEZpZWxkcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIE9iamVjdC52YWx1ZXMoZmllbGRzKSkge1xuICAgICAgICAgICAgY29uc3Qgc3ViQ29udGV4dCA9IGNyZWF0ZVN1YkNvbXBpbGF0aW9uQ29udGV4dChjb250ZXh0KTtcbiAgICAgICAgICAgIGFsbG93ZWRGaWVsZHMucHVzaChmaWVsZC5uYW1lKTtcbiAgICAgICAgICAgIGNvbnN0IGhhc1ZhbHVlTmFtZSA9IGhhc1ZhbHVlKCgwLCBhc3RfMS5hZGRQYXRoKShzdWJDb250ZXh0LmlucHV0UGF0aCwgZmllbGQubmFtZSkpO1xuICAgICAgICAgICAgZ2VuKGBcbiAgICAgICAgY29uc3QgJHtoYXNWYWx1ZU5hbWV9ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKFxuICAgICAgICAgICR7Z2V0T2JqZWN0UGF0aChzdWJDb250ZXh0LmlucHV0UGF0aCl9LCBcIiR7ZmllbGQubmFtZX1cIlxuICAgICAgICApO1xuICAgICAgYCk7XG4gICAgICAgICAgICBzdWJDb250ZXh0LmlucHV0UGF0aCA9ICgwLCBhc3RfMS5hZGRQYXRoKShzdWJDb250ZXh0LmlucHV0UGF0aCwgZmllbGQubmFtZSk7XG4gICAgICAgICAgICBzdWJDb250ZXh0LnJlc3BvbnNlUGF0aCA9ICgwLCBhc3RfMS5hZGRQYXRoKShzdWJDb250ZXh0LnJlc3BvbnNlUGF0aCwgZmllbGQubmFtZSk7XG4gICAgICAgICAgICBzdWJDb250ZXh0LmVycm9yTWVzc2FnZSA9IGAnVmFyaWFibGUgXCIkJHt2YXJOYW1lfVwiIGdvdCBpbnZhbGlkIHZhbHVlICcgKyBpbnNwZWN0KCR7Y3VycmVudElucHV0fSkgKyAnOyAnYDtcbiAgICAgICAgICAgIGdlbihgXG4gICAgICAgICR7Z2VuZXJhdGVJbnB1dChzdWJDb250ZXh0LCBmaWVsZC50eXBlLCBmaWVsZC5uYW1lLCBoYXNWYWx1ZU5hbWUsIGZpZWxkLmRlZmF1bHRWYWx1ZSwgZmFsc2UpfVxuICAgICAgYCk7XG4gICAgICAgIH1cbiAgICAgICAgZ2VuKGBcbiAgICAgIGNvbnN0IGFsbG93ZWRGaWVsZHMgPSAke0pTT04uc3RyaW5naWZ5KGFsbG93ZWRGaWVsZHMpfTtcbiAgICAgIGZvciAoY29uc3QgZmllbGROYW1lIG9mIE9iamVjdC5rZXlzKCR7Y3VycmVudElucHV0fSkpIHtcbiAgICAgICAgaWYgKCFhbGxvd2VkRmllbGRzLmluY2x1ZGVzKGZpZWxkTmFtZSkpIHtcbiAgICAgICAgICBlcnJvcnMucHVzaChuZXcgR3JhcGhRTEpJVEVycm9yKCdWYXJpYWJsZSBcIiQke3Zhck5hbWV9XCIgZ290IGludmFsaWQgdmFsdWUgJyArXG4gICAgICAgICAgICBpbnNwZWN0KCR7Y3VycmVudElucHV0fSkgKyBcIjsgXCIgK1xuICAgICAgICAgICAgJ0ZpZWxkIFwiJyArIGZpZWxkTmFtZSArICdcIiBpcyBub3QgZGVmaW5lZCBieSB0eXBlICR7dmFyVHlwZS5uYW1lfS4nLCAke2Vycm9yTG9jYXRpb259KSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9YCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCBsaW5lICovXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5rbm93biB0eXBlOiAke3ZhclR5cGV9YCk7XG4gICAgfVxuICAgIGlmICh3cmFwSW5MaXN0KSB7XG4gICAgICAgIGdlbihgJHtjdXJyZW50T3V0cHV0fSA9IFske2N1cnJlbnRPdXRwdXR9XTtgKTtcbiAgICB9XG4gICAgZ2VuKGB9YCk7XG4gICAgcmV0dXJuIGdlbi50b1N0cmluZygpO1xufVxuZnVuY3Rpb24gaGFzVmFsdWUocGF0aCkge1xuICAgIGNvbnN0IGZsYXR0ZW5lZCA9IFtdO1xuICAgIGxldCBjdXJyID0gcGF0aDtcbiAgICB3aGlsZSAoY3Vycikge1xuICAgICAgICBmbGF0dGVuZWQucHVzaChjdXJyLmtleSk7XG4gICAgICAgIGN1cnIgPSBjdXJyLnByZXY7XG4gICAgfVxuICAgIHJldHVybiBgaGFzVmFsdWUke2ZsYXR0ZW5lZC5qb2luKFwiX1wiKX1gO1xufVxuZnVuY3Rpb24gcHJpbnRFcnJvckxvY2F0aW9uKGxvY2F0aW9uKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGxvY2F0aW9uKTtcbn1cbmZ1bmN0aW9uIGdldE9iamVjdFBhdGgocGF0aCkge1xuICAgIGNvbnN0IGZsYXR0ZW5lZCA9IFtdO1xuICAgIGxldCBjdXJyID0gcGF0aDtcbiAgICB3aGlsZSAoY3Vycikge1xuICAgICAgICBmbGF0dGVuZWQudW5zaGlmdCh7IGtleTogY3Vyci5rZXksIHR5cGU6IGN1cnIudHlwZSB9KTtcbiAgICAgICAgY3VyciA9IGN1cnIucHJldjtcbiAgICB9XG4gICAgbGV0IG5hbWUgPSBmbGF0dGVuZWRbMF0ua2V5O1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgZmxhdHRlbmVkLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIG5hbWUgKz1cbiAgICAgICAgICAgIGZsYXR0ZW5lZFtpXS50eXBlID09PSBcImxpdGVyYWxcIlxuICAgICAgICAgICAgICAgID8gYFtcIiR7ZmxhdHRlbmVkW2ldLmtleX1cIl1gXG4gICAgICAgICAgICAgICAgOiBgWyR7ZmxhdHRlbmVkW2ldLmtleX1dYDtcbiAgICB9XG4gICAgcmV0dXJuIG5hbWU7XG59XG5mdW5jdGlvbiBwcmludE9iamVjdFBhdGgocGF0aCkge1xuICAgIGNvbnN0IGZsYXR0ZW5lZCA9IFtdO1xuICAgIGxldCBjdXJyID0gcGF0aDtcbiAgICB3aGlsZSAoY3Vycikge1xuICAgICAgICBmbGF0dGVuZWQudW5zaGlmdCh7IGtleTogY3Vyci5rZXksIHR5cGU6IGN1cnIudHlwZSB9KTtcbiAgICAgICAgY3VyciA9IGN1cnIucHJldjtcbiAgICB9XG4gICAgY29uc3QgaW5pdGlhbEluZGV4ID0gTWF0aC5taW4oZmxhdHRlbmVkLmxlbmd0aCAtIDEsIDEpO1xuICAgIGxldCBuYW1lID0gXCJ2YWx1ZVwiO1xuICAgIGZvciAobGV0IGkgPSBpbml0aWFsSW5kZXggKyAxOyBpIDwgZmxhdHRlbmVkLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIG5hbWUgKz1cbiAgICAgICAgICAgIGZsYXR0ZW5lZFtpXS50eXBlID09PSBcImxpdGVyYWxcIlxuICAgICAgICAgICAgICAgID8gYC4ke2ZsYXR0ZW5lZFtpXS5rZXl9YFxuICAgICAgICAgICAgICAgIDogYFskXFx7JHtmbGF0dGVuZWRbaV0ua2V5fX1dYDtcbiAgICB9XG4gICAgcmV0dXJuIG5hbWU7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD12YXJpYWJsZXMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/graphql-jit/dist/esm/variables.js\n");

/***/ })

};
;