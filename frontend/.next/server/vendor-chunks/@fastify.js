"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@fastify";
exports.ids = ["vendor-chunks/@fastify"];
exports.modules = {

/***/ "(ssr)/../node_modules/@fastify/merge-json-schemas/index.js":
/*!************************************************************!*\
  !*** ../node_modules/@fastify/merge-json-schemas/index.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst deepEqual = __webpack_require__(/*! fast-deep-equal */ \"(ssr)/../node_modules/fast-deep-equal/index.js\")\nconst resolvers = __webpack_require__(/*! ./lib/resolvers */ \"(ssr)/../node_modules/@fastify/merge-json-schemas/lib/resolvers.js\")\nconst errors = __webpack_require__(/*! ./lib/errors */ \"(ssr)/../node_modules/@fastify/merge-json-schemas/lib/errors.js\")\n\nconst keywordsResolvers = {\n  $id: resolvers.skip,\n  type: resolvers.hybridArraysIntersection,\n  enum: resolvers.arraysIntersection,\n  minLength: resolvers.maxNumber,\n  maxLength: resolvers.minNumber,\n  minimum: resolvers.maxNumber,\n  maximum: resolvers.minNumber,\n  multipleOf: resolvers.commonMultiple,\n  exclusiveMinimum: resolvers.maxNumber,\n  exclusiveMaximum: resolvers.minNumber,\n  minItems: resolvers.maxNumber,\n  maxItems: resolvers.minNumber,\n  maxProperties: resolvers.minNumber,\n  minProperties: resolvers.maxNumber,\n  const: resolvers.allEqual,\n  default: resolvers.allEqual,\n  format: resolvers.allEqual,\n  required: resolvers.arraysUnion,\n  properties: mergeProperties,\n  patternProperties: mergeObjects,\n  additionalProperties: mergeSchemasResolver,\n  items: mergeItems,\n  additionalItems: mergeAdditionalItems,\n  definitions: mergeObjects,\n  $defs: mergeObjects,\n  nullable: resolvers.booleanAnd,\n  oneOf: mergeOneOf,\n  anyOf: mergeOneOf,\n  allOf: resolvers.arraysUnion,\n  not: mergeSchemasResolver,\n  if: mergeIfThenElseSchemas,\n  then: resolvers.skip,\n  else: resolvers.skip,\n  dependencies: mergeDependencies,\n  dependentRequired: mergeDependencies,\n  dependentSchemas: mergeObjects,\n  propertyNames: mergeSchemasResolver,\n  uniqueItems: resolvers.booleanOr,\n  contains: mergeSchemasResolver\n}\n\nfunction mergeSchemasResolver (keyword, values, mergedSchema, schemas, options) {\n  mergedSchema[keyword] = _mergeSchemas(values, options)\n}\n\nfunction cartesianProduct (arrays) {\n  let result = [[]]\n\n  for (const array of arrays) {\n    const temp = []\n    for (const x of result) {\n      for (const y of array) {\n        temp.push([...x, y])\n      }\n    }\n    result = temp\n  }\n\n  return result\n}\n\nfunction mergeOneOf (keyword, values, mergedSchema, schemas, options) {\n  if (values.length === 1) {\n    mergedSchema[keyword] = values[0]\n    return\n  }\n\n  const product = cartesianProduct(values)\n  const mergedOneOf = []\n  for (const combination of product) {\n    try {\n      const mergedSchema = _mergeSchemas(combination, options)\n      if (mergedSchema !== undefined) {\n        mergedOneOf.push(mergedSchema)\n      }\n    } catch (error) {\n      // If this combination is not valid, we can ignore it.\n      if (error instanceof errors.MergeError) continue\n      throw error\n    }\n  }\n  mergedSchema[keyword] = mergedOneOf\n}\n\nfunction getSchemaForItem (schema, index) {\n  const { items, additionalItems } = schema\n\n  if (Array.isArray(items)) {\n    if (index < items.length) {\n      return items[index]\n    }\n    return additionalItems\n  }\n\n  if (items !== undefined) {\n    return items\n  }\n\n  return additionalItems\n}\n\nfunction mergeItems (keyword, values, mergedSchema, schemas, options) {\n  let maxArrayItemsLength = 0\n  for (const itemsSchema of values) {\n    if (Array.isArray(itemsSchema)) {\n      maxArrayItemsLength = Math.max(maxArrayItemsLength, itemsSchema.length)\n    }\n  }\n\n  if (maxArrayItemsLength === 0) {\n    mergedSchema[keyword] = _mergeSchemas(values, options)\n    return\n  }\n\n  const mergedItemsSchemas = []\n  for (let i = 0; i < maxArrayItemsLength; i++) {\n    const indexItemSchemas = []\n    for (const schema of schemas) {\n      const itemSchema = getSchemaForItem(schema, i)\n      if (itemSchema !== undefined) {\n        indexItemSchemas.push(itemSchema)\n      }\n    }\n    mergedItemsSchemas[i] = _mergeSchemas(indexItemSchemas, options)\n  }\n  mergedSchema[keyword] = mergedItemsSchemas\n}\n\nfunction mergeAdditionalItems (keyword, values, mergedSchema, schemas, options) {\n  let hasArrayItems = false\n  for (const schema of schemas) {\n    if (Array.isArray(schema.items)) {\n      hasArrayItems = true\n      break\n    }\n  }\n\n  if (!hasArrayItems) {\n    mergedSchema[keyword] = _mergeSchemas(values, options)\n    return\n  }\n\n  const mergedAdditionalItemsSchemas = []\n  for (const schema of schemas) {\n    let additionalItemsSchema = schema.additionalItems\n    if (\n      additionalItemsSchema === undefined &&\n      !Array.isArray(schema.items)\n    ) {\n      additionalItemsSchema = schema.items\n    }\n    if (additionalItemsSchema !== undefined) {\n      mergedAdditionalItemsSchemas.push(additionalItemsSchema)\n    }\n  }\n\n  mergedSchema[keyword] = _mergeSchemas(mergedAdditionalItemsSchemas, options)\n}\n\nfunction getSchemaForProperty (schema, propertyName) {\n  const { properties, patternProperties, additionalProperties } = schema\n\n  if (properties?.[propertyName] !== undefined) {\n    return properties[propertyName]\n  }\n\n  for (const pattern of Object.keys(patternProperties ?? {})) {\n    const regexp = new RegExp(pattern)\n    if (regexp.test(propertyName)) {\n      return patternProperties[pattern]\n    }\n  }\n\n  return additionalProperties\n}\n\nfunction mergeProperties (keyword, values, mergedSchema, schemas, options) {\n  const foundProperties = {}\n  for (const currentSchema of schemas) {\n    const properties = currentSchema.properties ?? {}\n    for (const propertyName of Object.keys(properties)) {\n      if (foundProperties[propertyName] !== undefined) continue\n\n      const propertySchema = properties[propertyName]\n      foundProperties[propertyName] = [propertySchema]\n\n      for (const anotherSchema of schemas) {\n        if (currentSchema === anotherSchema) continue\n\n        const propertySchema = getSchemaForProperty(anotherSchema, propertyName)\n        if (propertySchema !== undefined) {\n          foundProperties[propertyName].push(propertySchema)\n        }\n      }\n    }\n  }\n\n  const mergedProperties = {}\n  for (const property of Object.keys(foundProperties)) {\n    const propertySchemas = foundProperties[property]\n    mergedProperties[property] = _mergeSchemas(propertySchemas, options)\n  }\n  mergedSchema[keyword] = mergedProperties\n}\n\nfunction mergeObjects (keyword, values, mergedSchema, schemas, options) {\n  const objectsProperties = {}\n\n  for (const properties of values) {\n    for (const propertyName of Object.keys(properties)) {\n      if (objectsProperties[propertyName] === undefined) {\n        objectsProperties[propertyName] = []\n      }\n      objectsProperties[propertyName].push(properties[propertyName])\n    }\n  }\n\n  const mergedProperties = {}\n  for (const propertyName of Object.keys(objectsProperties)) {\n    const propertySchemas = objectsProperties[propertyName]\n    const mergedPropertySchema = _mergeSchemas(propertySchemas, options)\n    mergedProperties[propertyName] = mergedPropertySchema\n  }\n\n  mergedSchema[keyword] = mergedProperties\n}\n\nfunction mergeIfThenElseSchemas (keyword, values, mergedSchema, schemas, options) {\n  for (let i = 0; i < schemas.length; i++) {\n    const subSchema = {\n      if: schemas[i].if,\n      then: schemas[i].then,\n      else: schemas[i].else\n    }\n\n    if (subSchema.if === undefined) continue\n\n    if (mergedSchema.if === undefined) {\n      mergedSchema.if = subSchema.if\n      if (subSchema.then !== undefined) {\n        mergedSchema.then = subSchema.then\n      }\n      if (subSchema.else !== undefined) {\n        mergedSchema.else = subSchema.else\n      }\n      continue\n    }\n\n    if (mergedSchema.then !== undefined) {\n      mergedSchema.then = _mergeSchemas([mergedSchema.then, subSchema], options)\n    }\n    if (mergedSchema.else !== undefined) {\n      mergedSchema.else = _mergeSchemas([mergedSchema.else, subSchema], options)\n    }\n  }\n}\n\nfunction mergeDependencies (keyword, values, mergedSchema) {\n  const mergedDependencies = {}\n  for (const dependencies of values) {\n    for (const propertyName of Object.keys(dependencies)) {\n      if (mergedDependencies[propertyName] === undefined) {\n        mergedDependencies[propertyName] = []\n      }\n      const mergedPropertyDependencies = mergedDependencies[propertyName]\n      for (const propertyDependency of dependencies[propertyName]) {\n        if (!mergedPropertyDependencies.includes(propertyDependency)) {\n          mergedPropertyDependencies.push(propertyDependency)\n        }\n      }\n    }\n  }\n  mergedSchema[keyword] = mergedDependencies\n}\n\nfunction _mergeSchemas (schemas, options) {\n  if (schemas.length === 0) return {}\n  if (schemas.length === 1) return schemas[0]\n\n  const mergedSchema = {}\n  const keywords = {}\n\n  let allSchemasAreTrue = true\n\n  for (const schema of schemas) {\n    if (schema === false) return false\n    if (schema === true) continue\n    allSchemasAreTrue = false\n\n    for (const keyword of Object.keys(schema)) {\n      if (keywords[keyword] === undefined) {\n        keywords[keyword] = []\n      }\n      keywords[keyword].push(schema[keyword])\n    }\n  }\n\n  if (allSchemasAreTrue) return true\n\n  for (const keyword of Object.keys(keywords)) {\n    const keywordValues = keywords[keyword]\n    const resolver = options.resolvers[keyword] ?? options.defaultResolver\n    resolver(keyword, keywordValues, mergedSchema, schemas, options)\n  }\n\n  return mergedSchema\n}\n\nfunction defaultResolver (keyword, values, mergedSchema, schemas, options) {\n  const onConflict = options.onConflict ?? 'throw'\n\n  if (values.length === 1 || onConflict === 'first') {\n    mergedSchema[keyword] = values[0]\n    return\n  }\n\n  let allValuesEqual = true\n  for (let i = 1; i < values.length; i++) {\n    if (!deepEqual(values[i], values[0])) {\n      allValuesEqual = false\n      break\n    }\n  }\n\n  if (allValuesEqual) {\n    mergedSchema[keyword] = values[0]\n    return\n  }\n\n  if (onConflict === 'throw') {\n    throw new errors.ResolverNotFoundError(keyword, values)\n  }\n  if (onConflict === 'skip') {\n    return\n  }\n  throw new errors.InvalidOnConflictOptionError(onConflict)\n}\n\nfunction mergeSchemas (schemas, options = {}) {\n  if (options.defaultResolver === undefined) {\n    options.defaultResolver = defaultResolver\n  }\n\n  options.resolvers = { ...keywordsResolvers, ...options.resolvers }\n\n  const mergedSchema = _mergeSchemas(schemas, options)\n  return mergedSchema\n}\n\nmodule.exports = { mergeSchemas, keywordsResolvers, defaultResolver, ...errors }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BmYXN0aWZ5L21lcmdlLWpzb24tc2NoZW1hcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixrQkFBa0IsbUJBQU8sQ0FBQyx1RUFBaUI7QUFDM0Msa0JBQWtCLG1CQUFPLENBQUMsMkZBQWlCO0FBQzNDLGVBQWUsbUJBQU8sQ0FBQyxxRkFBYzs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLHlCQUF5Qjs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLHlCQUF5QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFVBQVUsc0RBQXNEOztBQUVoRTtBQUNBO0FBQ0E7O0FBRUEsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixvQkFBb0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBOztBQUVBLHdCQUF3Qjs7QUFFeEI7QUFDQTtBQUNBOztBQUVBLG1CQUFtQiIsInNvdXJjZXMiOlsid2VicGFjazovL2xlZGdpdHkteWllbGQtZnJvbnRlbmQvLi4vbm9kZV9tb2R1bGVzL0BmYXN0aWZ5L21lcmdlLWpzb24tc2NoZW1hcy9pbmRleC5qcz82ODE2Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBkZWVwRXF1YWwgPSByZXF1aXJlKCdmYXN0LWRlZXAtZXF1YWwnKVxuY29uc3QgcmVzb2x2ZXJzID0gcmVxdWlyZSgnLi9saWIvcmVzb2x2ZXJzJylcbmNvbnN0IGVycm9ycyA9IHJlcXVpcmUoJy4vbGliL2Vycm9ycycpXG5cbmNvbnN0IGtleXdvcmRzUmVzb2x2ZXJzID0ge1xuICAkaWQ6IHJlc29sdmVycy5za2lwLFxuICB0eXBlOiByZXNvbHZlcnMuaHlicmlkQXJyYXlzSW50ZXJzZWN0aW9uLFxuICBlbnVtOiByZXNvbHZlcnMuYXJyYXlzSW50ZXJzZWN0aW9uLFxuICBtaW5MZW5ndGg6IHJlc29sdmVycy5tYXhOdW1iZXIsXG4gIG1heExlbmd0aDogcmVzb2x2ZXJzLm1pbk51bWJlcixcbiAgbWluaW11bTogcmVzb2x2ZXJzLm1heE51bWJlcixcbiAgbWF4aW11bTogcmVzb2x2ZXJzLm1pbk51bWJlcixcbiAgbXVsdGlwbGVPZjogcmVzb2x2ZXJzLmNvbW1vbk11bHRpcGxlLFxuICBleGNsdXNpdmVNaW5pbXVtOiByZXNvbHZlcnMubWF4TnVtYmVyLFxuICBleGNsdXNpdmVNYXhpbXVtOiByZXNvbHZlcnMubWluTnVtYmVyLFxuICBtaW5JdGVtczogcmVzb2x2ZXJzLm1heE51bWJlcixcbiAgbWF4SXRlbXM6IHJlc29sdmVycy5taW5OdW1iZXIsXG4gIG1heFByb3BlcnRpZXM6IHJlc29sdmVycy5taW5OdW1iZXIsXG4gIG1pblByb3BlcnRpZXM6IHJlc29sdmVycy5tYXhOdW1iZXIsXG4gIGNvbnN0OiByZXNvbHZlcnMuYWxsRXF1YWwsXG4gIGRlZmF1bHQ6IHJlc29sdmVycy5hbGxFcXVhbCxcbiAgZm9ybWF0OiByZXNvbHZlcnMuYWxsRXF1YWwsXG4gIHJlcXVpcmVkOiByZXNvbHZlcnMuYXJyYXlzVW5pb24sXG4gIHByb3BlcnRpZXM6IG1lcmdlUHJvcGVydGllcyxcbiAgcGF0dGVyblByb3BlcnRpZXM6IG1lcmdlT2JqZWN0cyxcbiAgYWRkaXRpb25hbFByb3BlcnRpZXM6IG1lcmdlU2NoZW1hc1Jlc29sdmVyLFxuICBpdGVtczogbWVyZ2VJdGVtcyxcbiAgYWRkaXRpb25hbEl0ZW1zOiBtZXJnZUFkZGl0aW9uYWxJdGVtcyxcbiAgZGVmaW5pdGlvbnM6IG1lcmdlT2JqZWN0cyxcbiAgJGRlZnM6IG1lcmdlT2JqZWN0cyxcbiAgbnVsbGFibGU6IHJlc29sdmVycy5ib29sZWFuQW5kLFxuICBvbmVPZjogbWVyZ2VPbmVPZixcbiAgYW55T2Y6IG1lcmdlT25lT2YsXG4gIGFsbE9mOiByZXNvbHZlcnMuYXJyYXlzVW5pb24sXG4gIG5vdDogbWVyZ2VTY2hlbWFzUmVzb2x2ZXIsXG4gIGlmOiBtZXJnZUlmVGhlbkVsc2VTY2hlbWFzLFxuICB0aGVuOiByZXNvbHZlcnMuc2tpcCxcbiAgZWxzZTogcmVzb2x2ZXJzLnNraXAsXG4gIGRlcGVuZGVuY2llczogbWVyZ2VEZXBlbmRlbmNpZXMsXG4gIGRlcGVuZGVudFJlcXVpcmVkOiBtZXJnZURlcGVuZGVuY2llcyxcbiAgZGVwZW5kZW50U2NoZW1hczogbWVyZ2VPYmplY3RzLFxuICBwcm9wZXJ0eU5hbWVzOiBtZXJnZVNjaGVtYXNSZXNvbHZlcixcbiAgdW5pcXVlSXRlbXM6IHJlc29sdmVycy5ib29sZWFuT3IsXG4gIGNvbnRhaW5zOiBtZXJnZVNjaGVtYXNSZXNvbHZlclxufVxuXG5mdW5jdGlvbiBtZXJnZVNjaGVtYXNSZXNvbHZlciAoa2V5d29yZCwgdmFsdWVzLCBtZXJnZWRTY2hlbWEsIHNjaGVtYXMsIG9wdGlvbnMpIHtcbiAgbWVyZ2VkU2NoZW1hW2tleXdvcmRdID0gX21lcmdlU2NoZW1hcyh2YWx1ZXMsIG9wdGlvbnMpXG59XG5cbmZ1bmN0aW9uIGNhcnRlc2lhblByb2R1Y3QgKGFycmF5cykge1xuICBsZXQgcmVzdWx0ID0gW1tdXVxuXG4gIGZvciAoY29uc3QgYXJyYXkgb2YgYXJyYXlzKSB7XG4gICAgY29uc3QgdGVtcCA9IFtdXG4gICAgZm9yIChjb25zdCB4IG9mIHJlc3VsdCkge1xuICAgICAgZm9yIChjb25zdCB5IG9mIGFycmF5KSB7XG4gICAgICAgIHRlbXAucHVzaChbLi4ueCwgeV0pXG4gICAgICB9XG4gICAgfVxuICAgIHJlc3VsdCA9IHRlbXBcbiAgfVxuXG4gIHJldHVybiByZXN1bHRcbn1cblxuZnVuY3Rpb24gbWVyZ2VPbmVPZiAoa2V5d29yZCwgdmFsdWVzLCBtZXJnZWRTY2hlbWEsIHNjaGVtYXMsIG9wdGlvbnMpIHtcbiAgaWYgKHZhbHVlcy5sZW5ndGggPT09IDEpIHtcbiAgICBtZXJnZWRTY2hlbWFba2V5d29yZF0gPSB2YWx1ZXNbMF1cbiAgICByZXR1cm5cbiAgfVxuXG4gIGNvbnN0IHByb2R1Y3QgPSBjYXJ0ZXNpYW5Qcm9kdWN0KHZhbHVlcylcbiAgY29uc3QgbWVyZ2VkT25lT2YgPSBbXVxuICBmb3IgKGNvbnN0IGNvbWJpbmF0aW9uIG9mIHByb2R1Y3QpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgbWVyZ2VkU2NoZW1hID0gX21lcmdlU2NoZW1hcyhjb21iaW5hdGlvbiwgb3B0aW9ucylcbiAgICAgIGlmIChtZXJnZWRTY2hlbWEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBtZXJnZWRPbmVPZi5wdXNoKG1lcmdlZFNjaGVtYSlcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gSWYgdGhpcyBjb21iaW5hdGlvbiBpcyBub3QgdmFsaWQsIHdlIGNhbiBpZ25vcmUgaXQuXG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBlcnJvcnMuTWVyZ2VFcnJvcikgY29udGludWVcbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG4gIG1lcmdlZFNjaGVtYVtrZXl3b3JkXSA9IG1lcmdlZE9uZU9mXG59XG5cbmZ1bmN0aW9uIGdldFNjaGVtYUZvckl0ZW0gKHNjaGVtYSwgaW5kZXgpIHtcbiAgY29uc3QgeyBpdGVtcywgYWRkaXRpb25hbEl0ZW1zIH0gPSBzY2hlbWFcblxuICBpZiAoQXJyYXkuaXNBcnJheShpdGVtcykpIHtcbiAgICBpZiAoaW5kZXggPCBpdGVtcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBpdGVtc1tpbmRleF1cbiAgICB9XG4gICAgcmV0dXJuIGFkZGl0aW9uYWxJdGVtc1xuICB9XG5cbiAgaWYgKGl0ZW1zICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gaXRlbXNcbiAgfVxuXG4gIHJldHVybiBhZGRpdGlvbmFsSXRlbXNcbn1cblxuZnVuY3Rpb24gbWVyZ2VJdGVtcyAoa2V5d29yZCwgdmFsdWVzLCBtZXJnZWRTY2hlbWEsIHNjaGVtYXMsIG9wdGlvbnMpIHtcbiAgbGV0IG1heEFycmF5SXRlbXNMZW5ndGggPSAwXG4gIGZvciAoY29uc3QgaXRlbXNTY2hlbWEgb2YgdmFsdWVzKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbXNTY2hlbWEpKSB7XG4gICAgICBtYXhBcnJheUl0ZW1zTGVuZ3RoID0gTWF0aC5tYXgobWF4QXJyYXlJdGVtc0xlbmd0aCwgaXRlbXNTY2hlbWEubGVuZ3RoKVxuICAgIH1cbiAgfVxuXG4gIGlmIChtYXhBcnJheUl0ZW1zTGVuZ3RoID09PSAwKSB7XG4gICAgbWVyZ2VkU2NoZW1hW2tleXdvcmRdID0gX21lcmdlU2NoZW1hcyh2YWx1ZXMsIG9wdGlvbnMpXG4gICAgcmV0dXJuXG4gIH1cblxuICBjb25zdCBtZXJnZWRJdGVtc1NjaGVtYXMgPSBbXVxuICBmb3IgKGxldCBpID0gMDsgaSA8IG1heEFycmF5SXRlbXNMZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGluZGV4SXRlbVNjaGVtYXMgPSBbXVxuICAgIGZvciAoY29uc3Qgc2NoZW1hIG9mIHNjaGVtYXMpIHtcbiAgICAgIGNvbnN0IGl0ZW1TY2hlbWEgPSBnZXRTY2hlbWFGb3JJdGVtKHNjaGVtYSwgaSlcbiAgICAgIGlmIChpdGVtU2NoZW1hICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaW5kZXhJdGVtU2NoZW1hcy5wdXNoKGl0ZW1TY2hlbWEpXG4gICAgICB9XG4gICAgfVxuICAgIG1lcmdlZEl0ZW1zU2NoZW1hc1tpXSA9IF9tZXJnZVNjaGVtYXMoaW5kZXhJdGVtU2NoZW1hcywgb3B0aW9ucylcbiAgfVxuICBtZXJnZWRTY2hlbWFba2V5d29yZF0gPSBtZXJnZWRJdGVtc1NjaGVtYXNcbn1cblxuZnVuY3Rpb24gbWVyZ2VBZGRpdGlvbmFsSXRlbXMgKGtleXdvcmQsIHZhbHVlcywgbWVyZ2VkU2NoZW1hLCBzY2hlbWFzLCBvcHRpb25zKSB7XG4gIGxldCBoYXNBcnJheUl0ZW1zID0gZmFsc2VcbiAgZm9yIChjb25zdCBzY2hlbWEgb2Ygc2NoZW1hcykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHNjaGVtYS5pdGVtcykpIHtcbiAgICAgIGhhc0FycmF5SXRlbXMgPSB0cnVlXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICghaGFzQXJyYXlJdGVtcykge1xuICAgIG1lcmdlZFNjaGVtYVtrZXl3b3JkXSA9IF9tZXJnZVNjaGVtYXModmFsdWVzLCBvcHRpb25zKVxuICAgIHJldHVyblxuICB9XG5cbiAgY29uc3QgbWVyZ2VkQWRkaXRpb25hbEl0ZW1zU2NoZW1hcyA9IFtdXG4gIGZvciAoY29uc3Qgc2NoZW1hIG9mIHNjaGVtYXMpIHtcbiAgICBsZXQgYWRkaXRpb25hbEl0ZW1zU2NoZW1hID0gc2NoZW1hLmFkZGl0aW9uYWxJdGVtc1xuICAgIGlmIChcbiAgICAgIGFkZGl0aW9uYWxJdGVtc1NjaGVtYSA9PT0gdW5kZWZpbmVkICYmXG4gICAgICAhQXJyYXkuaXNBcnJheShzY2hlbWEuaXRlbXMpXG4gICAgKSB7XG4gICAgICBhZGRpdGlvbmFsSXRlbXNTY2hlbWEgPSBzY2hlbWEuaXRlbXNcbiAgICB9XG4gICAgaWYgKGFkZGl0aW9uYWxJdGVtc1NjaGVtYSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBtZXJnZWRBZGRpdGlvbmFsSXRlbXNTY2hlbWFzLnB1c2goYWRkaXRpb25hbEl0ZW1zU2NoZW1hKVxuICAgIH1cbiAgfVxuXG4gIG1lcmdlZFNjaGVtYVtrZXl3b3JkXSA9IF9tZXJnZVNjaGVtYXMobWVyZ2VkQWRkaXRpb25hbEl0ZW1zU2NoZW1hcywgb3B0aW9ucylcbn1cblxuZnVuY3Rpb24gZ2V0U2NoZW1hRm9yUHJvcGVydHkgKHNjaGVtYSwgcHJvcGVydHlOYW1lKSB7XG4gIGNvbnN0IHsgcHJvcGVydGllcywgcGF0dGVyblByb3BlcnRpZXMsIGFkZGl0aW9uYWxQcm9wZXJ0aWVzIH0gPSBzY2hlbWFcblxuICBpZiAocHJvcGVydGllcz8uW3Byb3BlcnR5TmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBwcm9wZXJ0aWVzW3Byb3BlcnR5TmFtZV1cbiAgfVxuXG4gIGZvciAoY29uc3QgcGF0dGVybiBvZiBPYmplY3Qua2V5cyhwYXR0ZXJuUHJvcGVydGllcyA/PyB7fSkpIHtcbiAgICBjb25zdCByZWdleHAgPSBuZXcgUmVnRXhwKHBhdHRlcm4pXG4gICAgaWYgKHJlZ2V4cC50ZXN0KHByb3BlcnR5TmFtZSkpIHtcbiAgICAgIHJldHVybiBwYXR0ZXJuUHJvcGVydGllc1twYXR0ZXJuXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBhZGRpdGlvbmFsUHJvcGVydGllc1xufVxuXG5mdW5jdGlvbiBtZXJnZVByb3BlcnRpZXMgKGtleXdvcmQsIHZhbHVlcywgbWVyZ2VkU2NoZW1hLCBzY2hlbWFzLCBvcHRpb25zKSB7XG4gIGNvbnN0IGZvdW5kUHJvcGVydGllcyA9IHt9XG4gIGZvciAoY29uc3QgY3VycmVudFNjaGVtYSBvZiBzY2hlbWFzKSB7XG4gICAgY29uc3QgcHJvcGVydGllcyA9IGN1cnJlbnRTY2hlbWEucHJvcGVydGllcyA/PyB7fVxuICAgIGZvciAoY29uc3QgcHJvcGVydHlOYW1lIG9mIE9iamVjdC5rZXlzKHByb3BlcnRpZXMpKSB7XG4gICAgICBpZiAoZm91bmRQcm9wZXJ0aWVzW3Byb3BlcnR5TmFtZV0gIT09IHVuZGVmaW5lZCkgY29udGludWVcblxuICAgICAgY29uc3QgcHJvcGVydHlTY2hlbWEgPSBwcm9wZXJ0aWVzW3Byb3BlcnR5TmFtZV1cbiAgICAgIGZvdW5kUHJvcGVydGllc1twcm9wZXJ0eU5hbWVdID0gW3Byb3BlcnR5U2NoZW1hXVxuXG4gICAgICBmb3IgKGNvbnN0IGFub3RoZXJTY2hlbWEgb2Ygc2NoZW1hcykge1xuICAgICAgICBpZiAoY3VycmVudFNjaGVtYSA9PT0gYW5vdGhlclNjaGVtYSkgY29udGludWVcblxuICAgICAgICBjb25zdCBwcm9wZXJ0eVNjaGVtYSA9IGdldFNjaGVtYUZvclByb3BlcnR5KGFub3RoZXJTY2hlbWEsIHByb3BlcnR5TmFtZSlcbiAgICAgICAgaWYgKHByb3BlcnR5U2NoZW1hICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBmb3VuZFByb3BlcnRpZXNbcHJvcGVydHlOYW1lXS5wdXNoKHByb3BlcnR5U2NoZW1hKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY29uc3QgbWVyZ2VkUHJvcGVydGllcyA9IHt9XG4gIGZvciAoY29uc3QgcHJvcGVydHkgb2YgT2JqZWN0LmtleXMoZm91bmRQcm9wZXJ0aWVzKSkge1xuICAgIGNvbnN0IHByb3BlcnR5U2NoZW1hcyA9IGZvdW5kUHJvcGVydGllc1twcm9wZXJ0eV1cbiAgICBtZXJnZWRQcm9wZXJ0aWVzW3Byb3BlcnR5XSA9IF9tZXJnZVNjaGVtYXMocHJvcGVydHlTY2hlbWFzLCBvcHRpb25zKVxuICB9XG4gIG1lcmdlZFNjaGVtYVtrZXl3b3JkXSA9IG1lcmdlZFByb3BlcnRpZXNcbn1cblxuZnVuY3Rpb24gbWVyZ2VPYmplY3RzIChrZXl3b3JkLCB2YWx1ZXMsIG1lcmdlZFNjaGVtYSwgc2NoZW1hcywgb3B0aW9ucykge1xuICBjb25zdCBvYmplY3RzUHJvcGVydGllcyA9IHt9XG5cbiAgZm9yIChjb25zdCBwcm9wZXJ0aWVzIG9mIHZhbHVlcykge1xuICAgIGZvciAoY29uc3QgcHJvcGVydHlOYW1lIG9mIE9iamVjdC5rZXlzKHByb3BlcnRpZXMpKSB7XG4gICAgICBpZiAob2JqZWN0c1Byb3BlcnRpZXNbcHJvcGVydHlOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9iamVjdHNQcm9wZXJ0aWVzW3Byb3BlcnR5TmFtZV0gPSBbXVxuICAgICAgfVxuICAgICAgb2JqZWN0c1Byb3BlcnRpZXNbcHJvcGVydHlOYW1lXS5wdXNoKHByb3BlcnRpZXNbcHJvcGVydHlOYW1lXSlcbiAgICB9XG4gIH1cblxuICBjb25zdCBtZXJnZWRQcm9wZXJ0aWVzID0ge31cbiAgZm9yIChjb25zdCBwcm9wZXJ0eU5hbWUgb2YgT2JqZWN0LmtleXMob2JqZWN0c1Byb3BlcnRpZXMpKSB7XG4gICAgY29uc3QgcHJvcGVydHlTY2hlbWFzID0gb2JqZWN0c1Byb3BlcnRpZXNbcHJvcGVydHlOYW1lXVxuICAgIGNvbnN0IG1lcmdlZFByb3BlcnR5U2NoZW1hID0gX21lcmdlU2NoZW1hcyhwcm9wZXJ0eVNjaGVtYXMsIG9wdGlvbnMpXG4gICAgbWVyZ2VkUHJvcGVydGllc1twcm9wZXJ0eU5hbWVdID0gbWVyZ2VkUHJvcGVydHlTY2hlbWFcbiAgfVxuXG4gIG1lcmdlZFNjaGVtYVtrZXl3b3JkXSA9IG1lcmdlZFByb3BlcnRpZXNcbn1cblxuZnVuY3Rpb24gbWVyZ2VJZlRoZW5FbHNlU2NoZW1hcyAoa2V5d29yZCwgdmFsdWVzLCBtZXJnZWRTY2hlbWEsIHNjaGVtYXMsIG9wdGlvbnMpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzY2hlbWFzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgc3ViU2NoZW1hID0ge1xuICAgICAgaWY6IHNjaGVtYXNbaV0uaWYsXG4gICAgICB0aGVuOiBzY2hlbWFzW2ldLnRoZW4sXG4gICAgICBlbHNlOiBzY2hlbWFzW2ldLmVsc2VcbiAgICB9XG5cbiAgICBpZiAoc3ViU2NoZW1hLmlmID09PSB1bmRlZmluZWQpIGNvbnRpbnVlXG5cbiAgICBpZiAobWVyZ2VkU2NoZW1hLmlmID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG1lcmdlZFNjaGVtYS5pZiA9IHN1YlNjaGVtYS5pZlxuICAgICAgaWYgKHN1YlNjaGVtYS50aGVuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbWVyZ2VkU2NoZW1hLnRoZW4gPSBzdWJTY2hlbWEudGhlblxuICAgICAgfVxuICAgICAgaWYgKHN1YlNjaGVtYS5lbHNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbWVyZ2VkU2NoZW1hLmVsc2UgPSBzdWJTY2hlbWEuZWxzZVxuICAgICAgfVxuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICBpZiAobWVyZ2VkU2NoZW1hLnRoZW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgbWVyZ2VkU2NoZW1hLnRoZW4gPSBfbWVyZ2VTY2hlbWFzKFttZXJnZWRTY2hlbWEudGhlbiwgc3ViU2NoZW1hXSwgb3B0aW9ucylcbiAgICB9XG4gICAgaWYgKG1lcmdlZFNjaGVtYS5lbHNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIG1lcmdlZFNjaGVtYS5lbHNlID0gX21lcmdlU2NoZW1hcyhbbWVyZ2VkU2NoZW1hLmVsc2UsIHN1YlNjaGVtYV0sIG9wdGlvbnMpXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG1lcmdlRGVwZW5kZW5jaWVzIChrZXl3b3JkLCB2YWx1ZXMsIG1lcmdlZFNjaGVtYSkge1xuICBjb25zdCBtZXJnZWREZXBlbmRlbmNpZXMgPSB7fVxuICBmb3IgKGNvbnN0IGRlcGVuZGVuY2llcyBvZiB2YWx1ZXMpIHtcbiAgICBmb3IgKGNvbnN0IHByb3BlcnR5TmFtZSBvZiBPYmplY3Qua2V5cyhkZXBlbmRlbmNpZXMpKSB7XG4gICAgICBpZiAobWVyZ2VkRGVwZW5kZW5jaWVzW3Byb3BlcnR5TmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBtZXJnZWREZXBlbmRlbmNpZXNbcHJvcGVydHlOYW1lXSA9IFtdXG4gICAgICB9XG4gICAgICBjb25zdCBtZXJnZWRQcm9wZXJ0eURlcGVuZGVuY2llcyA9IG1lcmdlZERlcGVuZGVuY2llc1twcm9wZXJ0eU5hbWVdXG4gICAgICBmb3IgKGNvbnN0IHByb3BlcnR5RGVwZW5kZW5jeSBvZiBkZXBlbmRlbmNpZXNbcHJvcGVydHlOYW1lXSkge1xuICAgICAgICBpZiAoIW1lcmdlZFByb3BlcnR5RGVwZW5kZW5jaWVzLmluY2x1ZGVzKHByb3BlcnR5RGVwZW5kZW5jeSkpIHtcbiAgICAgICAgICBtZXJnZWRQcm9wZXJ0eURlcGVuZGVuY2llcy5wdXNoKHByb3BlcnR5RGVwZW5kZW5jeSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBtZXJnZWRTY2hlbWFba2V5d29yZF0gPSBtZXJnZWREZXBlbmRlbmNpZXNcbn1cblxuZnVuY3Rpb24gX21lcmdlU2NoZW1hcyAoc2NoZW1hcywgb3B0aW9ucykge1xuICBpZiAoc2NoZW1hcy5sZW5ndGggPT09IDApIHJldHVybiB7fVxuICBpZiAoc2NoZW1hcy5sZW5ndGggPT09IDEpIHJldHVybiBzY2hlbWFzWzBdXG5cbiAgY29uc3QgbWVyZ2VkU2NoZW1hID0ge31cbiAgY29uc3Qga2V5d29yZHMgPSB7fVxuXG4gIGxldCBhbGxTY2hlbWFzQXJlVHJ1ZSA9IHRydWVcblxuICBmb3IgKGNvbnN0IHNjaGVtYSBvZiBzY2hlbWFzKSB7XG4gICAgaWYgKHNjaGVtYSA9PT0gZmFsc2UpIHJldHVybiBmYWxzZVxuICAgIGlmIChzY2hlbWEgPT09IHRydWUpIGNvbnRpbnVlXG4gICAgYWxsU2NoZW1hc0FyZVRydWUgPSBmYWxzZVxuXG4gICAgZm9yIChjb25zdCBrZXl3b3JkIG9mIE9iamVjdC5rZXlzKHNjaGVtYSkpIHtcbiAgICAgIGlmIChrZXl3b3Jkc1trZXl3b3JkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGtleXdvcmRzW2tleXdvcmRdID0gW11cbiAgICAgIH1cbiAgICAgIGtleXdvcmRzW2tleXdvcmRdLnB1c2goc2NoZW1hW2tleXdvcmRdKVxuICAgIH1cbiAgfVxuXG4gIGlmIChhbGxTY2hlbWFzQXJlVHJ1ZSkgcmV0dXJuIHRydWVcblxuICBmb3IgKGNvbnN0IGtleXdvcmQgb2YgT2JqZWN0LmtleXMoa2V5d29yZHMpKSB7XG4gICAgY29uc3Qga2V5d29yZFZhbHVlcyA9IGtleXdvcmRzW2tleXdvcmRdXG4gICAgY29uc3QgcmVzb2x2ZXIgPSBvcHRpb25zLnJlc29sdmVyc1trZXl3b3JkXSA/PyBvcHRpb25zLmRlZmF1bHRSZXNvbHZlclxuICAgIHJlc29sdmVyKGtleXdvcmQsIGtleXdvcmRWYWx1ZXMsIG1lcmdlZFNjaGVtYSwgc2NoZW1hcywgb3B0aW9ucylcbiAgfVxuXG4gIHJldHVybiBtZXJnZWRTY2hlbWFcbn1cblxuZnVuY3Rpb24gZGVmYXVsdFJlc29sdmVyIChrZXl3b3JkLCB2YWx1ZXMsIG1lcmdlZFNjaGVtYSwgc2NoZW1hcywgb3B0aW9ucykge1xuICBjb25zdCBvbkNvbmZsaWN0ID0gb3B0aW9ucy5vbkNvbmZsaWN0ID8/ICd0aHJvdydcblxuICBpZiAodmFsdWVzLmxlbmd0aCA9PT0gMSB8fCBvbkNvbmZsaWN0ID09PSAnZmlyc3QnKSB7XG4gICAgbWVyZ2VkU2NoZW1hW2tleXdvcmRdID0gdmFsdWVzWzBdXG4gICAgcmV0dXJuXG4gIH1cblxuICBsZXQgYWxsVmFsdWVzRXF1YWwgPSB0cnVlXG4gIGZvciAobGV0IGkgPSAxOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCFkZWVwRXF1YWwodmFsdWVzW2ldLCB2YWx1ZXNbMF0pKSB7XG4gICAgICBhbGxWYWx1ZXNFcXVhbCA9IGZhbHNlXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmIChhbGxWYWx1ZXNFcXVhbCkge1xuICAgIG1lcmdlZFNjaGVtYVtrZXl3b3JkXSA9IHZhbHVlc1swXVxuICAgIHJldHVyblxuICB9XG5cbiAgaWYgKG9uQ29uZmxpY3QgPT09ICd0aHJvdycpIHtcbiAgICB0aHJvdyBuZXcgZXJyb3JzLlJlc29sdmVyTm90Rm91bmRFcnJvcihrZXl3b3JkLCB2YWx1ZXMpXG4gIH1cbiAgaWYgKG9uQ29uZmxpY3QgPT09ICdza2lwJykge1xuICAgIHJldHVyblxuICB9XG4gIHRocm93IG5ldyBlcnJvcnMuSW52YWxpZE9uQ29uZmxpY3RPcHRpb25FcnJvcihvbkNvbmZsaWN0KVxufVxuXG5mdW5jdGlvbiBtZXJnZVNjaGVtYXMgKHNjaGVtYXMsIG9wdGlvbnMgPSB7fSkge1xuICBpZiAob3B0aW9ucy5kZWZhdWx0UmVzb2x2ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgIG9wdGlvbnMuZGVmYXVsdFJlc29sdmVyID0gZGVmYXVsdFJlc29sdmVyXG4gIH1cblxuICBvcHRpb25zLnJlc29sdmVycyA9IHsgLi4ua2V5d29yZHNSZXNvbHZlcnMsIC4uLm9wdGlvbnMucmVzb2x2ZXJzIH1cblxuICBjb25zdCBtZXJnZWRTY2hlbWEgPSBfbWVyZ2VTY2hlbWFzKHNjaGVtYXMsIG9wdGlvbnMpXG4gIHJldHVybiBtZXJnZWRTY2hlbWFcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7IG1lcmdlU2NoZW1hcywga2V5d29yZHNSZXNvbHZlcnMsIGRlZmF1bHRSZXNvbHZlciwgLi4uZXJyb3JzIH1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@fastify/merge-json-schemas/index.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@fastify/merge-json-schemas/lib/errors.js":
/*!*****************************************************************!*\
  !*** ../node_modules/@fastify/merge-json-schemas/lib/errors.js ***!
  \*****************************************************************/
/***/ ((module) => {

eval("\n\nclass MergeError extends Error {\n  constructor (keyword, schemas) {\n    super()\n    this.name = 'JsonSchemaMergeError'\n    this.code = 'JSON_SCHEMA_MERGE_ERROR'\n    this.message = `Failed to merge \"${keyword}\" keyword schemas.`\n    this.schemas = schemas\n  }\n}\n\nclass ResolverNotFoundError extends Error {\n  constructor (keyword, schemas) {\n    super()\n    this.name = 'JsonSchemaMergeError'\n    this.code = 'JSON_SCHEMA_MERGE_ERROR'\n    this.message = `Resolver for \"${keyword}\" keyword not found.`\n    this.schemas = schemas\n  }\n}\n\nclass InvalidOnConflictOptionError extends Error {\n  constructor (onConflict) {\n    super()\n    this.name = 'JsonSchemaMergeError'\n    this.code = 'JSON_SCHEMA_MERGE_ERROR'\n    this.message = `Invalid \"onConflict\" option: \"${onConflict}\".`\n  }\n}\n\nmodule.exports = {\n  MergeError,\n  ResolverNotFoundError,\n  InvalidOnConflictOptionError\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BmYXN0aWZ5L21lcmdlLWpzb24tc2NoZW1hcy9saWIvZXJyb3JzLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsUUFBUTtBQUMvQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxRQUFRO0FBQzVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELFdBQVc7QUFDL0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGVkZ2l0eS15aWVsZC1mcm9udGVuZC8uLi9ub2RlX21vZHVsZXMvQGZhc3RpZnkvbWVyZ2UtanNvbi1zY2hlbWFzL2xpYi9lcnJvcnMuanM/ZGFiZSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY2xhc3MgTWVyZ2VFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IgKGtleXdvcmQsIHNjaGVtYXMpIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5uYW1lID0gJ0pzb25TY2hlbWFNZXJnZUVycm9yJ1xuICAgIHRoaXMuY29kZSA9ICdKU09OX1NDSEVNQV9NRVJHRV9FUlJPUidcbiAgICB0aGlzLm1lc3NhZ2UgPSBgRmFpbGVkIHRvIG1lcmdlIFwiJHtrZXl3b3JkfVwiIGtleXdvcmQgc2NoZW1hcy5gXG4gICAgdGhpcy5zY2hlbWFzID0gc2NoZW1hc1xuICB9XG59XG5cbmNsYXNzIFJlc29sdmVyTm90Rm91bmRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IgKGtleXdvcmQsIHNjaGVtYXMpIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5uYW1lID0gJ0pzb25TY2hlbWFNZXJnZUVycm9yJ1xuICAgIHRoaXMuY29kZSA9ICdKU09OX1NDSEVNQV9NRVJHRV9FUlJPUidcbiAgICB0aGlzLm1lc3NhZ2UgPSBgUmVzb2x2ZXIgZm9yIFwiJHtrZXl3b3JkfVwiIGtleXdvcmQgbm90IGZvdW5kLmBcbiAgICB0aGlzLnNjaGVtYXMgPSBzY2hlbWFzXG4gIH1cbn1cblxuY2xhc3MgSW52YWxpZE9uQ29uZmxpY3RPcHRpb25FcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IgKG9uQ29uZmxpY3QpIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5uYW1lID0gJ0pzb25TY2hlbWFNZXJnZUVycm9yJ1xuICAgIHRoaXMuY29kZSA9ICdKU09OX1NDSEVNQV9NRVJHRV9FUlJPUidcbiAgICB0aGlzLm1lc3NhZ2UgPSBgSW52YWxpZCBcIm9uQ29uZmxpY3RcIiBvcHRpb246IFwiJHtvbkNvbmZsaWN0fVwiLmBcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgTWVyZ2VFcnJvcixcbiAgUmVzb2x2ZXJOb3RGb3VuZEVycm9yLFxuICBJbnZhbGlkT25Db25mbGljdE9wdGlvbkVycm9yXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@fastify/merge-json-schemas/lib/errors.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@fastify/merge-json-schemas/lib/resolvers.js":
/*!********************************************************************!*\
  !*** ../node_modules/@fastify/merge-json-schemas/lib/resolvers.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst deepEqual = __webpack_require__(/*! fast-deep-equal */ \"(ssr)/../node_modules/fast-deep-equal/index.js\")\nconst { MergeError } = __webpack_require__(/*! ./errors */ \"(ssr)/../node_modules/@fastify/merge-json-schemas/lib/errors.js\")\n\nfunction _arraysIntersection (arrays) {\n  let intersection = arrays[0]\n  for (let i = 1; i < arrays.length; i++) {\n    intersection = intersection.filter(\n      value => arrays[i].includes(value)\n    )\n  }\n  return intersection\n}\n\nfunction arraysIntersection (keyword, values, mergedSchema) {\n  const intersection = _arraysIntersection(values)\n  if (intersection.length === 0) {\n    throw new MergeError(keyword, values)\n  }\n  mergedSchema[keyword] = intersection\n}\n\nfunction hybridArraysIntersection (keyword, values, mergedSchema) {\n  for (let i = 0; i < values.length; i++) {\n    if (!Array.isArray(values[i])) {\n      values[i] = [values[i]]\n    }\n  }\n\n  const intersection = _arraysIntersection(values)\n  if (intersection.length === 0) {\n    throw new MergeError(keyword, values)\n  }\n\n  if (intersection.length === 1) {\n    mergedSchema[keyword] = intersection[0]\n  } else {\n    mergedSchema[keyword] = intersection\n  }\n}\n\nfunction arraysUnion (keyword, values, mergedSchema) {\n  const union = []\n\n  for (const array of values) {\n    for (const value of array) {\n      if (!union.includes(value)) {\n        union.push(value)\n      }\n    }\n  }\n\n  mergedSchema[keyword] = union\n}\n\nfunction minNumber (keyword, values, mergedSchema) {\n  mergedSchema[keyword] = Math.min(...values)\n}\n\nfunction maxNumber (keyword, values, mergedSchema) {\n  mergedSchema[keyword] = Math.max(...values)\n}\n\nfunction commonMultiple (keyword, values, mergedSchema) {\n  const gcd = (a, b) => (!b ? a : gcd(b, a % b))\n  const lcm = (a, b) => (a * b) / gcd(a, b)\n\n  let scale = 1\n  for (const value of values) {\n    while (value * scale % 1 !== 0) {\n      scale *= 10\n    }\n  }\n\n  let multiple = values[0] * scale\n  for (const value of values) {\n    multiple = lcm(multiple, value * scale)\n  }\n\n  mergedSchema[keyword] = multiple / scale\n}\n\nfunction allEqual (keyword, values, mergedSchema) {\n  const firstValue = values[0]\n  for (let i = 1; i < values.length; i++) {\n    if (!deepEqual(values[i], firstValue)) {\n      throw new MergeError(keyword, values)\n    }\n  }\n  mergedSchema[keyword] = firstValue\n}\n\nfunction skip () {}\n\nfunction booleanAnd (keyword, values, mergedSchema) {\n  for (const value of values) {\n    if (value === false) {\n      mergedSchema[keyword] = false\n      return\n    }\n  }\n  mergedSchema[keyword] = true\n}\n\nfunction booleanOr (keyword, values, mergedSchema) {\n  for (const value of values) {\n    if (value === true) {\n      mergedSchema[keyword] = true\n      return\n    }\n  }\n  mergedSchema[keyword] = false\n}\n\nmodule.exports = {\n  arraysIntersection,\n  hybridArraysIntersection,\n  arraysUnion,\n  minNumber,\n  maxNumber,\n  commonMultiple,\n  allEqual,\n  booleanAnd,\n  booleanOr,\n  skip\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BmYXN0aWZ5L21lcmdlLWpzb24tc2NoZW1hcy9saWIvcmVzb2x2ZXJzLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLGtCQUFrQixtQkFBTyxDQUFDLHVFQUFpQjtBQUMzQyxRQUFRLGFBQWEsRUFBRSxtQkFBTyxDQUFDLGlGQUFVOztBQUV6QztBQUNBO0FBQ0Esa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sZWRnaXR5LXlpZWxkLWZyb250ZW5kLy4uL25vZGVfbW9kdWxlcy9AZmFzdGlmeS9tZXJnZS1qc29uLXNjaGVtYXMvbGliL3Jlc29sdmVycy5qcz84M2M3Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBkZWVwRXF1YWwgPSByZXF1aXJlKCdmYXN0LWRlZXAtZXF1YWwnKVxuY29uc3QgeyBNZXJnZUVycm9yIH0gPSByZXF1aXJlKCcuL2Vycm9ycycpXG5cbmZ1bmN0aW9uIF9hcnJheXNJbnRlcnNlY3Rpb24gKGFycmF5cykge1xuICBsZXQgaW50ZXJzZWN0aW9uID0gYXJyYXlzWzBdXG4gIGZvciAobGV0IGkgPSAxOyBpIDwgYXJyYXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgaW50ZXJzZWN0aW9uID0gaW50ZXJzZWN0aW9uLmZpbHRlcihcbiAgICAgIHZhbHVlID0+IGFycmF5c1tpXS5pbmNsdWRlcyh2YWx1ZSlcbiAgICApXG4gIH1cbiAgcmV0dXJuIGludGVyc2VjdGlvblxufVxuXG5mdW5jdGlvbiBhcnJheXNJbnRlcnNlY3Rpb24gKGtleXdvcmQsIHZhbHVlcywgbWVyZ2VkU2NoZW1hKSB7XG4gIGNvbnN0IGludGVyc2VjdGlvbiA9IF9hcnJheXNJbnRlcnNlY3Rpb24odmFsdWVzKVxuICBpZiAoaW50ZXJzZWN0aW9uLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBNZXJnZUVycm9yKGtleXdvcmQsIHZhbHVlcylcbiAgfVxuICBtZXJnZWRTY2hlbWFba2V5d29yZF0gPSBpbnRlcnNlY3Rpb25cbn1cblxuZnVuY3Rpb24gaHlicmlkQXJyYXlzSW50ZXJzZWN0aW9uIChrZXl3b3JkLCB2YWx1ZXMsIG1lcmdlZFNjaGVtYSkge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZXNbaV0pKSB7XG4gICAgICB2YWx1ZXNbaV0gPSBbdmFsdWVzW2ldXVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGludGVyc2VjdGlvbiA9IF9hcnJheXNJbnRlcnNlY3Rpb24odmFsdWVzKVxuICBpZiAoaW50ZXJzZWN0aW9uLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBNZXJnZUVycm9yKGtleXdvcmQsIHZhbHVlcylcbiAgfVxuXG4gIGlmIChpbnRlcnNlY3Rpb24ubGVuZ3RoID09PSAxKSB7XG4gICAgbWVyZ2VkU2NoZW1hW2tleXdvcmRdID0gaW50ZXJzZWN0aW9uWzBdXG4gIH0gZWxzZSB7XG4gICAgbWVyZ2VkU2NoZW1hW2tleXdvcmRdID0gaW50ZXJzZWN0aW9uXG4gIH1cbn1cblxuZnVuY3Rpb24gYXJyYXlzVW5pb24gKGtleXdvcmQsIHZhbHVlcywgbWVyZ2VkU2NoZW1hKSB7XG4gIGNvbnN0IHVuaW9uID0gW11cblxuICBmb3IgKGNvbnN0IGFycmF5IG9mIHZhbHVlcykge1xuICAgIGZvciAoY29uc3QgdmFsdWUgb2YgYXJyYXkpIHtcbiAgICAgIGlmICghdW5pb24uaW5jbHVkZXModmFsdWUpKSB7XG4gICAgICAgIHVuaW9uLnB1c2godmFsdWUpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgbWVyZ2VkU2NoZW1hW2tleXdvcmRdID0gdW5pb25cbn1cblxuZnVuY3Rpb24gbWluTnVtYmVyIChrZXl3b3JkLCB2YWx1ZXMsIG1lcmdlZFNjaGVtYSkge1xuICBtZXJnZWRTY2hlbWFba2V5d29yZF0gPSBNYXRoLm1pbiguLi52YWx1ZXMpXG59XG5cbmZ1bmN0aW9uIG1heE51bWJlciAoa2V5d29yZCwgdmFsdWVzLCBtZXJnZWRTY2hlbWEpIHtcbiAgbWVyZ2VkU2NoZW1hW2tleXdvcmRdID0gTWF0aC5tYXgoLi4udmFsdWVzKVxufVxuXG5mdW5jdGlvbiBjb21tb25NdWx0aXBsZSAoa2V5d29yZCwgdmFsdWVzLCBtZXJnZWRTY2hlbWEpIHtcbiAgY29uc3QgZ2NkID0gKGEsIGIpID0+ICghYiA/IGEgOiBnY2QoYiwgYSAlIGIpKVxuICBjb25zdCBsY20gPSAoYSwgYikgPT4gKGEgKiBiKSAvIGdjZChhLCBiKVxuXG4gIGxldCBzY2FsZSA9IDFcbiAgZm9yIChjb25zdCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICB3aGlsZSAodmFsdWUgKiBzY2FsZSAlIDEgIT09IDApIHtcbiAgICAgIHNjYWxlICo9IDEwXG4gICAgfVxuICB9XG5cbiAgbGV0IG11bHRpcGxlID0gdmFsdWVzWzBdICogc2NhbGVcbiAgZm9yIChjb25zdCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICBtdWx0aXBsZSA9IGxjbShtdWx0aXBsZSwgdmFsdWUgKiBzY2FsZSlcbiAgfVxuXG4gIG1lcmdlZFNjaGVtYVtrZXl3b3JkXSA9IG11bHRpcGxlIC8gc2NhbGVcbn1cblxuZnVuY3Rpb24gYWxsRXF1YWwgKGtleXdvcmQsIHZhbHVlcywgbWVyZ2VkU2NoZW1hKSB7XG4gIGNvbnN0IGZpcnN0VmFsdWUgPSB2YWx1ZXNbMF1cbiAgZm9yIChsZXQgaSA9IDE7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIWRlZXBFcXVhbCh2YWx1ZXNbaV0sIGZpcnN0VmFsdWUpKSB7XG4gICAgICB0aHJvdyBuZXcgTWVyZ2VFcnJvcihrZXl3b3JkLCB2YWx1ZXMpXG4gICAgfVxuICB9XG4gIG1lcmdlZFNjaGVtYVtrZXl3b3JkXSA9IGZpcnN0VmFsdWVcbn1cblxuZnVuY3Rpb24gc2tpcCAoKSB7fVxuXG5mdW5jdGlvbiBib29sZWFuQW5kIChrZXl3b3JkLCB2YWx1ZXMsIG1lcmdlZFNjaGVtYSkge1xuICBmb3IgKGNvbnN0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgIGlmICh2YWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgIG1lcmdlZFNjaGVtYVtrZXl3b3JkXSA9IGZhbHNlXG4gICAgICByZXR1cm5cbiAgICB9XG4gIH1cbiAgbWVyZ2VkU2NoZW1hW2tleXdvcmRdID0gdHJ1ZVxufVxuXG5mdW5jdGlvbiBib29sZWFuT3IgKGtleXdvcmQsIHZhbHVlcywgbWVyZ2VkU2NoZW1hKSB7XG4gIGZvciAoY29uc3QgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgaWYgKHZhbHVlID09PSB0cnVlKSB7XG4gICAgICBtZXJnZWRTY2hlbWFba2V5d29yZF0gPSB0cnVlXG4gICAgICByZXR1cm5cbiAgICB9XG4gIH1cbiAgbWVyZ2VkU2NoZW1hW2tleXdvcmRdID0gZmFsc2Vcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGFycmF5c0ludGVyc2VjdGlvbixcbiAgaHlicmlkQXJyYXlzSW50ZXJzZWN0aW9uLFxuICBhcnJheXNVbmlvbixcbiAgbWluTnVtYmVyLFxuICBtYXhOdW1iZXIsXG4gIGNvbW1vbk11bHRpcGxlLFxuICBhbGxFcXVhbCxcbiAgYm9vbGVhbkFuZCxcbiAgYm9vbGVhbk9yLFxuICBza2lwXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@fastify/merge-json-schemas/lib/resolvers.js\n");

/***/ })

};
;