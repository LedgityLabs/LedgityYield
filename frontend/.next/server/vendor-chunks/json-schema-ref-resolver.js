"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/json-schema-ref-resolver";
exports.ids = ["vendor-chunks/json-schema-ref-resolver"];
exports.modules = {

/***/ "(ssr)/../node_modules/json-schema-ref-resolver/index.js":
/*!*********************************************************!*\
  !*** ../node_modules/json-schema-ref-resolver/index.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst deepEqual = __webpack_require__(/*! fast-deep-equal */ \"(ssr)/../node_modules/fast-deep-equal/index.js\")\n\nconst jsonSchemaRefSymbol = Symbol.for('json-schema-ref')\n\nclass RefResolver {\n  #schemas\n  #derefSchemas\n  #insertRefSymbol\n  #allowEqualDuplicates\n  #cloneSchemaWithoutRefs\n\n  constructor (opts = {}) {\n    this.#schemas = {}\n    this.#derefSchemas = {}\n    this.#insertRefSymbol = opts.insertRefSymbol ?? false\n    this.#allowEqualDuplicates = opts.allowEqualDuplicates ?? true\n    this.#cloneSchemaWithoutRefs = opts.cloneSchemaWithoutRefs ?? false\n  }\n\n  addSchema (schema, schemaId) {\n    if (schema.$id !== undefined && schema.$id.charAt(0) !== '#') {\n      // Schema has an $id that is not an anchor\n      schemaId = schema.$id\n    } else {\n      // Schema has no $id or $id is an anchor\n      this.#insertSchemaBySchemaId(schema, schemaId)\n    }\n    this.#addSchema(schema, schemaId)\n  }\n\n  getSchema (schemaId, jsonPointer = '#') {\n    const schema = this.#schemas[schemaId]\n    if (schema === undefined) {\n      throw new Error(\n        `Cannot resolve ref \"${schemaId}${jsonPointer}\". Schema with id \"${schemaId}\" is not found.`\n      )\n    }\n    if (schema.anchors[jsonPointer] !== undefined) {\n      return schema.anchors[jsonPointer]\n    }\n    return getDataByJSONPointer(schema.schema, jsonPointer)\n  }\n\n  hasSchema (schemaId) {\n    return this.#schemas[schemaId] !== undefined\n  }\n\n  getSchemaRefs (schemaId) {\n    const schema = this.#schemas[schemaId]\n    if (schema === undefined) {\n      throw new Error(`Schema with id \"${schemaId}\" is not found.`)\n    }\n    return schema.refs\n  }\n\n  getSchemaDependencies (schemaId, dependencies = {}) {\n    const schema = this.#schemas[schemaId]\n\n    for (const ref of schema.refs) {\n      const dependencySchemaId = ref.schemaId\n      if (dependencies[dependencySchemaId] !== undefined) continue\n      dependencies[dependencySchemaId] = this.getSchema(dependencySchemaId)\n      this.getSchemaDependencies(dependencySchemaId, dependencies)\n    }\n\n    return dependencies\n  }\n\n  derefSchema (schemaId) {\n    if (this.#derefSchemas[schemaId] !== undefined) return\n\n    const schema = this.#schemas[schemaId]\n    if (schema === undefined) {\n      throw new Error(`Schema with id \"${schemaId}\" is not found.`)\n    }\n\n    if (!this.#cloneSchemaWithoutRefs && schema.refs.length === 0) {\n      this.#derefSchemas[schemaId] = {\n        schema: schema.schema,\n        anchors: schema.anchors\n      }\n    }\n\n    const refs = []\n    this.#addDerefSchema(schema.schema, schemaId, refs)\n\n    const dependencies = this.getSchemaDependencies(schemaId)\n    for (const schemaId in dependencies) {\n      const schema = dependencies[schemaId]\n      this.#addDerefSchema(schema, schemaId, refs)\n    }\n\n    for (const ref of refs) {\n      const {\n        refSchemaId,\n        refJsonPointer\n      } = this.#parseSchemaRef(ref.ref, ref.sourceSchemaId)\n\n      const targetSchema = this.getDerefSchema(refSchemaId, refJsonPointer)\n      if (targetSchema === null) {\n        throw new Error(\n          `Cannot resolve ref \"${ref.ref}\". Ref \"${refJsonPointer}\" is not found in schema \"${refSchemaId}\".`\n        )\n      }\n\n      ref.targetSchema = targetSchema\n      ref.targetSchemaId = refSchemaId\n    }\n\n    for (const ref of refs) {\n      this.#resolveRef(ref, refs)\n    }\n  }\n\n  getDerefSchema (schemaId, jsonPointer = '#') {\n    let derefSchema = this.#derefSchemas[schemaId]\n    if (derefSchema === undefined) {\n      this.derefSchema(schemaId)\n      derefSchema = this.#derefSchemas[schemaId]\n    }\n    if (derefSchema.anchors[jsonPointer] !== undefined) {\n      return derefSchema.anchors[jsonPointer]\n    }\n    return getDataByJSONPointer(derefSchema.schema, jsonPointer)\n  }\n\n  #parseSchemaRef (ref, schemaId) {\n    const sharpIndex = ref.indexOf('#')\n    if (sharpIndex === -1) {\n      return { refSchemaId: ref, refJsonPointer: '#' }\n    }\n    if (sharpIndex === 0) {\n      return { refSchemaId: schemaId, refJsonPointer: ref }\n    }\n    return {\n      refSchemaId: ref.slice(0, sharpIndex),\n      refJsonPointer: ref.slice(sharpIndex)\n    }\n  }\n\n  #addSchema (schema, rootSchemaId) {\n    const schemaId = schema.$id\n    if (schemaId !== undefined && typeof schemaId === 'string') {\n      if (schemaId.charAt(0) === '#') {\n        this.#insertSchemaByAnchor(schema, rootSchemaId, schemaId)\n      } else {\n        this.#insertSchemaBySchemaId(schema, schemaId)\n        rootSchemaId = schemaId\n      }\n    }\n\n    const ref = schema.$ref\n    if (ref !== undefined && typeof ref === 'string') {\n      const { refSchemaId, refJsonPointer } = this.#parseSchemaRef(ref, rootSchemaId)\n      this.#schemas[rootSchemaId].refs.push({\n        schemaId: refSchemaId,\n        jsonPointer: refJsonPointer\n      })\n    }\n\n    for (const key in schema) {\n      if (typeof schema[key] === 'object' && schema[key] !== null) {\n        this.#addSchema(schema[key], rootSchemaId)\n      }\n    }\n  }\n\n  #addDerefSchema (schema, rootSchemaId, refs = []) {\n    const derefSchema = Array.isArray(schema) ? [...schema] : { ...schema }\n\n    const schemaId = derefSchema.$id\n    if (schemaId !== undefined && typeof schemaId === 'string') {\n      if (schemaId.charAt(0) === '#') {\n        this.#insertDerefSchemaByAnchor(derefSchema, rootSchemaId, schemaId)\n      } else {\n        this.#insertDerefSchemaBySchemaId(derefSchema, schemaId)\n        rootSchemaId = schemaId\n      }\n    }\n\n    if (derefSchema.$ref !== undefined) {\n      refs.push({\n        ref: derefSchema.$ref,\n        sourceSchemaId: rootSchemaId,\n        sourceSchema: derefSchema\n      })\n    }\n\n    for (const key in derefSchema) {\n      const value = derefSchema[key]\n      if (typeof value === 'object' && value !== null) {\n        derefSchema[key] = this.#addDerefSchema(value, rootSchemaId, refs)\n      }\n    }\n\n    return derefSchema\n  }\n\n  #resolveRef (ref, refs) {\n    const { sourceSchema, targetSchema } = ref\n\n    if (!sourceSchema.$ref) return\n    if (this.#insertRefSymbol) {\n      sourceSchema[jsonSchemaRefSymbol] = sourceSchema.$ref\n    }\n\n    delete sourceSchema.$ref\n\n    if (targetSchema.$ref) {\n      const targetSchemaRef = refs.find(ref => ref.sourceSchema === targetSchema)\n      this.#resolveRef(targetSchemaRef, refs)\n    }\n    for (const key in targetSchema) {\n      if (key === '$id') continue\n      if (sourceSchema[key] !== undefined) {\n        if (deepEqual(sourceSchema[key], targetSchema[key])) continue\n        throw new Error(\n          `Cannot resolve ref \"${ref.ref}\". Property \"${key}\" is already exist in schema \"${ref.sourceSchemaId}\".`\n        )\n      }\n      sourceSchema[key] = targetSchema[key]\n    }\n    ref.isResolved = true\n  }\n\n  #insertSchemaBySchemaId (schema, schemaId) {\n    const foundSchema = this.#schemas[schemaId]\n    if (foundSchema !== undefined) {\n      if (this.#allowEqualDuplicates && deepEqual(schema, foundSchema.schema)) return\n      throw new Error(`There is already another schema with id \"${schemaId}\".`)\n    }\n    this.#schemas[schemaId] = { schema, anchors: {}, refs: [] }\n  }\n\n  #insertSchemaByAnchor (schema, schemaId, anchor) {\n    const { anchors } = this.#schemas[schemaId]\n    if (anchors[anchor] !== undefined) {\n      throw new Error(`There is already another anchor \"${anchor}\" in a schema \"${schemaId}\".`)\n    }\n    anchors[anchor] = schema\n  }\n\n  #insertDerefSchemaBySchemaId (schema, schemaId) {\n    const foundSchema = this.#derefSchemas[schemaId]\n    if (foundSchema !== undefined) return\n\n    this.#derefSchemas[schemaId] = { schema, anchors: {} }\n  }\n\n  #insertDerefSchemaByAnchor (schema, schemaId, anchor) {\n    const { anchors } = this.#derefSchemas[schemaId]\n    anchors[anchor] = schema\n  }\n}\n\nfunction getDataByJSONPointer (data, jsonPointer) {\n  const parts = jsonPointer.split('/')\n  let current = data\n  for (const part of parts) {\n    if (part === '' || part === '#') continue\n    if (typeof current !== 'object' || current === null) {\n      return null\n    }\n    current = current[part]\n  }\n  return current ?? null\n}\n\nmodule.exports = { RefResolver }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL2pzb24tc2NoZW1hLXJlZi1yZXNvbHZlci9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixrQkFBa0IsbUJBQU8sQ0FBQyx1RUFBaUI7O0FBRTNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsU0FBUyxFQUFFLFlBQVkscUJBQXFCLFNBQVM7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxTQUFTO0FBQ2xEO0FBQ0E7QUFDQTs7QUFFQSxvREFBb0Q7QUFDcEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUNBQXlDLFNBQVM7QUFDbEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFFBQVEsVUFBVSxlQUFlLDRCQUE0QixZQUFZO0FBQzFHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsOEJBQThCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnRUFBZ0U7O0FBRWhFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLDZCQUE2Qjs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFFBQVEsZUFBZSxJQUFJLGdDQUFnQyxtQkFBbUI7QUFDL0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLFNBQVM7QUFDM0U7QUFDQSxnQ0FBZ0MsbUJBQW1CO0FBQ25EOztBQUVBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0EsMERBQTBELE9BQU8saUJBQWlCLFNBQVM7QUFDM0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUM7QUFDckM7O0FBRUE7QUFDQSxZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sZWRnaXR5LXlpZWxkLWZyb250ZW5kLy4uL25vZGVfbW9kdWxlcy9qc29uLXNjaGVtYS1yZWYtcmVzb2x2ZXIvaW5kZXguanM/OWNjNCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgZGVlcEVxdWFsID0gcmVxdWlyZSgnZmFzdC1kZWVwLWVxdWFsJylcblxuY29uc3QganNvblNjaGVtYVJlZlN5bWJvbCA9IFN5bWJvbC5mb3IoJ2pzb24tc2NoZW1hLXJlZicpXG5cbmNsYXNzIFJlZlJlc29sdmVyIHtcbiAgI3NjaGVtYXNcbiAgI2RlcmVmU2NoZW1hc1xuICAjaW5zZXJ0UmVmU3ltYm9sXG4gICNhbGxvd0VxdWFsRHVwbGljYXRlc1xuICAjY2xvbmVTY2hlbWFXaXRob3V0UmVmc1xuXG4gIGNvbnN0cnVjdG9yIChvcHRzID0ge30pIHtcbiAgICB0aGlzLiNzY2hlbWFzID0ge31cbiAgICB0aGlzLiNkZXJlZlNjaGVtYXMgPSB7fVxuICAgIHRoaXMuI2luc2VydFJlZlN5bWJvbCA9IG9wdHMuaW5zZXJ0UmVmU3ltYm9sID8/IGZhbHNlXG4gICAgdGhpcy4jYWxsb3dFcXVhbER1cGxpY2F0ZXMgPSBvcHRzLmFsbG93RXF1YWxEdXBsaWNhdGVzID8/IHRydWVcbiAgICB0aGlzLiNjbG9uZVNjaGVtYVdpdGhvdXRSZWZzID0gb3B0cy5jbG9uZVNjaGVtYVdpdGhvdXRSZWZzID8/IGZhbHNlXG4gIH1cblxuICBhZGRTY2hlbWEgKHNjaGVtYSwgc2NoZW1hSWQpIHtcbiAgICBpZiAoc2NoZW1hLiRpZCAhPT0gdW5kZWZpbmVkICYmIHNjaGVtYS4kaWQuY2hhckF0KDApICE9PSAnIycpIHtcbiAgICAgIC8vIFNjaGVtYSBoYXMgYW4gJGlkIHRoYXQgaXMgbm90IGFuIGFuY2hvclxuICAgICAgc2NoZW1hSWQgPSBzY2hlbWEuJGlkXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFNjaGVtYSBoYXMgbm8gJGlkIG9yICRpZCBpcyBhbiBhbmNob3JcbiAgICAgIHRoaXMuI2luc2VydFNjaGVtYUJ5U2NoZW1hSWQoc2NoZW1hLCBzY2hlbWFJZClcbiAgICB9XG4gICAgdGhpcy4jYWRkU2NoZW1hKHNjaGVtYSwgc2NoZW1hSWQpXG4gIH1cblxuICBnZXRTY2hlbWEgKHNjaGVtYUlkLCBqc29uUG9pbnRlciA9ICcjJykge1xuICAgIGNvbnN0IHNjaGVtYSA9IHRoaXMuI3NjaGVtYXNbc2NoZW1hSWRdXG4gICAgaWYgKHNjaGVtYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBDYW5ub3QgcmVzb2x2ZSByZWYgXCIke3NjaGVtYUlkfSR7anNvblBvaW50ZXJ9XCIuIFNjaGVtYSB3aXRoIGlkIFwiJHtzY2hlbWFJZH1cIiBpcyBub3QgZm91bmQuYFxuICAgICAgKVxuICAgIH1cbiAgICBpZiAoc2NoZW1hLmFuY2hvcnNbanNvblBvaW50ZXJdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBzY2hlbWEuYW5jaG9yc1tqc29uUG9pbnRlcl1cbiAgICB9XG4gICAgcmV0dXJuIGdldERhdGFCeUpTT05Qb2ludGVyKHNjaGVtYS5zY2hlbWEsIGpzb25Qb2ludGVyKVxuICB9XG5cbiAgaGFzU2NoZW1hIChzY2hlbWFJZCkge1xuICAgIHJldHVybiB0aGlzLiNzY2hlbWFzW3NjaGVtYUlkXSAhPT0gdW5kZWZpbmVkXG4gIH1cblxuICBnZXRTY2hlbWFSZWZzIChzY2hlbWFJZCkge1xuICAgIGNvbnN0IHNjaGVtYSA9IHRoaXMuI3NjaGVtYXNbc2NoZW1hSWRdXG4gICAgaWYgKHNjaGVtYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFNjaGVtYSB3aXRoIGlkIFwiJHtzY2hlbWFJZH1cIiBpcyBub3QgZm91bmQuYClcbiAgICB9XG4gICAgcmV0dXJuIHNjaGVtYS5yZWZzXG4gIH1cblxuICBnZXRTY2hlbWFEZXBlbmRlbmNpZXMgKHNjaGVtYUlkLCBkZXBlbmRlbmNpZXMgPSB7fSkge1xuICAgIGNvbnN0IHNjaGVtYSA9IHRoaXMuI3NjaGVtYXNbc2NoZW1hSWRdXG5cbiAgICBmb3IgKGNvbnN0IHJlZiBvZiBzY2hlbWEucmVmcykge1xuICAgICAgY29uc3QgZGVwZW5kZW5jeVNjaGVtYUlkID0gcmVmLnNjaGVtYUlkXG4gICAgICBpZiAoZGVwZW5kZW5jaWVzW2RlcGVuZGVuY3lTY2hlbWFJZF0gIT09IHVuZGVmaW5lZCkgY29udGludWVcbiAgICAgIGRlcGVuZGVuY2llc1tkZXBlbmRlbmN5U2NoZW1hSWRdID0gdGhpcy5nZXRTY2hlbWEoZGVwZW5kZW5jeVNjaGVtYUlkKVxuICAgICAgdGhpcy5nZXRTY2hlbWFEZXBlbmRlbmNpZXMoZGVwZW5kZW5jeVNjaGVtYUlkLCBkZXBlbmRlbmNpZXMpXG4gICAgfVxuXG4gICAgcmV0dXJuIGRlcGVuZGVuY2llc1xuICB9XG5cbiAgZGVyZWZTY2hlbWEgKHNjaGVtYUlkKSB7XG4gICAgaWYgKHRoaXMuI2RlcmVmU2NoZW1hc1tzY2hlbWFJZF0gIT09IHVuZGVmaW5lZCkgcmV0dXJuXG5cbiAgICBjb25zdCBzY2hlbWEgPSB0aGlzLiNzY2hlbWFzW3NjaGVtYUlkXVxuICAgIGlmIChzY2hlbWEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBTY2hlbWEgd2l0aCBpZCBcIiR7c2NoZW1hSWR9XCIgaXMgbm90IGZvdW5kLmApXG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLiNjbG9uZVNjaGVtYVdpdGhvdXRSZWZzICYmIHNjaGVtYS5yZWZzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy4jZGVyZWZTY2hlbWFzW3NjaGVtYUlkXSA9IHtcbiAgICAgICAgc2NoZW1hOiBzY2hlbWEuc2NoZW1hLFxuICAgICAgICBhbmNob3JzOiBzY2hlbWEuYW5jaG9yc1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHJlZnMgPSBbXVxuICAgIHRoaXMuI2FkZERlcmVmU2NoZW1hKHNjaGVtYS5zY2hlbWEsIHNjaGVtYUlkLCByZWZzKVxuXG4gICAgY29uc3QgZGVwZW5kZW5jaWVzID0gdGhpcy5nZXRTY2hlbWFEZXBlbmRlbmNpZXMoc2NoZW1hSWQpXG4gICAgZm9yIChjb25zdCBzY2hlbWFJZCBpbiBkZXBlbmRlbmNpZXMpIHtcbiAgICAgIGNvbnN0IHNjaGVtYSA9IGRlcGVuZGVuY2llc1tzY2hlbWFJZF1cbiAgICAgIHRoaXMuI2FkZERlcmVmU2NoZW1hKHNjaGVtYSwgc2NoZW1hSWQsIHJlZnMpXG4gICAgfVxuXG4gICAgZm9yIChjb25zdCByZWYgb2YgcmVmcykge1xuICAgICAgY29uc3Qge1xuICAgICAgICByZWZTY2hlbWFJZCxcbiAgICAgICAgcmVmSnNvblBvaW50ZXJcbiAgICAgIH0gPSB0aGlzLiNwYXJzZVNjaGVtYVJlZihyZWYucmVmLCByZWYuc291cmNlU2NoZW1hSWQpXG5cbiAgICAgIGNvbnN0IHRhcmdldFNjaGVtYSA9IHRoaXMuZ2V0RGVyZWZTY2hlbWEocmVmU2NoZW1hSWQsIHJlZkpzb25Qb2ludGVyKVxuICAgICAgaWYgKHRhcmdldFNjaGVtYSA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYENhbm5vdCByZXNvbHZlIHJlZiBcIiR7cmVmLnJlZn1cIi4gUmVmIFwiJHtyZWZKc29uUG9pbnRlcn1cIiBpcyBub3QgZm91bmQgaW4gc2NoZW1hIFwiJHtyZWZTY2hlbWFJZH1cIi5gXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgcmVmLnRhcmdldFNjaGVtYSA9IHRhcmdldFNjaGVtYVxuICAgICAgcmVmLnRhcmdldFNjaGVtYUlkID0gcmVmU2NoZW1hSWRcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IHJlZiBvZiByZWZzKSB7XG4gICAgICB0aGlzLiNyZXNvbHZlUmVmKHJlZiwgcmVmcylcbiAgICB9XG4gIH1cblxuICBnZXREZXJlZlNjaGVtYSAoc2NoZW1hSWQsIGpzb25Qb2ludGVyID0gJyMnKSB7XG4gICAgbGV0IGRlcmVmU2NoZW1hID0gdGhpcy4jZGVyZWZTY2hlbWFzW3NjaGVtYUlkXVxuICAgIGlmIChkZXJlZlNjaGVtYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmRlcmVmU2NoZW1hKHNjaGVtYUlkKVxuICAgICAgZGVyZWZTY2hlbWEgPSB0aGlzLiNkZXJlZlNjaGVtYXNbc2NoZW1hSWRdXG4gICAgfVxuICAgIGlmIChkZXJlZlNjaGVtYS5hbmNob3JzW2pzb25Qb2ludGVyXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZGVyZWZTY2hlbWEuYW5jaG9yc1tqc29uUG9pbnRlcl1cbiAgICB9XG4gICAgcmV0dXJuIGdldERhdGFCeUpTT05Qb2ludGVyKGRlcmVmU2NoZW1hLnNjaGVtYSwganNvblBvaW50ZXIpXG4gIH1cblxuICAjcGFyc2VTY2hlbWFSZWYgKHJlZiwgc2NoZW1hSWQpIHtcbiAgICBjb25zdCBzaGFycEluZGV4ID0gcmVmLmluZGV4T2YoJyMnKVxuICAgIGlmIChzaGFycEluZGV4ID09PSAtMSkge1xuICAgICAgcmV0dXJuIHsgcmVmU2NoZW1hSWQ6IHJlZiwgcmVmSnNvblBvaW50ZXI6ICcjJyB9XG4gICAgfVxuICAgIGlmIChzaGFycEluZGV4ID09PSAwKSB7XG4gICAgICByZXR1cm4geyByZWZTY2hlbWFJZDogc2NoZW1hSWQsIHJlZkpzb25Qb2ludGVyOiByZWYgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcmVmU2NoZW1hSWQ6IHJlZi5zbGljZSgwLCBzaGFycEluZGV4KSxcbiAgICAgIHJlZkpzb25Qb2ludGVyOiByZWYuc2xpY2Uoc2hhcnBJbmRleClcbiAgICB9XG4gIH1cblxuICAjYWRkU2NoZW1hIChzY2hlbWEsIHJvb3RTY2hlbWFJZCkge1xuICAgIGNvbnN0IHNjaGVtYUlkID0gc2NoZW1hLiRpZFxuICAgIGlmIChzY2hlbWFJZCAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBzY2hlbWFJZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmIChzY2hlbWFJZC5jaGFyQXQoMCkgPT09ICcjJykge1xuICAgICAgICB0aGlzLiNpbnNlcnRTY2hlbWFCeUFuY2hvcihzY2hlbWEsIHJvb3RTY2hlbWFJZCwgc2NoZW1hSWQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLiNpbnNlcnRTY2hlbWFCeVNjaGVtYUlkKHNjaGVtYSwgc2NoZW1hSWQpXG4gICAgICAgIHJvb3RTY2hlbWFJZCA9IHNjaGVtYUlkXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgcmVmID0gc2NoZW1hLiRyZWZcbiAgICBpZiAocmVmICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHJlZiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbnN0IHsgcmVmU2NoZW1hSWQsIHJlZkpzb25Qb2ludGVyIH0gPSB0aGlzLiNwYXJzZVNjaGVtYVJlZihyZWYsIHJvb3RTY2hlbWFJZClcbiAgICAgIHRoaXMuI3NjaGVtYXNbcm9vdFNjaGVtYUlkXS5yZWZzLnB1c2goe1xuICAgICAgICBzY2hlbWFJZDogcmVmU2NoZW1hSWQsXG4gICAgICAgIGpzb25Qb2ludGVyOiByZWZKc29uUG9pbnRlclxuICAgICAgfSlcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEpIHtcbiAgICAgIGlmICh0eXBlb2Ygc2NoZW1hW2tleV0gPT09ICdvYmplY3QnICYmIHNjaGVtYVtrZXldICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuI2FkZFNjaGVtYShzY2hlbWFba2V5XSwgcm9vdFNjaGVtYUlkKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gICNhZGREZXJlZlNjaGVtYSAoc2NoZW1hLCByb290U2NoZW1hSWQsIHJlZnMgPSBbXSkge1xuICAgIGNvbnN0IGRlcmVmU2NoZW1hID0gQXJyYXkuaXNBcnJheShzY2hlbWEpID8gWy4uLnNjaGVtYV0gOiB7IC4uLnNjaGVtYSB9XG5cbiAgICBjb25zdCBzY2hlbWFJZCA9IGRlcmVmU2NoZW1hLiRpZFxuICAgIGlmIChzY2hlbWFJZCAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBzY2hlbWFJZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmIChzY2hlbWFJZC5jaGFyQXQoMCkgPT09ICcjJykge1xuICAgICAgICB0aGlzLiNpbnNlcnREZXJlZlNjaGVtYUJ5QW5jaG9yKGRlcmVmU2NoZW1hLCByb290U2NoZW1hSWQsIHNjaGVtYUlkKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy4jaW5zZXJ0RGVyZWZTY2hlbWFCeVNjaGVtYUlkKGRlcmVmU2NoZW1hLCBzY2hlbWFJZClcbiAgICAgICAgcm9vdFNjaGVtYUlkID0gc2NoZW1hSWRcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZGVyZWZTY2hlbWEuJHJlZiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZWZzLnB1c2goe1xuICAgICAgICByZWY6IGRlcmVmU2NoZW1hLiRyZWYsXG4gICAgICAgIHNvdXJjZVNjaGVtYUlkOiByb290U2NoZW1hSWQsXG4gICAgICAgIHNvdXJjZVNjaGVtYTogZGVyZWZTY2hlbWFcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBrZXkgaW4gZGVyZWZTY2hlbWEpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gZGVyZWZTY2hlbWFba2V5XVxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgZGVyZWZTY2hlbWFba2V5XSA9IHRoaXMuI2FkZERlcmVmU2NoZW1hKHZhbHVlLCByb290U2NoZW1hSWQsIHJlZnMpXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlcmVmU2NoZW1hXG4gIH1cblxuICAjcmVzb2x2ZVJlZiAocmVmLCByZWZzKSB7XG4gICAgY29uc3QgeyBzb3VyY2VTY2hlbWEsIHRhcmdldFNjaGVtYSB9ID0gcmVmXG5cbiAgICBpZiAoIXNvdXJjZVNjaGVtYS4kcmVmKSByZXR1cm5cbiAgICBpZiAodGhpcy4jaW5zZXJ0UmVmU3ltYm9sKSB7XG4gICAgICBzb3VyY2VTY2hlbWFbanNvblNjaGVtYVJlZlN5bWJvbF0gPSBzb3VyY2VTY2hlbWEuJHJlZlxuICAgIH1cblxuICAgIGRlbGV0ZSBzb3VyY2VTY2hlbWEuJHJlZlxuXG4gICAgaWYgKHRhcmdldFNjaGVtYS4kcmVmKSB7XG4gICAgICBjb25zdCB0YXJnZXRTY2hlbWFSZWYgPSByZWZzLmZpbmQocmVmID0+IHJlZi5zb3VyY2VTY2hlbWEgPT09IHRhcmdldFNjaGVtYSlcbiAgICAgIHRoaXMuI3Jlc29sdmVSZWYodGFyZ2V0U2NoZW1hUmVmLCByZWZzKVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBpbiB0YXJnZXRTY2hlbWEpIHtcbiAgICAgIGlmIChrZXkgPT09ICckaWQnKSBjb250aW51ZVxuICAgICAgaWYgKHNvdXJjZVNjaGVtYVtrZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGRlZXBFcXVhbChzb3VyY2VTY2hlbWFba2V5XSwgdGFyZ2V0U2NoZW1hW2tleV0pKSBjb250aW51ZVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYENhbm5vdCByZXNvbHZlIHJlZiBcIiR7cmVmLnJlZn1cIi4gUHJvcGVydHkgXCIke2tleX1cIiBpcyBhbHJlYWR5IGV4aXN0IGluIHNjaGVtYSBcIiR7cmVmLnNvdXJjZVNjaGVtYUlkfVwiLmBcbiAgICAgICAgKVxuICAgICAgfVxuICAgICAgc291cmNlU2NoZW1hW2tleV0gPSB0YXJnZXRTY2hlbWFba2V5XVxuICAgIH1cbiAgICByZWYuaXNSZXNvbHZlZCA9IHRydWVcbiAgfVxuXG4gICNpbnNlcnRTY2hlbWFCeVNjaGVtYUlkIChzY2hlbWEsIHNjaGVtYUlkKSB7XG4gICAgY29uc3QgZm91bmRTY2hlbWEgPSB0aGlzLiNzY2hlbWFzW3NjaGVtYUlkXVxuICAgIGlmIChmb3VuZFNjaGVtYSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAodGhpcy4jYWxsb3dFcXVhbER1cGxpY2F0ZXMgJiYgZGVlcEVxdWFsKHNjaGVtYSwgZm91bmRTY2hlbWEuc2NoZW1hKSkgcmV0dXJuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZXJlIGlzIGFscmVhZHkgYW5vdGhlciBzY2hlbWEgd2l0aCBpZCBcIiR7c2NoZW1hSWR9XCIuYClcbiAgICB9XG4gICAgdGhpcy4jc2NoZW1hc1tzY2hlbWFJZF0gPSB7IHNjaGVtYSwgYW5jaG9yczoge30sIHJlZnM6IFtdIH1cbiAgfVxuXG4gICNpbnNlcnRTY2hlbWFCeUFuY2hvciAoc2NoZW1hLCBzY2hlbWFJZCwgYW5jaG9yKSB7XG4gICAgY29uc3QgeyBhbmNob3JzIH0gPSB0aGlzLiNzY2hlbWFzW3NjaGVtYUlkXVxuICAgIGlmIChhbmNob3JzW2FuY2hvcl0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGVyZSBpcyBhbHJlYWR5IGFub3RoZXIgYW5jaG9yIFwiJHthbmNob3J9XCIgaW4gYSBzY2hlbWEgXCIke3NjaGVtYUlkfVwiLmApXG4gICAgfVxuICAgIGFuY2hvcnNbYW5jaG9yXSA9IHNjaGVtYVxuICB9XG5cbiAgI2luc2VydERlcmVmU2NoZW1hQnlTY2hlbWFJZCAoc2NoZW1hLCBzY2hlbWFJZCkge1xuICAgIGNvbnN0IGZvdW5kU2NoZW1hID0gdGhpcy4jZGVyZWZTY2hlbWFzW3NjaGVtYUlkXVxuICAgIGlmIChmb3VuZFNjaGVtYSAhPT0gdW5kZWZpbmVkKSByZXR1cm5cblxuICAgIHRoaXMuI2RlcmVmU2NoZW1hc1tzY2hlbWFJZF0gPSB7IHNjaGVtYSwgYW5jaG9yczoge30gfVxuICB9XG5cbiAgI2luc2VydERlcmVmU2NoZW1hQnlBbmNob3IgKHNjaGVtYSwgc2NoZW1hSWQsIGFuY2hvcikge1xuICAgIGNvbnN0IHsgYW5jaG9ycyB9ID0gdGhpcy4jZGVyZWZTY2hlbWFzW3NjaGVtYUlkXVxuICAgIGFuY2hvcnNbYW5jaG9yXSA9IHNjaGVtYVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldERhdGFCeUpTT05Qb2ludGVyIChkYXRhLCBqc29uUG9pbnRlcikge1xuICBjb25zdCBwYXJ0cyA9IGpzb25Qb2ludGVyLnNwbGl0KCcvJylcbiAgbGV0IGN1cnJlbnQgPSBkYXRhXG4gIGZvciAoY29uc3QgcGFydCBvZiBwYXJ0cykge1xuICAgIGlmIChwYXJ0ID09PSAnJyB8fCBwYXJ0ID09PSAnIycpIGNvbnRpbnVlXG4gICAgaWYgKHR5cGVvZiBjdXJyZW50ICE9PSAnb2JqZWN0JyB8fCBjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgICBjdXJyZW50ID0gY3VycmVudFtwYXJ0XVxuICB9XG4gIHJldHVybiBjdXJyZW50ID8/IG51bGxcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7IFJlZlJlc29sdmVyIH1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/json-schema-ref-resolver/index.js\n");

/***/ })

};
;