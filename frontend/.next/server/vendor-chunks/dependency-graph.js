/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/dependency-graph";
exports.ids = ["vendor-chunks/dependency-graph"];
exports.modules = {

/***/ "(ssr)/../node_modules/dependency-graph/lib/dep_graph.js":
/*!*********************************************************!*\
  !*** ../node_modules/dependency-graph/lib/dep_graph.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/**\n * A simple dependency graph\n */\n\n/**\n * Helper for creating a Topological Sort using Depth-First-Search on a set of edges.\n *\n * Detects cycles and throws an Error if one is detected (unless the \"circular\"\n * parameter is \"true\" in which case it ignores them).\n *\n * @param edges The set of edges to DFS through\n * @param leavesOnly Whether to only return \"leaf\" nodes (ones who have no edges)\n * @param result An array in which the results will be populated\n * @param circular A boolean to allow circular dependencies\n */\nfunction createDFS(edges, leavesOnly, result, circular) {\n  var visited = {};\n  return function (start) {\n    if (visited[start]) {\n      return;\n    }\n    var inCurrentPath = {};\n    var currentPath = [];\n    var todo = []; // used as a stack\n    todo.push({ node: start, processed: false });\n    while (todo.length > 0) {\n      var current = todo[todo.length - 1]; // peek at the todo stack\n      var processed = current.processed;\n      var node = current.node;\n      if (!processed) {\n        // Haven't visited edges yet (visiting phase)\n        if (visited[node]) {\n          todo.pop();\n          continue;\n        } else if (inCurrentPath[node]) {\n          // It's not a DAG\n          if (circular) {\n            todo.pop();\n            // If we're tolerating cycles, don't revisit the node\n            continue;\n          }\n          currentPath.push(node);\n          throw new DepGraphCycleError(currentPath);\n        }\n\n        inCurrentPath[node] = true;\n        currentPath.push(node);\n        var nodeEdges = edges[node];\n        // (push edges onto the todo stack in reverse order to be order-compatible with the old DFS implementation)\n        for (var i = nodeEdges.length - 1; i >= 0; i--) {\n          todo.push({ node: nodeEdges[i], processed: false });\n        }\n        current.processed = true;\n      } else {\n        // Have visited edges (stack unrolling phase)\n        todo.pop();\n        currentPath.pop();\n        inCurrentPath[node] = false;\n        visited[node] = true;\n        if (!leavesOnly || edges[node].length === 0) {\n          result.push(node);\n        }\n      }\n    }\n  };\n}\n\n/**\n * Simple Dependency Graph\n */\nvar DepGraph = (exports.DepGraph = function DepGraph(opts) {\n  this.nodes = {}; // Node -> Node/Data (treated like a Set)\n  this.outgoingEdges = {}; // Node -> [Dependency Node]\n  this.incomingEdges = {}; // Node -> [Dependant Node]\n  this.circular = opts && !!opts.circular; // Allows circular deps\n});\nDepGraph.prototype = {\n  /**\n   * The number of nodes in the graph.\n   */\n  size: function () {\n    return Object.keys(this.nodes).length;\n  },\n  /**\n   * Add a node to the dependency graph. If a node already exists, this method will do nothing.\n   */\n  addNode: function (node, data) {\n    if (!this.hasNode(node)) {\n      // Checking the arguments length allows the user to add a node with undefined data\n      if (arguments.length === 2) {\n        this.nodes[node] = data;\n      } else {\n        this.nodes[node] = node;\n      }\n      this.outgoingEdges[node] = [];\n      this.incomingEdges[node] = [];\n    }\n  },\n  /**\n   * Remove a node from the dependency graph. If a node does not exist, this method will do nothing.\n   */\n  removeNode: function (node) {\n    if (this.hasNode(node)) {\n      delete this.nodes[node];\n      delete this.outgoingEdges[node];\n      delete this.incomingEdges[node];\n      [this.incomingEdges, this.outgoingEdges].forEach(function (edgeList) {\n        Object.keys(edgeList).forEach(function (key) {\n          var idx = edgeList[key].indexOf(node);\n          if (idx >= 0) {\n            edgeList[key].splice(idx, 1);\n          }\n        }, this);\n      });\n    }\n  },\n  /**\n   * Check if a node exists in the graph\n   */\n  hasNode: function (node) {\n    return this.nodes.hasOwnProperty(node);\n  },\n  /**\n   * Get the data associated with a node name\n   */\n  getNodeData: function (node) {\n    if (this.hasNode(node)) {\n      return this.nodes[node];\n    } else {\n      throw new Error(\"Node does not exist: \" + node);\n    }\n  },\n  /**\n   * Set the associated data for a given node name. If the node does not exist, this method will throw an error\n   */\n  setNodeData: function (node, data) {\n    if (this.hasNode(node)) {\n      this.nodes[node] = data;\n    } else {\n      throw new Error(\"Node does not exist: \" + node);\n    }\n  },\n  /**\n   * Add a dependency between two nodes. If either of the nodes does not exist,\n   * an Error will be thrown.\n   */\n  addDependency: function (from, to) {\n    if (!this.hasNode(from)) {\n      throw new Error(\"Node does not exist: \" + from);\n    }\n    if (!this.hasNode(to)) {\n      throw new Error(\"Node does not exist: \" + to);\n    }\n    if (this.outgoingEdges[from].indexOf(to) === -1) {\n      this.outgoingEdges[from].push(to);\n    }\n    if (this.incomingEdges[to].indexOf(from) === -1) {\n      this.incomingEdges[to].push(from);\n    }\n    return true;\n  },\n  /**\n   * Remove a dependency between two nodes.\n   */\n  removeDependency: function (from, to) {\n    var idx;\n    if (this.hasNode(from)) {\n      idx = this.outgoingEdges[from].indexOf(to);\n      if (idx >= 0) {\n        this.outgoingEdges[from].splice(idx, 1);\n      }\n    }\n\n    if (this.hasNode(to)) {\n      idx = this.incomingEdges[to].indexOf(from);\n      if (idx >= 0) {\n        this.incomingEdges[to].splice(idx, 1);\n      }\n    }\n  },\n  /**\n   * Return a clone of the dependency graph. If any custom data is attached\n   * to the nodes, it will only be shallow copied.\n   */\n  clone: function () {\n    var source = this;\n    var result = new DepGraph();\n    var keys = Object.keys(source.nodes);\n    keys.forEach(function (n) {\n      result.nodes[n] = source.nodes[n];\n      result.outgoingEdges[n] = source.outgoingEdges[n].slice(0);\n      result.incomingEdges[n] = source.incomingEdges[n].slice(0);\n    });\n    return result;\n  },\n  /**\n   * Get an array containing the direct dependencies of the specified node.\n   *\n   * Throws an Error if the specified node does not exist.\n   */\n  directDependenciesOf: function (node) {\n    if (this.hasNode(node)) {\n      return this.outgoingEdges[node].slice(0);\n    } else {\n      throw new Error(\"Node does not exist: \" + node);\n    }\n  },\n  /**\n   * Get an array containing the nodes that directly depend on the specified node.\n   *\n   * Throws an Error if the specified node does not exist.\n   */\n  directDependantsOf: function (node) {\n    if (this.hasNode(node)) {\n      return this.incomingEdges[node].slice(0);\n    } else {\n      throw new Error(\"Node does not exist: \" + node);\n    }\n  },\n  /**\n   * Get an array containing the nodes that the specified node depends on (transitively).\n   *\n   * Throws an Error if the graph has a cycle, or the specified node does not exist.\n   *\n   * If `leavesOnly` is true, only nodes that do not depend on any other nodes will be returned\n   * in the array.\n   */\n  dependenciesOf: function (node, leavesOnly) {\n    if (this.hasNode(node)) {\n      var result = [];\n      var DFS = createDFS(\n        this.outgoingEdges,\n        leavesOnly,\n        result,\n        this.circular\n      );\n      DFS(node);\n      var idx = result.indexOf(node);\n      if (idx >= 0) {\n        result.splice(idx, 1);\n      }\n      return result;\n    } else {\n      throw new Error(\"Node does not exist: \" + node);\n    }\n  },\n  /**\n   * get an array containing the nodes that depend on the specified node (transitively).\n   *\n   * Throws an Error if the graph has a cycle, or the specified node does not exist.\n   *\n   * If `leavesOnly` is true, only nodes that do not have any dependants will be returned in the array.\n   */\n  dependantsOf: function (node, leavesOnly) {\n    if (this.hasNode(node)) {\n      var result = [];\n      var DFS = createDFS(\n        this.incomingEdges,\n        leavesOnly,\n        result,\n        this.circular\n      );\n      DFS(node);\n      var idx = result.indexOf(node);\n      if (idx >= 0) {\n        result.splice(idx, 1);\n      }\n      return result;\n    } else {\n      throw new Error(\"Node does not exist: \" + node);\n    }\n  },\n  /**\n   * Construct the overall processing order for the dependency graph.\n   *\n   * Throws an Error if the graph has a cycle.\n   *\n   * If `leavesOnly` is true, only nodes that do not depend on any other nodes will be returned.\n   */\n  overallOrder: function (leavesOnly) {\n    var self = this;\n    var result = [];\n    var keys = Object.keys(this.nodes);\n    if (keys.length === 0) {\n      return result; // Empty graph\n    } else {\n      if (!this.circular) {\n        // Look for cycles - we run the DFS starting at all the nodes in case there\n        // are several disconnected subgraphs inside this dependency graph.\n        var CycleDFS = createDFS(this.outgoingEdges, false, [], this.circular);\n        keys.forEach(function (n) {\n          CycleDFS(n);\n        });\n      }\n\n      var DFS = createDFS(\n        this.outgoingEdges,\n        leavesOnly,\n        result,\n        this.circular\n      );\n      // Find all potential starting points (nodes with nothing depending on them) an\n      // run a DFS starting at these points to get the order\n      keys\n        .filter(function (node) {\n          return self.incomingEdges[node].length === 0;\n        })\n        .forEach(function (n) {\n          DFS(n);\n        });\n\n      // If we're allowing cycles - we need to run the DFS against any remaining\n      // nodes that did not end up in the initial result (as they are part of a\n      // subgraph that does not have a clear starting point)\n      if (this.circular) {\n        keys\n          .filter(function (node) {\n            return result.indexOf(node) === -1;\n          })\n          .forEach(function (n) {\n            DFS(n);\n          });\n      }\n\n      return result;\n    }\n  },\n  /**\n   * Get an array of nodes that have no dependants (i.e. nothing depends on them).\n   */\n  entryNodes: function () {\n    var self = this;\n    return Object.keys(this.nodes).filter(function (node) {\n      return self.incomingEdges[node].length === 0;\n    });\n  }\n};\n\n// Create some aliases\nDepGraph.prototype.directDependentsOf = DepGraph.prototype.directDependantsOf;\nDepGraph.prototype.dependentsOf = DepGraph.prototype.dependantsOf;\n\n/**\n * Cycle error, including the path of the cycle.\n */\nvar DepGraphCycleError = (exports.DepGraphCycleError = function (cyclePath) {\n  var message = \"Dependency Cycle Found: \" + cyclePath.join(\" -> \");\n  var instance = new Error(message);\n  instance.cyclePath = cyclePath;\n  Object.setPrototypeOf(instance, Object.getPrototypeOf(this));\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(instance, DepGraphCycleError);\n  }\n  return instance;\n});\nDepGraphCycleError.prototype = Object.create(Error.prototype, {\n  constructor: {\n    value: Error,\n    enumerable: false,\n    writable: true,\n    configurable: true\n  }\n});\nObject.setPrototypeOf(DepGraphCycleError, Error);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL2RlcGVuZGVuY3ktZ3JhcGgvbGliL2RlcF9ncmFwaC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsZ0JBQWdCLCtCQUErQjtBQUMvQztBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsUUFBUTtBQUNuRCxzQkFBc0Isc0NBQXNDO0FBQzVEO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixnQkFBZ0I7QUFDaEMsbUJBQW1CO0FBQ25CLDJCQUEyQjtBQUMzQiwyQkFBMkI7QUFDM0IsMkNBQTJDO0FBQzNDLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiwwQkFBMEI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovL2xlZGdpdHkteWllbGQtZnJvbnRlbmQvLi4vbm9kZV9tb2R1bGVzL2RlcGVuZGVuY3ktZ3JhcGgvbGliL2RlcF9ncmFwaC5qcz82ZWMwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQSBzaW1wbGUgZGVwZW5kZW5jeSBncmFwaFxuICovXG5cbi8qKlxuICogSGVscGVyIGZvciBjcmVhdGluZyBhIFRvcG9sb2dpY2FsIFNvcnQgdXNpbmcgRGVwdGgtRmlyc3QtU2VhcmNoIG9uIGEgc2V0IG9mIGVkZ2VzLlxuICpcbiAqIERldGVjdHMgY3ljbGVzIGFuZCB0aHJvd3MgYW4gRXJyb3IgaWYgb25lIGlzIGRldGVjdGVkICh1bmxlc3MgdGhlIFwiY2lyY3VsYXJcIlxuICogcGFyYW1ldGVyIGlzIFwidHJ1ZVwiIGluIHdoaWNoIGNhc2UgaXQgaWdub3JlcyB0aGVtKS5cbiAqXG4gKiBAcGFyYW0gZWRnZXMgVGhlIHNldCBvZiBlZGdlcyB0byBERlMgdGhyb3VnaFxuICogQHBhcmFtIGxlYXZlc09ubHkgV2hldGhlciB0byBvbmx5IHJldHVybiBcImxlYWZcIiBub2RlcyAob25lcyB3aG8gaGF2ZSBubyBlZGdlcylcbiAqIEBwYXJhbSByZXN1bHQgQW4gYXJyYXkgaW4gd2hpY2ggdGhlIHJlc3VsdHMgd2lsbCBiZSBwb3B1bGF0ZWRcbiAqIEBwYXJhbSBjaXJjdWxhciBBIGJvb2xlYW4gdG8gYWxsb3cgY2lyY3VsYXIgZGVwZW5kZW5jaWVzXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZURGUyhlZGdlcywgbGVhdmVzT25seSwgcmVzdWx0LCBjaXJjdWxhcikge1xuICB2YXIgdmlzaXRlZCA9IHt9O1xuICByZXR1cm4gZnVuY3Rpb24gKHN0YXJ0KSB7XG4gICAgaWYgKHZpc2l0ZWRbc3RhcnRdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBpbkN1cnJlbnRQYXRoID0ge307XG4gICAgdmFyIGN1cnJlbnRQYXRoID0gW107XG4gICAgdmFyIHRvZG8gPSBbXTsgLy8gdXNlZCBhcyBhIHN0YWNrXG4gICAgdG9kby5wdXNoKHsgbm9kZTogc3RhcnQsIHByb2Nlc3NlZDogZmFsc2UgfSk7XG4gICAgd2hpbGUgKHRvZG8ubGVuZ3RoID4gMCkge1xuICAgICAgdmFyIGN1cnJlbnQgPSB0b2RvW3RvZG8ubGVuZ3RoIC0gMV07IC8vIHBlZWsgYXQgdGhlIHRvZG8gc3RhY2tcbiAgICAgIHZhciBwcm9jZXNzZWQgPSBjdXJyZW50LnByb2Nlc3NlZDtcbiAgICAgIHZhciBub2RlID0gY3VycmVudC5ub2RlO1xuICAgICAgaWYgKCFwcm9jZXNzZWQpIHtcbiAgICAgICAgLy8gSGF2ZW4ndCB2aXNpdGVkIGVkZ2VzIHlldCAodmlzaXRpbmcgcGhhc2UpXG4gICAgICAgIGlmICh2aXNpdGVkW25vZGVdKSB7XG4gICAgICAgICAgdG9kby5wb3AoKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIGlmIChpbkN1cnJlbnRQYXRoW25vZGVdKSB7XG4gICAgICAgICAgLy8gSXQncyBub3QgYSBEQUdcbiAgICAgICAgICBpZiAoY2lyY3VsYXIpIHtcbiAgICAgICAgICAgIHRvZG8ucG9wKCk7XG4gICAgICAgICAgICAvLyBJZiB3ZSdyZSB0b2xlcmF0aW5nIGN5Y2xlcywgZG9uJ3QgcmV2aXNpdCB0aGUgbm9kZVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGN1cnJlbnRQYXRoLnB1c2gobm9kZSk7XG4gICAgICAgICAgdGhyb3cgbmV3IERlcEdyYXBoQ3ljbGVFcnJvcihjdXJyZW50UGF0aCk7XG4gICAgICAgIH1cblxuICAgICAgICBpbkN1cnJlbnRQYXRoW25vZGVdID0gdHJ1ZTtcbiAgICAgICAgY3VycmVudFBhdGgucHVzaChub2RlKTtcbiAgICAgICAgdmFyIG5vZGVFZGdlcyA9IGVkZ2VzW25vZGVdO1xuICAgICAgICAvLyAocHVzaCBlZGdlcyBvbnRvIHRoZSB0b2RvIHN0YWNrIGluIHJldmVyc2Ugb3JkZXIgdG8gYmUgb3JkZXItY29tcGF0aWJsZSB3aXRoIHRoZSBvbGQgREZTIGltcGxlbWVudGF0aW9uKVxuICAgICAgICBmb3IgKHZhciBpID0gbm9kZUVkZ2VzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgdG9kby5wdXNoKHsgbm9kZTogbm9kZUVkZ2VzW2ldLCBwcm9jZXNzZWQ6IGZhbHNlIH0pO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnQucHJvY2Vzc2VkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEhhdmUgdmlzaXRlZCBlZGdlcyAoc3RhY2sgdW5yb2xsaW5nIHBoYXNlKVxuICAgICAgICB0b2RvLnBvcCgpO1xuICAgICAgICBjdXJyZW50UGF0aC5wb3AoKTtcbiAgICAgICAgaW5DdXJyZW50UGF0aFtub2RlXSA9IGZhbHNlO1xuICAgICAgICB2aXNpdGVkW25vZGVdID0gdHJ1ZTtcbiAgICAgICAgaWYgKCFsZWF2ZXNPbmx5IHx8IGVkZ2VzW25vZGVdLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKG5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIFNpbXBsZSBEZXBlbmRlbmN5IEdyYXBoXG4gKi9cbnZhciBEZXBHcmFwaCA9IChleHBvcnRzLkRlcEdyYXBoID0gZnVuY3Rpb24gRGVwR3JhcGgob3B0cykge1xuICB0aGlzLm5vZGVzID0ge307IC8vIE5vZGUgLT4gTm9kZS9EYXRhICh0cmVhdGVkIGxpa2UgYSBTZXQpXG4gIHRoaXMub3V0Z29pbmdFZGdlcyA9IHt9OyAvLyBOb2RlIC0+IFtEZXBlbmRlbmN5IE5vZGVdXG4gIHRoaXMuaW5jb21pbmdFZGdlcyA9IHt9OyAvLyBOb2RlIC0+IFtEZXBlbmRhbnQgTm9kZV1cbiAgdGhpcy5jaXJjdWxhciA9IG9wdHMgJiYgISFvcHRzLmNpcmN1bGFyOyAvLyBBbGxvd3MgY2lyY3VsYXIgZGVwc1xufSk7XG5EZXBHcmFwaC5wcm90b3R5cGUgPSB7XG4gIC8qKlxuICAgKiBUaGUgbnVtYmVyIG9mIG5vZGVzIGluIHRoZSBncmFwaC5cbiAgICovXG4gIHNpemU6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5ub2RlcykubGVuZ3RoO1xuICB9LFxuICAvKipcbiAgICogQWRkIGEgbm9kZSB0byB0aGUgZGVwZW5kZW5jeSBncmFwaC4gSWYgYSBub2RlIGFscmVhZHkgZXhpc3RzLCB0aGlzIG1ldGhvZCB3aWxsIGRvIG5vdGhpbmcuXG4gICAqL1xuICBhZGROb2RlOiBmdW5jdGlvbiAobm9kZSwgZGF0YSkge1xuICAgIGlmICghdGhpcy5oYXNOb2RlKG5vZGUpKSB7XG4gICAgICAvLyBDaGVja2luZyB0aGUgYXJndW1lbnRzIGxlbmd0aCBhbGxvd3MgdGhlIHVzZXIgdG8gYWRkIGEgbm9kZSB3aXRoIHVuZGVmaW5lZCBkYXRhXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICB0aGlzLm5vZGVzW25vZGVdID0gZGF0YTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubm9kZXNbbm9kZV0gPSBub2RlO1xuICAgICAgfVxuICAgICAgdGhpcy5vdXRnb2luZ0VkZ2VzW25vZGVdID0gW107XG4gICAgICB0aGlzLmluY29taW5nRWRnZXNbbm9kZV0gPSBbXTtcbiAgICB9XG4gIH0sXG4gIC8qKlxuICAgKiBSZW1vdmUgYSBub2RlIGZyb20gdGhlIGRlcGVuZGVuY3kgZ3JhcGguIElmIGEgbm9kZSBkb2VzIG5vdCBleGlzdCwgdGhpcyBtZXRob2Qgd2lsbCBkbyBub3RoaW5nLlxuICAgKi9cbiAgcmVtb3ZlTm9kZTogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICBpZiAodGhpcy5oYXNOb2RlKG5vZGUpKSB7XG4gICAgICBkZWxldGUgdGhpcy5ub2Rlc1tub2RlXTtcbiAgICAgIGRlbGV0ZSB0aGlzLm91dGdvaW5nRWRnZXNbbm9kZV07XG4gICAgICBkZWxldGUgdGhpcy5pbmNvbWluZ0VkZ2VzW25vZGVdO1xuICAgICAgW3RoaXMuaW5jb21pbmdFZGdlcywgdGhpcy5vdXRnb2luZ0VkZ2VzXS5mb3JFYWNoKGZ1bmN0aW9uIChlZGdlTGlzdCkge1xuICAgICAgICBPYmplY3Qua2V5cyhlZGdlTGlzdCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgdmFyIGlkeCA9IGVkZ2VMaXN0W2tleV0uaW5kZXhPZihub2RlKTtcbiAgICAgICAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgICAgICAgIGVkZ2VMaXN0W2tleV0uc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgbm9kZSBleGlzdHMgaW4gdGhlIGdyYXBoXG4gICAqL1xuICBoYXNOb2RlOiBmdW5jdGlvbiAobm9kZSkge1xuICAgIHJldHVybiB0aGlzLm5vZGVzLmhhc093blByb3BlcnR5KG5vZGUpO1xuICB9LFxuICAvKipcbiAgICogR2V0IHRoZSBkYXRhIGFzc29jaWF0ZWQgd2l0aCBhIG5vZGUgbmFtZVxuICAgKi9cbiAgZ2V0Tm9kZURhdGE6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgaWYgKHRoaXMuaGFzTm9kZShub2RlKSkge1xuICAgICAgcmV0dXJuIHRoaXMubm9kZXNbbm9kZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vZGUgZG9lcyBub3QgZXhpc3Q6IFwiICsgbm9kZSk7XG4gICAgfVxuICB9LFxuICAvKipcbiAgICogU2V0IHRoZSBhc3NvY2lhdGVkIGRhdGEgZm9yIGEgZ2l2ZW4gbm9kZSBuYW1lLiBJZiB0aGUgbm9kZSBkb2VzIG5vdCBleGlzdCwgdGhpcyBtZXRob2Qgd2lsbCB0aHJvdyBhbiBlcnJvclxuICAgKi9cbiAgc2V0Tm9kZURhdGE6IGZ1bmN0aW9uIChub2RlLCBkYXRhKSB7XG4gICAgaWYgKHRoaXMuaGFzTm9kZShub2RlKSkge1xuICAgICAgdGhpcy5ub2Rlc1tub2RlXSA9IGRhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vZGUgZG9lcyBub3QgZXhpc3Q6IFwiICsgbm9kZSk7XG4gICAgfVxuICB9LFxuICAvKipcbiAgICogQWRkIGEgZGVwZW5kZW5jeSBiZXR3ZWVuIHR3byBub2Rlcy4gSWYgZWl0aGVyIG9mIHRoZSBub2RlcyBkb2VzIG5vdCBleGlzdCxcbiAgICogYW4gRXJyb3Igd2lsbCBiZSB0aHJvd24uXG4gICAqL1xuICBhZGREZXBlbmRlbmN5OiBmdW5jdGlvbiAoZnJvbSwgdG8pIHtcbiAgICBpZiAoIXRoaXMuaGFzTm9kZShmcm9tKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm9kZSBkb2VzIG5vdCBleGlzdDogXCIgKyBmcm9tKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmhhc05vZGUodG8pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb2RlIGRvZXMgbm90IGV4aXN0OiBcIiArIHRvKTtcbiAgICB9XG4gICAgaWYgKHRoaXMub3V0Z29pbmdFZGdlc1tmcm9tXS5pbmRleE9mKHRvKSA9PT0gLTEpIHtcbiAgICAgIHRoaXMub3V0Z29pbmdFZGdlc1tmcm9tXS5wdXNoKHRvKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaW5jb21pbmdFZGdlc1t0b10uaW5kZXhPZihmcm9tKSA9PT0gLTEpIHtcbiAgICAgIHRoaXMuaW5jb21pbmdFZGdlc1t0b10ucHVzaChmcm9tKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG4gIC8qKlxuICAgKiBSZW1vdmUgYSBkZXBlbmRlbmN5IGJldHdlZW4gdHdvIG5vZGVzLlxuICAgKi9cbiAgcmVtb3ZlRGVwZW5kZW5jeTogZnVuY3Rpb24gKGZyb20sIHRvKSB7XG4gICAgdmFyIGlkeDtcbiAgICBpZiAodGhpcy5oYXNOb2RlKGZyb20pKSB7XG4gICAgICBpZHggPSB0aGlzLm91dGdvaW5nRWRnZXNbZnJvbV0uaW5kZXhPZih0byk7XG4gICAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgICAgdGhpcy5vdXRnb2luZ0VkZ2VzW2Zyb21dLnNwbGljZShpZHgsIDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmhhc05vZGUodG8pKSB7XG4gICAgICBpZHggPSB0aGlzLmluY29taW5nRWRnZXNbdG9dLmluZGV4T2YoZnJvbSk7XG4gICAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgICAgdGhpcy5pbmNvbWluZ0VkZ2VzW3RvXS5zcGxpY2UoaWR4LCAxKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBjbG9uZSBvZiB0aGUgZGVwZW5kZW5jeSBncmFwaC4gSWYgYW55IGN1c3RvbSBkYXRhIGlzIGF0dGFjaGVkXG4gICAqIHRvIHRoZSBub2RlcywgaXQgd2lsbCBvbmx5IGJlIHNoYWxsb3cgY29waWVkLlxuICAgKi9cbiAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc291cmNlID0gdGhpcztcbiAgICB2YXIgcmVzdWx0ID0gbmV3IERlcEdyYXBoKCk7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2Uubm9kZXMpO1xuICAgIGtleXMuZm9yRWFjaChmdW5jdGlvbiAobikge1xuICAgICAgcmVzdWx0Lm5vZGVzW25dID0gc291cmNlLm5vZGVzW25dO1xuICAgICAgcmVzdWx0Lm91dGdvaW5nRWRnZXNbbl0gPSBzb3VyY2Uub3V0Z29pbmdFZGdlc1tuXS5zbGljZSgwKTtcbiAgICAgIHJlc3VsdC5pbmNvbWluZ0VkZ2VzW25dID0gc291cmNlLmluY29taW5nRWRnZXNbbl0uc2xpY2UoMCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSxcbiAgLyoqXG4gICAqIEdldCBhbiBhcnJheSBjb250YWluaW5nIHRoZSBkaXJlY3QgZGVwZW5kZW5jaWVzIG9mIHRoZSBzcGVjaWZpZWQgbm9kZS5cbiAgICpcbiAgICogVGhyb3dzIGFuIEVycm9yIGlmIHRoZSBzcGVjaWZpZWQgbm9kZSBkb2VzIG5vdCBleGlzdC5cbiAgICovXG4gIGRpcmVjdERlcGVuZGVuY2llc09mOiBmdW5jdGlvbiAobm9kZSkge1xuICAgIGlmICh0aGlzLmhhc05vZGUobm9kZSkpIHtcbiAgICAgIHJldHVybiB0aGlzLm91dGdvaW5nRWRnZXNbbm9kZV0uc2xpY2UoMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vZGUgZG9lcyBub3QgZXhpc3Q6IFwiICsgbm9kZSk7XG4gICAgfVxuICB9LFxuICAvKipcbiAgICogR2V0IGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIG5vZGVzIHRoYXQgZGlyZWN0bHkgZGVwZW5kIG9uIHRoZSBzcGVjaWZpZWQgbm9kZS5cbiAgICpcbiAgICogVGhyb3dzIGFuIEVycm9yIGlmIHRoZSBzcGVjaWZpZWQgbm9kZSBkb2VzIG5vdCBleGlzdC5cbiAgICovXG4gIGRpcmVjdERlcGVuZGFudHNPZjogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICBpZiAodGhpcy5oYXNOb2RlKG5vZGUpKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbmNvbWluZ0VkZ2VzW25vZGVdLnNsaWNlKDApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb2RlIGRvZXMgbm90IGV4aXN0OiBcIiArIG5vZGUpO1xuICAgIH1cbiAgfSxcbiAgLyoqXG4gICAqIEdldCBhbiBhcnJheSBjb250YWluaW5nIHRoZSBub2RlcyB0aGF0IHRoZSBzcGVjaWZpZWQgbm9kZSBkZXBlbmRzIG9uICh0cmFuc2l0aXZlbHkpLlxuICAgKlxuICAgKiBUaHJvd3MgYW4gRXJyb3IgaWYgdGhlIGdyYXBoIGhhcyBhIGN5Y2xlLCBvciB0aGUgc3BlY2lmaWVkIG5vZGUgZG9lcyBub3QgZXhpc3QuXG4gICAqXG4gICAqIElmIGBsZWF2ZXNPbmx5YCBpcyB0cnVlLCBvbmx5IG5vZGVzIHRoYXQgZG8gbm90IGRlcGVuZCBvbiBhbnkgb3RoZXIgbm9kZXMgd2lsbCBiZSByZXR1cm5lZFxuICAgKiBpbiB0aGUgYXJyYXkuXG4gICAqL1xuICBkZXBlbmRlbmNpZXNPZjogZnVuY3Rpb24gKG5vZGUsIGxlYXZlc09ubHkpIHtcbiAgICBpZiAodGhpcy5oYXNOb2RlKG5vZGUpKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICB2YXIgREZTID0gY3JlYXRlREZTKFxuICAgICAgICB0aGlzLm91dGdvaW5nRWRnZXMsXG4gICAgICAgIGxlYXZlc09ubHksXG4gICAgICAgIHJlc3VsdCxcbiAgICAgICAgdGhpcy5jaXJjdWxhclxuICAgICAgKTtcbiAgICAgIERGUyhub2RlKTtcbiAgICAgIHZhciBpZHggPSByZXN1bHQuaW5kZXhPZihub2RlKTtcbiAgICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgICByZXN1bHQuc3BsaWNlKGlkeCwgMSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb2RlIGRvZXMgbm90IGV4aXN0OiBcIiArIG5vZGUpO1xuICAgIH1cbiAgfSxcbiAgLyoqXG4gICAqIGdldCBhbiBhcnJheSBjb250YWluaW5nIHRoZSBub2RlcyB0aGF0IGRlcGVuZCBvbiB0aGUgc3BlY2lmaWVkIG5vZGUgKHRyYW5zaXRpdmVseSkuXG4gICAqXG4gICAqIFRocm93cyBhbiBFcnJvciBpZiB0aGUgZ3JhcGggaGFzIGEgY3ljbGUsIG9yIHRoZSBzcGVjaWZpZWQgbm9kZSBkb2VzIG5vdCBleGlzdC5cbiAgICpcbiAgICogSWYgYGxlYXZlc09ubHlgIGlzIHRydWUsIG9ubHkgbm9kZXMgdGhhdCBkbyBub3QgaGF2ZSBhbnkgZGVwZW5kYW50cyB3aWxsIGJlIHJldHVybmVkIGluIHRoZSBhcnJheS5cbiAgICovXG4gIGRlcGVuZGFudHNPZjogZnVuY3Rpb24gKG5vZGUsIGxlYXZlc09ubHkpIHtcbiAgICBpZiAodGhpcy5oYXNOb2RlKG5vZGUpKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICB2YXIgREZTID0gY3JlYXRlREZTKFxuICAgICAgICB0aGlzLmluY29taW5nRWRnZXMsXG4gICAgICAgIGxlYXZlc09ubHksXG4gICAgICAgIHJlc3VsdCxcbiAgICAgICAgdGhpcy5jaXJjdWxhclxuICAgICAgKTtcbiAgICAgIERGUyhub2RlKTtcbiAgICAgIHZhciBpZHggPSByZXN1bHQuaW5kZXhPZihub2RlKTtcbiAgICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgICByZXN1bHQuc3BsaWNlKGlkeCwgMSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb2RlIGRvZXMgbm90IGV4aXN0OiBcIiArIG5vZGUpO1xuICAgIH1cbiAgfSxcbiAgLyoqXG4gICAqIENvbnN0cnVjdCB0aGUgb3ZlcmFsbCBwcm9jZXNzaW5nIG9yZGVyIGZvciB0aGUgZGVwZW5kZW5jeSBncmFwaC5cbiAgICpcbiAgICogVGhyb3dzIGFuIEVycm9yIGlmIHRoZSBncmFwaCBoYXMgYSBjeWNsZS5cbiAgICpcbiAgICogSWYgYGxlYXZlc09ubHlgIGlzIHRydWUsIG9ubHkgbm9kZXMgdGhhdCBkbyBub3QgZGVwZW5kIG9uIGFueSBvdGhlciBub2RlcyB3aWxsIGJlIHJldHVybmVkLlxuICAgKi9cbiAgb3ZlcmFsbE9yZGVyOiBmdW5jdGlvbiAobGVhdmVzT25seSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh0aGlzLm5vZGVzKTtcbiAgICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiByZXN1bHQ7IC8vIEVtcHR5IGdyYXBoXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghdGhpcy5jaXJjdWxhcikge1xuICAgICAgICAvLyBMb29rIGZvciBjeWNsZXMgLSB3ZSBydW4gdGhlIERGUyBzdGFydGluZyBhdCBhbGwgdGhlIG5vZGVzIGluIGNhc2UgdGhlcmVcbiAgICAgICAgLy8gYXJlIHNldmVyYWwgZGlzY29ubmVjdGVkIHN1YmdyYXBocyBpbnNpZGUgdGhpcyBkZXBlbmRlbmN5IGdyYXBoLlxuICAgICAgICB2YXIgQ3ljbGVERlMgPSBjcmVhdGVERlModGhpcy5vdXRnb2luZ0VkZ2VzLCBmYWxzZSwgW10sIHRoaXMuY2lyY3VsYXIpO1xuICAgICAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgICBDeWNsZURGUyhuKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBERlMgPSBjcmVhdGVERlMoXG4gICAgICAgIHRoaXMub3V0Z29pbmdFZGdlcyxcbiAgICAgICAgbGVhdmVzT25seSxcbiAgICAgICAgcmVzdWx0LFxuICAgICAgICB0aGlzLmNpcmN1bGFyXG4gICAgICApO1xuICAgICAgLy8gRmluZCBhbGwgcG90ZW50aWFsIHN0YXJ0aW5nIHBvaW50cyAobm9kZXMgd2l0aCBub3RoaW5nIGRlcGVuZGluZyBvbiB0aGVtKSBhblxuICAgICAgLy8gcnVuIGEgREZTIHN0YXJ0aW5nIGF0IHRoZXNlIHBvaW50cyB0byBnZXQgdGhlIG9yZGVyXG4gICAgICBrZXlzXG4gICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICByZXR1cm4gc2VsZi5pbmNvbWluZ0VkZ2VzW25vZGVdLmxlbmd0aCA9PT0gMDtcbiAgICAgICAgfSlcbiAgICAgICAgLmZvckVhY2goZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgICBERlMobik7XG4gICAgICAgIH0pO1xuXG4gICAgICAvLyBJZiB3ZSdyZSBhbGxvd2luZyBjeWNsZXMgLSB3ZSBuZWVkIHRvIHJ1biB0aGUgREZTIGFnYWluc3QgYW55IHJlbWFpbmluZ1xuICAgICAgLy8gbm9kZXMgdGhhdCBkaWQgbm90IGVuZCB1cCBpbiB0aGUgaW5pdGlhbCByZXN1bHQgKGFzIHRoZXkgYXJlIHBhcnQgb2YgYVxuICAgICAgLy8gc3ViZ3JhcGggdGhhdCBkb2VzIG5vdCBoYXZlIGEgY2xlYXIgc3RhcnRpbmcgcG9pbnQpXG4gICAgICBpZiAodGhpcy5jaXJjdWxhcikge1xuICAgICAgICBrZXlzXG4gICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5pbmRleE9mKG5vZGUpID09PSAtMTtcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChuKSB7XG4gICAgICAgICAgICBERlMobik7XG4gICAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9LFxuICAvKipcbiAgICogR2V0IGFuIGFycmF5IG9mIG5vZGVzIHRoYXQgaGF2ZSBubyBkZXBlbmRhbnRzIChpLmUuIG5vdGhpbmcgZGVwZW5kcyBvbiB0aGVtKS5cbiAgICovXG4gIGVudHJ5Tm9kZXM6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMubm9kZXMpLmZpbHRlcihmdW5jdGlvbiAobm9kZSkge1xuICAgICAgcmV0dXJuIHNlbGYuaW5jb21pbmdFZGdlc1tub2RlXS5sZW5ndGggPT09IDA7XG4gICAgfSk7XG4gIH1cbn07XG5cbi8vIENyZWF0ZSBzb21lIGFsaWFzZXNcbkRlcEdyYXBoLnByb3RvdHlwZS5kaXJlY3REZXBlbmRlbnRzT2YgPSBEZXBHcmFwaC5wcm90b3R5cGUuZGlyZWN0RGVwZW5kYW50c09mO1xuRGVwR3JhcGgucHJvdG90eXBlLmRlcGVuZGVudHNPZiA9IERlcEdyYXBoLnByb3RvdHlwZS5kZXBlbmRhbnRzT2Y7XG5cbi8qKlxuICogQ3ljbGUgZXJyb3IsIGluY2x1ZGluZyB0aGUgcGF0aCBvZiB0aGUgY3ljbGUuXG4gKi9cbnZhciBEZXBHcmFwaEN5Y2xlRXJyb3IgPSAoZXhwb3J0cy5EZXBHcmFwaEN5Y2xlRXJyb3IgPSBmdW5jdGlvbiAoY3ljbGVQYXRoKSB7XG4gIHZhciBtZXNzYWdlID0gXCJEZXBlbmRlbmN5IEN5Y2xlIEZvdW5kOiBcIiArIGN5Y2xlUGF0aC5qb2luKFwiIC0+IFwiKTtcbiAgdmFyIGluc3RhbmNlID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICBpbnN0YW5jZS5jeWNsZVBhdGggPSBjeWNsZVBhdGg7XG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihpbnN0YW5jZSwgT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpKTtcbiAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoaW5zdGFuY2UsIERlcEdyYXBoQ3ljbGVFcnJvcik7XG4gIH1cbiAgcmV0dXJuIGluc3RhbmNlO1xufSk7XG5EZXBHcmFwaEN5Y2xlRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUsIHtcbiAgY29uc3RydWN0b3I6IHtcbiAgICB2YWx1ZTogRXJyb3IsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH1cbn0pO1xuT2JqZWN0LnNldFByb3RvdHlwZU9mKERlcEdyYXBoQ3ljbGVFcnJvciwgRXJyb3IpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/dependency-graph/lib/dep_graph.js\n");

/***/ })

};
;