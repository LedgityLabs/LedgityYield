"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/graphql-ws";
exports.ids = ["vendor-chunks/graphql-ws"];
exports.modules = {

/***/ "(ssr)/../node_modules/graphql-ws/lib/client.mjs":
/*!*************************************************!*\
  !*** ../node_modules/graphql-ws/lib/client.mjs ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CloseCode: () => (/* reexport safe */ _common_mjs__WEBPACK_IMPORTED_MODULE_0__.CloseCode),\n/* harmony export */   DEPRECATED_GRAPHQL_WS_PROTOCOL: () => (/* reexport safe */ _common_mjs__WEBPACK_IMPORTED_MODULE_0__.DEPRECATED_GRAPHQL_WS_PROTOCOL),\n/* harmony export */   GRAPHQL_TRANSPORT_WS_PROTOCOL: () => (/* reexport safe */ _common_mjs__WEBPACK_IMPORTED_MODULE_0__.GRAPHQL_TRANSPORT_WS_PROTOCOL),\n/* harmony export */   MessageType: () => (/* reexport safe */ _common_mjs__WEBPACK_IMPORTED_MODULE_0__.MessageType),\n/* harmony export */   TerminatedCloseEvent: () => (/* binding */ TerminatedCloseEvent),\n/* harmony export */   createClient: () => (/* binding */ createClient),\n/* harmony export */   isMessage: () => (/* reexport safe */ _common_mjs__WEBPACK_IMPORTED_MODULE_0__.isMessage),\n/* harmony export */   parseMessage: () => (/* reexport safe */ _common_mjs__WEBPACK_IMPORTED_MODULE_0__.parseMessage),\n/* harmony export */   stringifyMessage: () => (/* reexport safe */ _common_mjs__WEBPACK_IMPORTED_MODULE_0__.stringifyMessage),\n/* harmony export */   validateMessage: () => (/* reexport safe */ _common_mjs__WEBPACK_IMPORTED_MODULE_0__.validateMessage)\n/* harmony export */ });\n/* harmony import */ var _common_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.mjs */ \"(ssr)/../node_modules/graphql-ws/lib/common.mjs\");\n/* harmony import */ var _utils_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.mjs */ \"(ssr)/../node_modules/graphql-ws/lib/utils.mjs\");\n/**\n *\n * client\n *\n */\nvar __await = (undefined && undefined.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }\nvar __asyncGenerator = (undefined && undefined.__asyncGenerator) || function (thisArg, _arguments, generator) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n    function fulfill(value) { resume(\"next\", value); }\n    function reject(value) { resume(\"throw\", value); }\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n};\n\n\n/** This file is the entry point for browsers, re-export common elements. */\n\n/**\n * Creates a disposable GraphQL over WebSocket client.\n *\n * @category Client\n */\nfunction createClient(options) {\n    const { url, connectionParams, lazy = true, onNonLazyError = console.error, lazyCloseTimeout: lazyCloseTimeoutMs = 0, keepAlive = 0, disablePong, connectionAckWaitTimeout = 0, retryAttempts = 5, retryWait = async function randomisedExponentialBackoff(retries) {\n        let retryDelay = 1000; // start with 1s delay\n        for (let i = 0; i < retries; i++) {\n            retryDelay *= 2;\n        }\n        await new Promise((resolve) => setTimeout(resolve, retryDelay +\n            // add random timeout from 300ms to 3s\n            Math.floor(Math.random() * (3000 - 300) + 300)));\n    }, shouldRetry = isLikeCloseEvent, isFatalConnectionProblem, on, webSocketImpl, \n    /**\n     * Generates a v4 UUID to be used as the ID using `Math`\n     * as the random number generator. Supply your own generator\n     * in case you need more uniqueness.\n     *\n     * Reference: https://gist.github.com/jed/982883\n     */\n    generateID = function generateUUID() {\n        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\n            const r = (Math.random() * 16) | 0, v = c == 'x' ? r : (r & 0x3) | 0x8;\n            return v.toString(16);\n        });\n    }, jsonMessageReplacer: replacer, jsonMessageReviver: reviver, } = options;\n    let ws;\n    if (webSocketImpl) {\n        if (!isWebSocket(webSocketImpl)) {\n            throw new Error('Invalid WebSocket implementation provided');\n        }\n        ws = webSocketImpl;\n    }\n    else if (typeof WebSocket !== 'undefined') {\n        ws = WebSocket;\n    }\n    else if (typeof global !== 'undefined') {\n        ws =\n            global.WebSocket ||\n                // @ts-expect-error: Support more browsers\n                global.MozWebSocket;\n    }\n    else if (typeof window !== 'undefined') {\n        ws =\n            window.WebSocket ||\n                // @ts-expect-error: Support more browsers\n                window.MozWebSocket;\n    }\n    if (!ws)\n        throw new Error(\"WebSocket implementation missing; on Node you can `import WebSocket from 'ws';` and pass `webSocketImpl: WebSocket` to `createClient`\");\n    const WebSocketImpl = ws;\n    // websocket status emitter, subscriptions are handled differently\n    const emitter = (() => {\n        const message = (() => {\n            const listeners = {};\n            return {\n                on(id, listener) {\n                    listeners[id] = listener;\n                    return () => {\n                        delete listeners[id];\n                    };\n                },\n                emit(message) {\n                    var _a;\n                    if ('id' in message)\n                        (_a = listeners[message.id]) === null || _a === void 0 ? void 0 : _a.call(listeners, message);\n                },\n            };\n        })();\n        const listeners = {\n            connecting: (on === null || on === void 0 ? void 0 : on.connecting) ? [on.connecting] : [],\n            opened: (on === null || on === void 0 ? void 0 : on.opened) ? [on.opened] : [],\n            connected: (on === null || on === void 0 ? void 0 : on.connected) ? [on.connected] : [],\n            ping: (on === null || on === void 0 ? void 0 : on.ping) ? [on.ping] : [],\n            pong: (on === null || on === void 0 ? void 0 : on.pong) ? [on.pong] : [],\n            message: (on === null || on === void 0 ? void 0 : on.message) ? [message.emit, on.message] : [message.emit],\n            closed: (on === null || on === void 0 ? void 0 : on.closed) ? [on.closed] : [],\n            error: (on === null || on === void 0 ? void 0 : on.error) ? [on.error] : [],\n        };\n        return {\n            onMessage: message.on,\n            on(event, listener) {\n                const l = listeners[event];\n                l.push(listener);\n                return () => {\n                    l.splice(l.indexOf(listener), 1);\n                };\n            },\n            emit(event, ...args) {\n                // we copy the listeners so that unlistens dont \"pull the rug under our feet\"\n                for (const listener of [...listeners[event]]) {\n                    // @ts-expect-error: The args should fit\n                    listener(...args);\n                }\n            },\n        };\n    })();\n    // invokes the callback either when an error or closed event is emitted,\n    // first one that gets called prevails, other emissions are ignored\n    function errorOrClosed(cb) {\n        const listening = [\n            // errors are fatal and more critical than close events, throw them first\n            emitter.on('error', (err) => {\n                listening.forEach((unlisten) => unlisten());\n                cb(err);\n            }),\n            // closes can be graceful and not fatal, throw them second (if error didnt throw)\n            emitter.on('closed', (event) => {\n                listening.forEach((unlisten) => unlisten());\n                cb(event);\n            }),\n        ];\n    }\n    let connecting, locks = 0, lazyCloseTimeout, retrying = false, retries = 0, disposed = false;\n    async function connect() {\n        // clear the lazy close timeout immediatelly so that close gets debounced\n        // see: https://github.com/enisdenjo/graphql-ws/issues/388\n        clearTimeout(lazyCloseTimeout);\n        const [socket, throwOnClose] = await (connecting !== null && connecting !== void 0 ? connecting : (connecting = new Promise((connected, denied) => (async () => {\n            if (retrying) {\n                await retryWait(retries);\n                // subscriptions might complete while waiting for retry\n                if (!locks) {\n                    connecting = undefined;\n                    return denied({ code: 1000, reason: 'All Subscriptions Gone' });\n                }\n                retries++;\n            }\n            emitter.emit('connecting', retrying);\n            const socket = new WebSocketImpl(typeof url === 'function' ? await url() : url, _common_mjs__WEBPACK_IMPORTED_MODULE_0__.GRAPHQL_TRANSPORT_WS_PROTOCOL);\n            let connectionAckTimeout, queuedPing;\n            function enqueuePing() {\n                if (isFinite(keepAlive) && keepAlive > 0) {\n                    clearTimeout(queuedPing); // in case where a pong was received before a ping (this is valid behaviour)\n                    queuedPing = setTimeout(() => {\n                        if (socket.readyState === WebSocketImpl.OPEN) {\n                            socket.send((0,_common_mjs__WEBPACK_IMPORTED_MODULE_0__.stringifyMessage)({ type: _common_mjs__WEBPACK_IMPORTED_MODULE_0__.MessageType.Ping }));\n                            emitter.emit('ping', false, undefined);\n                        }\n                    }, keepAlive);\n                }\n            }\n            errorOrClosed((errOrEvent) => {\n                connecting = undefined;\n                clearTimeout(connectionAckTimeout);\n                clearTimeout(queuedPing);\n                denied(errOrEvent);\n                if (errOrEvent instanceof TerminatedCloseEvent) {\n                    socket.close(4499, 'Terminated'); // close event is artificial and emitted manually, see `Client.terminate()` below\n                    socket.onerror = null;\n                    socket.onclose = null;\n                }\n            });\n            socket.onerror = (err) => emitter.emit('error', err);\n            socket.onclose = (event) => emitter.emit('closed', event);\n            socket.onopen = async () => {\n                try {\n                    emitter.emit('opened', socket);\n                    const payload = typeof connectionParams === 'function'\n                        ? await connectionParams()\n                        : connectionParams;\n                    // connectionParams might take too long causing the server to kick off the client\n                    // the necessary error/close event is already reported - simply stop execution\n                    if (socket.readyState !== WebSocketImpl.OPEN)\n                        return;\n                    socket.send((0,_common_mjs__WEBPACK_IMPORTED_MODULE_0__.stringifyMessage)(payload\n                        ? {\n                            type: _common_mjs__WEBPACK_IMPORTED_MODULE_0__.MessageType.ConnectionInit,\n                            payload,\n                        }\n                        : {\n                            type: _common_mjs__WEBPACK_IMPORTED_MODULE_0__.MessageType.ConnectionInit,\n                            // payload is completely absent if not provided\n                        }, replacer));\n                    if (isFinite(connectionAckWaitTimeout) &&\n                        connectionAckWaitTimeout > 0) {\n                        connectionAckTimeout = setTimeout(() => {\n                            socket.close(_common_mjs__WEBPACK_IMPORTED_MODULE_0__.CloseCode.ConnectionAcknowledgementTimeout, 'Connection acknowledgement timeout');\n                        }, connectionAckWaitTimeout);\n                    }\n                    enqueuePing(); // enqueue ping (noop if disabled)\n                }\n                catch (err) {\n                    emitter.emit('error', err);\n                    socket.close(_common_mjs__WEBPACK_IMPORTED_MODULE_0__.CloseCode.InternalClientError, (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.limitCloseReason)(err instanceof Error ? err.message : new Error(err).message, 'Internal client error'));\n                }\n            };\n            let acknowledged = false;\n            socket.onmessage = ({ data }) => {\n                try {\n                    const message = (0,_common_mjs__WEBPACK_IMPORTED_MODULE_0__.parseMessage)(data, reviver);\n                    emitter.emit('message', message);\n                    if (message.type === 'ping' || message.type === 'pong') {\n                        emitter.emit(message.type, true, message.payload); // received\n                        if (message.type === 'pong') {\n                            enqueuePing(); // enqueue next ping (noop if disabled)\n                        }\n                        else if (!disablePong) {\n                            // respond with pong on ping\n                            socket.send((0,_common_mjs__WEBPACK_IMPORTED_MODULE_0__.stringifyMessage)(message.payload\n                                ? {\n                                    type: _common_mjs__WEBPACK_IMPORTED_MODULE_0__.MessageType.Pong,\n                                    payload: message.payload,\n                                }\n                                : {\n                                    type: _common_mjs__WEBPACK_IMPORTED_MODULE_0__.MessageType.Pong,\n                                    // payload is completely absent if not provided\n                                }));\n                            emitter.emit('pong', false, message.payload);\n                        }\n                        return; // ping and pongs can be received whenever\n                    }\n                    if (acknowledged)\n                        return; // already connected and acknowledged\n                    if (message.type !== _common_mjs__WEBPACK_IMPORTED_MODULE_0__.MessageType.ConnectionAck)\n                        throw new Error(`First message cannot be of type ${message.type}`);\n                    clearTimeout(connectionAckTimeout);\n                    acknowledged = true;\n                    emitter.emit('connected', socket, message.payload, retrying); // connected = socket opened + acknowledged\n                    retrying = false; // future lazy connects are not retries\n                    retries = 0; // reset the retries on connect\n                    connected([\n                        socket,\n                        new Promise((_, reject) => errorOrClosed(reject)),\n                    ]);\n                }\n                catch (err) {\n                    socket.onmessage = null; // stop reading messages as soon as reading breaks once\n                    emitter.emit('error', err);\n                    socket.close(_common_mjs__WEBPACK_IMPORTED_MODULE_0__.CloseCode.BadResponse, (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.limitCloseReason)(err instanceof Error ? err.message : new Error(err).message, 'Bad response'));\n                }\n            };\n        })())));\n        // if the provided socket is in a closing state, wait for the throw on close\n        if (socket.readyState === WebSocketImpl.CLOSING)\n            await throwOnClose;\n        let release = () => {\n            // releases this connection\n        };\n        const released = new Promise((resolve) => (release = resolve));\n        return [\n            socket,\n            release,\n            Promise.race([\n                // wait for\n                released.then(() => {\n                    if (!locks) {\n                        // and if no more locks are present, complete the connection\n                        const complete = () => socket.close(1000, 'Normal Closure');\n                        if (isFinite(lazyCloseTimeoutMs) && lazyCloseTimeoutMs > 0) {\n                            // if the keepalive is set, allow for the specified calmdown time and\n                            // then complete if the socket is still open.\n                            lazyCloseTimeout = setTimeout(() => {\n                                if (socket.readyState === WebSocketImpl.OPEN)\n                                    complete();\n                            }, lazyCloseTimeoutMs);\n                        }\n                        else {\n                            // otherwise complete immediately\n                            complete();\n                        }\n                    }\n                }),\n                // or\n                throwOnClose,\n            ]),\n        ];\n    }\n    /**\n     * Checks the `connect` problem and evaluates if the client should retry.\n     */\n    function shouldRetryConnectOrThrow(errOrCloseEvent) {\n        // some close codes are worth reporting immediately\n        if (isLikeCloseEvent(errOrCloseEvent) &&\n            (isFatalInternalCloseCode(errOrCloseEvent.code) ||\n                [\n                    _common_mjs__WEBPACK_IMPORTED_MODULE_0__.CloseCode.InternalServerError,\n                    _common_mjs__WEBPACK_IMPORTED_MODULE_0__.CloseCode.InternalClientError,\n                    _common_mjs__WEBPACK_IMPORTED_MODULE_0__.CloseCode.BadRequest,\n                    _common_mjs__WEBPACK_IMPORTED_MODULE_0__.CloseCode.BadResponse,\n                    _common_mjs__WEBPACK_IMPORTED_MODULE_0__.CloseCode.Unauthorized,\n                    // CloseCode.Forbidden, might grant access out after retry\n                    _common_mjs__WEBPACK_IMPORTED_MODULE_0__.CloseCode.SubprotocolNotAcceptable,\n                    // CloseCode.ConnectionInitialisationTimeout, might not time out after retry\n                    // CloseCode.ConnectionAcknowledgementTimeout, might not time out after retry\n                    _common_mjs__WEBPACK_IMPORTED_MODULE_0__.CloseCode.SubscriberAlreadyExists,\n                    _common_mjs__WEBPACK_IMPORTED_MODULE_0__.CloseCode.TooManyInitialisationRequests,\n                    // 4499, // Terminated, probably because the socket froze, we want to retry\n                ].includes(errOrCloseEvent.code)))\n            throw errOrCloseEvent;\n        // client was disposed, no retries should proceed regardless\n        if (disposed)\n            return false;\n        // normal closure (possibly all subscriptions have completed)\n        // if no locks were acquired in the meantime, shouldnt try again\n        if (isLikeCloseEvent(errOrCloseEvent) && errOrCloseEvent.code === 1000)\n            return locks > 0;\n        // retries are not allowed or we tried to many times, report error\n        if (!retryAttempts || retries >= retryAttempts)\n            throw errOrCloseEvent;\n        // throw non-retryable connection problems\n        if (!shouldRetry(errOrCloseEvent))\n            throw errOrCloseEvent;\n        // @deprecated throw fatal connection problems immediately\n        if (isFatalConnectionProblem === null || isFatalConnectionProblem === void 0 ? void 0 : isFatalConnectionProblem(errOrCloseEvent))\n            throw errOrCloseEvent;\n        // looks good, start retrying\n        return (retrying = true);\n    }\n    // in non-lazy (hot?) mode always hold one connection lock to persist the socket\n    if (!lazy) {\n        (async () => {\n            locks++;\n            for (;;) {\n                try {\n                    const [, , throwOnClose] = await connect();\n                    await throwOnClose; // will always throw because releaser is not used\n                }\n                catch (errOrCloseEvent) {\n                    try {\n                        if (!shouldRetryConnectOrThrow(errOrCloseEvent))\n                            return;\n                    }\n                    catch (errOrCloseEvent) {\n                        // report thrown error, no further retries\n                        return onNonLazyError === null || onNonLazyError === void 0 ? void 0 : onNonLazyError(errOrCloseEvent);\n                    }\n                }\n            }\n        })();\n    }\n    function subscribe(payload, sink) {\n        const id = generateID(payload);\n        let done = false, errored = false, releaser = () => {\n            // for handling completions before connect\n            locks--;\n            done = true;\n        };\n        (async () => {\n            locks++;\n            for (;;) {\n                try {\n                    const [socket, release, waitForReleaseOrThrowOnClose] = await connect();\n                    // if done while waiting for connect, release the connection lock right away\n                    if (done)\n                        return release();\n                    const unlisten = emitter.onMessage(id, (message) => {\n                        switch (message.type) {\n                            case _common_mjs__WEBPACK_IMPORTED_MODULE_0__.MessageType.Next: {\n                                // eslint-disable-next-line @typescript-eslint/no-explicit-any -- payload will fit type\n                                sink.next(message.payload);\n                                return;\n                            }\n                            case _common_mjs__WEBPACK_IMPORTED_MODULE_0__.MessageType.Error: {\n                                (errored = true), (done = true);\n                                sink.error(message.payload);\n                                releaser();\n                                return;\n                            }\n                            case _common_mjs__WEBPACK_IMPORTED_MODULE_0__.MessageType.Complete: {\n                                done = true;\n                                releaser(); // release completes the sink\n                                return;\n                            }\n                        }\n                    });\n                    socket.send((0,_common_mjs__WEBPACK_IMPORTED_MODULE_0__.stringifyMessage)({\n                        id,\n                        type: _common_mjs__WEBPACK_IMPORTED_MODULE_0__.MessageType.Subscribe,\n                        payload,\n                    }, replacer));\n                    releaser = () => {\n                        if (!done && socket.readyState === WebSocketImpl.OPEN)\n                            // if not completed already and socket is open, send complete message to server on release\n                            socket.send((0,_common_mjs__WEBPACK_IMPORTED_MODULE_0__.stringifyMessage)({\n                                id,\n                                type: _common_mjs__WEBPACK_IMPORTED_MODULE_0__.MessageType.Complete,\n                            }, replacer));\n                        locks--;\n                        done = true;\n                        release();\n                    };\n                    // either the releaser will be called, connection completed and\n                    // the promise resolved or the socket closed and the promise rejected.\n                    // whatever happens though, we want to stop listening for messages\n                    await waitForReleaseOrThrowOnClose.finally(unlisten);\n                    return; // completed, shouldnt try again\n                }\n                catch (errOrCloseEvent) {\n                    if (!shouldRetryConnectOrThrow(errOrCloseEvent))\n                        return;\n                }\n            }\n        })()\n            .then(() => {\n            // delivering either an error or a complete terminates the sequence\n            if (!errored)\n                sink.complete();\n        }) // resolves on release or normal closure\n            .catch((err) => {\n            sink.error(err);\n        }); // rejects on close events and errors\n        return () => {\n            // dispose only of active subscriptions\n            if (!done)\n                releaser();\n        };\n    }\n    return {\n        on: emitter.on,\n        subscribe,\n        iterate(request) {\n            const pending = [];\n            const deferred = {\n                done: false,\n                error: null,\n                resolve: () => {\n                    // noop\n                },\n            };\n            const dispose = subscribe(request, {\n                next(val) {\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    pending.push(val);\n                    deferred.resolve();\n                },\n                error(err) {\n                    deferred.done = true;\n                    deferred.error = err;\n                    deferred.resolve();\n                },\n                complete() {\n                    deferred.done = true;\n                    deferred.resolve();\n                },\n            });\n            const iterator = (function iterator() {\n                return __asyncGenerator(this, arguments, function* iterator_1() {\n                    for (;;) {\n                        if (!pending.length) {\n                            // only wait if there are no pending messages available\n                            yield __await(new Promise((resolve) => (deferred.resolve = resolve)));\n                        }\n                        // first flush\n                        while (pending.length) {\n                            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                            yield yield __await(pending.shift());\n                        }\n                        // then error\n                        if (deferred.error) {\n                            throw deferred.error;\n                        }\n                        // or complete\n                        if (deferred.done) {\n                            return yield __await(void 0);\n                        }\n                    }\n                });\n            })();\n            iterator.throw = async (err) => {\n                if (!deferred.done) {\n                    deferred.done = true;\n                    deferred.error = err;\n                    deferred.resolve();\n                }\n                return { done: true, value: undefined };\n            };\n            iterator.return = async () => {\n                dispose();\n                return { done: true, value: undefined };\n            };\n            return iterator;\n        },\n        async dispose() {\n            disposed = true;\n            if (connecting) {\n                // if there is a connection, close it\n                const [socket] = await connecting;\n                socket.close(1000, 'Normal Closure');\n            }\n        },\n        terminate() {\n            if (connecting) {\n                // only if there is a connection\n                emitter.emit('closed', new TerminatedCloseEvent());\n            }\n        },\n    };\n}\n/**\n * A syntetic close event `4499: Terminated` is issued to the current to immediately\n * close the connection without waiting for the one coming from `WebSocket.onclose`.\n *\n * Terminating is not considered fatal and a connection retry will occur as expected.\n *\n * Useful in cases where the WebSocket is stuck and not emitting any events;\n * can happen on iOS Safari, see: https://github.com/enisdenjo/graphql-ws/discussions/290.\n */\nclass TerminatedCloseEvent extends Error {\n    constructor() {\n        super(...arguments);\n        this.name = 'TerminatedCloseEvent';\n        this.message = '4499: Terminated';\n        this.code = 4499;\n        this.reason = 'Terminated';\n        this.wasClean = false;\n    }\n}\nfunction isLikeCloseEvent(val) {\n    return (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.isObject)(val) && 'code' in val && 'reason' in val;\n}\nfunction isFatalInternalCloseCode(code) {\n    if ([\n        1000,\n        1001,\n        1006,\n        1005,\n        1012,\n        1013,\n        1014, // Bad Gateway\n    ].includes(code))\n        return false;\n    // all other internal errors are fatal\n    return code >= 1000 && code <= 1999;\n}\nfunction isWebSocket(val) {\n    return (typeof val === 'function' &&\n        'constructor' in val &&\n        'CLOSED' in val &&\n        'CLOSING' in val &&\n        'CONNECTING' in val &&\n        'OPEN' in val);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL2dyYXBocWwtd3MvbGliL2NsaWVudC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBSSxJQUFJLFNBQUksNEJBQTRCO0FBQ3ZELHdCQUF3QixTQUFJLElBQUksU0FBSTtBQUNwQztBQUNBO0FBQ0EsaUJBQWlCLHVGQUF1RixjQUFjO0FBQ3RILHVCQUF1QixnQ0FBZ0MscUNBQXFDLDJDQUEyQztBQUN2SSw0QkFBNEIsTUFBTSxpQkFBaUIsWUFBWTtBQUMvRCx1QkFBdUI7QUFDdkIsOEJBQThCO0FBQzlCLDZCQUE2QjtBQUM3Qiw0QkFBNEI7QUFDNUI7QUFDc0g7QUFDN0Q7QUFDekQ7QUFDNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsWUFBWTtBQUNaLCtCQUErQjtBQUMvQix3QkFBd0IsYUFBYTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSyxnRUFBZ0U7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCw0Q0FBNEM7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsOENBQThDO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEZBQTRGLHNFQUE2QjtBQUN6SDtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBLHdDQUF3Qyw2REFBZ0IsR0FBRyxNQUFNLG9EQUFXLE9BQU87QUFDbkY7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsNkRBQWdCO0FBQ2hEO0FBQ0Esa0NBQWtDLG9EQUFXO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxvREFBVztBQUM3QztBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsa0RBQVM7QUFDbEQseUJBQXlCO0FBQ3pCO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxrREFBUyxzQkFBc0IsNERBQWdCO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxNQUFNO0FBQ3hDO0FBQ0Esb0NBQW9DLHlEQUFZO0FBQ2hEO0FBQ0E7QUFDQSwyRUFBMkU7QUFDM0U7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLDZEQUFnQjtBQUN4RDtBQUNBLDBDQUEwQyxvREFBVztBQUNyRDtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsb0RBQVc7QUFDckQ7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLHlDQUF5QyxvREFBVztBQUNwRCwyRUFBMkUsYUFBYTtBQUN4RjtBQUNBO0FBQ0Esa0ZBQWtGO0FBQ2xGLHNDQUFzQztBQUN0QyxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsaUNBQWlDLGtEQUFTLGNBQWMsNERBQWdCO0FBQ3hFO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtEQUFTO0FBQzdCLG9CQUFvQixrREFBUztBQUM3QixvQkFBb0Isa0RBQVM7QUFDN0Isb0JBQW9CLGtEQUFTO0FBQzdCLG9CQUFvQixrREFBUztBQUM3QjtBQUNBLG9CQUFvQixrREFBUztBQUM3QjtBQUNBO0FBQ0Esb0JBQW9CLGtEQUFTO0FBQzdCLG9CQUFvQixrREFBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLG9EQUFXO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLG9EQUFXO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsb0RBQVc7QUFDNUM7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGdDQUFnQyw2REFBZ0I7QUFDaEQ7QUFDQSw4QkFBOEIsb0RBQVc7QUFDekM7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLDZEQUFnQjtBQUN4RDtBQUNBLHNDQUFzQyxvREFBVztBQUNqRCw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVMsR0FBRztBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsb0RBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xlZGdpdHkteWllbGQtZnJvbnRlbmQvLi4vbm9kZV9tb2R1bGVzL2dyYXBocWwtd3MvbGliL2NsaWVudC5tanM/ZTdjOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqXG4gKiBjbGllbnRcbiAqXG4gKi9cbnZhciBfX2F3YWl0ID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0KSB8fCBmdW5jdGlvbiAodikgeyByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIF9fYXdhaXQgPyAodGhpcy52ID0gdiwgdGhpcykgOiBuZXcgX19hd2FpdCh2KTsgfVxudmFyIF9fYXN5bmNHZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fYXN5bmNHZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBnZW5lcmF0b3IpIHtcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xuICAgIHZhciBnID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pLCBpLCBxID0gW107XG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpZiAoZ1tuXSkgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYikgeyBxLnB1c2goW24sIHYsIGEsIGJdKSA+IDEgfHwgcmVzdW1lKG4sIHYpOyB9KTsgfTsgfVxuICAgIGZ1bmN0aW9uIHJlc3VtZShuLCB2KSB7IHRyeSB7IHN0ZXAoZ1tuXSh2KSk7IH0gY2F0Y2ggKGUpIHsgc2V0dGxlKHFbMF1bM10sIGUpOyB9IH1cbiAgICBmdW5jdGlvbiBzdGVwKHIpIHsgci52YWx1ZSBpbnN0YW5jZW9mIF9fYXdhaXQgPyBQcm9taXNlLnJlc29sdmUoci52YWx1ZS52KS50aGVuKGZ1bGZpbGwsIHJlamVjdCkgOiBzZXR0bGUocVswXVsyXSwgcik7IH1cbiAgICBmdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7IHJlc3VtZShcIm5leHRcIiwgdmFsdWUpOyB9XG4gICAgZnVuY3Rpb24gcmVqZWN0KHZhbHVlKSB7IHJlc3VtZShcInRocm93XCIsIHZhbHVlKTsgfVxuICAgIGZ1bmN0aW9uIHNldHRsZShmLCB2KSB7IGlmIChmKHYpLCBxLnNoaWZ0KCksIHEubGVuZ3RoKSByZXN1bWUocVswXVswXSwgcVswXVsxXSk7IH1cbn07XG5pbXBvcnQgeyBHUkFQSFFMX1RSQU5TUE9SVF9XU19QUk9UT0NPTCwgQ2xvc2VDb2RlLCBNZXNzYWdlVHlwZSwgcGFyc2VNZXNzYWdlLCBzdHJpbmdpZnlNZXNzYWdlLCB9IGZyb20gJy4vY29tbW9uLm1qcyc7XG5pbXBvcnQgeyBpc09iamVjdCwgbGltaXRDbG9zZVJlYXNvbiB9IGZyb20gJy4vdXRpbHMubWpzJztcbi8qKiBUaGlzIGZpbGUgaXMgdGhlIGVudHJ5IHBvaW50IGZvciBicm93c2VycywgcmUtZXhwb3J0IGNvbW1vbiBlbGVtZW50cy4gKi9cbmV4cG9ydCAqIGZyb20gJy4vY29tbW9uLm1qcyc7XG4vKipcbiAqIENyZWF0ZXMgYSBkaXNwb3NhYmxlIEdyYXBoUUwgb3ZlciBXZWJTb2NrZXQgY2xpZW50LlxuICpcbiAqIEBjYXRlZ29yeSBDbGllbnRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNsaWVudChvcHRpb25zKSB7XG4gICAgY29uc3QgeyB1cmwsIGNvbm5lY3Rpb25QYXJhbXMsIGxhenkgPSB0cnVlLCBvbk5vbkxhenlFcnJvciA9IGNvbnNvbGUuZXJyb3IsIGxhenlDbG9zZVRpbWVvdXQ6IGxhenlDbG9zZVRpbWVvdXRNcyA9IDAsIGtlZXBBbGl2ZSA9IDAsIGRpc2FibGVQb25nLCBjb25uZWN0aW9uQWNrV2FpdFRpbWVvdXQgPSAwLCByZXRyeUF0dGVtcHRzID0gNSwgcmV0cnlXYWl0ID0gYXN5bmMgZnVuY3Rpb24gcmFuZG9taXNlZEV4cG9uZW50aWFsQmFja29mZihyZXRyaWVzKSB7XG4gICAgICAgIGxldCByZXRyeURlbGF5ID0gMTAwMDsgLy8gc3RhcnQgd2l0aCAxcyBkZWxheVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJldHJpZXM7IGkrKykge1xuICAgICAgICAgICAgcmV0cnlEZWxheSAqPSAyO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIHJldHJ5RGVsYXkgK1xuICAgICAgICAgICAgLy8gYWRkIHJhbmRvbSB0aW1lb3V0IGZyb20gMzAwbXMgdG8gM3NcbiAgICAgICAgICAgIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqICgzMDAwIC0gMzAwKSArIDMwMCkpKTtcbiAgICB9LCBzaG91bGRSZXRyeSA9IGlzTGlrZUNsb3NlRXZlbnQsIGlzRmF0YWxDb25uZWN0aW9uUHJvYmxlbSwgb24sIHdlYlNvY2tldEltcGwsIFxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIHY0IFVVSUQgdG8gYmUgdXNlZCBhcyB0aGUgSUQgdXNpbmcgYE1hdGhgXG4gICAgICogYXMgdGhlIHJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yLiBTdXBwbHkgeW91ciBvd24gZ2VuZXJhdG9yXG4gICAgICogaW4gY2FzZSB5b3UgbmVlZCBtb3JlIHVuaXF1ZW5lc3MuXG4gICAgICpcbiAgICAgKiBSZWZlcmVuY2U6IGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL2plZC85ODI4ODNcbiAgICAgKi9cbiAgICBnZW5lcmF0ZUlEID0gZnVuY3Rpb24gZ2VuZXJhdGVVVUlEKCkge1xuICAgICAgICByZXR1cm4gJ3h4eHh4eHh4LXh4eHgtNHh4eC15eHh4LXh4eHh4eHh4eHh4eCcucmVwbGFjZSgvW3h5XS9nLCAoYykgPT4ge1xuICAgICAgICAgICAgY29uc3QgciA9IChNYXRoLnJhbmRvbSgpICogMTYpIHwgMCwgdiA9IGMgPT0gJ3gnID8gciA6IChyICYgMHgzKSB8IDB4ODtcbiAgICAgICAgICAgIHJldHVybiB2LnRvU3RyaW5nKDE2KTtcbiAgICAgICAgfSk7XG4gICAgfSwganNvbk1lc3NhZ2VSZXBsYWNlcjogcmVwbGFjZXIsIGpzb25NZXNzYWdlUmV2aXZlcjogcmV2aXZlciwgfSA9IG9wdGlvbnM7XG4gICAgbGV0IHdzO1xuICAgIGlmICh3ZWJTb2NrZXRJbXBsKSB7XG4gICAgICAgIGlmICghaXNXZWJTb2NrZXQod2ViU29ja2V0SW1wbCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBXZWJTb2NrZXQgaW1wbGVtZW50YXRpb24gcHJvdmlkZWQnKTtcbiAgICAgICAgfVxuICAgICAgICB3cyA9IHdlYlNvY2tldEltcGw7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBXZWJTb2NrZXQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHdzID0gV2ViU29ja2V0O1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB3cyA9XG4gICAgICAgICAgICBnbG9iYWwuV2ViU29ja2V0IHx8XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogU3VwcG9ydCBtb3JlIGJyb3dzZXJzXG4gICAgICAgICAgICAgICAgZ2xvYmFsLk1veldlYlNvY2tldDtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgd3MgPVxuICAgICAgICAgICAgd2luZG93LldlYlNvY2tldCB8fFxuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IFN1cHBvcnQgbW9yZSBicm93c2Vyc1xuICAgICAgICAgICAgICAgIHdpbmRvdy5Nb3pXZWJTb2NrZXQ7XG4gICAgfVxuICAgIGlmICghd3MpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIldlYlNvY2tldCBpbXBsZW1lbnRhdGlvbiBtaXNzaW5nOyBvbiBOb2RlIHlvdSBjYW4gYGltcG9ydCBXZWJTb2NrZXQgZnJvbSAnd3MnO2AgYW5kIHBhc3MgYHdlYlNvY2tldEltcGw6IFdlYlNvY2tldGAgdG8gYGNyZWF0ZUNsaWVudGBcIik7XG4gICAgY29uc3QgV2ViU29ja2V0SW1wbCA9IHdzO1xuICAgIC8vIHdlYnNvY2tldCBzdGF0dXMgZW1pdHRlciwgc3Vic2NyaXB0aW9ucyBhcmUgaGFuZGxlZCBkaWZmZXJlbnRseVxuICAgIGNvbnN0IGVtaXR0ZXIgPSAoKCkgPT4ge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IHt9O1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBvbihpZCwgbGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzW2lkXSA9IGxpc3RlbmVyO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGxpc3RlbmVyc1tpZF07XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBlbWl0KG1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICBpZiAoJ2lkJyBpbiBtZXNzYWdlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKF9hID0gbGlzdGVuZXJzW21lc3NhZ2UuaWRdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChsaXN0ZW5lcnMsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSgpO1xuICAgICAgICBjb25zdCBsaXN0ZW5lcnMgPSB7XG4gICAgICAgICAgICBjb25uZWN0aW5nOiAob24gPT09IG51bGwgfHwgb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uLmNvbm5lY3RpbmcpID8gW29uLmNvbm5lY3RpbmddIDogW10sXG4gICAgICAgICAgICBvcGVuZWQ6IChvbiA9PT0gbnVsbCB8fCBvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogb24ub3BlbmVkKSA/IFtvbi5vcGVuZWRdIDogW10sXG4gICAgICAgICAgICBjb25uZWN0ZWQ6IChvbiA9PT0gbnVsbCB8fCBvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogb24uY29ubmVjdGVkKSA/IFtvbi5jb25uZWN0ZWRdIDogW10sXG4gICAgICAgICAgICBwaW5nOiAob24gPT09IG51bGwgfHwgb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uLnBpbmcpID8gW29uLnBpbmddIDogW10sXG4gICAgICAgICAgICBwb25nOiAob24gPT09IG51bGwgfHwgb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uLnBvbmcpID8gW29uLnBvbmddIDogW10sXG4gICAgICAgICAgICBtZXNzYWdlOiAob24gPT09IG51bGwgfHwgb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uLm1lc3NhZ2UpID8gW21lc3NhZ2UuZW1pdCwgb24ubWVzc2FnZV0gOiBbbWVzc2FnZS5lbWl0XSxcbiAgICAgICAgICAgIGNsb3NlZDogKG9uID09PSBudWxsIHx8IG9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbi5jbG9zZWQpID8gW29uLmNsb3NlZF0gOiBbXSxcbiAgICAgICAgICAgIGVycm9yOiAob24gPT09IG51bGwgfHwgb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uLmVycm9yKSA/IFtvbi5lcnJvcl0gOiBbXSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG9uTWVzc2FnZTogbWVzc2FnZS5vbixcbiAgICAgICAgICAgIG9uKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGwgPSBsaXN0ZW5lcnNbZXZlbnRdO1xuICAgICAgICAgICAgICAgIGwucHVzaChsaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbC5zcGxpY2UobC5pbmRleE9mKGxpc3RlbmVyKSwgMSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbWl0KGV2ZW50LCAuLi5hcmdzKSB7XG4gICAgICAgICAgICAgICAgLy8gd2UgY29weSB0aGUgbGlzdGVuZXJzIHNvIHRoYXQgdW5saXN0ZW5zIGRvbnQgXCJwdWxsIHRoZSBydWcgdW5kZXIgb3VyIGZlZXRcIlxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgWy4uLmxpc3RlbmVyc1tldmVudF1dKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IFRoZSBhcmdzIHNob3VsZCBmaXRcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXIoLi4uYXJncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9KSgpO1xuICAgIC8vIGludm9rZXMgdGhlIGNhbGxiYWNrIGVpdGhlciB3aGVuIGFuIGVycm9yIG9yIGNsb3NlZCBldmVudCBpcyBlbWl0dGVkLFxuICAgIC8vIGZpcnN0IG9uZSB0aGF0IGdldHMgY2FsbGVkIHByZXZhaWxzLCBvdGhlciBlbWlzc2lvbnMgYXJlIGlnbm9yZWRcbiAgICBmdW5jdGlvbiBlcnJvck9yQ2xvc2VkKGNiKSB7XG4gICAgICAgIGNvbnN0IGxpc3RlbmluZyA9IFtcbiAgICAgICAgICAgIC8vIGVycm9ycyBhcmUgZmF0YWwgYW5kIG1vcmUgY3JpdGljYWwgdGhhbiBjbG9zZSBldmVudHMsIHRocm93IHRoZW0gZmlyc3RcbiAgICAgICAgICAgIGVtaXR0ZXIub24oJ2Vycm9yJywgKGVycikgPT4ge1xuICAgICAgICAgICAgICAgIGxpc3RlbmluZy5mb3JFYWNoKCh1bmxpc3RlbikgPT4gdW5saXN0ZW4oKSk7XG4gICAgICAgICAgICAgICAgY2IoZXJyKTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgLy8gY2xvc2VzIGNhbiBiZSBncmFjZWZ1bCBhbmQgbm90IGZhdGFsLCB0aHJvdyB0aGVtIHNlY29uZCAoaWYgZXJyb3IgZGlkbnQgdGhyb3cpXG4gICAgICAgICAgICBlbWl0dGVyLm9uKCdjbG9zZWQnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5pbmcuZm9yRWFjaCgodW5saXN0ZW4pID0+IHVubGlzdGVuKCkpO1xuICAgICAgICAgICAgICAgIGNiKGV2ZW50KTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICBdO1xuICAgIH1cbiAgICBsZXQgY29ubmVjdGluZywgbG9ja3MgPSAwLCBsYXp5Q2xvc2VUaW1lb3V0LCByZXRyeWluZyA9IGZhbHNlLCByZXRyaWVzID0gMCwgZGlzcG9zZWQgPSBmYWxzZTtcbiAgICBhc3luYyBmdW5jdGlvbiBjb25uZWN0KCkge1xuICAgICAgICAvLyBjbGVhciB0aGUgbGF6eSBjbG9zZSB0aW1lb3V0IGltbWVkaWF0ZWxseSBzbyB0aGF0IGNsb3NlIGdldHMgZGVib3VuY2VkXG4gICAgICAgIC8vIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL2VuaXNkZW5qby9ncmFwaHFsLXdzL2lzc3Vlcy8zODhcbiAgICAgICAgY2xlYXJUaW1lb3V0KGxhenlDbG9zZVRpbWVvdXQpO1xuICAgICAgICBjb25zdCBbc29ja2V0LCB0aHJvd09uQ2xvc2VdID0gYXdhaXQgKGNvbm5lY3RpbmcgIT09IG51bGwgJiYgY29ubmVjdGluZyAhPT0gdm9pZCAwID8gY29ubmVjdGluZyA6IChjb25uZWN0aW5nID0gbmV3IFByb21pc2UoKGNvbm5lY3RlZCwgZGVuaWVkKSA9PiAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHJldHJ5aW5nKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgcmV0cnlXYWl0KHJldHJpZXMpO1xuICAgICAgICAgICAgICAgIC8vIHN1YnNjcmlwdGlvbnMgbWlnaHQgY29tcGxldGUgd2hpbGUgd2FpdGluZyBmb3IgcmV0cnlcbiAgICAgICAgICAgICAgICBpZiAoIWxvY2tzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3RpbmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZW5pZWQoeyBjb2RlOiAxMDAwLCByZWFzb246ICdBbGwgU3Vic2NyaXB0aW9ucyBHb25lJyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0cmllcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZW1pdHRlci5lbWl0KCdjb25uZWN0aW5nJywgcmV0cnlpbmcpO1xuICAgICAgICAgICAgY29uc3Qgc29ja2V0ID0gbmV3IFdlYlNvY2tldEltcGwodHlwZW9mIHVybCA9PT0gJ2Z1bmN0aW9uJyA/IGF3YWl0IHVybCgpIDogdXJsLCBHUkFQSFFMX1RSQU5TUE9SVF9XU19QUk9UT0NPTCk7XG4gICAgICAgICAgICBsZXQgY29ubmVjdGlvbkFja1RpbWVvdXQsIHF1ZXVlZFBpbmc7XG4gICAgICAgICAgICBmdW5jdGlvbiBlbnF1ZXVlUGluZygpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNGaW5pdGUoa2VlcEFsaXZlKSAmJiBrZWVwQWxpdmUgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChxdWV1ZWRQaW5nKTsgLy8gaW4gY2FzZSB3aGVyZSBhIHBvbmcgd2FzIHJlY2VpdmVkIGJlZm9yZSBhIHBpbmcgKHRoaXMgaXMgdmFsaWQgYmVoYXZpb3VyKVxuICAgICAgICAgICAgICAgICAgICBxdWV1ZWRQaW5nID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc29ja2V0LnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldEltcGwuT1BFTikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvY2tldC5zZW5kKHN0cmluZ2lmeU1lc3NhZ2UoeyB0eXBlOiBNZXNzYWdlVHlwZS5QaW5nIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbWl0dGVyLmVtaXQoJ3BpbmcnLCBmYWxzZSwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwga2VlcEFsaXZlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlcnJvck9yQ2xvc2VkKChlcnJPckV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgY29ubmVjdGluZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoY29ubmVjdGlvbkFja1RpbWVvdXQpO1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChxdWV1ZWRQaW5nKTtcbiAgICAgICAgICAgICAgICBkZW5pZWQoZXJyT3JFdmVudCk7XG4gICAgICAgICAgICAgICAgaWYgKGVyck9yRXZlbnQgaW5zdGFuY2VvZiBUZXJtaW5hdGVkQ2xvc2VFdmVudCkge1xuICAgICAgICAgICAgICAgICAgICBzb2NrZXQuY2xvc2UoNDQ5OSwgJ1Rlcm1pbmF0ZWQnKTsgLy8gY2xvc2UgZXZlbnQgaXMgYXJ0aWZpY2lhbCBhbmQgZW1pdHRlZCBtYW51YWxseSwgc2VlIGBDbGllbnQudGVybWluYXRlKClgIGJlbG93XG4gICAgICAgICAgICAgICAgICAgIHNvY2tldC5vbmVycm9yID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgc29ja2V0Lm9uY2xvc2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc29ja2V0Lm9uZXJyb3IgPSAoZXJyKSA9PiBlbWl0dGVyLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgICAgIHNvY2tldC5vbmNsb3NlID0gKGV2ZW50KSA9PiBlbWl0dGVyLmVtaXQoJ2Nsb3NlZCcsIGV2ZW50KTtcbiAgICAgICAgICAgIHNvY2tldC5vbm9wZW4gPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZW1pdHRlci5lbWl0KCdvcGVuZWQnLCBzb2NrZXQpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gdHlwZW9mIGNvbm5lY3Rpb25QYXJhbXMgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgICAgICAgICAgICAgID8gYXdhaXQgY29ubmVjdGlvblBhcmFtcygpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGNvbm5lY3Rpb25QYXJhbXM7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbm5lY3Rpb25QYXJhbXMgbWlnaHQgdGFrZSB0b28gbG9uZyBjYXVzaW5nIHRoZSBzZXJ2ZXIgdG8ga2ljayBvZmYgdGhlIGNsaWVudFxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgbmVjZXNzYXJ5IGVycm9yL2Nsb3NlIGV2ZW50IGlzIGFscmVhZHkgcmVwb3J0ZWQgLSBzaW1wbHkgc3RvcCBleGVjdXRpb25cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNvY2tldC5yZWFkeVN0YXRlICE9PSBXZWJTb2NrZXRJbXBsLk9QRU4pXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIHNvY2tldC5zZW5kKHN0cmluZ2lmeU1lc3NhZ2UocGF5bG9hZFxuICAgICAgICAgICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogTWVzc2FnZVR5cGUuQ29ubmVjdGlvbkluaXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IE1lc3NhZ2VUeXBlLkNvbm5lY3Rpb25Jbml0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBheWxvYWQgaXMgY29tcGxldGVseSBhYnNlbnQgaWYgbm90IHByb3ZpZGVkXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCByZXBsYWNlcikpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNGaW5pdGUoY29ubmVjdGlvbkFja1dhaXRUaW1lb3V0KSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbkFja1dhaXRUaW1lb3V0ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbkFja1RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb2NrZXQuY2xvc2UoQ2xvc2VDb2RlLkNvbm5lY3Rpb25BY2tub3dsZWRnZW1lbnRUaW1lb3V0LCAnQ29ubmVjdGlvbiBhY2tub3dsZWRnZW1lbnQgdGltZW91dCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgY29ubmVjdGlvbkFja1dhaXRUaW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbnF1ZXVlUGluZygpOyAvLyBlbnF1ZXVlIHBpbmcgKG5vb3AgaWYgZGlzYWJsZWQpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgZW1pdHRlci5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgICAgICAgICAgICAgICAgIHNvY2tldC5jbG9zZShDbG9zZUNvZGUuSW50ZXJuYWxDbGllbnRFcnJvciwgbGltaXRDbG9zZVJlYXNvbihlcnIgaW5zdGFuY2VvZiBFcnJvciA/IGVyci5tZXNzYWdlIDogbmV3IEVycm9yKGVycikubWVzc2FnZSwgJ0ludGVybmFsIGNsaWVudCBlcnJvcicpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbGV0IGFja25vd2xlZGdlZCA9IGZhbHNlO1xuICAgICAgICAgICAgc29ja2V0Lm9ubWVzc2FnZSA9ICh7IGRhdGEgfSkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBwYXJzZU1lc3NhZ2UoZGF0YSwgcmV2aXZlcik7XG4gICAgICAgICAgICAgICAgICAgIGVtaXR0ZXIuZW1pdCgnbWVzc2FnZScsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS50eXBlID09PSAncGluZycgfHwgbWVzc2FnZS50eXBlID09PSAncG9uZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtaXR0ZXIuZW1pdChtZXNzYWdlLnR5cGUsIHRydWUsIG1lc3NhZ2UucGF5bG9hZCk7IC8vIHJlY2VpdmVkXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS50eXBlID09PSAncG9uZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnF1ZXVlUGluZygpOyAvLyBlbnF1ZXVlIG5leHQgcGluZyAobm9vcCBpZiBkaXNhYmxlZClcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFkaXNhYmxlUG9uZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlc3BvbmQgd2l0aCBwb25nIG9uIHBpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb2NrZXQuc2VuZChzdHJpbmdpZnlNZXNzYWdlKG1lc3NhZ2UucGF5bG9hZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IE1lc3NhZ2VUeXBlLlBvbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkOiBtZXNzYWdlLnBheWxvYWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBNZXNzYWdlVHlwZS5Qb25nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcGF5bG9hZCBpcyBjb21wbGV0ZWx5IGFic2VudCBpZiBub3QgcHJvdmlkZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVtaXR0ZXIuZW1pdCgncG9uZycsIGZhbHNlLCBtZXNzYWdlLnBheWxvYWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBwaW5nIGFuZCBwb25ncyBjYW4gYmUgcmVjZWl2ZWQgd2hlbmV2ZXJcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoYWNrbm93bGVkZ2VkKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBhbHJlYWR5IGNvbm5lY3RlZCBhbmQgYWNrbm93bGVkZ2VkXG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLnR5cGUgIT09IE1lc3NhZ2VUeXBlLkNvbm5lY3Rpb25BY2spXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZpcnN0IG1lc3NhZ2UgY2Fubm90IGJlIG9mIHR5cGUgJHttZXNzYWdlLnR5cGV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChjb25uZWN0aW9uQWNrVGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgIGFja25vd2xlZGdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGVtaXR0ZXIuZW1pdCgnY29ubmVjdGVkJywgc29ja2V0LCBtZXNzYWdlLnBheWxvYWQsIHJldHJ5aW5nKTsgLy8gY29ubmVjdGVkID0gc29ja2V0IG9wZW5lZCArIGFja25vd2xlZGdlZFxuICAgICAgICAgICAgICAgICAgICByZXRyeWluZyA9IGZhbHNlOyAvLyBmdXR1cmUgbGF6eSBjb25uZWN0cyBhcmUgbm90IHJldHJpZXNcbiAgICAgICAgICAgICAgICAgICAgcmV0cmllcyA9IDA7IC8vIHJlc2V0IHRoZSByZXRyaWVzIG9uIGNvbm5lY3RcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdGVkKFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvY2tldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBQcm9taXNlKChfLCByZWplY3QpID0+IGVycm9yT3JDbG9zZWQocmVqZWN0KSksXG4gICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHNvY2tldC5vbm1lc3NhZ2UgPSBudWxsOyAvLyBzdG9wIHJlYWRpbmcgbWVzc2FnZXMgYXMgc29vbiBhcyByZWFkaW5nIGJyZWFrcyBvbmNlXG4gICAgICAgICAgICAgICAgICAgIGVtaXR0ZXIuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICBzb2NrZXQuY2xvc2UoQ2xvc2VDb2RlLkJhZFJlc3BvbnNlLCBsaW1pdENsb3NlUmVhc29uKGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyLm1lc3NhZ2UgOiBuZXcgRXJyb3IoZXJyKS5tZXNzYWdlLCAnQmFkIHJlc3BvbnNlJykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pKCkpKSk7XG4gICAgICAgIC8vIGlmIHRoZSBwcm92aWRlZCBzb2NrZXQgaXMgaW4gYSBjbG9zaW5nIHN0YXRlLCB3YWl0IGZvciB0aGUgdGhyb3cgb24gY2xvc2VcbiAgICAgICAgaWYgKHNvY2tldC5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXRJbXBsLkNMT1NJTkcpXG4gICAgICAgICAgICBhd2FpdCB0aHJvd09uQ2xvc2U7XG4gICAgICAgIGxldCByZWxlYXNlID0gKCkgPT4ge1xuICAgICAgICAgICAgLy8gcmVsZWFzZXMgdGhpcyBjb25uZWN0aW9uXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlbGVhc2VkID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IChyZWxlYXNlID0gcmVzb2x2ZSkpO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgc29ja2V0LFxuICAgICAgICAgICAgcmVsZWFzZSxcbiAgICAgICAgICAgIFByb21pc2UucmFjZShbXG4gICAgICAgICAgICAgICAgLy8gd2FpdCBmb3JcbiAgICAgICAgICAgICAgICByZWxlYXNlZC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFsb2Nrcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW5kIGlmIG5vIG1vcmUgbG9ja3MgYXJlIHByZXNlbnQsIGNvbXBsZXRlIHRoZSBjb25uZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb21wbGV0ZSA9ICgpID0+IHNvY2tldC5jbG9zZSgxMDAwLCAnTm9ybWFsIENsb3N1cmUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0Zpbml0ZShsYXp5Q2xvc2VUaW1lb3V0TXMpICYmIGxhenlDbG9zZVRpbWVvdXRNcyA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUga2VlcGFsaXZlIGlzIHNldCwgYWxsb3cgZm9yIHRoZSBzcGVjaWZpZWQgY2FsbWRvd24gdGltZSBhbmRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGVuIGNvbXBsZXRlIGlmIHRoZSBzb2NrZXQgaXMgc3RpbGwgb3Blbi5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXp5Q2xvc2VUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzb2NrZXQucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0SW1wbC5PUEVOKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBsYXp5Q2xvc2VUaW1lb3V0TXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIGNvbXBsZXRlIGltbWVkaWF0ZWx5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIC8vIG9yXG4gICAgICAgICAgICAgICAgdGhyb3dPbkNsb3NlLFxuICAgICAgICAgICAgXSksXG4gICAgICAgIF07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyB0aGUgYGNvbm5lY3RgIHByb2JsZW0gYW5kIGV2YWx1YXRlcyBpZiB0aGUgY2xpZW50IHNob3VsZCByZXRyeS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaG91bGRSZXRyeUNvbm5lY3RPclRocm93KGVyck9yQ2xvc2VFdmVudCkge1xuICAgICAgICAvLyBzb21lIGNsb3NlIGNvZGVzIGFyZSB3b3J0aCByZXBvcnRpbmcgaW1tZWRpYXRlbHlcbiAgICAgICAgaWYgKGlzTGlrZUNsb3NlRXZlbnQoZXJyT3JDbG9zZUV2ZW50KSAmJlxuICAgICAgICAgICAgKGlzRmF0YWxJbnRlcm5hbENsb3NlQ29kZShlcnJPckNsb3NlRXZlbnQuY29kZSkgfHxcbiAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgIENsb3NlQ29kZS5JbnRlcm5hbFNlcnZlckVycm9yLFxuICAgICAgICAgICAgICAgICAgICBDbG9zZUNvZGUuSW50ZXJuYWxDbGllbnRFcnJvcixcbiAgICAgICAgICAgICAgICAgICAgQ2xvc2VDb2RlLkJhZFJlcXVlc3QsXG4gICAgICAgICAgICAgICAgICAgIENsb3NlQ29kZS5CYWRSZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgICAgQ2xvc2VDb2RlLlVuYXV0aG9yaXplZCxcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2xvc2VDb2RlLkZvcmJpZGRlbiwgbWlnaHQgZ3JhbnQgYWNjZXNzIG91dCBhZnRlciByZXRyeVxuICAgICAgICAgICAgICAgICAgICBDbG9zZUNvZGUuU3VicHJvdG9jb2xOb3RBY2NlcHRhYmxlLFxuICAgICAgICAgICAgICAgICAgICAvLyBDbG9zZUNvZGUuQ29ubmVjdGlvbkluaXRpYWxpc2F0aW9uVGltZW91dCwgbWlnaHQgbm90IHRpbWUgb3V0IGFmdGVyIHJldHJ5XG4gICAgICAgICAgICAgICAgICAgIC8vIENsb3NlQ29kZS5Db25uZWN0aW9uQWNrbm93bGVkZ2VtZW50VGltZW91dCwgbWlnaHQgbm90IHRpbWUgb3V0IGFmdGVyIHJldHJ5XG4gICAgICAgICAgICAgICAgICAgIENsb3NlQ29kZS5TdWJzY3JpYmVyQWxyZWFkeUV4aXN0cyxcbiAgICAgICAgICAgICAgICAgICAgQ2xvc2VDb2RlLlRvb01hbnlJbml0aWFsaXNhdGlvblJlcXVlc3RzLFxuICAgICAgICAgICAgICAgICAgICAvLyA0NDk5LCAvLyBUZXJtaW5hdGVkLCBwcm9iYWJseSBiZWNhdXNlIHRoZSBzb2NrZXQgZnJvemUsIHdlIHdhbnQgdG8gcmV0cnlcbiAgICAgICAgICAgICAgICBdLmluY2x1ZGVzKGVyck9yQ2xvc2VFdmVudC5jb2RlKSkpXG4gICAgICAgICAgICB0aHJvdyBlcnJPckNsb3NlRXZlbnQ7XG4gICAgICAgIC8vIGNsaWVudCB3YXMgZGlzcG9zZWQsIG5vIHJldHJpZXMgc2hvdWxkIHByb2NlZWQgcmVnYXJkbGVzc1xuICAgICAgICBpZiAoZGlzcG9zZWQpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIC8vIG5vcm1hbCBjbG9zdXJlIChwb3NzaWJseSBhbGwgc3Vic2NyaXB0aW9ucyBoYXZlIGNvbXBsZXRlZClcbiAgICAgICAgLy8gaWYgbm8gbG9ja3Mgd2VyZSBhY3F1aXJlZCBpbiB0aGUgbWVhbnRpbWUsIHNob3VsZG50IHRyeSBhZ2FpblxuICAgICAgICBpZiAoaXNMaWtlQ2xvc2VFdmVudChlcnJPckNsb3NlRXZlbnQpICYmIGVyck9yQ2xvc2VFdmVudC5jb2RlID09PSAxMDAwKVxuICAgICAgICAgICAgcmV0dXJuIGxvY2tzID4gMDtcbiAgICAgICAgLy8gcmV0cmllcyBhcmUgbm90IGFsbG93ZWQgb3Igd2UgdHJpZWQgdG8gbWFueSB0aW1lcywgcmVwb3J0IGVycm9yXG4gICAgICAgIGlmICghcmV0cnlBdHRlbXB0cyB8fCByZXRyaWVzID49IHJldHJ5QXR0ZW1wdHMpXG4gICAgICAgICAgICB0aHJvdyBlcnJPckNsb3NlRXZlbnQ7XG4gICAgICAgIC8vIHRocm93IG5vbi1yZXRyeWFibGUgY29ubmVjdGlvbiBwcm9ibGVtc1xuICAgICAgICBpZiAoIXNob3VsZFJldHJ5KGVyck9yQ2xvc2VFdmVudCkpXG4gICAgICAgICAgICB0aHJvdyBlcnJPckNsb3NlRXZlbnQ7XG4gICAgICAgIC8vIEBkZXByZWNhdGVkIHRocm93IGZhdGFsIGNvbm5lY3Rpb24gcHJvYmxlbXMgaW1tZWRpYXRlbHlcbiAgICAgICAgaWYgKGlzRmF0YWxDb25uZWN0aW9uUHJvYmxlbSA9PT0gbnVsbCB8fCBpc0ZhdGFsQ29ubmVjdGlvblByb2JsZW0gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGlzRmF0YWxDb25uZWN0aW9uUHJvYmxlbShlcnJPckNsb3NlRXZlbnQpKVxuICAgICAgICAgICAgdGhyb3cgZXJyT3JDbG9zZUV2ZW50O1xuICAgICAgICAvLyBsb29rcyBnb29kLCBzdGFydCByZXRyeWluZ1xuICAgICAgICByZXR1cm4gKHJldHJ5aW5nID0gdHJ1ZSk7XG4gICAgfVxuICAgIC8vIGluIG5vbi1sYXp5IChob3Q/KSBtb2RlIGFsd2F5cyBob2xkIG9uZSBjb25uZWN0aW9uIGxvY2sgdG8gcGVyc2lzdCB0aGUgc29ja2V0XG4gICAgaWYgKCFsYXp5KSB7XG4gICAgICAgIChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBsb2NrcysrO1xuICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFssICwgdGhyb3dPbkNsb3NlXSA9IGF3YWl0IGNvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhyb3dPbkNsb3NlOyAvLyB3aWxsIGFsd2F5cyB0aHJvdyBiZWNhdXNlIHJlbGVhc2VyIGlzIG5vdCB1c2VkXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJPckNsb3NlRXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2hvdWxkUmV0cnlDb25uZWN0T3JUaHJvdyhlcnJPckNsb3NlRXZlbnQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyT3JDbG9zZUV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZXBvcnQgdGhyb3duIGVycm9yLCBubyBmdXJ0aGVyIHJldHJpZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvbk5vbkxhenlFcnJvciA9PT0gbnVsbCB8fCBvbk5vbkxhenlFcnJvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25Ob25MYXp5RXJyb3IoZXJyT3JDbG9zZUV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3Vic2NyaWJlKHBheWxvYWQsIHNpbmspIHtcbiAgICAgICAgY29uc3QgaWQgPSBnZW5lcmF0ZUlEKHBheWxvYWQpO1xuICAgICAgICBsZXQgZG9uZSA9IGZhbHNlLCBlcnJvcmVkID0gZmFsc2UsIHJlbGVhc2VyID0gKCkgPT4ge1xuICAgICAgICAgICAgLy8gZm9yIGhhbmRsaW5nIGNvbXBsZXRpb25zIGJlZm9yZSBjb25uZWN0XG4gICAgICAgICAgICBsb2Nrcy0tO1xuICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBsb2NrcysrO1xuICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFtzb2NrZXQsIHJlbGVhc2UsIHdhaXRGb3JSZWxlYXNlT3JUaHJvd09uQ2xvc2VdID0gYXdhaXQgY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiBkb25lIHdoaWxlIHdhaXRpbmcgZm9yIGNvbm5lY3QsIHJlbGVhc2UgdGhlIGNvbm5lY3Rpb24gbG9jayByaWdodCBhd2F5XG4gICAgICAgICAgICAgICAgICAgIGlmIChkb25lKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlbGVhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdW5saXN0ZW4gPSBlbWl0dGVyLm9uTWVzc2FnZShpZCwgKG1lc3NhZ2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAobWVzc2FnZS50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBNZXNzYWdlVHlwZS5OZXh0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55IC0tIHBheWxvYWQgd2lsbCBmaXQgdHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaW5rLm5leHQobWVzc2FnZS5wYXlsb2FkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIE1lc3NhZ2VUeXBlLkVycm9yOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChlcnJvcmVkID0gdHJ1ZSksIChkb25lID0gdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpbmsuZXJyb3IobWVzc2FnZS5wYXlsb2FkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVsZWFzZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIE1lc3NhZ2VUeXBlLkNvbXBsZXRlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWxlYXNlcigpOyAvLyByZWxlYXNlIGNvbXBsZXRlcyB0aGUgc2lua1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc29ja2V0LnNlbmQoc3RyaW5naWZ5TWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IE1lc3NhZ2VUeXBlLlN1YnNjcmliZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWQsXG4gICAgICAgICAgICAgICAgICAgIH0sIHJlcGxhY2VyKSk7XG4gICAgICAgICAgICAgICAgICAgIHJlbGVhc2VyID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFkb25lICYmIHNvY2tldC5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXRJbXBsLk9QRU4pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgbm90IGNvbXBsZXRlZCBhbHJlYWR5IGFuZCBzb2NrZXQgaXMgb3Blbiwgc2VuZCBjb21wbGV0ZSBtZXNzYWdlIHRvIHNlcnZlciBvbiByZWxlYXNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc29ja2V0LnNlbmQoc3RyaW5naWZ5TWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBNZXNzYWdlVHlwZS5Db21wbGV0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCByZXBsYWNlcikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9ja3MtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVsZWFzZSgpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAvLyBlaXRoZXIgdGhlIHJlbGVhc2VyIHdpbGwgYmUgY2FsbGVkLCBjb25uZWN0aW9uIGNvbXBsZXRlZCBhbmRcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHByb21pc2UgcmVzb2x2ZWQgb3IgdGhlIHNvY2tldCBjbG9zZWQgYW5kIHRoZSBwcm9taXNlIHJlamVjdGVkLlxuICAgICAgICAgICAgICAgICAgICAvLyB3aGF0ZXZlciBoYXBwZW5zIHRob3VnaCwgd2Ugd2FudCB0byBzdG9wIGxpc3RlbmluZyBmb3IgbWVzc2FnZXNcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgd2FpdEZvclJlbGVhc2VPclRocm93T25DbG9zZS5maW5hbGx5KHVubGlzdGVuKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBjb21wbGV0ZWQsIHNob3VsZG50IHRyeSBhZ2FpblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyT3JDbG9zZUV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc2hvdWxkUmV0cnlDb25uZWN0T3JUaHJvdyhlcnJPckNsb3NlRXZlbnQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkoKVxuICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgLy8gZGVsaXZlcmluZyBlaXRoZXIgYW4gZXJyb3Igb3IgYSBjb21wbGV0ZSB0ZXJtaW5hdGVzIHRoZSBzZXF1ZW5jZVxuICAgICAgICAgICAgaWYgKCFlcnJvcmVkKVxuICAgICAgICAgICAgICAgIHNpbmsuY29tcGxldGUoKTtcbiAgICAgICAgfSkgLy8gcmVzb2x2ZXMgb24gcmVsZWFzZSBvciBub3JtYWwgY2xvc3VyZVxuICAgICAgICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgIHNpbmsuZXJyb3IoZXJyKTtcbiAgICAgICAgfSk7IC8vIHJlamVjdHMgb24gY2xvc2UgZXZlbnRzIGFuZCBlcnJvcnNcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIC8vIGRpc3Bvc2Ugb25seSBvZiBhY3RpdmUgc3Vic2NyaXB0aW9uc1xuICAgICAgICAgICAgaWYgKCFkb25lKVxuICAgICAgICAgICAgICAgIHJlbGVhc2VyKCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIG9uOiBlbWl0dGVyLm9uLFxuICAgICAgICBzdWJzY3JpYmUsXG4gICAgICAgIGl0ZXJhdGUocmVxdWVzdCkge1xuICAgICAgICAgICAgY29uc3QgcGVuZGluZyA9IFtdO1xuICAgICAgICAgICAgY29uc3QgZGVmZXJyZWQgPSB7XG4gICAgICAgICAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgICAgICAgICAgcmVzb2x2ZTogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBub29wXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBkaXNwb3NlID0gc3Vic2NyaWJlKHJlcXVlc3QsIHtcbiAgICAgICAgICAgICAgICBuZXh0KHZhbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgICAgICBwZW5kaW5nLnB1c2godmFsKTtcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZXJyb3IoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLmRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5lcnJvciA9IGVycjtcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY29tcGxldGUoKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLmRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgaXRlcmF0b3IgPSAoZnVuY3Rpb24gaXRlcmF0b3IoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fYXN5bmNHZW5lcmF0b3IodGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiogaXRlcmF0b3JfMSgpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwZW5kaW5nLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9ubHkgd2FpdCBpZiB0aGVyZSBhcmUgbm8gcGVuZGluZyBtZXNzYWdlcyBhdmFpbGFibGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCBfX2F3YWl0KG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiAoZGVmZXJyZWQucmVzb2x2ZSA9IHJlc29sdmUpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmaXJzdCBmbHVzaFxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHBlbmRpbmcubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCB5aWVsZCBfX2F3YWl0KHBlbmRpbmcuc2hpZnQoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGVuIGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVmZXJyZWQuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBkZWZlcnJlZC5lcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9yIGNvbXBsZXRlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVmZXJyZWQuZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCBfX2F3YWl0KHZvaWQgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICBpdGVyYXRvci50aHJvdyA9IGFzeW5jIChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIWRlZmVycmVkLmRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQuZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLmVycm9yID0gZXJyO1xuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7IGRvbmU6IHRydWUsIHZhbHVlOiB1bmRlZmluZWQgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpdGVyYXRvci5yZXR1cm4gPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRvbmU6IHRydWUsIHZhbHVlOiB1bmRlZmluZWQgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gaXRlcmF0b3I7XG4gICAgICAgIH0sXG4gICAgICAgIGFzeW5jIGRpc3Bvc2UoKSB7XG4gICAgICAgICAgICBkaXNwb3NlZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAoY29ubmVjdGluZykge1xuICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIGEgY29ubmVjdGlvbiwgY2xvc2UgaXRcbiAgICAgICAgICAgICAgICBjb25zdCBbc29ja2V0XSA9IGF3YWl0IGNvbm5lY3Rpbmc7XG4gICAgICAgICAgICAgICAgc29ja2V0LmNsb3NlKDEwMDAsICdOb3JtYWwgQ2xvc3VyZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB0ZXJtaW5hdGUoKSB7XG4gICAgICAgICAgICBpZiAoY29ubmVjdGluZykge1xuICAgICAgICAgICAgICAgIC8vIG9ubHkgaWYgdGhlcmUgaXMgYSBjb25uZWN0aW9uXG4gICAgICAgICAgICAgICAgZW1pdHRlci5lbWl0KCdjbG9zZWQnLCBuZXcgVGVybWluYXRlZENsb3NlRXZlbnQoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8qKlxuICogQSBzeW50ZXRpYyBjbG9zZSBldmVudCBgNDQ5OTogVGVybWluYXRlZGAgaXMgaXNzdWVkIHRvIHRoZSBjdXJyZW50IHRvIGltbWVkaWF0ZWx5XG4gKiBjbG9zZSB0aGUgY29ubmVjdGlvbiB3aXRob3V0IHdhaXRpbmcgZm9yIHRoZSBvbmUgY29taW5nIGZyb20gYFdlYlNvY2tldC5vbmNsb3NlYC5cbiAqXG4gKiBUZXJtaW5hdGluZyBpcyBub3QgY29uc2lkZXJlZCBmYXRhbCBhbmQgYSBjb25uZWN0aW9uIHJldHJ5IHdpbGwgb2NjdXIgYXMgZXhwZWN0ZWQuXG4gKlxuICogVXNlZnVsIGluIGNhc2VzIHdoZXJlIHRoZSBXZWJTb2NrZXQgaXMgc3R1Y2sgYW5kIG5vdCBlbWl0dGluZyBhbnkgZXZlbnRzO1xuICogY2FuIGhhcHBlbiBvbiBpT1MgU2FmYXJpLCBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9lbmlzZGVuam8vZ3JhcGhxbC13cy9kaXNjdXNzaW9ucy8yOTAuXG4gKi9cbmV4cG9ydCBjbGFzcyBUZXJtaW5hdGVkQ2xvc2VFdmVudCBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ1Rlcm1pbmF0ZWRDbG9zZUV2ZW50JztcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gJzQ0OTk6IFRlcm1pbmF0ZWQnO1xuICAgICAgICB0aGlzLmNvZGUgPSA0NDk5O1xuICAgICAgICB0aGlzLnJlYXNvbiA9ICdUZXJtaW5hdGVkJztcbiAgICAgICAgdGhpcy53YXNDbGVhbiA9IGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzTGlrZUNsb3NlRXZlbnQodmFsKSB7XG4gICAgcmV0dXJuIGlzT2JqZWN0KHZhbCkgJiYgJ2NvZGUnIGluIHZhbCAmJiAncmVhc29uJyBpbiB2YWw7XG59XG5mdW5jdGlvbiBpc0ZhdGFsSW50ZXJuYWxDbG9zZUNvZGUoY29kZSkge1xuICAgIGlmIChbXG4gICAgICAgIDEwMDAsXG4gICAgICAgIDEwMDEsXG4gICAgICAgIDEwMDYsXG4gICAgICAgIDEwMDUsXG4gICAgICAgIDEwMTIsXG4gICAgICAgIDEwMTMsXG4gICAgICAgIDEwMTQsIC8vIEJhZCBHYXRld2F5XG4gICAgXS5pbmNsdWRlcyhjb2RlKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIC8vIGFsbCBvdGhlciBpbnRlcm5hbCBlcnJvcnMgYXJlIGZhdGFsXG4gICAgcmV0dXJuIGNvZGUgPj0gMTAwMCAmJiBjb2RlIDw9IDE5OTk7XG59XG5mdW5jdGlvbiBpc1dlYlNvY2tldCh2YWwpIHtcbiAgICByZXR1cm4gKHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgJ2NvbnN0cnVjdG9yJyBpbiB2YWwgJiZcbiAgICAgICAgJ0NMT1NFRCcgaW4gdmFsICYmXG4gICAgICAgICdDTE9TSU5HJyBpbiB2YWwgJiZcbiAgICAgICAgJ0NPTk5FQ1RJTkcnIGluIHZhbCAmJlxuICAgICAgICAnT1BFTicgaW4gdmFsKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/graphql-ws/lib/client.mjs\n");

/***/ }),

/***/ "(ssr)/../node_modules/graphql-ws/lib/common.mjs":
/*!*************************************************!*\
  !*** ../node_modules/graphql-ws/lib/common.mjs ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CloseCode: () => (/* binding */ CloseCode),\n/* harmony export */   DEPRECATED_GRAPHQL_WS_PROTOCOL: () => (/* binding */ DEPRECATED_GRAPHQL_WS_PROTOCOL),\n/* harmony export */   GRAPHQL_TRANSPORT_WS_PROTOCOL: () => (/* binding */ GRAPHQL_TRANSPORT_WS_PROTOCOL),\n/* harmony export */   MessageType: () => (/* binding */ MessageType),\n/* harmony export */   isMessage: () => (/* binding */ isMessage),\n/* harmony export */   parseMessage: () => (/* binding */ parseMessage),\n/* harmony export */   stringifyMessage: () => (/* binding */ stringifyMessage),\n/* harmony export */   validateMessage: () => (/* binding */ validateMessage)\n/* harmony export */ });\n/* harmony import */ var _utils_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.mjs */ \"(ssr)/../node_modules/graphql-ws/lib/utils.mjs\");\n/**\n *\n * common\n *\n */\n\n/**\n * The WebSocket sub-protocol used for the [GraphQL over WebSocket Protocol](https://github.com/graphql/graphql-over-http/blob/main/rfcs/GraphQLOverWebSocket.md).\n *\n * @category Common\n */\nconst GRAPHQL_TRANSPORT_WS_PROTOCOL = 'graphql-transport-ws';\n/**\n * The deprecated subprotocol used by [subscriptions-transport-ws](https://github.com/apollographql/subscriptions-transport-ws).\n *\n * @private\n */\nconst DEPRECATED_GRAPHQL_WS_PROTOCOL = 'graphql-ws';\n/**\n * `graphql-ws` expected and standard close codes of the [GraphQL over WebSocket Protocol](https://github.com/graphql/graphql-over-http/blob/main/rfcs/GraphQLOverWebSocket.md).\n *\n * @category Common\n */\nvar CloseCode;\n(function (CloseCode) {\n    CloseCode[CloseCode[\"InternalServerError\"] = 4500] = \"InternalServerError\";\n    CloseCode[CloseCode[\"InternalClientError\"] = 4005] = \"InternalClientError\";\n    CloseCode[CloseCode[\"BadRequest\"] = 4400] = \"BadRequest\";\n    CloseCode[CloseCode[\"BadResponse\"] = 4004] = \"BadResponse\";\n    /** Tried subscribing before connect ack */\n    CloseCode[CloseCode[\"Unauthorized\"] = 4401] = \"Unauthorized\";\n    CloseCode[CloseCode[\"Forbidden\"] = 4403] = \"Forbidden\";\n    CloseCode[CloseCode[\"SubprotocolNotAcceptable\"] = 4406] = \"SubprotocolNotAcceptable\";\n    CloseCode[CloseCode[\"ConnectionInitialisationTimeout\"] = 4408] = \"ConnectionInitialisationTimeout\";\n    CloseCode[CloseCode[\"ConnectionAcknowledgementTimeout\"] = 4504] = \"ConnectionAcknowledgementTimeout\";\n    /** Subscriber distinction is very important */\n    CloseCode[CloseCode[\"SubscriberAlreadyExists\"] = 4409] = \"SubscriberAlreadyExists\";\n    CloseCode[CloseCode[\"TooManyInitialisationRequests\"] = 4429] = \"TooManyInitialisationRequests\";\n})(CloseCode || (CloseCode = {}));\n/**\n * Types of messages allowed to be sent by the client/server over the WS protocol.\n *\n * @category Common\n */\nvar MessageType;\n(function (MessageType) {\n    MessageType[\"ConnectionInit\"] = \"connection_init\";\n    MessageType[\"ConnectionAck\"] = \"connection_ack\";\n    MessageType[\"Ping\"] = \"ping\";\n    MessageType[\"Pong\"] = \"pong\";\n    MessageType[\"Subscribe\"] = \"subscribe\";\n    MessageType[\"Next\"] = \"next\";\n    MessageType[\"Error\"] = \"error\";\n    MessageType[\"Complete\"] = \"complete\";\n})(MessageType || (MessageType = {}));\n/**\n * Validates the message against the GraphQL over WebSocket Protocol.\n *\n * Invalid messages will throw descriptive errors.\n *\n * @category Common\n */\nfunction validateMessage(val) {\n    if (!(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject)(val)) {\n        throw new Error(`Message is expected to be an object, but got ${(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.extendedTypeof)(val)}`);\n    }\n    if (!val.type) {\n        throw new Error(`Message is missing the 'type' property`);\n    }\n    if (typeof val.type !== 'string') {\n        throw new Error(`Message is expects the 'type' property to be a string, but got ${(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.extendedTypeof)(val.type)}`);\n    }\n    switch (val.type) {\n        case MessageType.ConnectionInit:\n        case MessageType.ConnectionAck:\n        case MessageType.Ping:\n        case MessageType.Pong: {\n            if (val.payload != null && !(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject)(val.payload)) {\n                throw new Error(`\"${val.type}\" message expects the 'payload' property to be an object or nullish or missing, but got \"${val.payload}\"`);\n            }\n            break;\n        }\n        case MessageType.Subscribe: {\n            if (typeof val.id !== 'string') {\n                throw new Error(`\"${val.type}\" message expects the 'id' property to be a string, but got ${(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.extendedTypeof)(val.id)}`);\n            }\n            if (!val.id) {\n                throw new Error(`\"${val.type}\" message requires a non-empty 'id' property`);\n            }\n            if (!(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject)(val.payload)) {\n                throw new Error(`\"${val.type}\" message expects the 'payload' property to be an object, but got ${(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.extendedTypeof)(val.payload)}`);\n            }\n            if (typeof val.payload.query !== 'string') {\n                throw new Error(`\"${val.type}\" message payload expects the 'query' property to be a string, but got ${(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.extendedTypeof)(val.payload.query)}`);\n            }\n            if (val.payload.variables != null && !(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject)(val.payload.variables)) {\n                throw new Error(`\"${val.type}\" message payload expects the 'variables' property to be a an object or nullish or missing, but got ${(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.extendedTypeof)(val.payload.variables)}`);\n            }\n            if (val.payload.operationName != null &&\n                (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.extendedTypeof)(val.payload.operationName) !== 'string') {\n                throw new Error(`\"${val.type}\" message payload expects the 'operationName' property to be a string or nullish or missing, but got ${(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.extendedTypeof)(val.payload.operationName)}`);\n            }\n            if (val.payload.extensions != null && !(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject)(val.payload.extensions)) {\n                throw new Error(`\"${val.type}\" message payload expects the 'extensions' property to be a an object or nullish or missing, but got ${(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.extendedTypeof)(val.payload.extensions)}`);\n            }\n            break;\n        }\n        case MessageType.Next: {\n            if (typeof val.id !== 'string') {\n                throw new Error(`\"${val.type}\" message expects the 'id' property to be a string, but got ${(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.extendedTypeof)(val.id)}`);\n            }\n            if (!val.id) {\n                throw new Error(`\"${val.type}\" message requires a non-empty 'id' property`);\n            }\n            if (!(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject)(val.payload)) {\n                throw new Error(`\"${val.type}\" message expects the 'payload' property to be an object, but got ${(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.extendedTypeof)(val.payload)}`);\n            }\n            break;\n        }\n        case MessageType.Error: {\n            if (typeof val.id !== 'string') {\n                throw new Error(`\"${val.type}\" message expects the 'id' property to be a string, but got ${(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.extendedTypeof)(val.id)}`);\n            }\n            if (!val.id) {\n                throw new Error(`\"${val.type}\" message requires a non-empty 'id' property`);\n            }\n            if (!(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.areGraphQLErrors)(val.payload)) {\n                throw new Error(`\"${val.type}\" message expects the 'payload' property to be an array of GraphQL errors, but got ${JSON.stringify(val.payload)}`);\n            }\n            break;\n        }\n        case MessageType.Complete: {\n            if (typeof val.id !== 'string') {\n                throw new Error(`\"${val.type}\" message expects the 'id' property to be a string, but got ${(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.extendedTypeof)(val.id)}`);\n            }\n            if (!val.id) {\n                throw new Error(`\"${val.type}\" message requires a non-empty 'id' property`);\n            }\n            break;\n        }\n        default:\n            throw new Error(`Invalid message 'type' property \"${val.type}\"`);\n    }\n    return val;\n}\n/**\n * Checks if the provided value is a valid GraphQL over WebSocket message.\n *\n * @deprecated Use `validateMessage` instead.\n *\n * @category Common\n */\nfunction isMessage(val) {\n    try {\n        validateMessage(val);\n        return true;\n    }\n    catch (_a) {\n        return false;\n    }\n}\n/**\n * Parses the raw websocket message data to a valid message.\n *\n * @category Common\n */\nfunction parseMessage(data, reviver) {\n    return validateMessage(typeof data === 'string' ? JSON.parse(data, reviver) : data);\n}\n/**\n * Stringifies a valid message ready to be sent through the socket.\n *\n * @category Common\n */\nfunction stringifyMessage(msg, replacer) {\n    validateMessage(msg);\n    return JSON.stringify(msg, replacer);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL2dyYXBocWwtd3MvbGliL2NvbW1vbi5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUN5RTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw4QkFBOEI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxrQ0FBa0M7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFNBQVMsb0RBQVE7QUFDakIsd0VBQXdFLDBEQUFjLE1BQU07QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBGQUEwRiwwREFBYyxXQUFXO0FBQ25IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxvREFBUTtBQUNoRCxvQ0FBb0MsU0FBUywyRkFBMkYsWUFBWTtBQUNwSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFNBQVMsOERBQThELDBEQUFjLFNBQVM7QUFDbEk7QUFDQTtBQUNBLG9DQUFvQyxTQUFTO0FBQzdDO0FBQ0EsaUJBQWlCLG9EQUFRO0FBQ3pCLG9DQUFvQyxTQUFTLG9FQUFvRSwwREFBYyxjQUFjO0FBQzdJO0FBQ0E7QUFDQSxvQ0FBb0MsU0FBUyx5RUFBeUUsMERBQWMsb0JBQW9CO0FBQ3hKO0FBQ0Esa0RBQWtELG9EQUFRO0FBQzFELG9DQUFvQyxTQUFTLHNHQUFzRywwREFBYyx3QkFBd0I7QUFDekw7QUFDQTtBQUNBLGdCQUFnQiwwREFBYztBQUM5QixvQ0FBb0MsU0FBUyx1R0FBdUcsMERBQWMsNEJBQTRCO0FBQzlMO0FBQ0EsbURBQW1ELG9EQUFRO0FBQzNELG9DQUFvQyxTQUFTLHVHQUF1RywwREFBYyx5QkFBeUI7QUFDM0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxTQUFTLDhEQUE4RCwwREFBYyxTQUFTO0FBQ2xJO0FBQ0E7QUFDQSxvQ0FBb0MsU0FBUztBQUM3QztBQUNBLGlCQUFpQixvREFBUTtBQUN6QixvQ0FBb0MsU0FBUyxvRUFBb0UsMERBQWMsY0FBYztBQUM3STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFNBQVMsOERBQThELDBEQUFjLFNBQVM7QUFDbEk7QUFDQTtBQUNBLG9DQUFvQyxTQUFTO0FBQzdDO0FBQ0EsaUJBQWlCLDREQUFnQjtBQUNqQyxvQ0FBb0MsU0FBUyxxRkFBcUYsNEJBQTRCO0FBQzlKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsU0FBUyw4REFBOEQsMERBQWMsU0FBUztBQUNsSTtBQUNBO0FBQ0Esb0NBQW9DLFNBQVM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsU0FBUztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sZWRnaXR5LXlpZWxkLWZyb250ZW5kLy4uL25vZGVfbW9kdWxlcy9ncmFwaHFsLXdzL2xpYi9jb21tb24ubWpzPzA1ZDkiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKlxuICogY29tbW9uXG4gKlxuICovXG5pbXBvcnQgeyBhcmVHcmFwaFFMRXJyb3JzLCBleHRlbmRlZFR5cGVvZiwgaXNPYmplY3QgfSBmcm9tICcuL3V0aWxzLm1qcyc7XG4vKipcbiAqIFRoZSBXZWJTb2NrZXQgc3ViLXByb3RvY29sIHVzZWQgZm9yIHRoZSBbR3JhcGhRTCBvdmVyIFdlYlNvY2tldCBQcm90b2NvbF0oaHR0cHM6Ly9naXRodWIuY29tL2dyYXBocWwvZ3JhcGhxbC1vdmVyLWh0dHAvYmxvYi9tYWluL3JmY3MvR3JhcGhRTE92ZXJXZWJTb2NrZXQubWQpLlxuICpcbiAqIEBjYXRlZ29yeSBDb21tb25cbiAqL1xuZXhwb3J0IGNvbnN0IEdSQVBIUUxfVFJBTlNQT1JUX1dTX1BST1RPQ09MID0gJ2dyYXBocWwtdHJhbnNwb3J0LXdzJztcbi8qKlxuICogVGhlIGRlcHJlY2F0ZWQgc3VicHJvdG9jb2wgdXNlZCBieSBbc3Vic2NyaXB0aW9ucy10cmFuc3BvcnQtd3NdKGh0dHBzOi8vZ2l0aHViLmNvbS9hcG9sbG9ncmFwaHFsL3N1YnNjcmlwdGlvbnMtdHJhbnNwb3J0LXdzKS5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY29uc3QgREVQUkVDQVRFRF9HUkFQSFFMX1dTX1BST1RPQ09MID0gJ2dyYXBocWwtd3MnO1xuLyoqXG4gKiBgZ3JhcGhxbC13c2AgZXhwZWN0ZWQgYW5kIHN0YW5kYXJkIGNsb3NlIGNvZGVzIG9mIHRoZSBbR3JhcGhRTCBvdmVyIFdlYlNvY2tldCBQcm90b2NvbF0oaHR0cHM6Ly9naXRodWIuY29tL2dyYXBocWwvZ3JhcGhxbC1vdmVyLWh0dHAvYmxvYi9tYWluL3JmY3MvR3JhcGhRTE92ZXJXZWJTb2NrZXQubWQpLlxuICpcbiAqIEBjYXRlZ29yeSBDb21tb25cbiAqL1xuZXhwb3J0IHZhciBDbG9zZUNvZGU7XG4oZnVuY3Rpb24gKENsb3NlQ29kZSkge1xuICAgIENsb3NlQ29kZVtDbG9zZUNvZGVbXCJJbnRlcm5hbFNlcnZlckVycm9yXCJdID0gNDUwMF0gPSBcIkludGVybmFsU2VydmVyRXJyb3JcIjtcbiAgICBDbG9zZUNvZGVbQ2xvc2VDb2RlW1wiSW50ZXJuYWxDbGllbnRFcnJvclwiXSA9IDQwMDVdID0gXCJJbnRlcm5hbENsaWVudEVycm9yXCI7XG4gICAgQ2xvc2VDb2RlW0Nsb3NlQ29kZVtcIkJhZFJlcXVlc3RcIl0gPSA0NDAwXSA9IFwiQmFkUmVxdWVzdFwiO1xuICAgIENsb3NlQ29kZVtDbG9zZUNvZGVbXCJCYWRSZXNwb25zZVwiXSA9IDQwMDRdID0gXCJCYWRSZXNwb25zZVwiO1xuICAgIC8qKiBUcmllZCBzdWJzY3JpYmluZyBiZWZvcmUgY29ubmVjdCBhY2sgKi9cbiAgICBDbG9zZUNvZGVbQ2xvc2VDb2RlW1wiVW5hdXRob3JpemVkXCJdID0gNDQwMV0gPSBcIlVuYXV0aG9yaXplZFwiO1xuICAgIENsb3NlQ29kZVtDbG9zZUNvZGVbXCJGb3JiaWRkZW5cIl0gPSA0NDAzXSA9IFwiRm9yYmlkZGVuXCI7XG4gICAgQ2xvc2VDb2RlW0Nsb3NlQ29kZVtcIlN1YnByb3RvY29sTm90QWNjZXB0YWJsZVwiXSA9IDQ0MDZdID0gXCJTdWJwcm90b2NvbE5vdEFjY2VwdGFibGVcIjtcbiAgICBDbG9zZUNvZGVbQ2xvc2VDb2RlW1wiQ29ubmVjdGlvbkluaXRpYWxpc2F0aW9uVGltZW91dFwiXSA9IDQ0MDhdID0gXCJDb25uZWN0aW9uSW5pdGlhbGlzYXRpb25UaW1lb3V0XCI7XG4gICAgQ2xvc2VDb2RlW0Nsb3NlQ29kZVtcIkNvbm5lY3Rpb25BY2tub3dsZWRnZW1lbnRUaW1lb3V0XCJdID0gNDUwNF0gPSBcIkNvbm5lY3Rpb25BY2tub3dsZWRnZW1lbnRUaW1lb3V0XCI7XG4gICAgLyoqIFN1YnNjcmliZXIgZGlzdGluY3Rpb24gaXMgdmVyeSBpbXBvcnRhbnQgKi9cbiAgICBDbG9zZUNvZGVbQ2xvc2VDb2RlW1wiU3Vic2NyaWJlckFscmVhZHlFeGlzdHNcIl0gPSA0NDA5XSA9IFwiU3Vic2NyaWJlckFscmVhZHlFeGlzdHNcIjtcbiAgICBDbG9zZUNvZGVbQ2xvc2VDb2RlW1wiVG9vTWFueUluaXRpYWxpc2F0aW9uUmVxdWVzdHNcIl0gPSA0NDI5XSA9IFwiVG9vTWFueUluaXRpYWxpc2F0aW9uUmVxdWVzdHNcIjtcbn0pKENsb3NlQ29kZSB8fCAoQ2xvc2VDb2RlID0ge30pKTtcbi8qKlxuICogVHlwZXMgb2YgbWVzc2FnZXMgYWxsb3dlZCB0byBiZSBzZW50IGJ5IHRoZSBjbGllbnQvc2VydmVyIG92ZXIgdGhlIFdTIHByb3RvY29sLlxuICpcbiAqIEBjYXRlZ29yeSBDb21tb25cbiAqL1xuZXhwb3J0IHZhciBNZXNzYWdlVHlwZTtcbihmdW5jdGlvbiAoTWVzc2FnZVR5cGUpIHtcbiAgICBNZXNzYWdlVHlwZVtcIkNvbm5lY3Rpb25Jbml0XCJdID0gXCJjb25uZWN0aW9uX2luaXRcIjtcbiAgICBNZXNzYWdlVHlwZVtcIkNvbm5lY3Rpb25BY2tcIl0gPSBcImNvbm5lY3Rpb25fYWNrXCI7XG4gICAgTWVzc2FnZVR5cGVbXCJQaW5nXCJdID0gXCJwaW5nXCI7XG4gICAgTWVzc2FnZVR5cGVbXCJQb25nXCJdID0gXCJwb25nXCI7XG4gICAgTWVzc2FnZVR5cGVbXCJTdWJzY3JpYmVcIl0gPSBcInN1YnNjcmliZVwiO1xuICAgIE1lc3NhZ2VUeXBlW1wiTmV4dFwiXSA9IFwibmV4dFwiO1xuICAgIE1lc3NhZ2VUeXBlW1wiRXJyb3JcIl0gPSBcImVycm9yXCI7XG4gICAgTWVzc2FnZVR5cGVbXCJDb21wbGV0ZVwiXSA9IFwiY29tcGxldGVcIjtcbn0pKE1lc3NhZ2VUeXBlIHx8IChNZXNzYWdlVHlwZSA9IHt9KSk7XG4vKipcbiAqIFZhbGlkYXRlcyB0aGUgbWVzc2FnZSBhZ2FpbnN0IHRoZSBHcmFwaFFMIG92ZXIgV2ViU29ja2V0IFByb3RvY29sLlxuICpcbiAqIEludmFsaWQgbWVzc2FnZXMgd2lsbCB0aHJvdyBkZXNjcmlwdGl2ZSBlcnJvcnMuXG4gKlxuICogQGNhdGVnb3J5IENvbW1vblxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVNZXNzYWdlKHZhbCkge1xuICAgIGlmICghaXNPYmplY3QodmFsKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1lc3NhZ2UgaXMgZXhwZWN0ZWQgdG8gYmUgYW4gb2JqZWN0LCBidXQgZ290ICR7ZXh0ZW5kZWRUeXBlb2YodmFsKX1gKTtcbiAgICB9XG4gICAgaWYgKCF2YWwudHlwZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1lc3NhZ2UgaXMgbWlzc2luZyB0aGUgJ3R5cGUnIHByb3BlcnR5YCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsLnR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTWVzc2FnZSBpcyBleHBlY3RzIHRoZSAndHlwZScgcHJvcGVydHkgdG8gYmUgYSBzdHJpbmcsIGJ1dCBnb3QgJHtleHRlbmRlZFR5cGVvZih2YWwudHlwZSl9YCk7XG4gICAgfVxuICAgIHN3aXRjaCAodmFsLnR5cGUpIHtcbiAgICAgICAgY2FzZSBNZXNzYWdlVHlwZS5Db25uZWN0aW9uSW5pdDpcbiAgICAgICAgY2FzZSBNZXNzYWdlVHlwZS5Db25uZWN0aW9uQWNrOlxuICAgICAgICBjYXNlIE1lc3NhZ2VUeXBlLlBpbmc6XG4gICAgICAgIGNhc2UgTWVzc2FnZVR5cGUuUG9uZzoge1xuICAgICAgICAgICAgaWYgKHZhbC5wYXlsb2FkICE9IG51bGwgJiYgIWlzT2JqZWN0KHZhbC5wYXlsb2FkKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgXCIke3ZhbC50eXBlfVwiIG1lc3NhZ2UgZXhwZWN0cyB0aGUgJ3BheWxvYWQnIHByb3BlcnR5IHRvIGJlIGFuIG9iamVjdCBvciBudWxsaXNoIG9yIG1pc3NpbmcsIGJ1dCBnb3QgXCIke3ZhbC5wYXlsb2FkfVwiYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIE1lc3NhZ2VUeXBlLlN1YnNjcmliZToge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwuaWQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcIiR7dmFsLnR5cGV9XCIgbWVzc2FnZSBleHBlY3RzIHRoZSAnaWQnIHByb3BlcnR5IHRvIGJlIGEgc3RyaW5nLCBidXQgZ290ICR7ZXh0ZW5kZWRUeXBlb2YodmFsLmlkKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdmFsLmlkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcIiR7dmFsLnR5cGV9XCIgbWVzc2FnZSByZXF1aXJlcyBhIG5vbi1lbXB0eSAnaWQnIHByb3BlcnR5YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzT2JqZWN0KHZhbC5wYXlsb2FkKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgXCIke3ZhbC50eXBlfVwiIG1lc3NhZ2UgZXhwZWN0cyB0aGUgJ3BheWxvYWQnIHByb3BlcnR5IHRvIGJlIGFuIG9iamVjdCwgYnV0IGdvdCAke2V4dGVuZGVkVHlwZW9mKHZhbC5wYXlsb2FkKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsLnBheWxvYWQucXVlcnkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcIiR7dmFsLnR5cGV9XCIgbWVzc2FnZSBwYXlsb2FkIGV4cGVjdHMgdGhlICdxdWVyeScgcHJvcGVydHkgdG8gYmUgYSBzdHJpbmcsIGJ1dCBnb3QgJHtleHRlbmRlZFR5cGVvZih2YWwucGF5bG9hZC5xdWVyeSl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsLnBheWxvYWQudmFyaWFibGVzICE9IG51bGwgJiYgIWlzT2JqZWN0KHZhbC5wYXlsb2FkLnZhcmlhYmxlcykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFwiJHt2YWwudHlwZX1cIiBtZXNzYWdlIHBheWxvYWQgZXhwZWN0cyB0aGUgJ3ZhcmlhYmxlcycgcHJvcGVydHkgdG8gYmUgYSBhbiBvYmplY3Qgb3IgbnVsbGlzaCBvciBtaXNzaW5nLCBidXQgZ290ICR7ZXh0ZW5kZWRUeXBlb2YodmFsLnBheWxvYWQudmFyaWFibGVzKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWwucGF5bG9hZC5vcGVyYXRpb25OYW1lICE9IG51bGwgJiZcbiAgICAgICAgICAgICAgICBleHRlbmRlZFR5cGVvZih2YWwucGF5bG9hZC5vcGVyYXRpb25OYW1lKSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFwiJHt2YWwudHlwZX1cIiBtZXNzYWdlIHBheWxvYWQgZXhwZWN0cyB0aGUgJ29wZXJhdGlvbk5hbWUnIHByb3BlcnR5IHRvIGJlIGEgc3RyaW5nIG9yIG51bGxpc2ggb3IgbWlzc2luZywgYnV0IGdvdCAke2V4dGVuZGVkVHlwZW9mKHZhbC5wYXlsb2FkLm9wZXJhdGlvbk5hbWUpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbC5wYXlsb2FkLmV4dGVuc2lvbnMgIT0gbnVsbCAmJiAhaXNPYmplY3QodmFsLnBheWxvYWQuZXh0ZW5zaW9ucykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFwiJHt2YWwudHlwZX1cIiBtZXNzYWdlIHBheWxvYWQgZXhwZWN0cyB0aGUgJ2V4dGVuc2lvbnMnIHByb3BlcnR5IHRvIGJlIGEgYW4gb2JqZWN0IG9yIG51bGxpc2ggb3IgbWlzc2luZywgYnV0IGdvdCAke2V4dGVuZGVkVHlwZW9mKHZhbC5wYXlsb2FkLmV4dGVuc2lvbnMpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBNZXNzYWdlVHlwZS5OZXh0OiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbC5pZCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFwiJHt2YWwudHlwZX1cIiBtZXNzYWdlIGV4cGVjdHMgdGhlICdpZCcgcHJvcGVydHkgdG8gYmUgYSBzdHJpbmcsIGJ1dCBnb3QgJHtleHRlbmRlZFR5cGVvZih2YWwuaWQpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF2YWwuaWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFwiJHt2YWwudHlwZX1cIiBtZXNzYWdlIHJlcXVpcmVzIGEgbm9uLWVtcHR5ICdpZCcgcHJvcGVydHlgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNPYmplY3QodmFsLnBheWxvYWQpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcIiR7dmFsLnR5cGV9XCIgbWVzc2FnZSBleHBlY3RzIHRoZSAncGF5bG9hZCcgcHJvcGVydHkgdG8gYmUgYW4gb2JqZWN0LCBidXQgZ290ICR7ZXh0ZW5kZWRUeXBlb2YodmFsLnBheWxvYWQpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBNZXNzYWdlVHlwZS5FcnJvcjoge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwuaWQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcIiR7dmFsLnR5cGV9XCIgbWVzc2FnZSBleHBlY3RzIHRoZSAnaWQnIHByb3BlcnR5IHRvIGJlIGEgc3RyaW5nLCBidXQgZ290ICR7ZXh0ZW5kZWRUeXBlb2YodmFsLmlkKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdmFsLmlkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcIiR7dmFsLnR5cGV9XCIgbWVzc2FnZSByZXF1aXJlcyBhIG5vbi1lbXB0eSAnaWQnIHByb3BlcnR5YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWFyZUdyYXBoUUxFcnJvcnModmFsLnBheWxvYWQpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcIiR7dmFsLnR5cGV9XCIgbWVzc2FnZSBleHBlY3RzIHRoZSAncGF5bG9hZCcgcHJvcGVydHkgdG8gYmUgYW4gYXJyYXkgb2YgR3JhcGhRTCBlcnJvcnMsIGJ1dCBnb3QgJHtKU09OLnN0cmluZ2lmeSh2YWwucGF5bG9hZCl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIE1lc3NhZ2VUeXBlLkNvbXBsZXRlOiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbC5pZCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFwiJHt2YWwudHlwZX1cIiBtZXNzYWdlIGV4cGVjdHMgdGhlICdpZCcgcHJvcGVydHkgdG8gYmUgYSBzdHJpbmcsIGJ1dCBnb3QgJHtleHRlbmRlZFR5cGVvZih2YWwuaWQpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF2YWwuaWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFwiJHt2YWwudHlwZX1cIiBtZXNzYWdlIHJlcXVpcmVzIGEgbm9uLWVtcHR5ICdpZCcgcHJvcGVydHlgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgbWVzc2FnZSAndHlwZScgcHJvcGVydHkgXCIke3ZhbC50eXBlfVwiYCk7XG4gICAgfVxuICAgIHJldHVybiB2YWw7XG59XG4vKipcbiAqIENoZWNrcyBpZiB0aGUgcHJvdmlkZWQgdmFsdWUgaXMgYSB2YWxpZCBHcmFwaFFMIG92ZXIgV2ViU29ja2V0IG1lc3NhZ2UuXG4gKlxuICogQGRlcHJlY2F0ZWQgVXNlIGB2YWxpZGF0ZU1lc3NhZ2VgIGluc3RlYWQuXG4gKlxuICogQGNhdGVnb3J5IENvbW1vblxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNNZXNzYWdlKHZhbCkge1xuICAgIHRyeSB7XG4gICAgICAgIHZhbGlkYXRlTWVzc2FnZSh2YWwpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG4vKipcbiAqIFBhcnNlcyB0aGUgcmF3IHdlYnNvY2tldCBtZXNzYWdlIGRhdGEgdG8gYSB2YWxpZCBtZXNzYWdlLlxuICpcbiAqIEBjYXRlZ29yeSBDb21tb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlTWVzc2FnZShkYXRhLCByZXZpdmVyKSB7XG4gICAgcmV0dXJuIHZhbGlkYXRlTWVzc2FnZSh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycgPyBKU09OLnBhcnNlKGRhdGEsIHJldml2ZXIpIDogZGF0YSk7XG59XG4vKipcbiAqIFN0cmluZ2lmaWVzIGEgdmFsaWQgbWVzc2FnZSByZWFkeSB0byBiZSBzZW50IHRocm91Z2ggdGhlIHNvY2tldC5cbiAqXG4gKiBAY2F0ZWdvcnkgQ29tbW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHJpbmdpZnlNZXNzYWdlKG1zZywgcmVwbGFjZXIpIHtcbiAgICB2YWxpZGF0ZU1lc3NhZ2UobXNnKTtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkobXNnLCByZXBsYWNlcik7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/graphql-ws/lib/common.mjs\n");

/***/ }),

/***/ "(ssr)/../node_modules/graphql-ws/lib/utils.mjs":
/*!************************************************!*\
  !*** ../node_modules/graphql-ws/lib/utils.mjs ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   areGraphQLErrors: () => (/* binding */ areGraphQLErrors),\n/* harmony export */   extendedTypeof: () => (/* binding */ extendedTypeof),\n/* harmony export */   isAsyncGenerator: () => (/* binding */ isAsyncGenerator),\n/* harmony export */   isAsyncIterable: () => (/* binding */ isAsyncIterable),\n/* harmony export */   isObject: () => (/* binding */ isObject),\n/* harmony export */   limitCloseReason: () => (/* binding */ limitCloseReason)\n/* harmony export */ });\n/** @private */\nfunction extendedTypeof(val) {\n    if (val === null) {\n        return 'null';\n    }\n    if (Array.isArray(val)) {\n        return 'array';\n    }\n    return typeof val;\n}\n/** @private */\nfunction isObject(val) {\n    return extendedTypeof(val) === 'object';\n}\n/** @private */\nfunction isAsyncIterable(val) {\n    return typeof Object(val)[Symbol.asyncIterator] === 'function';\n}\n/** @private */\nfunction isAsyncGenerator(val) {\n    return (isObject(val) &&\n        typeof Object(val)[Symbol.asyncIterator] === 'function' &&\n        typeof val.return === 'function'\n    // for lazy ones, we only need the return anyway\n    // typeof val.throw === 'function' &&\n    // typeof val.next === 'function'\n    );\n}\n/** @private */\nfunction areGraphQLErrors(obj) {\n    return (Array.isArray(obj) &&\n        // must be at least one error\n        obj.length > 0 &&\n        // error has at least a message\n        obj.every((ob) => 'message' in ob));\n}\n/**\n * Limits the WebSocket close event reason to not exceed a length of one frame.\n * Reference: https://datatracker.ietf.org/doc/html/rfc6455#section-5.2.\n *\n * @private\n */\nfunction limitCloseReason(reason, whenTooLong) {\n    return reason.length < 124 ? reason : whenTooLong;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL2dyYXBocWwtd3MvbGliL3V0aWxzLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sZWRnaXR5LXlpZWxkLWZyb250ZW5kLy4uL25vZGVfbW9kdWxlcy9ncmFwaHFsLXdzL2xpYi91dGlscy5tanM/N2U1MCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiogQHByaXZhdGUgKi9cbmV4cG9ydCBmdW5jdGlvbiBleHRlbmRlZFR5cGVvZih2YWwpIHtcbiAgICBpZiAodmFsID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAnbnVsbCc7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAgcmV0dXJuICdhcnJheSc7XG4gICAgfVxuICAgIHJldHVybiB0eXBlb2YgdmFsO1xufVxuLyoqIEBwcml2YXRlICovXG5leHBvcnQgZnVuY3Rpb24gaXNPYmplY3QodmFsKSB7XG4gICAgcmV0dXJuIGV4dGVuZGVkVHlwZW9mKHZhbCkgPT09ICdvYmplY3QnO1xufVxuLyoqIEBwcml2YXRlICovXG5leHBvcnQgZnVuY3Rpb24gaXNBc3luY0l0ZXJhYmxlKHZhbCkge1xuICAgIHJldHVybiB0eXBlb2YgT2JqZWN0KHZhbClbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID09PSAnZnVuY3Rpb24nO1xufVxuLyoqIEBwcml2YXRlICovXG5leHBvcnQgZnVuY3Rpb24gaXNBc3luY0dlbmVyYXRvcih2YWwpIHtcbiAgICByZXR1cm4gKGlzT2JqZWN0KHZhbCkgJiZcbiAgICAgICAgdHlwZW9mIE9iamVjdCh2YWwpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICB0eXBlb2YgdmFsLnJldHVybiA9PT0gJ2Z1bmN0aW9uJ1xuICAgIC8vIGZvciBsYXp5IG9uZXMsIHdlIG9ubHkgbmVlZCB0aGUgcmV0dXJuIGFueXdheVxuICAgIC8vIHR5cGVvZiB2YWwudGhyb3cgPT09ICdmdW5jdGlvbicgJiZcbiAgICAvLyB0eXBlb2YgdmFsLm5leHQgPT09ICdmdW5jdGlvbidcbiAgICApO1xufVxuLyoqIEBwcml2YXRlICovXG5leHBvcnQgZnVuY3Rpb24gYXJlR3JhcGhRTEVycm9ycyhvYmopIHtcbiAgICByZXR1cm4gKEFycmF5LmlzQXJyYXkob2JqKSAmJlxuICAgICAgICAvLyBtdXN0IGJlIGF0IGxlYXN0IG9uZSBlcnJvclxuICAgICAgICBvYmoubGVuZ3RoID4gMCAmJlxuICAgICAgICAvLyBlcnJvciBoYXMgYXQgbGVhc3QgYSBtZXNzYWdlXG4gICAgICAgIG9iai5ldmVyeSgob2IpID0+ICdtZXNzYWdlJyBpbiBvYikpO1xufVxuLyoqXG4gKiBMaW1pdHMgdGhlIFdlYlNvY2tldCBjbG9zZSBldmVudCByZWFzb24gdG8gbm90IGV4Y2VlZCBhIGxlbmd0aCBvZiBvbmUgZnJhbWUuXG4gKiBSZWZlcmVuY2U6IGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjNjQ1NSNzZWN0aW9uLTUuMi5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gbGltaXRDbG9zZVJlYXNvbihyZWFzb24sIHdoZW5Ub29Mb25nKSB7XG4gICAgcmV0dXJuIHJlYXNvbi5sZW5ndGggPCAxMjQgPyByZWFzb24gOiB3aGVuVG9vTG9uZztcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/graphql-ws/lib/utils.mjs\n");

/***/ })

};
;