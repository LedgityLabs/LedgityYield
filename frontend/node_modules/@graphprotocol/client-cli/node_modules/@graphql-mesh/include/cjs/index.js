"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.include = include;
exports.registerTsconfigPaths = registerTsconfigPaths;
const tslib_1 = require("tslib");
// eslint-disable-next-line import/no-nodejs-modules
const node_module_1 = tslib_1.__importDefault(require("node:module"));
const get_tsconfig_1 = require("get-tsconfig");
const jiti_1 = tslib_1.__importDefault(require("jiti"));
const jiti = (0, jiti_1.default)(
/**
 * We intentionally provide an empty string here and let jiti handle the base URL.
 *
 * This is because `import.meta.url` is not available in CJS (and cant even be in the syntax)
 * and `__filename` is not available in ESM.
 */
'');
/**
 * Import a module, ESM or CJS at the provided {@link path}.
 *
 * If the included module has a "default" export, it will be returned instead.
 *
 * If the module at {@link path} is not found, `null` will be returned.
 */
async function include(path, nativeImport) {
    const module = await (nativeImport ? Promise.resolve(`${path}`).then(s => tslib_1.__importStar(require(s))) : jiti.import(path, {}));
    if (!module) {
        throw new Error('Included module is empty');
    }
    if (typeof module !== 'object') {
        throw new Error(`Included module is not an object, is instead "${typeof module}"`);
    }
    if ('default' in module) {
        return module.default;
    }
    return module;
}
/**
 * Parses the closest `(t|j)sconfig.json` paths and augments Node's module
 * resolution to consider those paths during imports.
 *
 * @returns The unregister function.
 */
function registerTsconfigPaths({ cwd = process.cwd(), configName = process.env.MESH_INCLUDE_TSCONFIG_NAME || 'tsconfig.json', } = {}) {
    const tsconfig = (0, get_tsconfig_1.getTsconfig)(cwd, configName);
    if (!tsconfig)
        return () => { }; // no tsconfig, no register
    const pathsMatcher = (0, get_tsconfig_1.createPathsMatcher)(tsconfig);
    if (!pathsMatcher)
        return () => { }; // no paths matcher, no register
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-expect-error
    const originalResolveFilename = node_module_1.default._resolveFilename;
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-expect-error
    node_module_1.default._resolveFilename = (...args) => {
        const [path, ...rest] = args;
        try {
            return originalResolveFilename(...args);
        }
        catch (e) {
            if (e.code !== 'MODULE_NOT_FOUND') {
                // throw non-module_not_found errors immediately
                throw e;
            }
            // original resolve didnt find the module, try resolving using tsconfig paths
            for (const possiblePath of pathsMatcher(path)) {
                try {
                    return originalResolveFilename(possiblePath, ...rest);
                }
                catch {
                    // noop
                }
            }
            // tsconfig paths couldnt resolve the module either, throw original error
            throw e;
        }
    };
    return function unregisterTsconfigPaths() {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-expect-error
        node_module_1.default._resolveFilename = originalResolveFilename;
    };
}
