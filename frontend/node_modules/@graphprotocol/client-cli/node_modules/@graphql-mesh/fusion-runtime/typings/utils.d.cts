import { type DocumentNode, type ExecutionResult, type GraphQLSchema } from 'graphql';
import type { Transport, TransportContext, TransportEntry, TransportGetSubgraphExecutor, TransportGetSubgraphExecutorOptions } from '@graphql-mesh/transport-common';
import type { Logger } from '@graphql-mesh/types';
import { type ExecutionRequest, type Executor, type Maybe, type MaybePromise } from '@graphql-tools/utils';
export type { TransportEntry, TransportGetSubgraphExecutor, TransportGetSubgraphExecutorOptions };
export type Transports = {
    [key: string]: MaybePromise<Transport | {
        default: Transport;
    }>;
} | ((kind: string) => MaybePromise<Transport | {
    default: Transport;
}>);
export declare const subgraphNameByExecutionRequest: WeakMap<ExecutionRequest<any, any, any, Record<string, any>, any>, string>;
/**
 * This function creates a executor factory that uses the transport packages,
 * and wraps them with the hooks
 */
export declare function getOnSubgraphExecute({ onSubgraphExecuteHooks, transportContext, transportEntryMap, getSubgraphSchema, transportExecutorStack, transports, }: {
    onSubgraphExecuteHooks: OnSubgraphExecuteHook[];
    transports?: Transports;
    transportContext?: TransportContext;
    transportEntryMap?: Record<string, TransportEntry>;
    getSubgraphSchema(subgraphName: string): GraphQLSchema;
    transportExecutorStack: AsyncDisposableStack;
}): (subgraphName: string, executionRequest: ExecutionRequest) => MaybePromise<import("@graphql-tools/utils").MaybeAsyncIterable<import("@graphql-tools/utils").ExecutionResult<any, any>>>;
export interface WrapExecuteWithHooksOptions {
    executor: Executor;
    onSubgraphExecuteHooks: OnSubgraphExecuteHook[];
    subgraphName: string;
    transportEntryMap?: Record<string, TransportEntry>;
    getSubgraphSchema: (subgraphName: string) => GraphQLSchema;
    transportContext?: TransportContext;
}
declare module 'graphql' {
    interface GraphQLResolveInfo {
        executionRequest?: ExecutionRequest;
    }
}
/**
 * This function wraps the executor created by the transport package
 * with `onSubgraphExecuteHooks` to hook into the execution phase of subgraphs
 */
export declare function wrapExecutorWithHooks({ executor, onSubgraphExecuteHooks, subgraphName, transportEntryMap, getSubgraphSchema, transportContext, }: WrapExecuteWithHooksOptions): Executor;
export interface UnifiedGraphPlugin<TContext> {
    onSubgraphExecute?: OnSubgraphExecuteHook<TContext>;
}
export type OnSubgraphExecuteHook<TContext = any> = (payload: OnSubgraphExecutePayload<TContext>) => MaybePromise<Maybe<OnSubgraphExecuteDoneHook | void>>;
export interface OnSubgraphExecutePayload<TContext> {
    subgraph: GraphQLSchema;
    subgraphName: string;
    transportEntry?: TransportEntry;
    executionRequest: ExecutionRequest<any, TContext>;
    setExecutionRequest(executionRequest: ExecutionRequest): void;
    executor: Executor;
    setExecutor(executor: Executor): void;
    requestId?: string;
    logger?: Logger;
}
export interface OnSubgraphExecuteDonePayload {
    result: AsyncIterable<ExecutionResult> | ExecutionResult;
    setResult(result: AsyncIterable<ExecutionResult> | ExecutionResult): void;
}
export type OnSubgraphExecuteDoneHook = (payload: OnSubgraphExecuteDonePayload) => MaybePromise<Maybe<OnSubgraphExecuteDoneResult | void>>;
export type OnSubgraphExecuteDoneResultOnNext = (payload: OnSubgraphExecuteDoneOnNextPayload) => MaybePromise<void>;
export interface OnSubgraphExecuteDoneOnNextPayload {
    result: ExecutionResult;
    setResult(result: ExecutionResult): void;
}
export type OnSubgraphExecuteDoneResultOnEnd = () => MaybePromise<void>;
export type OnSubgraphExecuteDoneResult = {
    onNext?: OnSubgraphExecuteDoneResultOnNext;
    onEnd?: OnSubgraphExecuteDoneResultOnEnd;
};
export declare function compareSchemas(a: DocumentNode | string | GraphQLSchema, b: DocumentNode | string | GraphQLSchema): boolean;
export declare function compareSubgraphNames(name1: string, name2: string): boolean;
