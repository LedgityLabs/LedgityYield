import { getNamedType, getNullableType, isInterfaceType, isListType, isObjectType, isUnionType, Kind, parseValue, print, valueFromASTUntyped, } from 'graphql';
import { cloneSubschemaConfig, } from '@graphql-tools/delegate';
import { getDirective, getImplementingTypes, MapperKind, mapSchema, mergeDeep, parseSelectionSet, } from '@graphql-tools/utils';
import { defaultStitchingDirectiveOptions } from './defaultStitchingDirectiveOptions.js';
import { parseMergeArgsExpr } from './parseMergeArgsExpr.js';
import { addProperty, getProperties, getProperty } from './properties.js';
export function stitchingDirectivesTransformer(options = {}) {
    const { keyDirectiveName, computedDirectiveName, mergeDirectiveName, canonicalDirectiveName, pathToDirectivesInExtensions, } = {
        ...defaultStitchingDirectiveOptions,
        ...options,
    };
    return (subschemaConfig) => {
        const newSubschemaConfig = cloneSubschemaConfig(subschemaConfig);
        const selectionSetsByType = Object.create(null);
        const computedFieldSelectionSets = Object.create(null);
        const mergedTypesResolversInfo = Object.create(null);
        const canonicalTypesInfo = Object.create(null);
        const selectionSetsByTypeAndEntryField = Object.create(null);
        const mergedTypesResolversInfoByEntryField = Object.create(null);
        const schema = subschemaConfig.schema;
        function setCanonicalDefinition(typeName, fieldName) {
            canonicalTypesInfo[typeName] = canonicalTypesInfo[typeName] || Object.create(null);
            if (fieldName) {
                const fields = canonicalTypesInfo[typeName].fields ?? Object.create(null);
                canonicalTypesInfo[typeName].fields = fields;
                fields[fieldName] = true;
            }
            else {
                canonicalTypesInfo[typeName].canonical = true;
            }
        }
        mapSchema(schema, {
            [MapperKind.OBJECT_TYPE]: type => {
                const keyDirective = getDirective(schema, type, keyDirectiveName, pathToDirectivesInExtensions)?.[0];
                if (keyDirective != null) {
                    const selectionSet = parseSelectionSet(keyDirective['selectionSet'], {
                        noLocation: true,
                    });
                    selectionSetsByType[type.name] = selectionSet;
                }
                const canonicalDirective = getDirective(schema, type, canonicalDirectiveName, pathToDirectivesInExtensions)?.[0];
                if (canonicalDirective != null) {
                    setCanonicalDefinition(type.name);
                }
                return undefined;
            },
            [MapperKind.OBJECT_FIELD]: (fieldConfig, fieldName, typeName) => {
                const computedDirective = getDirective(schema, fieldConfig, computedDirectiveName, pathToDirectivesInExtensions)?.[0];
                if (computedDirective != null) {
                    const selectionSet = parseSelectionSet(computedDirective['selectionSet'], {
                        noLocation: true,
                    });
                    if (!computedFieldSelectionSets[typeName]) {
                        computedFieldSelectionSets[typeName] = Object.create(null);
                    }
                    computedFieldSelectionSets[typeName][fieldName] = selectionSet;
                }
                const mergeDirective = getDirective(schema, fieldConfig, mergeDirectiveName, pathToDirectivesInExtensions)?.[0];
                if (mergeDirective?.['keyField'] != null) {
                    const mergeDirectiveKeyField = mergeDirective['keyField'];
                    const selectionSet = parseSelectionSet(`{ ${mergeDirectiveKeyField}}`, {
                        noLocation: true,
                    });
                    const typeNames = mergeDirective['types'];
                    const returnType = getNamedType(fieldConfig.type);
                    forEachConcreteType(schema, returnType, typeNames, typeName => {
                        if (typeNames == null || typeNames.includes(typeName)) {
                            let existingEntryFieldMap = selectionSetsByTypeAndEntryField[typeName];
                            if (existingEntryFieldMap == null) {
                                existingEntryFieldMap = Object.create(null);
                                selectionSetsByTypeAndEntryField[typeName] = existingEntryFieldMap;
                            }
                            let existingSelectionSet = existingEntryFieldMap[fieldName];
                            if (existingSelectionSet == null) {
                                existingSelectionSet = selectionSetsByType[typeName];
                            }
                            existingEntryFieldMap[fieldName] = existingSelectionSet
                                ? mergeSelectionSets(existingSelectionSet, selectionSet)
                                : selectionSet;
                        }
                    });
                }
                const canonicalDirective = getDirective(schema, fieldConfig, canonicalDirectiveName, pathToDirectivesInExtensions)?.[0];
                if (canonicalDirective != null) {
                    setCanonicalDefinition(typeName, fieldName);
                }
                return undefined;
            },
            [MapperKind.INTERFACE_TYPE]: type => {
                const canonicalDirective = getDirective(schema, type, canonicalDirectiveName, pathToDirectivesInExtensions)?.[0];
                if (canonicalDirective) {
                    setCanonicalDefinition(type.name);
                }
                return undefined;
            },
            [MapperKind.INTERFACE_FIELD]: (fieldConfig, fieldName, typeName) => {
                const canonicalDirective = getDirective(schema, fieldConfig, canonicalDirectiveName, pathToDirectivesInExtensions)?.[0];
                if (canonicalDirective) {
                    setCanonicalDefinition(typeName, fieldName);
                }
                return undefined;
            },
            [MapperKind.INPUT_OBJECT_TYPE]: type => {
                const canonicalDirective = getDirective(schema, type, canonicalDirectiveName, pathToDirectivesInExtensions)?.[0];
                if (canonicalDirective) {
                    setCanonicalDefinition(type.name);
                }
                return undefined;
            },
            [MapperKind.INPUT_OBJECT_FIELD]: (inputFieldConfig, fieldName, typeName) => {
                const canonicalDirective = getDirective(schema, inputFieldConfig, canonicalDirectiveName, pathToDirectivesInExtensions)?.[0];
                if (canonicalDirective != null) {
                    setCanonicalDefinition(typeName, fieldName);
                }
                return undefined;
            },
            [MapperKind.UNION_TYPE]: type => {
                const canonicalDirective = getDirective(schema, type, canonicalDirectiveName, pathToDirectivesInExtensions)?.[0];
                if (canonicalDirective != null) {
                    setCanonicalDefinition(type.name);
                }
                return undefined;
            },
            [MapperKind.ENUM_TYPE]: type => {
                const canonicalDirective = getDirective(schema, type, canonicalDirectiveName, pathToDirectivesInExtensions)?.[0];
                if (canonicalDirective != null) {
                    setCanonicalDefinition(type.name);
                }
                return undefined;
            },
            [MapperKind.SCALAR_TYPE]: type => {
                const canonicalDirective = getDirective(schema, type, canonicalDirectiveName, pathToDirectivesInExtensions)?.[0];
                if (canonicalDirective != null) {
                    setCanonicalDefinition(type.name);
                }
                return undefined;
            },
        });
        if (subschemaConfig.merge) {
            for (const typeName in subschemaConfig.merge) {
                const mergedTypeConfig = subschemaConfig.merge[typeName];
                if (mergedTypeConfig.selectionSet) {
                    const selectionSet = parseSelectionSet(mergedTypeConfig.selectionSet, {
                        noLocation: true,
                    });
                    if (selectionSet) {
                        if (selectionSetsByType[typeName]) {
                            selectionSetsByType[typeName] = mergeSelectionSets(selectionSetsByType[typeName], selectionSet);
                        }
                        else {
                            selectionSetsByType[typeName] = selectionSet;
                        }
                    }
                }
                if (mergedTypeConfig.fields) {
                    for (const fieldName in mergedTypeConfig.fields) {
                        const fieldConfig = mergedTypeConfig.fields[fieldName];
                        if (!fieldConfig.selectionSet)
                            continue;
                        const selectionSet = parseSelectionSet(fieldConfig.selectionSet, { noLocation: true });
                        if (selectionSet) {
                            if (computedFieldSelectionSets[typeName]?.[fieldName]) {
                                computedFieldSelectionSets[typeName][fieldName] = mergeSelectionSets(computedFieldSelectionSets[typeName][fieldName], selectionSet);
                            }
                            else {
                                if (computedFieldSelectionSets[typeName] == null) {
                                    computedFieldSelectionSets[typeName] = Object.create(null);
                                }
                                computedFieldSelectionSets[typeName][fieldName] = selectionSet;
                            }
                        }
                    }
                }
            }
        }
        const allSelectionSetsByType = Object.create(null);
        for (const typeName in selectionSetsByType) {
            allSelectionSetsByType[typeName] = allSelectionSetsByType[typeName] || [];
            const selectionSet = selectionSetsByType[typeName];
            allSelectionSetsByType[typeName].push(selectionSet);
        }
        for (const typeName in computedFieldSelectionSets) {
            const selectionSets = computedFieldSelectionSets[typeName];
            for (const i in selectionSets) {
                allSelectionSetsByType[typeName] = allSelectionSetsByType[typeName] || [];
                const selectionSet = selectionSets[i];
                allSelectionSetsByType[typeName].push(selectionSet);
            }
        }
        mapSchema(schema, {
            [MapperKind.OBJECT_FIELD]: function objectFieldMapper(fieldConfig, fieldName) {
                const mergeDirective = getDirective(schema, fieldConfig, mergeDirectiveName, pathToDirectivesInExtensions)?.[0];
                if (mergeDirective != null) {
                    const returnType = getNullableType(fieldConfig.type);
                    const returnsList = isListType(returnType);
                    const namedType = getNamedType(returnType);
                    let mergeArgsExpr = mergeDirective['argsExpr'];
                    if (mergeArgsExpr == null) {
                        const key = mergeDirective['key'];
                        const keyField = mergeDirective['keyField'];
                        const keyExpr = key != null ? buildKeyExpr(key) : keyField != null ? `$key.${keyField}` : '$key';
                        const keyArg = mergeDirective['keyArg'];
                        const argNames = keyArg == null ? [Object.keys(fieldConfig.args ?? {})[0]] : keyArg.split('.');
                        const lastArgName = argNames.pop();
                        mergeArgsExpr = returnsList
                            ? `${lastArgName}: [[${keyExpr}]]`
                            : `${lastArgName}: ${keyExpr}`;
                        for (const argName of argNames.reverse()) {
                            mergeArgsExpr = `${argName}: { ${mergeArgsExpr} }`;
                        }
                    }
                    const typeNames = mergeDirective['types'];
                    forEachConcreteTypeName(namedType, schema, typeNames, function generateResolveInfo(typeName) {
                        const mergedSelectionSets = [];
                        if (allSelectionSetsByType[typeName]) {
                            mergedSelectionSets.push(...allSelectionSetsByType[typeName]);
                        }
                        if (selectionSetsByTypeAndEntryField[typeName]?.[fieldName]) {
                            mergedSelectionSets.push(selectionSetsByTypeAndEntryField[typeName][fieldName]);
                        }
                        const parsedMergeArgsExpr = parseMergeArgsExpr(mergeArgsExpr, allSelectionSetsByType[typeName] == null
                            ? undefined
                            : mergeSelectionSets(...mergedSelectionSets));
                        const additionalArgs = mergeDirective['additionalArgs'];
                        if (additionalArgs != null) {
                            parsedMergeArgsExpr.args = mergeDeep([
                                parsedMergeArgsExpr.args,
                                valueFromASTUntyped(parseValue(`{ ${additionalArgs} }`, { noLocation: true })),
                            ]);
                        }
                        if (selectionSetsByTypeAndEntryField[typeName]?.[fieldName] != null) {
                            const typeConfigByField = (mergedTypesResolversInfoByEntryField[typeName] ||=
                                Object.create(null));
                            typeConfigByField[fieldName] = {
                                fieldName,
                                returnsList,
                                ...parsedMergeArgsExpr,
                            };
                        }
                        else {
                            mergedTypesResolversInfo[typeName] = {
                                fieldName,
                                returnsList,
                                ...parsedMergeArgsExpr,
                            };
                        }
                    });
                }
                return undefined;
            },
        });
        for (const typeName in selectionSetsByType) {
            const selectionSet = selectionSetsByType[typeName];
            const mergeConfig = newSubschemaConfig.merge ?? Object.create(null);
            newSubschemaConfig.merge = mergeConfig;
            if (mergeConfig[typeName] == null) {
                newSubschemaConfig.merge[typeName] = Object.create(null);
            }
            const mergeTypeConfig = mergeConfig[typeName];
            mergeTypeConfig.selectionSet = print(selectionSet);
        }
        for (const typeName in computedFieldSelectionSets) {
            const selectionSets = computedFieldSelectionSets[typeName];
            const mergeConfig = newSubschemaConfig.merge ?? Object.create(null);
            newSubschemaConfig.merge = mergeConfig;
            if (mergeConfig[typeName] == null) {
                mergeConfig[typeName] = Object.create(null);
            }
            const mergeTypeConfig = newSubschemaConfig.merge[typeName];
            const mergeTypeConfigFields = mergeTypeConfig.fields ?? Object.create(null);
            mergeTypeConfig.fields = mergeTypeConfigFields;
            for (const fieldName in selectionSets) {
                const selectionSet = selectionSets[fieldName];
                const fieldConfig = mergeTypeConfigFields[fieldName] ?? Object.create(null);
                mergeTypeConfigFields[fieldName] = fieldConfig;
                fieldConfig.selectionSet = print(selectionSet);
                fieldConfig.computed = true;
            }
        }
        for (const typeName in mergedTypesResolversInfo) {
            const mergedTypeResolverInfo = mergedTypesResolversInfo[typeName];
            const mergeConfig = newSubschemaConfig.merge ?? Object.create(null);
            newSubschemaConfig.merge = mergeConfig;
            if (newSubschemaConfig.merge[typeName] == null) {
                newSubschemaConfig.merge[typeName] = Object.create(null);
            }
            const mergeTypeConfig = newSubschemaConfig.merge[typeName];
            mergeTypeConfig.fieldName = mergedTypeResolverInfo.fieldName;
            if (mergedTypeResolverInfo.returnsList) {
                mergeTypeConfig.key = generateKeyFn(mergedTypeResolverInfo);
                mergeTypeConfig.argsFromKeys = generateArgsFromKeysFn(mergedTypeResolverInfo);
            }
            else {
                mergeTypeConfig.args = generateArgsFn(mergedTypeResolverInfo);
            }
        }
        for (const typeName in canonicalTypesInfo) {
            const canonicalTypeInfo = canonicalTypesInfo[typeName];
            const mergeConfig = newSubschemaConfig.merge ?? Object.create(null);
            newSubschemaConfig.merge = mergeConfig;
            if (newSubschemaConfig.merge[typeName] == null) {
                newSubschemaConfig.merge[typeName] = Object.create(null);
            }
            const mergeTypeConfig = newSubschemaConfig.merge[typeName];
            if (canonicalTypeInfo.canonical) {
                mergeTypeConfig.canonical = true;
            }
            if (canonicalTypeInfo.fields) {
                const mergeTypeConfigFields = mergeTypeConfig.fields ?? Object.create(null);
                mergeTypeConfig.fields = mergeTypeConfigFields;
                for (const fieldName in canonicalTypeInfo.fields) {
                    if (mergeTypeConfigFields[fieldName] == null) {
                        mergeTypeConfigFields[fieldName] = Object.create(null);
                    }
                    mergeTypeConfigFields[fieldName].canonical = true;
                }
            }
        }
        for (const typeName in mergedTypesResolversInfoByEntryField) {
            const entryPoints = [];
            const existingMergeConfig = newSubschemaConfig.merge?.[typeName];
            const newMergeConfig = (newSubschemaConfig.merge ||= Object.create(null));
            if (existingMergeConfig) {
                const { fields, canonical, ...baseEntryPoint } = existingMergeConfig;
                newMergeConfig[typeName] = {
                    fields,
                    canonical,
                    entryPoints,
                };
                entryPoints.push(baseEntryPoint);
            }
            else {
                newMergeConfig[typeName] = {
                    entryPoints,
                };
            }
            for (const fieldName in mergedTypesResolversInfoByEntryField[typeName]) {
                const mergedTypeResolverInfo = mergedTypesResolversInfoByEntryField[typeName][fieldName];
                const newEntryPoint = {
                    fieldName,
                    selectionSet: print(selectionSetsByTypeAndEntryField[typeName][fieldName]),
                };
                if (mergedTypeResolverInfo.returnsList) {
                    newEntryPoint.key = generateKeyFn(mergedTypeResolverInfo);
                    newEntryPoint.argsFromKeys = generateArgsFromKeysFn(mergedTypeResolverInfo);
                }
                else {
                    newEntryPoint.args = generateArgsFn(mergedTypeResolverInfo);
                }
                entryPoints.push(newEntryPoint);
            }
            if (entryPoints.length === 1) {
                const [entryPoint] = entryPoints;
                const { fields, canonical } = newMergeConfig[typeName];
                newMergeConfig[typeName] = {
                    ...entryPoint,
                    fields,
                    canonical,
                };
            }
        }
        return newSubschemaConfig;
    };
}
function forEachConcreteType(schema, type, typeNames, fn) {
    if (isInterfaceType(type)) {
        for (const typeName of getImplementingTypes(type.name, schema)) {
            if (typeNames == null || typeNames.includes(typeName)) {
                fn(typeName);
            }
        }
    }
    else if (isUnionType(type)) {
        for (const { name: typeName } of type.getTypes()) {
            if (typeNames == null || typeNames.includes(typeName)) {
                fn(typeName);
            }
        }
    }
    else if (isObjectType(type)) {
        fn(type.name);
    }
}
function generateKeyFn(mergedTypeResolverInfo) {
    return function keyFn(originalResult) {
        return getProperties(originalResult, mergedTypeResolverInfo.usedProperties);
    };
}
function generateArgsFromKeysFn(mergedTypeResolverInfo) {
    const { expansions, args } = mergedTypeResolverInfo;
    return function generateArgsFromKeys(keys) {
        const newArgs = mergeDeep([{}, args]);
        if (expansions) {
            for (const expansion of expansions) {
                const mappingInstructions = expansion.mappingInstructions;
                const expanded = [];
                for (const key of keys) {
                    let newValue = mergeDeep([{}, expansion.valuePath]);
                    for (const { destinationPath, sourcePath } of mappingInstructions) {
                        if (destinationPath.length) {
                            addProperty(newValue, destinationPath, getProperty(key, sourcePath));
                        }
                        else {
                            newValue = getProperty(key, sourcePath);
                        }
                    }
                    expanded.push(newValue);
                }
                addProperty(newArgs, expansion.valuePath, expanded);
            }
        }
        return newArgs;
    };
}
function generateArgsFn(mergedTypeResolverInfo) {
    const { mappingInstructions, args, usedProperties } = mergedTypeResolverInfo;
    return function generateArgs(originalResult) {
        const newArgs = mergeDeep([{}, args]);
        const filteredResult = getProperties(originalResult, usedProperties);
        if (mappingInstructions) {
            for (const mappingInstruction of mappingInstructions) {
                const { destinationPath, sourcePath } = mappingInstruction;
                addProperty(newArgs, destinationPath, getProperty(filteredResult, sourcePath));
            }
        }
        return newArgs;
    };
}
function buildKeyExpr(key) {
    let mergedObject = {};
    for (const keyDef of key) {
        let [aliasOrKeyPath, keyPath] = keyDef.split(':');
        let aliasPath;
        if (keyPath == null) {
            keyPath = aliasPath = aliasOrKeyPath;
        }
        else {
            aliasPath = aliasOrKeyPath;
        }
        const aliasParts = aliasPath.split('.');
        const lastAliasPart = aliasParts.pop();
        if (lastAliasPart == null) {
            throw new Error(`Key "${key}" is invalid, no path provided.`);
        }
        let object = { [lastAliasPart]: `$key.${keyPath}` };
        for (const aliasPart of aliasParts.reverse()) {
            object = { [aliasPart]: object };
        }
        mergedObject = mergeDeep([mergedObject, object]);
    }
    return JSON.stringify(mergedObject).replace(/"/g, '');
}
function mergeSelectionSets(...selectionSets) {
    const normalizedSelections = Object.create(null);
    for (const selectionSet of selectionSets) {
        for (const selection of selectionSet.selections) {
            const normalizedSelection = print(selection);
            normalizedSelections[normalizedSelection] = selection;
        }
    }
    const newSelectionSet = {
        kind: Kind.SELECTION_SET,
        selections: Object.values(normalizedSelections),
    };
    return newSelectionSet;
}
function forEachConcreteTypeName(returnType, schema, typeNames, fn) {
    if (isInterfaceType(returnType)) {
        for (const typeName of getImplementingTypes(returnType.name, schema)) {
            if (typeNames == null || typeNames.includes(typeName)) {
                fn(typeName);
            }
        }
    }
    else if (isUnionType(returnType)) {
        for (const type of returnType.getTypes()) {
            if (typeNames == null || typeNames.includes(type.name)) {
                fn(type.name);
            }
        }
    }
    else if (isObjectType(returnType) &&
        (typeNames == null || typeNames.includes(returnType.name))) {
        fn(returnType.name);
    }
}
