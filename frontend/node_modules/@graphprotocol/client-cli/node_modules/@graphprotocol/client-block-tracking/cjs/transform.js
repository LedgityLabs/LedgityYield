"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BlockTrackingTransform = void 0;
const utils_1 = require("@graphql-tools/utils");
const graphql_1 = require("graphql");
const shared_js_1 = require("./shared.js");
const DEFAULTS = {
    if: true,
    validateSchema: true,
    ...shared_js_1.DEFAULT_CONFIG,
};
const validateSchema = (0, utils_1.memoize2)(function validateSchema(schema, config) {
    const metaType = schema.getType(config.metaTypeName);
    if (metaType == null || !(0, graphql_1.isObjectType)(metaType)) {
        throw new Error(`Make sure you have a type named "${config.metaTypeName}" in this source before applying Block Tracking`);
    }
    const blockField = metaType.getFields()[config.blockFieldName];
    if (blockField == null) {
        throw new Error(`Make sure you have a type named "${config.metaTypeName}" with "${config.blockFieldName}" field in this source before applying Block Tracking`);
    }
    const blockType = (0, graphql_1.getNamedType)(blockField.type);
    if (!(0, graphql_1.isObjectType)(blockType)) {
        throw new Error(`Make sure you have a correct block type in this source before applying Block Tracking`);
    }
    const blockNumberField = blockType.getFields()[config.blockNumberFieldName];
    if (blockNumberField == null) {
        throw new Error(`Make sure you have a correct block type with "${config.blockNumberFieldName}" field in this source before applying Block Tracking`);
    }
    const queryType = schema.getQueryType();
    if (queryType == null) {
        throw new Error(`Make sure you have a query type in this source before applying Block Tracking`);
    }
    const queryFields = queryType.getFields();
    const metaQueryField = queryFields[config.metaRootFieldName];
    if (metaQueryField == null) {
        throw new Error(`Make sure you have a query type with "${config.metaRootFieldName}" field in this source before applying Block Tracking`);
    }
    const metaQueryFieldType = (0, graphql_1.getNamedType)(metaQueryField.type);
    if (!(0, graphql_1.isObjectType)(metaQueryFieldType) || metaQueryFieldType.name !== config.metaTypeName) {
        throw new Error(`Make sure you have a query type with "${config.metaRootFieldName}" field with the correct ${config.metaTypeName} type in this source before applying Block Tracking`);
    }
    for (const fieldName in queryFields) {
        if (fieldName === config.metaRootFieldName) {
            continue;
        }
        const field = queryFields[fieldName];
        const blockArgument = field.args.find((arg) => arg.name === config.blockArgumentName);
        if (blockArgument == null) {
            throw new Error(`Make sure you have query root fields with "${config.blockArgumentName}" argument in this source before applying Block Tracking`);
        }
        const blockArgumentType = (0, graphql_1.getNamedType)(blockArgument.type);
        if (!(0, graphql_1.isInputObjectType)(blockArgumentType)) {
            throw new Error(`Make sure you have query root fields with "${config.blockArgumentName}" argument returning correct type in this source before applying Block Tracking`);
        }
        const blockArgumentFields = blockArgumentType.getFields();
        const minBlockArgument = blockArgumentFields[config.minBlockArgumentName];
        if (minBlockArgument == null) {
            throw new Error(`Make sure you have query root fields with "${config.blockArgumentName}" argument with "${config.minBlockArgumentName}" field in this source before applying Block Tracking`);
        }
    }
});
const schemaMinBlockMap = new WeakMap();
class BlockTrackingTransform {
    constructor({ config } = {}) {
        this.config = {
            ...DEFAULTS,
            ...config,
        };
        if (!this.config.if) {
            return {};
        }
    }
    transformSchema(schema, subschemaConfig) {
        if (this.config.validateSchema) {
            validateSchema(subschemaConfig.schema, this.config);
        }
        return schema;
    }
    transformRequest(executionRequest, delegationContext) {
        return (0, shared_js_1.transformExecutionRequest)(executionRequest, this.config, delegationContext.transformedSchema, delegationContext.subschemaConfig?.batch, schemaMinBlockMap.get(delegationContext.subschema));
    }
    transformResult(originalResult, delegationContext) {
        const newBlockNumber = (0, shared_js_1.getNewBlockNumberFromExecutionResult)(originalResult, this.config);
        if (newBlockNumber != null) {
            const existingMinBlock = schemaMinBlockMap.get(delegationContext.subschema);
            if (existingMinBlock == null || newBlockNumber > existingMinBlock) {
                schemaMinBlockMap.set(delegationContext.subschema, newBlockNumber);
            }
        }
        return originalResult;
    }
}
exports.BlockTrackingTransform = BlockTrackingTransform;
