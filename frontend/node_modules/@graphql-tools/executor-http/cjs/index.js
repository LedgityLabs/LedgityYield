"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isLiveQueryOperationDefinitionNode = exports.buildHTTPExecutor = void 0;
const value_or_promise_1 = require("value-or-promise");
const utils_1 = require("@graphql-tools/utils");
const fetch_1 = require("@whatwg-node/fetch");
const createFormDataFromVariables_js_1 = require("./createFormDataFromVariables.js");
const defaultPrintFn_js_1 = require("./defaultPrintFn.js");
const handleEventStreamResponse_js_1 = require("./handleEventStreamResponse.js");
const handleMultipartMixedResponse_js_1 = require("./handleMultipartMixedResponse.js");
const isLiveQueryOperationDefinitionNode_js_1 = require("./isLiveQueryOperationDefinitionNode.js");
Object.defineProperty(exports, "isLiveQueryOperationDefinitionNode", { enumerable: true, get: function () { return isLiveQueryOperationDefinitionNode_js_1.isLiveQueryOperationDefinitionNode; } });
const prepareGETUrl_js_1 = require("./prepareGETUrl.js");
function buildHTTPExecutor(options) {
    const printFn = options?.print ?? defaultPrintFn_js_1.defaultPrintFn;
    let disposeCtrl;
    const baseExecutor = (request) => {
        if (disposeCtrl?.signal.aborted) {
            return createResultForAbort(disposeCtrl.signal);
        }
        const fetchFn = request.extensions?.fetch ?? options?.fetch ?? fetch_1.fetch;
        let method = request.extensions?.method || options?.method;
        const operationAst = (0, utils_1.getOperationASTFromRequest)(request);
        const operationType = operationAst.operation;
        if ((options?.useGETForQueries || request.extensions?.useGETForQueries) &&
            operationType === 'query') {
            method = 'GET';
        }
        let accept = 'application/graphql-response+json, application/json, multipart/mixed';
        if (operationType === 'subscription' || (0, isLiveQueryOperationDefinitionNode_js_1.isLiveQueryOperationDefinitionNode)(operationAst)) {
            method ||= 'GET';
            accept = 'text/event-stream';
        }
        else {
            method ||= 'POST';
        }
        const endpoint = request.extensions?.endpoint || options?.endpoint || '/graphql';
        const headers = { accept };
        if (options?.headers) {
            Object.assign(headers, typeof options?.headers === 'function' ? options.headers(request) : options?.headers);
        }
        if (request.extensions?.headers) {
            const { headers: headersFromExtensions, ...restExtensions } = request.extensions;
            Object.assign(headers, headersFromExtensions);
            request.extensions = restExtensions;
        }
        const query = printFn(request.document);
        let signal = disposeCtrl?.signal;
        let clearTimeoutFn = () => { };
        if (options?.timeout) {
            const timeoutCtrl = new AbortController();
            signal = timeoutCtrl.signal;
            disposeCtrl?.signal.addEventListener('abort', clearTimeoutFn);
            const timeoutId = setTimeout(() => {
                if (!timeoutCtrl.signal.aborted) {
                    timeoutCtrl.abort('timeout');
                }
                disposeCtrl?.signal.removeEventListener('abort', clearTimeoutFn);
            }, options.timeout);
            clearTimeoutFn = () => {
                clearTimeout(timeoutId);
            };
        }
        const upstreamErrorExtensions = {
            request: {
                method,
            },
            response: {},
        };
        return new value_or_promise_1.ValueOrPromise(() => {
            switch (method) {
                case 'GET': {
                    const finalUrl = (0, prepareGETUrl_js_1.prepareGETUrl)({
                        baseUrl: endpoint,
                        query,
                        variables: request.variables,
                        operationName: request.operationName,
                        extensions: request.extensions,
                    });
                    const fetchOptions = {
                        method: 'GET',
                        headers,
                        signal,
                    };
                    if (options?.credentials != null) {
                        fetchOptions.credentials = options.credentials;
                    }
                    upstreamErrorExtensions.request.url = finalUrl;
                    return fetchFn(finalUrl, fetchOptions, request.context, request.info);
                }
                case 'POST': {
                    const body = {
                        query,
                        variables: request.variables,
                        operationName: request.operationName,
                        extensions: request.extensions,
                    };
                    upstreamErrorExtensions.request.body = body;
                    return new value_or_promise_1.ValueOrPromise(() => (0, createFormDataFromVariables_js_1.createFormDataFromVariables)(body, {
                        File: options?.File,
                        FormData: options?.FormData,
                    }))
                        .then(body => {
                        if (typeof body === 'string' && !headers['content-type']) {
                            upstreamErrorExtensions.request.body = body;
                            headers['content-type'] = 'application/json';
                        }
                        const fetchOptions = {
                            method: 'POST',
                            body,
                            headers,
                            signal,
                        };
                        if (options?.credentials != null) {
                            fetchOptions.credentials = options.credentials;
                        }
                        return fetchFn(endpoint, fetchOptions, request.context, request.info);
                    })
                        .resolve();
                }
            }
        })
            .then((fetchResult) => {
            upstreamErrorExtensions.response.status = fetchResult.status;
            upstreamErrorExtensions.response.statusText = fetchResult.statusText;
            Object.defineProperty(upstreamErrorExtensions.response, 'headers', {
                get() {
                    return Object.fromEntries(fetchResult.headers.entries());
                },
            });
            clearTimeoutFn();
            // Retry should respect HTTP Errors
            if (options?.retry != null && !fetchResult.status.toString().startsWith('2')) {
                throw new Error(fetchResult.statusText || `Upstream HTTP Error: ${fetchResult.status}`);
            }
            const contentType = fetchResult.headers.get('content-type');
            if (contentType?.includes('text/event-stream')) {
                return (0, handleEventStreamResponse_js_1.handleEventStreamResponse)(fetchResult);
            }
            else if (contentType?.includes('multipart/mixed')) {
                return (0, handleMultipartMixedResponse_js_1.handleMultipartMixedResponse)(fetchResult);
            }
            return fetchResult.text();
        })
            .then(result => {
            if (typeof result === 'string') {
                upstreamErrorExtensions.response.body = result;
                if (result) {
                    try {
                        const parsedResult = JSON.parse(result);
                        upstreamErrorExtensions.response.body = parsedResult;
                        if (parsedResult.data == null &&
                            (parsedResult.errors == null || parsedResult.errors.length === 0)) {
                            return {
                                errors: [
                                    (0, utils_1.createGraphQLError)('Unexpected empty "data" and "errors" fields in result: ' + result, {
                                        extensions: upstreamErrorExtensions,
                                    }),
                                ],
                            };
                        }
                        if (Array.isArray(parsedResult.errors)) {
                            return {
                                ...parsedResult,
                                errors: parsedResult.errors.map(({ message, ...options }) => (0, utils_1.createGraphQLError)(message, {
                                    ...options,
                                    extensions: {
                                        code: 'DOWNSTREAM_SERVICE_ERROR',
                                        ...(options.extensions || {}),
                                    },
                                })),
                            };
                        }
                        return parsedResult;
                    }
                    catch (e) {
                        return {
                            errors: [
                                (0, utils_1.createGraphQLError)(`Unexpected response: ${JSON.stringify(result)}`, {
                                    extensions: upstreamErrorExtensions,
                                    originalError: e,
                                }),
                            ],
                        };
                    }
                }
            }
            else {
                return result;
            }
        })
            .catch((e) => {
            if (e.name === 'AggregateError') {
                return {
                    errors: e.errors.map((e) => coerceFetchError(e, {
                        signal,
                        endpoint,
                        upstreamErrorExtensions,
                    })),
                };
            }
            return {
                errors: [
                    coerceFetchError(e, {
                        signal,
                        endpoint,
                        upstreamErrorExtensions,
                    }),
                ],
            };
        })
            .resolve();
    };
    let executor = baseExecutor;
    if (options?.retry != null) {
        executor = function retryExecutor(request) {
            let result;
            let attempt = 0;
            function retryAttempt() {
                if (disposeCtrl?.signal.aborted) {
                    return createResultForAbort(disposeCtrl.signal);
                }
                attempt++;
                if (attempt > options.retry) {
                    if (result != null) {
                        return result;
                    }
                    return {
                        errors: [(0, utils_1.createGraphQLError)('No response returned from fetch')],
                    };
                }
                return new value_or_promise_1.ValueOrPromise(() => baseExecutor(request))
                    .then(res => {
                    result = res;
                    if (result?.errors?.length) {
                        return retryAttempt();
                    }
                    return result;
                })
                    .resolve();
            }
            return retryAttempt();
        };
    }
    if (!options?.disposable) {
        disposeCtrl = undefined;
        return executor;
    }
    disposeCtrl = new AbortController();
    Object.defineProperties(executor, {
        [Symbol.dispose]: {
            get() {
                return function dispose() {
                    return disposeCtrl.abort(createAbortErrorReason());
                };
            },
        },
        [Symbol.asyncDispose]: {
            get() {
                return function asyncDispose() {
                    return disposeCtrl.abort(createAbortErrorReason());
                };
            },
        },
    });
    return executor;
}
exports.buildHTTPExecutor = buildHTTPExecutor;
function coerceFetchError(e, { signal, endpoint, upstreamErrorExtensions, }) {
    if (typeof e === 'string') {
        return (0, utils_1.createGraphQLError)(e, {
            extensions: upstreamErrorExtensions,
        });
    }
    else if (e.name === 'GraphQLError') {
        return e;
    }
    else if (e.name === 'TypeError' && e.message === 'fetch failed') {
        return (0, utils_1.createGraphQLError)(`fetch failed to ${endpoint}`, {
            extensions: upstreamErrorExtensions,
            originalError: e,
        });
    }
    else if (e.name === 'AbortError' && signal?.reason) {
        return createGraphQLErrorForAbort(signal, {
            extensions: upstreamErrorExtensions,
        });
    }
    else if (e.message) {
        return (0, utils_1.createGraphQLError)(e.message, {
            extensions: upstreamErrorExtensions,
            originalError: e,
        });
    }
    else {
        return (0, utils_1.createGraphQLError)('Unknown error', {
            extensions: upstreamErrorExtensions,
            originalError: e,
        });
    }
}
function createAbortErrorReason() {
    return new Error('Executor was disposed.');
}
function createGraphQLErrorForAbort(signal, extensions) {
    return (0, utils_1.createGraphQLError)('The operation was aborted. reason: ' + signal.reason, {
        extensions,
    });
}
function createResultForAbort(signal, extensions) {
    return {
        errors: [createGraphQLErrorForAbort(signal, extensions)],
    };
}
