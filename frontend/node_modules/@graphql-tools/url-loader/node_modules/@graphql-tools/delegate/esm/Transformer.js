import { checkResultAndHandleErrors } from './checkResultAndHandleErrors.js';
import { finalizeGatewayRequest } from './finalizeGatewayRequest.js';
import { prepareGatewayDocument } from './prepareGatewayDocument.js';
export class Transformer {
    transformations = [];
    delegationContext;
    hasOverlappingAliases = false;
    constructor(context) {
        this.delegationContext = context;
        const transforms = context.transforms;
        const delegationTransforms = transforms.slice().reverse();
        for (const transform of delegationTransforms) {
            this.addTransform(transform);
        }
    }
    addTransform(transform, context = {}) {
        this.transformations.push({ transform, context });
    }
    transformRequest(originalRequest) {
        let request = {
            ...originalRequest,
            document: prepareGatewayDocument(originalRequest.document, this.delegationContext.transformedSchema, this.delegationContext.returnType, this.delegationContext.info?.schema),
        };
        for (const transformation of this.transformations) {
            if (transformation.transform.transformRequest) {
                request = transformation.transform.transformRequest(request, this.delegationContext, transformation.context);
            }
        }
        return finalizeGatewayRequest(request, this.delegationContext, () => {
            this.hasOverlappingAliases = true;
        });
    }
    transformResult(originalResult) {
        let result = originalResult;
        // from right to left
        for (let i = this.transformations.length - 1; i >= 0; i--) {
            const transformation = this.transformations[i];
            if (transformation.transform.transformResult) {
                result = transformation.transform.transformResult(result, this.delegationContext, transformation.context);
            }
        }
        if (this.hasOverlappingAliases) {
            result = removeOverlappingAliases(result);
        }
        return checkResultAndHandleErrors(result, this.delegationContext);
    }
}
function removeOverlappingAliases(result) {
    if (result != null) {
        if (Array.isArray(result)) {
            return result.map(removeOverlappingAliases);
        }
        else if (typeof result === 'object') {
            const newResult = {};
            for (const key in result) {
                if (key.startsWith('_nullable_') || key.startsWith('_nonNullable_')) {
                    const newKey = key.replace(/^_nullable_/, '').replace(/^_nonNullable_/, '');
                    newResult[newKey] = removeOverlappingAliases(result[key]);
                }
                else {
                    newResult[key] = removeOverlappingAliases(result[key]);
                }
            }
            return newResult;
        }
    }
    return result;
}
