{"version":3,"file":"profile.js","sourceRoot":"","sources":["../../../../src/testing/internal/profile/profile.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from \"react\";\n\nimport { TextEncoder, TextDecoder } from \"util\";\n\nglobal.TextEncoder ??= TextEncoder;\n// @ts-ignore\nglobal.TextDecoder ??= TextDecoder;\nimport type { Render, BaseRender } from \"./Render.js\";\nimport { RenderInstance } from \"./Render.js\";\nimport { applyStackTrace, captureStackTrace } from \"./traces.js\";\nimport type { ProfilerContextValue } from \"./context.js\";\nimport { ProfilerContextProvider, useProfilerContext } from \"./context.js\";\nimport { disableActWarnings } from \"../disposables/index.js\";\n\ntype ValidSnapshot = void | (object & { /* not a function */ call?: never });\n\n/** only used for passing around data internally */\nconst _stackTrace = Symbol();\n/** @internal */\nexport interface NextRenderOptions {\n  timeout?: number;\n  [_stackTrace]?: string;\n}\n\n/** @internal */\ninterface ProfilerProps {\n  children: React.ReactNode;\n}\n\n/** @internal */\nexport interface Profiler<Snapshot>\n  extends React.FC<ProfilerProps>,\n    ProfiledComponentFields<Snapshot>,\n    ProfiledComponentOnlyFields<Snapshot> {}\n\ninterface ReplaceSnapshot<Snapshot> {\n  (newSnapshot: Snapshot): void;\n  (updateSnapshot: (lastSnapshot: Readonly<Snapshot>) => Snapshot): void;\n}\n\ninterface MergeSnapshot<Snapshot> {\n  (partialSnapshot: Partial<Snapshot>): void;\n  (\n    updatePartialSnapshot: (\n      lastSnapshot: Readonly<Snapshot>\n    ) => Partial<Snapshot>\n  ): void;\n}\n\ninterface ProfiledComponentOnlyFields<Snapshot> {\n  // Allows for partial updating of the snapshot by shallow merging the results\n  mergeSnapshot: MergeSnapshot<Snapshot>;\n  // Performs a full replacement of the snapshot\n  replaceSnapshot: ReplaceSnapshot<Snapshot>;\n}\ninterface ProfiledComponentFields<Snapshot> {\n  /**\n   * An array of all renders that have happened so far.\n   * Errors thrown during component render will be captured here, too.\n   */\n  renders: Array<\n    Render<Snapshot> | { phase: \"snapshotError\"; count: number; error: unknown }\n  >;\n  /**\n   * Peeks the next render from the current iterator position, without advancing the iterator.\n   * If no render has happened yet, it will wait for the next render to happen.\n   * @throws {WaitForRenderTimeoutError} if no render happens within the timeout\n   */\n  peekRender(options?: NextRenderOptions): Promise<Render<Snapshot>>;\n  /**\n   * Iterates to the next render and returns it.\n   * If no render has happened yet, it will wait for the next render to happen.\n   * @throws {WaitForRenderTimeoutError} if no render happens within the timeout\n   */\n  takeRender(options?: NextRenderOptions): Promise<Render<Snapshot>>;\n  /**\n   * Returns the total number of renders.\n   */\n  totalRenderCount(): number;\n  /**\n   * Returns the current render.\n   * @throws {Error} if no render has happened yet\n   */\n  getCurrentRender(): Render<Snapshot>;\n  /**\n   * Waits for the next render to happen.\n   * Does not advance the render iterator.\n   */\n  waitForNextRender(options?: NextRenderOptions): Promise<Render<Snapshot>>;\n}\n\nexport interface ProfiledComponent<Snapshot extends ValidSnapshot, Props = {}>\n  extends React.FC<Props>,\n    ProfiledComponentFields<Snapshot>,\n    ProfiledComponentOnlyFields<Snapshot> {}\n\n/** @internal */\nexport function profile<Snapshot extends ValidSnapshot = void, Props = {}>({\n  Component,\n  ...options\n}: Parameters<typeof createProfiler<Snapshot>>[0] & {\n  Component: React.ComponentType<Props>;\n}): ProfiledComponent<Snapshot, Props> {\n  const Profiler = createProfiler(options);\n\n  return Object.assign(\n    function ProfiledComponent(props: Props) {\n      return (\n        <Profiler>\n          <Component {...(props as any)} />\n        </Profiler>\n      );\n    },\n    {\n      mergeSnapshot: Profiler.mergeSnapshot,\n      replaceSnapshot: Profiler.replaceSnapshot,\n      getCurrentRender: Profiler.getCurrentRender,\n      peekRender: Profiler.peekRender,\n      takeRender: Profiler.takeRender,\n      totalRenderCount: Profiler.totalRenderCount,\n      waitForNextRender: Profiler.waitForNextRender,\n      get renders() {\n        return Profiler.renders;\n      },\n    }\n  );\n}\n\n/** @internal */\nexport function createProfiler<Snapshot extends ValidSnapshot = void>({\n  onRender,\n  snapshotDOM = false,\n  initialSnapshot,\n  skipNonTrackingRenders,\n}: {\n  onRender?: (\n    info: BaseRender & {\n      snapshot: Snapshot;\n      replaceSnapshot: ReplaceSnapshot<Snapshot>;\n      mergeSnapshot: MergeSnapshot<Snapshot>;\n    }\n  ) => void;\n  snapshotDOM?: boolean;\n  initialSnapshot?: Snapshot;\n  /**\n   * This will skip renders during which no renders tracked by\n   * `useTrackRenders` occured.\n   */\n  skipNonTrackingRenders?: boolean;\n} = {}) {\n  let nextRender: Promise<Render<Snapshot>> | undefined;\n  let resolveNextRender: ((render: Render<Snapshot>) => void) | undefined;\n  let rejectNextRender: ((error: unknown) => void) | undefined;\n  function resetNextRender() {\n    nextRender = resolveNextRender = rejectNextRender = undefined;\n  }\n  const snapshotRef = { current: initialSnapshot };\n  const replaceSnapshot: ReplaceSnapshot<Snapshot> = (snap) => {\n    if (typeof snap === \"function\") {\n      if (!initialSnapshot) {\n        throw new Error(\n          \"Cannot use a function to update the snapshot if no initial snapshot was provided.\"\n        );\n      }\n      snapshotRef.current = snap(\n        typeof snapshotRef.current === \"object\" ?\n          // \"cheap best effort\" to prevent accidental mutation of the last snapshot\n          { ...snapshotRef.current! }\n        : snapshotRef.current!\n      );\n    } else {\n      snapshotRef.current = snap;\n    }\n  };\n\n  const mergeSnapshot: MergeSnapshot<Snapshot> = (partialSnapshot) => {\n    replaceSnapshot((snapshot) => ({\n      ...snapshot,\n      ...(typeof partialSnapshot === \"function\" ?\n        partialSnapshot(snapshot)\n      : partialSnapshot),\n    }));\n  };\n\n  const profilerContext: ProfilerContextValue = {\n    renderedComponents: [],\n  };\n\n  const profilerOnRender: React.ProfilerOnRenderCallback = (\n    id,\n    phase,\n    actualDuration,\n    baseDuration,\n    startTime,\n    commitTime\n  ) => {\n    if (\n      skipNonTrackingRenders &&\n      profilerContext.renderedComponents.length === 0\n    ) {\n      return;\n    }\n    const baseRender = {\n      id,\n      phase,\n      actualDuration,\n      baseDuration,\n      startTime,\n      commitTime,\n      count: Profiler.renders.length + 1,\n    };\n    try {\n      /*\n       * The `onRender` function could contain `expect` calls that throw\n       * `JestAssertionError`s - but we are still inside of React, where errors\n       * might be swallowed.\n       * So we record them and re-throw them in `takeRender`\n       * Additionally, we reject the `waitForNextRender` promise.\n       */\n      onRender?.({\n        ...baseRender,\n        replaceSnapshot,\n        mergeSnapshot,\n        snapshot: snapshotRef.current!,\n      });\n\n      const snapshot = snapshotRef.current as Snapshot;\n      const domSnapshot =\n        snapshotDOM ? window.document.body.innerHTML : undefined;\n      const render = new RenderInstance(\n        baseRender,\n        snapshot,\n        domSnapshot,\n        profilerContext.renderedComponents\n      );\n      profilerContext.renderedComponents = [];\n      Profiler.renders.push(render);\n      resolveNextRender?.(render);\n    } catch (error) {\n      Profiler.renders.push({\n        phase: \"snapshotError\",\n        count: Profiler.renders.length,\n        error,\n      });\n      rejectNextRender?.(error);\n    } finally {\n      resetNextRender();\n    }\n  };\n\n  let iteratorPosition = 0;\n  const Profiler: Profiler<Snapshot> = Object.assign(\n    ({ children }: ProfilerProps) => {\n      return (\n        <ProfilerContextProvider value={profilerContext}>\n          <React.Profiler id=\"test\" onRender={profilerOnRender}>\n            {children}\n          </React.Profiler>\n        </ProfilerContextProvider>\n      );\n    },\n    {\n      replaceSnapshot,\n      mergeSnapshot,\n    } satisfies ProfiledComponentOnlyFields<Snapshot>,\n    {\n      renders: new Array<\n        | Render<Snapshot>\n        | { phase: \"snapshotError\"; count: number; error: unknown }\n      >(),\n      totalRenderCount() {\n        return Profiler.renders.length;\n      },\n      async peekRender(options: NextRenderOptions = {}) {\n        if (iteratorPosition < Profiler.renders.length) {\n          const render = Profiler.renders[iteratorPosition];\n\n          if (render.phase === \"snapshotError\") {\n            throw render.error;\n          }\n\n          return render;\n        }\n        return Profiler.waitForNextRender({\n          [_stackTrace]: captureStackTrace(Profiler.peekRender),\n          ...options,\n        });\n      },\n      async takeRender(options: NextRenderOptions = {}) {\n        // In many cases we do not control the resolution of the suspended\n        // promise which results in noisy tests when the profiler due to\n        // repeated act warnings.\n        using _disabledActWarnings = disableActWarnings();\n\n        let error: unknown = undefined;\n\n        try {\n          return await Profiler.peekRender({\n            [_stackTrace]: captureStackTrace(Profiler.takeRender),\n            ...options,\n          });\n        } catch (e) {\n          error = e;\n          throw e;\n        } finally {\n          if (!(error && error instanceof WaitForRenderTimeoutError)) {\n            iteratorPosition++;\n          }\n        }\n      },\n      getCurrentRender() {\n        // The \"current\" render should point at the same render that the most\n        // recent `takeRender` call returned, so we need to get the \"previous\"\n        // iterator position, otherwise `takeRender` advances the iterator\n        // to the next render. This means we need to call `takeRender` at least\n        // once before we can get a current render.\n        const currentPosition = iteratorPosition - 1;\n\n        if (currentPosition < 0) {\n          throw new Error(\n            \"No current render available. You need to call `takeRender` before you can get the current render.\"\n          );\n        }\n\n        const render = Profiler.renders[currentPosition];\n\n        if (render.phase === \"snapshotError\") {\n          throw render.error;\n        }\n        return render;\n      },\n      waitForNextRender({\n        timeout = 1000,\n        // capture the stack trace here so its stack trace is as close to the calling code as possible\n        [_stackTrace]: stackTrace = captureStackTrace(\n          Profiler.waitForNextRender\n        ),\n      }: NextRenderOptions = {}) {\n        if (!nextRender) {\n          nextRender = Promise.race<Render<Snapshot>>([\n            new Promise<Render<Snapshot>>((resolve, reject) => {\n              resolveNextRender = resolve;\n              rejectNextRender = reject;\n            }),\n            new Promise<Render<Snapshot>>((_, reject) =>\n              setTimeout(() => {\n                reject(\n                  applyStackTrace(new WaitForRenderTimeoutError(), stackTrace)\n                );\n                resetNextRender();\n              }, timeout)\n            ),\n          ]);\n        }\n        return nextRender;\n      },\n    } satisfies ProfiledComponentFields<Snapshot>\n  );\n  return Profiler;\n}\n\n/** @internal */\nexport class WaitForRenderTimeoutError extends Error {\n  constructor() {\n    super(\"Exceeded timeout waiting for next render.\");\n    Object.setPrototypeOf(this, new.target.prototype);\n  }\n}\n\ntype StringReplaceRenderWithSnapshot<T extends string> =\n  T extends `${infer Pre}Render${infer Post}` ? `${Pre}Snapshot${Post}` : T;\n\ntype ResultReplaceRenderWithSnapshot<T> =\n  T extends (...args: infer Args) => Render<infer Snapshot> ?\n    (...args: Args) => Snapshot\n  : T extends (...args: infer Args) => Promise<Render<infer Snapshot>> ?\n    (...args: Args) => Promise<Snapshot>\n  : T;\n\ntype ProfiledHookFields<ReturnValue> =\n  ProfiledComponentFields<ReturnValue> extends infer PC ?\n    {\n      [K in keyof PC as StringReplaceRenderWithSnapshot<\n        K & string\n      >]: ResultReplaceRenderWithSnapshot<PC[K]>;\n    }\n  : never;\n\n/** @internal */\nexport interface ProfiledHook<Props, ReturnValue>\n  extends React.FC<Props>,\n    ProfiledHookFields<ReturnValue> {\n  Profiler: Profiler<ReturnValue>;\n}\n\n/** @internal */\nexport function profileHook<ReturnValue extends ValidSnapshot, Props>(\n  renderCallback: (props: Props) => ReturnValue\n): ProfiledHook<Props, ReturnValue> {\n  const Profiler = createProfiler<ReturnValue>();\n\n  const ProfiledHook = (props: Props) => {\n    Profiler.replaceSnapshot(renderCallback(props));\n    return null;\n  };\n\n  return Object.assign(\n    function App(props: Props) {\n      return (\n        <Profiler>\n          <ProfiledHook {...(props as any)} />\n        </Profiler>\n      );\n    },\n    {\n      Profiler,\n    },\n    {\n      renders: Profiler.renders,\n      totalSnapshotCount: Profiler.totalRenderCount,\n      async peekSnapshot(options) {\n        return (await Profiler.peekRender(options)).snapshot;\n      },\n      async takeSnapshot(options) {\n        return (await Profiler.takeRender(options)).snapshot;\n      },\n      getCurrentSnapshot() {\n        return Profiler.getCurrentRender().snapshot;\n      },\n      async waitForNextSnapshot(options) {\n        return (await Profiler.waitForNextRender(options)).snapshot;\n      },\n    } satisfies ProfiledHookFields<ReturnValue>\n  );\n}\n\nfunction resolveR18HookOwner(): React.ComponentType | undefined {\n  return (React as any).__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED\n    ?.ReactCurrentOwner?.current?.elementType;\n}\n\nfunction resolveR19HookOwner(): React.ComponentType | undefined {\n  return (\n    React as any\n  ).__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE?.A?.getOwner()\n    .elementType;\n}\n\nexport function useTrackRenders({ name }: { name?: string } = {}) {\n  const component = name || resolveR18HookOwner() || resolveR19HookOwner();\n\n  if (!component) {\n    throw new Error(\n      \"useTrackRender: Unable to determine component. Please ensure the hook is called inside a rendered component or provide a `name` option.\"\n    );\n  }\n\n  const ctx = useProfilerContext();\n\n  if (!ctx) {\n    throw new Error(\n      \"useTrackComponentRender: A Profiler must be created and rendered to track component renders\"\n    );\n  }\n\n  React.useLayoutEffect(() => {\n    ctx.renderedComponents.unshift(component);\n  });\n}\n"]}