"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateTsArtifacts = generateTsArtifacts;
exports.compileTS = compileTS;
const tslib_1 = require("tslib");
const graphql_1 = require("graphql");
const json5_1 = tslib_1.__importDefault(require("json5"));
const pascal_case_1 = require("pascal-case");
const typescript_1 = tslib_1.__importDefault(require("typescript"));
const core_1 = require("@graphql-codegen/core");
const typedDocumentNodePlugin = tslib_1.__importStar(require("@graphql-codegen/typed-document-node"));
const tsBasePlugin = tslib_1.__importStar(require("@graphql-codegen/typescript"));
const typescriptGenericSdk = tslib_1.__importStar(require("@graphql-codegen/typescript-generic-sdk"));
const tsOperationsPlugin = tslib_1.__importStar(require("@graphql-codegen/typescript-operations"));
const tsResolversPlugin = tslib_1.__importStar(require("@graphql-codegen/typescript-resolvers"));
const cross_helpers_1 = require("@graphql-mesh/cross-helpers");
const utils_1 = require("@graphql-mesh/utils");
const utils_2 = require("@graphql-tools/utils");
const generate_operations_js_1 = require("./generate-operations.js");
const unifiedContextIdentifier = 'MeshContext';
class CodegenHelpers extends tsBasePlugin.TsVisitor {
    getTypeToUse(namedType, isVisitingInputType) {
        if (this.scalars[namedType.name.value]) {
            return this._getScalar(namedType.name.value, isVisitingInputType ? 'input' : 'output');
        }
        return this._getTypeForNode(namedType, isVisitingInputType);
    }
}
function buildSignatureBasedOnRootFields(codegenHelpers, type, schema) {
    if (!type) {
        return {};
    }
    const fields = type.getFields();
    const operationMap = {};
    for (const fieldName in fields) {
        const field = fields[fieldName];
        const argsExists = field.args && field.args.length > 0;
        const argsName = argsExists ? `${type.name}${field.name}Args` : '{}';
        const parentTypeNode = {
            kind: graphql_1.Kind.NAMED_TYPE,
            name: {
                kind: graphql_1.Kind.NAME,
                value: type.name,
            },
        };
        const namedFieldType = (0, graphql_1.getNamedType)(field.type);
        if ((0, graphql_1.isAbstractType)(namedFieldType)) {
            const possibleTypes = schema.getPossibleTypes(namedFieldType);
            const typeNamesDef = possibleTypes
                .map(possibleType => codegenHelpers.getTypeToUse({
                kind: graphql_1.Kind.NAMED_TYPE,
                name: {
                    kind: graphql_1.Kind.NAME,
                    value: possibleType.name,
                },
            }, false))
                .join(' | ');
            const originalDef = field.type.toString();
            const def = originalDef.replace(namedFieldType.name, typeNamesDef);
            operationMap[fieldName] = `  /** ${field.description} **/\n  ${field.name}: InContextSdkMethod<${def}, ${argsName}, ${unifiedContextIdentifier}>`;
        }
        else {
            operationMap[fieldName] = `  /** ${field.description} **/\n  ${field.name}: InContextSdkMethod<${codegenHelpers.getTypeToUse(parentTypeNode, false)}['${fieldName}'], ${argsName}, ${unifiedContextIdentifier}>`;
        }
    }
    return operationMap;
}
async function generateTypesForApi(options) {
    const config = {
        skipTypename: true,
        flattenGeneratedTypes: options.flattenTypes,
        onlyOperationTypes: options.flattenTypes,
        preResolveTypes: options.flattenTypes,
        namingConvention: 'keep',
        enumsAsTypes: true,
        ignoreEnumValuesFromSchema: true,
        useIndexSignature: true,
        ...options.codegenConfig,
    };
    const baseTypes = await (0, core_1.codegen)({
        filename: options.name + '_types.ts',
        documents: [],
        config,
        schemaAst: options.schema,
        schema: undefined, // This is not necessary on codegen. Will be removed later
        skipDocumentsValidation: true,
        plugins: [
            {
                typescript: {},
            },
        ],
        pluginMap: {
            typescript: tsBasePlugin,
        },
    });
    const codegenHelpers = new CodegenHelpers(options.schema, config, {});
    const namespace = (0, pascal_case_1.pascalCase)(`${options.name}Types`);
    const queryOperationMap = buildSignatureBasedOnRootFields(codegenHelpers, options.schema.getQueryType(), options.schema);
    const mutationOperationMap = buildSignatureBasedOnRootFields(codegenHelpers, options.schema.getMutationType(), options.schema);
    const subscriptionsOperationMap = buildSignatureBasedOnRootFields(codegenHelpers, options.schema.getSubscriptionType(), options.schema);
    const codeAst = `
import { InContextSdkMethod } from '@graphql-mesh/types';
import { MeshContext } from '@graphql-mesh/runtime';

export namespace ${namespace} {
  ${baseTypes}
  export type QuerySdk = {
    ${Object.values(queryOperationMap).join(',\n')}
  };

  export type MutationSdk = {
    ${Object.values(mutationOperationMap).join(',\n')}
  };

  export type SubscriptionSdk = {
    ${Object.values(subscriptionsOperationMap).join(',\n')}
  };

  export type Context = {
      [${JSON.stringify(options.name)}]: { Query: QuerySdk, Mutation: MutationSdk, Subscription: SubscriptionSdk },
      ${Object.keys(options.contextVariables)
        .map(key => `[${JSON.stringify(key)}]: ${options.contextVariables[key]}`)
        .join(',\n')}
    };
}
`;
    return {
        identifier: namespace,
        codeAst,
    };
}
const BASEDIR_ASSIGNMENT_COMMENT = `/* BASEDIR_ASSIGNMENT */`;
async function generateTsArtifacts({ unifiedSchema, rawSources, mergerType = 'stitching', documents, flattenTypes, importedModulesSet, baseDir, meshConfigImportCodes, meshConfigCodes, logger, sdkConfig, fileType, codegenConfig = {}, pollingInterval, }, cliParams) {
    const artifactsDir = cross_helpers_1.path.join(baseDir, cliParams.artifactsDir);
    logger.info('Generating index file in TypeScript');
    for (const rawSource of rawSources) {
        const transformedSchema = unifiedSchema.extensions.sourceMap.get(rawSource);
        const sdl = (0, utils_2.printSchemaWithDirectives)(transformedSchema);
        await (0, utils_1.writeFile)(cross_helpers_1.path.join(artifactsDir, `sources/${rawSource.name}/schema.graphql`), sdl);
    }
    const documentsInput = sdkConfig?.generateOperations
        ? (0, generate_operations_js_1.generateOperations)(unifiedSchema, sdkConfig.generateOperations)
        : documents;
    const pluginsInput = [
        {
            typescript: {},
        },
        {
            resolvers: {},
        },
        {
            contextSdk: {},
        },
    ];
    if (documentsInput.length) {
        pluginsInput.push({
            typescriptOperations: {},
        }, {
            typedDocumentNode: {},
        }, {
            typescriptGenericSdk: {
                documentMode: 'external',
                importDocumentNodeExternallyFrom: 'NOWHERE',
            },
        });
        const documentHashMap = {};
        for (const document of documentsInput) {
            if (document.sha256Hash) {
                documentHashMap[document.sha256Hash] = document.rawSDL || (0, utils_1.printWithCache)(document.document);
            }
        }
        await (0, utils_1.writeFile)(cross_helpers_1.path.join(artifactsDir, `persisted_operations.json`), JSON.stringify(documentHashMap, null, 2));
    }
    const codegenOutput = '// @ts-nocheck\n' +
        (await (0, core_1.codegen)({
            filename: 'types.ts',
            documents: documentsInput,
            config: {
                skipTypename: true,
                flattenGeneratedTypes: flattenTypes,
                onlyOperationTypes: flattenTypes,
                preResolveTypes: flattenTypes,
                namingConvention: 'keep',
                documentMode: 'graphQLTag',
                gqlImport: '@graphql-mesh/utils#gql',
                enumsAsTypes: true,
                ignoreEnumValuesFromSchema: true,
                useIndexSignature: true,
                noSchemaStitching: false,
                contextType: unifiedContextIdentifier,
                federation: mergerType === 'federation',
                ...codegenConfig,
            },
            schemaAst: unifiedSchema,
            schema: undefined, // This is not necessary on codegen.
            // skipDocumentsValidation: true,
            pluginMap: {
                typescript: tsBasePlugin,
                typescriptOperations: tsOperationsPlugin,
                typedDocumentNode: typedDocumentNodePlugin,
                typescriptGenericSdk,
                resolvers: tsResolversPlugin,
                contextSdk: {
                    plugin: async () => {
                        const importCodes = new Set([
                            ...meshConfigImportCodes,
                            `import { getMesh, ExecuteMeshFn, SubscribeMeshFn, MeshContext as BaseMeshContext, MeshInstance } from '@graphql-mesh/runtime';`,
                            `import { MeshStore, FsStoreStorageAdapter } from '@graphql-mesh/store';`,
                            `import { path as pathModule } from '@graphql-mesh/cross-helpers';`,
                            `import { ImportFn } from '@graphql-mesh/types';`,
                        ]);
                        const results = await Promise.all(rawSources.map(async (source) => {
                            const sourceMap = unifiedSchema.extensions.sourceMap;
                            const sourceSchema = sourceMap.get(source);
                            const { identifier, codeAst } = await generateTypesForApi({
                                schema: sourceSchema,
                                name: source.name,
                                contextVariables: source.contextVariables,
                                flattenTypes,
                                codegenConfig,
                            });
                            if (codeAst) {
                                const content = '// @ts-nocheck\n' + codeAst;
                                await (0, utils_1.writeFile)(cross_helpers_1.path.join(artifactsDir, `sources/${source.name}/types.ts`), content);
                            }
                            if (identifier) {
                                importCodes.add(`import type { ${identifier} } from './sources/${source.name}/types';`);
                            }
                            return {
                                identifier,
                                codeAst,
                            };
                        }));
                        const contextType = `export type ${unifiedContextIdentifier} = ${results
                            .map(r => `${r?.identifier}.Context`)
                            .filter(Boolean)
                            .join(' & ')} & BaseMeshContext;`;
                        let meshMethods = `
${BASEDIR_ASSIGNMENT_COMMENT}

const importFn: ImportFn = <T>(moduleId: string) => {
  const relativeModuleId = (pathModule.isAbsolute(moduleId) ? pathModule.relative(baseDir, moduleId) : moduleId).split('\\\\').join('/').replace(baseDir + '/', '');
  switch(relativeModuleId) {${[...importedModulesSet]
                            .map((importedModuleName, importedModuleIndex) => {
                            const importPathRelativeToBaseDir = cross_helpers_1.path
                                .relative(baseDir, importedModuleName)
                                .split('\\')
                                .join('/');
                            let importPath = importedModuleName;
                            if (importPath.startsWith('.')) {
                                importPath = cross_helpers_1.path.join(baseDir, importPath);
                            }
                            if (cross_helpers_1.path.isAbsolute(importPath)) {
                                importPath = `./${cross_helpers_1.path
                                    .relative(artifactsDir, importedModuleName)
                                    .split('\\')
                                    .join('/')}`;
                                importPath = replaceTypeScriptExtension(importPath);
                            }
                            const importIdentifier = `importedModule$${importedModuleIndex}`;
                            importCodes.add(`import * as ${importIdentifier} from ${JSON.stringify(importPath)};`);
                            return `
    case ${JSON.stringify(importPathRelativeToBaseDir)}:
      return Promise.resolve(${importIdentifier}) as T;
    `;
                        })
                            .join('')}
    default:
      return Promise.reject(new Error(\`Cannot find module '\${relativeModuleId}'.\`));
  }
};

const rootStore = new MeshStore('${cliParams.artifactsDir}', new FsStoreStorageAdapter({
  cwd: baseDir,
  importFn,
  fileType: ${JSON.stringify(fileType)},
}), {
  readonly: ${!pollingInterval},
  validate: false
});

${[...meshConfigCodes].join('\n')}

let meshInstance$: Promise<MeshInstance> | undefined;

export const pollingInterval = ${pollingInterval || null};

export function ${cliParams.builtMeshFactoryName}(): Promise<MeshInstance> {
  if (meshInstance$ == null) {
    if (pollingInterval) {
      setInterval(() => {
        getMeshOptions()
        .then(meshOptions => getMesh(meshOptions))
        .then(newMesh =>
          meshInstance$.then(oldMesh => {
            oldMesh.destroy()
            meshInstance$ = Promise.resolve(newMesh)
          })
        ).catch(err => {
          console.error("Mesh polling failed so the existing version will be used:", err);
        });
      }, pollingInterval)
    }
    meshInstance$ = getMeshOptions().then(meshOptions => getMesh(meshOptions)).then(mesh => {
      const id = mesh.pubsub.subscribe('destroy', () => {
        meshInstance$ = undefined;
        mesh.pubsub.unsubscribe(id);
      });
      return mesh;
    });
  }
  return meshInstance$;
}

export const execute: ExecuteMeshFn = (...args) => ${cliParams.builtMeshFactoryName}().then(({ execute }) => execute(...args));

export const subscribe: SubscribeMeshFn = (...args) => ${cliParams.builtMeshFactoryName}().then(({ subscribe }) => subscribe(...args));`;
                        if (documentsInput.length) {
                            meshMethods += `
export function ${cliParams.builtMeshSDKFactoryName}<TGlobalContext = any, TOperationContext = any>(globalContext?: TGlobalContext) {
  const sdkRequester$ = ${cliParams.builtMeshFactoryName}().then(({ sdkRequesterFactory }) => sdkRequesterFactory(globalContext));
  return getSdk<TOperationContext, TGlobalContext>((...args) => sdkRequester$.then(sdkRequester => sdkRequester(...args)));
}`;
                        }
                        return {
                            prepend: [[...importCodes].join('\n'), '\n\n'],
                            content: [contextType, meshMethods].join('\n\n'),
                        };
                    },
                },
            },
            plugins: pluginsInput,
        }))
            .replace(`import * as Operations from 'NOWHERE';\n`, '')
            .replace(`import { DocumentNode } from 'graphql';`, '')
            .split('(Operations.')
            .join('(');
    const endpointAssignmentESM = `import { fileURLToPath } from '@graphql-mesh/utils';
const baseDir = pathModule.join(pathModule.dirname(fileURLToPath(require('node:url').pathToFileURL(__filename))), '${cross_helpers_1.path.relative(artifactsDir, baseDir)}');`;
    const endpointAssignmentCJS = `const baseDir = pathModule.join(typeof __dirname === 'string' ? __dirname : '/', '${cross_helpers_1.path.relative(artifactsDir, baseDir)}');`;
    const tsFilePath = cross_helpers_1.path.join(artifactsDir, 'index.ts');
    const jobs = [];
    const jsFilePath = cross_helpers_1.path.join(artifactsDir, 'index.js');
    const dtsFilePath = cross_helpers_1.path.join(artifactsDir, 'index.d.ts');
    const esmJob = (ext) => async () => {
        logger.info('Writing index.ts for ESM to the disk.');
        await (0, utils_1.writeFile)(tsFilePath, codegenOutput.replace(BASEDIR_ASSIGNMENT_COMMENT, endpointAssignmentESM));
        const esmJsFilePath = cross_helpers_1.path.join(artifactsDir, `index.${ext}`);
        if (await (0, utils_1.pathExists)(esmJsFilePath)) {
            await cross_helpers_1.fs.promises.unlink(esmJsFilePath);
        }
        if (fileType !== 'ts') {
            logger.info(`Compiling TS file as ES Module to "index.${ext}"`);
            compileTS(tsFilePath, typescript_1.default.ModuleKind.ESNext, [jsFilePath, dtsFilePath]);
            if (ext === 'mjs') {
                const mjsFilePath = cross_helpers_1.path.join(artifactsDir, 'index.mjs');
                await cross_helpers_1.fs.promises.rename(jsFilePath, mjsFilePath);
            }
            logger.info('Deleting index.ts');
            await cross_helpers_1.fs.promises.unlink(tsFilePath);
        }
    };
    const cjsJob = async () => {
        logger.info('Writing index.ts for CJS to the disk.');
        await (0, utils_1.writeFile)(tsFilePath, codegenOutput.replace(BASEDIR_ASSIGNMENT_COMMENT, endpointAssignmentCJS));
        if (await (0, utils_1.pathExists)(jsFilePath)) {
            await cross_helpers_1.fs.promises.unlink(jsFilePath);
        }
        if (fileType !== 'ts') {
            logger.info('Compiling TS file as CommonJS Module to `index.js`');
            compileTS(tsFilePath, typescript_1.default.ModuleKind.CommonJS, [jsFilePath, dtsFilePath]);
            logger.info('Deleting index.ts');
            await cross_helpers_1.fs.promises.unlink(tsFilePath);
        }
    };
    const packageJsonJob = (module) => () => (0, utils_1.writeJSON)(cross_helpers_1.path.join(artifactsDir, 'package.json'), {
        name: 'mesh-artifacts',
        private: true,
        type: module,
        main: 'index.js',
        module: 'index.mjs',
        sideEffects: false,
        typings: 'index.d.ts',
        typescript: {
            definition: 'index.d.ts',
        },
        exports: {
            '.': {
                require: './index.js',
                import: './index.mjs',
            },
            './*': {
                require: './*.js',
                import: './*.mjs',
            },
        },
    });
    function setTsConfigDefault() {
        jobs.push(cjsJob);
        if (fileType !== 'ts') {
            jobs.push(packageJsonJob('commonjs'));
        }
    }
    const rootDir = cross_helpers_1.path.resolve('./');
    const tsConfigPath = cross_helpers_1.path.join(rootDir, 'tsconfig.json');
    const packageJsonPath = cross_helpers_1.path.join(rootDir, 'package.json');
    if (await (0, utils_1.pathExists)(tsConfigPath)) {
        // case tsconfig exists
        const tsConfigStr = await cross_helpers_1.fs.promises.readFile(tsConfigPath, 'utf-8');
        const tsConfig = json5_1.default.parse(tsConfigStr);
        if (tsConfig?.compilerOptions?.module?.toLowerCase()?.startsWith('es')) {
            // case tsconfig set to esm
            jobs.push(esmJob('js'));
            if (fileType !== 'ts') {
                jobs.push(packageJsonJob('module'));
            }
        }
        else if (tsConfig?.compilerOptions?.module?.toLowerCase()?.startsWith('node') &&
            (await (0, utils_1.pathExists)(packageJsonPath))) {
            // case tsconfig set to node* and package.json exists
            const packageJsonStr = await cross_helpers_1.fs.promises.readFile(packageJsonPath, 'utf-8');
            const packageJson = json5_1.default.parse(packageJsonStr);
            if (packageJson?.type === 'module') {
                // case package.json set to esm
                jobs.push(esmJob('js'));
                if (fileType !== 'ts') {
                    jobs.push(packageJsonJob('module'));
                }
            }
            else {
                // case package.json set to cjs or not set
                setTsConfigDefault();
            }
        }
        else {
            // case tsconfig set to cjs or set to node* with no package.json
            setTsConfigDefault();
        }
    }
    else if (await (0, utils_1.pathExists)(packageJsonPath)) {
        // case package.json exists
        const packageJsonStr = await cross_helpers_1.fs.promises.readFile(packageJsonPath, 'utf-8');
        const packageJson = json5_1.default.parse(packageJsonStr);
        if (packageJson?.type === 'module') {
            // case package.json set to esm
            jobs.push(esmJob('js'));
            if (fileType !== 'ts') {
                jobs.push(packageJsonJob('module'));
            }
        }
        else {
            // case package.json set to cjs or not set
            jobs.push(esmJob('mjs'));
            if (fileType === 'js') {
                jobs.push(packageJsonJob('module'));
            }
            else {
                jobs.push(cjsJob);
                jobs.push(packageJsonJob('commonjs'));
            }
        }
    }
    else {
        // case no tsconfig and no package.json
        jobs.push(esmJob('mjs'));
        if (fileType === 'js') {
            jobs.push(packageJsonJob('module'));
        }
        else {
            jobs.push(cjsJob);
            jobs.push(packageJsonJob('commonjs'));
        }
    }
    for (const job of jobs) {
        await job();
    }
}
function compileTS(tsFilePath, module, outputFilePaths) {
    const options = {
        target: typescript_1.default.ScriptTarget.ESNext,
        module,
        sourceMap: false,
        inlineSourceMap: false,
        importHelpers: true,
        allowSyntheticDefaultImports: true,
        esModuleInterop: true,
        declaration: true,
    };
    const host = typescript_1.default.createCompilerHost(options);
    const hostWriteFile = host.writeFile.bind(host);
    host.writeFile = (fileName, ...rest) => {
        if (outputFilePaths.some(f => cross_helpers_1.path.normalize(f) === cross_helpers_1.path.normalize(fileName))) {
            return hostWriteFile(fileName, ...rest);
        }
    };
    // Prepare and emit the d.ts files
    const program = typescript_1.default.createProgram([tsFilePath], options, host);
    program.emit();
}
/**
 * If the specified path corresponds to a TypeScript file, replace
 * its extension to `.js`.
 *
 * @param {string} path The path to a potential TypeScript file
 * @returns {string}
 */
function replaceTypeScriptExtension(path) {
    let modifiedPath = path;
    if (modifiedPath.toLowerCase().endsWith('.ts')) {
        const extensionStart = modifiedPath.lastIndexOf('.');
        modifiedPath = modifiedPath.substring(0, extensionStart).concat('.js');
    }
    return modifiedPath;
}
