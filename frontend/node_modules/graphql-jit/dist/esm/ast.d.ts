import { ArgumentNode, ASTNode, DirectiveNode, FieldNode, GraphQLArgument, GraphQLDirective, GraphQLField, GraphQLInputType, GraphQLObjectType, SelectionSetNode, SourceLocation, ValueNode, VariableNode } from "graphql";
import { CompilationContext } from "./execution";
import { resolveFieldDef } from "./compat";
export interface JitFieldNode extends FieldNode {
    /**
     * @deprecated Use __internalShouldIncludePath instead
     * @see __internalShouldIncludePath
     */
    __internalShouldInclude?: string;
    __internalShouldIncludePath?: {
        [path: string]: string;
    };
}
export interface FieldsAndNodes {
    [key: string]: JitFieldNode[];
}
/**
 * Given a selectionSet, adds all of the fields in that selection to
 * the passed in map of fields, and returns it at the end.
 *
 * CollectFields requires the "runtime type" of an object. For a field which
 * returns an Interface or Union type, the "runtime type" will be the actual
 * Object type returned by that field.
 */
export declare function collectFields(compilationContext: CompilationContext, runtimeType: GraphQLObjectType, selectionSet: SelectionSetNode, fields: FieldsAndNodes, visitedFragmentNames: {
    [key: string]: boolean;
}, parentResponsePath?: ObjectPath): FieldsAndNodes;
export { resolveFieldDef };
export declare function collectSubfields(compilationContext: CompilationContext, returnType: GraphQLObjectType, fieldNodes: FieldNode[], parentResponsePath?: ObjectPath): {
    [key: string]: FieldNode[];
};
type ResponsePathType = "variable" | "literal" | "meta";
export interface ObjectPath {
    prev: ObjectPath | undefined;
    key: string;
    type: ResponsePathType;
}
interface MissingVariablePath {
    valueNode: VariableNode;
    path?: ObjectPath;
    argument?: {
        definition: GraphQLArgument;
        node: ArgumentNode;
    };
}
export interface Arguments {
    values: {
        [argument: string]: any;
    };
    missing: MissingVariablePath[];
}
/**
 * Prepares an object map of argument values given a list of argument
 * definitions and list of argument AST nodes.
 *
 * Note: The returned value is a plain Object with a prototype, since it is
 * exposed to user code. Care should be taken to not pull values from the
 * Object prototype.
 */
export declare function getArgumentDefs(def: GraphQLField<any, any> | GraphQLDirective, node: FieldNode | DirectiveNode): Arguments;
interface ASTValueWithVariables {
    value: object | string | boolean | symbol | number | null | any[];
    variables: MissingVariablePath[];
}
interface ASTValue {
    value: object | string | boolean | symbol | number | null | any[];
}
export declare function valueFromAST(valueNode: ValueNode, type: GraphQLInputType): undefined | ASTValue | ASTValueWithVariables;
export declare function computeLocations(nodes: ASTNode[]): SourceLocation[];
export declare function addPath(responsePath: ObjectPath | undefined, key: string, type?: ResponsePathType): ObjectPath;
export declare function flattenPath(path: ObjectPath): Array<{
    key: string;
    type: ResponsePathType;
}>;
/**
 * Serialize a path for use in the skip/include directives.
 *
 * @param path The path to serialize
 * @returns The path serialized as a string, with the root path first.
 */
export declare function serializeObjectPathForSkipInclude(path: ObjectPath | undefined): string;
/**
 * join two path segments to a dot notation, handling empty strings
 *
 * @param a path segment
 * @param b path segment
 * @returns combined path in dot notation
 */
export declare function joinSkipIncludePath(a: string, b: string): string;
